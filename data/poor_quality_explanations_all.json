{
  "version": "2.0",
  "generated_at": "2025-11-04T22:13:43.656266",
  "total": 114,
  "stats": {
    "by_file": {
      "items_2021_round1.jsonl": 2,
      "items_2022_round1.jsonl": 7,
      "items_2022_round2.jsonl": 10,
      "items_2022_round3.jsonl": 8,
      "items_2023_round1.jsonl": 6,
      "items_2023_round2.jsonl": 10,
      "items_2023_round3.jsonl": 15,
      "items_2024_round1.jsonl": 12,
      "items_2024_round2.jsonl": 12,
      "items_2024_round3.jsonl": 14,
      "items_2025_round1.jsonl": 9,
      "items_2025_round2.jsonl": 9
    },
    "by_issue_type": {
      "범용적인 설명 문구 사용": 58,
      "구체적인 설명 부족": 29,
      "범용적인 설명 문구 다수": 49,
      "문제 내용과 연관성 부족": 90,
      "범용적인 설명 문구 과다": 7
    }
  },
  "items": [
    {
      "file": "items_2021_round1.jsonl",
      "q_no": "Q001",
      "doc_id": "2021_round1",
      "question_text": "물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.",
      "question_full": "물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.",
      "explanation_current": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. **사용 목적:**\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. **동작 방식:**\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n**답:** RARP (Reverse Address Resolution Protocol)",
      "explanation_preview": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "RARP (Reverse Address Resolution Protocol)"
        ],
        "raw_text": "RARP (Reverse Address Resolution Protocol)"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 482
      }
    },
    {
      "file": "items_2021_round1.jsonl",
      "q_no": "Q001",
      "doc_id": "2021_round1",
      "question_text": "0 <= x <= 10이면 -1 0 10 11 검사",
      "question_full": "0 <= x <= 10이면 -1 0 10 11 검사",
      "explanation_current": "이 문제는 **경계값 분석(Boundary Value Analysis)** 테스트 기법을 설명하는 문제입니다.\n\n**경계값 분석이란?**\n- 블랙박스 테스트 기법 중 하나\n- 입력 조건의 **경계값과 그 근처 값**을 테스트 케이스로 선정하는 기법\n- 경계에서 오류가 발생할 가능성이 높기 때문에 경계값을 집중적으로 테스트\n\n**문제 분석:**\n- 입력 조건: `0 <= x <= 10`\n- 경계값: 0 (하한 경계), 10 (상한 경계)\n- 경계 근처 값: -1 (하한 경계 바로 아래), 11 (상한 경계 바로 위)\n\n**테스트 케이스:**\n- **-1**: 경계값(0) 바로 아래, 무효값 (경계 오류 검사)\n- **0**: 하한 경계값, 유효값 (경계 검사)\n- **10**: 상한 경계값, 유효값 (경계 검사)\n- **11**: 경계값(10) 바로 위, 무효값 (경계 오류 검사)\n\n**경계값 분석의 원리:**\n- 경계값: 유효 범위의 최소값과 최대값 (0, 10)\n- 경계 바로 밖: 무효 범위의 값 (-1, 11)\n- 경계에서 오류가 발생할 가능성이 높으므로 이러한 값들을 반드시 테스트\n\n**일반적인 경계값 분석 규칙:**\n- 입력 범위가 `a <= x <= b`일 때:\n  - 경계값: `a`, `b` (유효 경계)\n  - 경계 바로 밖: `a-1`, `b+1` (무효 경계)\n  - 경계 바로 안: `a+1`, `b-1` (유효 내부)\n\n**답:** **경계값 분석**",
      "explanation_preview": "이 문제는 **경계값 분석(Boundary Value Analysis)** 테스트 기법을 설명하는 문제입니다.\n\n**경계값 분석이란?**\n- 블랙박스 테스트 기법 중 하나\n- 입력 조건의 **경계값과 그 근처 값**을 테스트 케이스로 선정하는 기법\n- 경계에서 오류가 발생할 가능성이 높기 때문에 경계값을 집중적으로 테스트\n\n**문제 분석:**\n- 입력 조건",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "경계값 분석"
        ],
        "raw_text": "경계값 분석"
      },
      "primary_category": "기타",
      "quality": {
        "score": 65,
        "issues": [
          "범용적인 설명 문구 다수",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 720
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q003",
      "doc_id": "2022_round1",
      "question_text": "다음 자바 문법에 알맞는 출력 결과를 작성하시오.",
      "question_full": "다음 자바 문법에 알맞는 출력 결과를 작성하시오.",
      "explanation_current": "**주어진 코드:**\n```java\nclass A {\n    int a;\n    int b;\n}\n\npublic class Main {\n    static void func1(A m) {\n        m.a *= 10;\n    }\n    \n    static void func2(A m) {\n        m.a += m.b;\n    }\n    \n    public static void main(String args[]) {\n        A m = new A();\n        m.a = 100;\n        func1(m);\n        m.b = m.a;\n        func2(m);\n        System.out.printf(\"%d\", m.a);\n    }\n}\n```\n\n**Java 객체 참조 전달:**\n- Java에서 객체는 **참조(reference)로 전달**됩니다\n- 메서드에 객체를 전달하면 **원본 객체의 참조**가 전달됩니다\n- 메서드 내에서 객체의 필드를 변경하면 **원본 객체도 함께 변경**됩니다\n\n**단계별 실행 과정:**\n\n**1. 객체 생성 및 초기화:**\n- `A m = new A();` → `m.a = 0`, `m.b = 0` (기본값)\n- `m.a = 100;` → `m.a = 100`, `m.b = 0`\n\n**2. func1(m) 호출:**\n- `m.a *= 10;` → `m.a = m.a * 10 = 100 * 10 = 1000`\n- 참조로 전달되었으므로 원본 객체의 `m.a`가 1000으로 변경됨\n- 상태: `m.a = 1000`, `m.b = 0`\n\n**3. m.b 값 설정:**\n- `m.b = m.a;` → `m.b = 1000`\n- 상태: `m.a = 1000`, `m.b = 1000`\n\n**4. func2(m) 호출:**\n- `m.a += m.b;` → `m.a = m.a + m.b = 1000 + 1000 = 2000`\n- 참조로 전달되었으므로 원본 객체의 `m.a`가 2000으로 변경됨\n- 상태: `m.a = 2000`, `m.b = 1000`\n\n**5. 출력:**\n- `System.out.printf(\"%d\", m.a);` → **2000 출력**\n\n**실행 순서 요약:**\n| 단계 | 코드 | m.a | m.b |\n|------|------|-----|-----|\n| 초기화 | `A m = new A()` | 0 | 0 |\n| 1 | `m.a = 100` | 100 | 0 |\n| 2 | `func1(m)` → `m.a *= 10` | 1000 | 0 |\n| 3 | `m.b = m.a` | 1000 | 1000 |\n| 4 | `func2(m)` → `m.a += m.b` | 2000 | 1000 |\n| 5 | `printf(\"%d\", m.a)` | **2000 출력** | 1000 |\n\n**핵심 포인트:**\n- `*=`: 곱셈 후 할당 (`m.a *= 10` = `m.a = m.a * 10`)\n- `+=`: 덧셈 후 할당 (`m.a += m.b` = `m.a = m.a + m.b`)\n- Java에서 **기본 타입은 값 전달**, **객체는 참조 전달**\n- 객체의 필드를 메서드에서 변경하면 원본 객체도 변경됨\n\n**답:** **2000**",
      "explanation_preview": "**주어진 코드:**\n```java\nclass A {\n    int a;\n    int b;\n}\n\npublic class Main {\n    static void func1(A m) {\n        m.a *= 10;\n    }\n    \n    static void func2(A m) {\n        m.a += m.b;\n    }\n    \n    pu",
      "image_refs": [
        "images/2022_round1/3.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class A {\n  int a;\n  int b;\n}\n  public class Main {\n  static void func1(A m){\n   m.a *= 10;\n  }\n  static void func2(A m){\n    m.a += m.b;\n  }\n  public static void main(String args[]){\n  A m = new A();\n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  System.out.printf(\"%d\", m.a);\n  }\n}",
          "line_numbers": [
            1,
            20
          ],
          "file": "data/codes/2022_round1/Q003_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "2000"
        ],
        "raw_text": "2000"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1589
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q004",
      "doc_id": "2022_round1",
      "question_text": "다음 SQL 결과에 알맞는 쿼리을 작성하시오.\nSELECT name, score FROM 성적\n\n(1) BY ( 2 ) ( 3 )",
      "question_full": "다음 SQL 결과에 알맞는 쿼리을 작성하시오.\nSELECT name, score FROM 성적\n\n(1) BY ( 2 ) ( 3 )",
      "explanation_current": "문제에서 제시된 SQL 결과를 보면 **점수(score) 기준으로 내림차순 정렬**이 필요합니다.\n\n**주어진 쿼리 패턴:**\n```sql\nSELECT name, score FROM 성적\n(1) BY (2) (3)\n```\n\n**패턴 분석:**\n- `(1) BY (2) (3)` 형태는 **ORDER BY 절**을 나타냅니다\n- `BY` 앞에는 `ORDER`가 오고\n- `BY` 뒤에는 정렬 기준 컬럼명과 정렬 방향이 옵니다\n\n**ORDER BY 절 구조:**\n```sql\nORDER BY 컬럼명 [ASC | DESC]\n```\n- `ORDER BY`: 결과를 정렬하기 위한 SQL 절\n- `컬럼명`: 정렬 기준이 되는 컬럼\n- `ASC`: 오름차순 (Ascending, 기본값, 생략 가능)\n- `DESC`: 내림차순 (Descending, 높은 값부터 낮은 값 순서)\n\n**문제의 요구사항:**\n- 주어진 결과를 보면 점수가 **높은 순서부터 낮은 순서**로 정렬되어 있음\n- 따라서 **내림차순(DESC)** 정렬 필요\n- 정렬 기준 컬럼은 **score**\n\n**빈칸 채우기:**\n1. **(1)**: `ORDER` - ORDER BY 절의 시작 키워드\n2. **(2)**: `score` - 정렬 기준 컬럼명 (점수 컬럼)\n3. **(3)**: `DESC` - 내림차순 정렬 지정\n\n**완성된 쿼리:**\n```sql\nSELECT name, score FROM 성적\nORDER BY score DESC\n```\n\n**실행 결과:**\n- 성적 테이블에서 학생 이름과 점수를 조회\n- 점수가 높은 학생부터 낮은 학생 순서로 정렬되어 출력\n\n**ORDER BY 사용 예시:**\n- `ORDER BY score ASC` 또는 `ORDER BY score`: 점수 오름차순 (낮은 점수 → 높은 점수)\n- `ORDER BY score DESC`: 점수 내림차순 (높은 점수 → 낮은 점수)\n- `ORDER BY name`: 이름 오름차순 (가나다순)\n\n**답:**\n- (1) **ORDER**\n- (2) **score**\n- (3) **DESC**",
      "explanation_preview": "문제에서 제시된 SQL 결과를 보면 **점수(score) 기준으로 내림차순 정렬**이 필요합니다.\n\n**주어진 쿼리 패턴:**\n```sql\nSELECT name, score FROM 성적\n(1) BY (2) (3)\n```\n\n**패턴 분석:**\n- `(1) BY (2) (3)` 형태는 **ORDER BY 절**을 나타냅니다\n- `BY` 앞에는 `ORDER`가",
      "image_refs": [
        "images/2022_round1/4.png"
      ],
      "code_blocks": [],
      "table_refs": [
        {
          "id": "table1",
          "json": "data/tables/2022_round1/Q004_table1.json",
          "rows": 18,
          "cols": 1
        }
      ],
      "answer": {
        "keys": [
          "1) ORDER",
          "2) score",
          "3) DESC"
        ],
        "raw_text": "1) ORDER 2) score 3) DESC"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1030
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q008",
      "doc_id": "2022_round1",
      "question_text": "다음 아래 단어를 영어 약자로 작성하시오.\n임시 키 무결성 프로토콜",
      "question_full": "다음 아래 단어를 영어 약자로 작성하시오.\n임시 키 무결성 프로토콜",
      "explanation_current": "문제에서 요구하는 것은 **\"임시 키 무결성 프로토콜\"**을 영어 약자로 작성하는 것입니다.\n\n**TKIP (Temporal Key Integrity Protocol):**\n\n**영어 약자 풀이:**\n- **T**emporal: 임시의, 시간에 따른\n- **K**ey: 키\n- **I**ntegrity: 무결성\n- **P**rotocol: 프로토콜\n- **TKIP = Temporal Key Integrity Protocol**\n\n**TKIP의 정의:**\n- **임시 키 무결성 프로토콜** 또는 **시간적 키 무결성 프로토콜**\n- 무선 네트워크 보안을 위한 암호화 프로토콜\n- WEP(Wired Equivalent Privacy)의 취약점을 보완하기 위해 개발\n\n**TKIP의 특징:**\n1. **임시 키(Temporal Key) 사용:**\n   - 정적 키를 사용하는 WEP와 달리 **동적으로 키를 변경**\n   - 일정 시간마다 또는 패킷 단위로 키를 갱신\n   - 보안 강화\n\n2. **무결성(Integrity) 보장:**\n   - 데이터가 전송 중 변조되지 않았음을 검증\n   - MIC(Message Integrity Check)를 사용하여 데이터 무결성 확인\n\n3. **WEP 호환성:**\n   - 기존 WEP 하드웨어에서도 사용 가능\n   - 소프트웨어 업데이트로 적용 가능\n\n**TKIP의 용도:**\n- Wi-Fi 네트워크(WLAN) 보안\n- IEEE 802.11i 표준의 일부\n- WPA(Wi-Fi Protected Access)에서 사용\n- WEP의 보안 취약점을 개선\n\n**답:** **TKIP**",
      "explanation_preview": "문제에서 요구하는 것은 **\"임시 키 무결성 프로토콜\"**을 영어 약자로 작성하는 것입니다.\n\n**TKIP (Temporal Key Integrity Protocol):**\n\n**영어 약자 풀이:**\n- **T**emporal: 임시의, 시간에 따른\n- **K**ey: 키\n- **I**ntegrity: 무결성\n- **P**rotocol: 프로토콜\n- **T",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "TKIP"
        ],
        "raw_text": "TKIP"
      },
      "primary_category": "데이터베이스",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 796
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q014",
      "doc_id": "2022_round1",
      "question_text": "다음 소스코드에서 입력값이 5가 들어왔을때 출력되는 값을 작성하시오.",
      "question_full": "다음 소스코드에서 입력값이 5가 들어왔을때 출력되는 값을 작성하시오.",
      "explanation_current": "이 코드는 **재귀 함수를 이용한 팩토리얼 계산** 문제입니다.\n\n**주어진 코드:**\n```c\n#include <stdio.h>\nint func(int a) {\n    if (a <= 1) return 1;\n    return a * func(a - 1);\n}\nint main() {\n    int a;\n    scanf(\"%d\", &a);\n    printf(\"%d\", func(a));\n}\n```\n\n**팩토리얼(Factorial) 정의:**\n- n! = n × (n-1) × (n-2) × ... × 2 × 1\n- 예: 5! = 5 × 4 × 3 × 2 × 1 = 120\n- 0! = 1! = 1 (특수 케이스)\n\n**재귀 함수 동작 원리:**\n- **기저 조건(Base Case)**: `if (a <= 1) return 1` - 재귀 종료 조건\n- **재귀 호출**: `return a * func(a - 1)` - 자기 자신을 호출하여 작은 문제로 분해\n\n**입력값이 5일 때 실행 과정:**\n\n**호출 스택 (Call Stack):**\n```\nfunc(5)\n  └─ func(4)\n      └─ func(3)\n          └─ func(2)\n              └─ func(1) ← 기저 조건 도달\n```\n\n**단계별 추적:**\n\n1. **func(5) 호출:**\n   - `5 <= 1`? 아니오\n   - `return 5 * func(4)` 실행 (func(4) 결과 기다림)\n\n2. **func(4) 호출:**\n   - `4 <= 1`? 아니오\n   - `return 4 * func(3)` 실행 (func(3) 결과 기다림)\n\n3. **func(3) 호출:**\n   - `3 <= 1`? 아니오\n   - `return 3 * func(2)` 실행 (func(2) 결과 기다림)\n\n4. **func(2) 호출:**\n   - `2 <= 1`? 아니오\n   - `return 2 * func(1)` 실행 (func(1) 결과 기다림)\n\n5. **func(1) 호출:**\n   - `1 <= 1`? **예** → `return 1` (기저 조건, 재귀 종료)\n\n**값 반환 과정 (Unwinding):**\n```\nfunc(1) = 1                                    ← 반환\nfunc(2) = 2 * func(1) = 2 * 1 = 2            ← 반환\nfunc(3) = 3 * func(2) = 3 * 2 = 6            ← 반환\nfunc(4) = 4 * func(3) = 4 * 6 = 24           ← 반환\nfunc(5) = 5 * func(4) = 5 * 24 = 120         ← 최종 반환\n```\n\n**실행 순서 요약 표:**\n| 단계 | 호출 | 조건 확인 | 반환값 | 계산식 |\n|------|------|-----------|--------|--------|\n| 5 | func(5) | 5 <= 1? 아니오 | - | 5 * func(4) 대기 |\n| 4 | func(4) | 4 <= 1? 아니오 | - | 4 * func(3) 대기 |\n| 3 | func(3) | 3 <= 1? 아니오 | - | 3 * func(2) 대기 |\n| 2 | func(2) | 2 <= 1? 아니오 | - | 2 * func(1) 대기 |\n| 1 | func(1) | 1 <= 1? **예** | **1** | 기저 조건 |\n| 2 | func(2) | - | **2** | 2 * 1 = 2 |\n| 3 | func(3) | - | **6** | 3 * 2 = 6 |\n| 4 | func(4) | - | **24** | 4 * 6 = 24 |\n| 5 | func(5) | - | **120** | 5 * 24 = 120 |\n\n**최종 출력:** `printf(\"%d\", 120)` → **120**\n\n**재귀 함수의 특징:**\n- **분할 정복(Divide and Conquer)**: 큰 문제를 작은 문제로 나눔\n- **기저 조건**: 재귀 종료 조건이 반드시 필요 (없으면 무한 루프)\n- **호출 스택**: 함수 호출이 스택에 쌓임 (후입선출, LIFO)\n- **메모리 사용**: 호출이 깊을수록 스택 메모리 많이 사용\n\n**답:** **120**",
      "explanation_preview": "이 코드는 **재귀 함수를 이용한 팩토리얼 계산** 문제입니다.\n\n**주어진 코드:**\n```c\n#include <stdio.h>\nint func(int a) {\n    if (a <= 1) return 1;\n    return a * func(a - 1);\n}\nint main() {\n    int a;\n    scanf(\"%d\", &a);\n    prin",
      "image_refs": [
        "images/2022_round1/14.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nint func(int a) {\n  if (a <= 1) return 1;\n  return a * func(a - 1);\n}\nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  printf(\"%d\", func(a));\n}",
          "line_numbers": [
            1,
            10
          ],
          "file": "data/codes/2022_round1/Q014_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "120"
        ],
        "raw_text": "120"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2099
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q016",
      "doc_id": "2022_round1",
      "question_text": "다음 설명에 대한 답을 영어 약자로 작성하시오.\n정보보호 관리체계의 영문 약자",
      "question_full": "다음 설명에 대한 답을 영어 약자로 작성하시오.\n정보보호 관리체계의 영문 약자",
      "explanation_current": "문제에서 요구하는 것은 **\"정보보호 관리체계\"**의 영문 약자입니다.\n\n**ISMS (Information Security Management System):**\n\n**영어 약자 풀이:**\n- **I**nformation: 정보\n- **S**ecurity: 보안, 보호\n- **M**anagement: 관리\n- **S**ystem: 체계, 시스템\n- **ISMS = Information Security Management System**\n\n**ISMS의 정의:**\n- **정보보호 관리체계** 또는 **정보보안 관리체계**\n- 조직의 정보자산을 체계적으로 보호하기 위한 관리 시스템\n- 정보보안 위험을 관리하고 통제하기 위한 일련의 정책, 절차, 프로세스\n\n**ISMS의 주요 요소:**\n1. **정보자산 관리**: 정보자산 식별, 분류, 보호\n2. **보안 정책**: 조직의 보안 목표와 방침 수립\n3. **위험 관리**: 보안 위협 식별, 평가, 대응\n4. **통제 체계**: 기술적/물리적/관리적 보안 통제\n5. **지속적 개선**: PDCA 사이클을 통한 관리체계 개선\n\n**ISMS 인증:**\n- **인증 기관**: 한국인터넷진흥원(KISA, Korea Internet & Security Agency)\n- **인증 기준**: ISO/IEC 27001 국제표준 기반\n- **인증 범위**: 조직 전체 또는 특정 부서/시스템\n- **인증 유효기간**: 3년 (재인증 필요)\n\n**ISMS의 목적:**\n- 정보자산의 기밀성, 무결성, 가용성 보장\n- 정보보안 위험을 사전에 예방 및 차단\n- 법규 및 규정 준수\n- 조직의 신뢰성 및 경쟁력 향상\n\n**ISMS와 관련 개념:**\n- **ISO/IEC 27001**: ISMS를 위한 국제 표준\n- **PIMS (Personal Information Management System)**: 개인정보보호 관리체계\n- **ISO/IEC 27002**: 정보보안 통제를 위한 실무 지침\n\n**답:** **ISMS (Information Security Management System)**",
      "explanation_preview": "문제에서 요구하는 것은 **\"정보보호 관리체계\"**의 영문 약자입니다.\n\n**ISMS (Information Security Management System):**\n\n**영어 약자 풀이:**\n- **I**nformation: 정보\n- **S**ecurity: 보안, 보호\n- **M**anagement: 관리\n- **S**ystem: 체계, 시스템\n- **I",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ISMS (Information Security Management System)"
        ],
        "raw_text": "ISMS (Information Security Management System)"
      },
      "primary_category": "기타",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1029
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q019",
      "doc_id": "2022_round1",
      "question_text": "다음 소스코드가 실행할 때의 출력값을 작성하시오.",
      "question_full": "다음 소스코드가 실행할 때의 출력값을 작성하시오.",
      "explanation_current": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 나열하는 문제입니다.\n\n**V모델(V-Model)이란?**\n- 소프트웨어 개발 생명주기 모델 중 하나\n- **개발 단계**와 **테스트 단계**가 대칭적으로 연결된 V자 형태의 모델\n- 왼쪽 다리는 개발 단계, 오른쪽 다리는 테스트 단계\n\n**V모델의 테스트 단계 (오른쪽 다리, 아래에서 위로):**\n\n1. **단위 테스트 (Unit Test):**\n   - **목적**: 개별 모듈(함수, 클래스)의 기능을 검증\n   - **시점**: 코딩 단계 완료 후\n   - **담당**: 개발자\n   - **대상**: 개별 컴포넌트나 함수\n   - **예시**: 함수의 입력/출력 검증, 로직 오류 확인\n   - **대응하는 개발 단계**: 코딩 단계\n\n2. **통합 테스트 (Integration Test):**\n   - **목적**: 여러 모듈을 결합하여 인터페이스와 상호작용을 검증\n   - **시점**: 단위 테스트 완료 후\n   - **담당**: 개발자 또는 테스터\n   - **대상**: 모듈 간의 인터페이스, 데이터 전달\n   - **예시**: API 통합, 데이터베이스 연동 테스트\n   - **대응하는 개발 단계**: 설계 단계\n\n3. **시스템 테스트 (System Test):**\n   - **목적**: 전체 시스템이 요구사항을 만족하는지 검증\n   - **시점**: 통합 테스트 완료 후\n   - **담당**: 테스터 또는 QA 팀\n   - **대상**: 완성된 전체 시스템\n   - **예시**: 성능 테스트, 보안 테스트, 사용성 테스트\n   - **대응하는 개발 단계**: 요구사항 분석 단계\n\n4. **인수 테스트 (Acceptance Test):**\n   - **목적**: 사용자 요구사항을 만족하는지 최종 검증\n   - **시점**: 시스템 테스트 완료 후\n   - **담당**: 사용자 또는 고객\n   - **대상**: 전체 시스템 (사용자 관점)\n   - **예시**: 알파 테스트, 베타 테스트, 사용자 인수 테스트\n   - **대응하는 개발 단계**: 요구사항 정의 단계\n\n**V모델 구조:**\n```\n요구사항 분석 ←→ 인수 테스트\n    ↓              ↑\n시스템 설계 ←→ 시스템 테스트\n    ↓              ↑\n상세 설계 ←→ 통합 테스트\n    ↓              ↑\n   코딩 ←→ 단위 테스트\n```\n\n**답:**\n- 1) **단위 테스트**\n- 2) **통합 테스트**\n- 3) **시스템 테스트**\n- (4) **인수 테스트** (문제에서 요구하는 범위에 따라 포함 여부 결정)",
      "explanation_preview": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 나열하는 문제입니다.\n\n**V모델(V-Model)이란?**\n- 소프트웨어 개발 생명주기 모델 중 하나\n- **개발 단계**와 **테스트 단계**가 대칭적으로 연결된 V자 형태의 모델\n- 왼쪽 다리는 개발 단계, 오른쪽 다리는 테스트 단계\n\n**V모델의 테스트 단계 (오른쪽 다리, 아래에서",
      "image_refs": [
        "images/2022_round1/19.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1) 단위 테스트",
          "2) 통합 테스트",
          "3) 시스템 테스트"
        ],
        "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1303
      }
    },
    {
      "file": "items_2022_round1.jsonl",
      "q_no": "Q020",
      "doc_id": "2022_round1",
      "question_text": "다음은 V모델에서의 테스트 단계에 대한 설명으로 괄호 안에 들어갈 답을 작성하시오.",
      "question_full": "다음은 V모델에서의 테스트 단계에 대한 설명으로 괄호 안에 들어갈 답을 작성하시오.",
      "explanation_current": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 작성하는 문제입니다.\n\n**V모델(V-Model)의 구조:**\n- 소프트웨어 개발 생명주기 모델\n- **개발 단계(왼쪽 다리)**와 **테스트 단계(오른쪽 다리)**가 V자 형태로 대칭\n- 각 개발 단계마다 대응하는 테스트 단계가 존재\n\n**V모델의 테스트 단계 (아래에서 위로 순서):**\n\n**1. 단위 테스트 (Unit Testing):**\n- **정의**: 개별 모듈, 함수, 클래스의 기능을 검증하는 테스트\n- **시점**: 코딩 단계가 완료된 후\n- **담당자**: 개발자\n- **목적**: 코드의 논리적 오류, 알고리즘 오류 발견\n- **대응 개발 단계**: 코딩 단계\n- **예시**: 함수의 반환값 검증, 변수 상태 확인\n\n**2. 통합 테스트 (Integration Testing):**\n- **정의**: 여러 모듈을 결합하여 인터페이스와 상호작용을 검증하는 테스트\n- **시점**: 단위 테스트 완료 후\n- **담당자**: 개발자 또는 통합 테스터\n- **목적**: 모듈 간 인터페이스 오류, 데이터 전달 오류 발견\n- **대응 개발 단계**: 설계 단계 (상세 설계, 시스템 설계)\n- **예시**: API 호출 테스트, 데이터베이스 연동 테스트\n\n**3. 시스템 테스트 (System Testing):**\n- **정의**: 완성된 전체 시스템이 요구사항을 만족하는지 검증하는 테스트\n- **시점**: 통합 테스트 완료 후\n- **담당자**: QA 팀 또는 전문 테스터\n- **목적**: 요구사항 충족 여부, 성능, 보안, 사용성 검증\n- **대응 개발 단계**: 요구사항 분석 단계\n- **예시**: 성능 테스트, 보안 테스트, 부하 테스트, 회귀 테스트\n\n**4. 인수 테스트 (Acceptance Testing):**\n- **정의**: 사용자 또는 고객이 시스템을 실제 사용 환경에서 검증하는 테스트\n- **시점**: 시스템 테스트 완료 후\n- **담당자**: 사용자 또는 고객\n- **목적**: 사용자 요구사항 만족 여부 최종 확인\n- **대응 개발 단계**: 요구사항 정의 단계\n- **예시**: 알파 테스트, 베타 테스트, 사용자 인수 테스트(UAT)\n\n**V모델 전체 구조:**\n```\n        요구사항 정의 ←→ 인수 테스트\n              ↓              ↑\n        요구사항 분석 ←→ 시스템 테스트\n              ↓              ↑\n          시스템 설계 ←→ 통합 테스트\n              ↓              ↑\n          상세 설계 ←→ 단위 테스트\n              ↓              ↑\n            코딩\n```\n\n**테스트 단계의 특징:**\n- **점진적 확대**: 단위(작은 범위) → 통합(중간 범위) → 시스템(큰 범위) → 인수(최종 검증)\n- **오류 발견 단계**: 단위 테스트에서는 코드 오류, 시스템 테스트에서는 요구사항 오류 발견\n- **비용**: 발견 시점이 늦을수록 수정 비용 증가 (V모델의 위로 올라갈수록 비용 증가)\n\n**답:**\n- (1) **단위 테스트**\n- (2) **통합 테스트**\n- (3) **시스템 테스트**",
      "explanation_preview": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 작성하는 문제입니다.\n\n**V모델(V-Model)의 구조:**\n- 소프트웨어 개발 생명주기 모델\n- **개발 단계(왼쪽 다리)**와 **테스트 단계(오른쪽 다리)**가 V자 형태로 대칭\n- 각 개발 단계마다 대응하는 테스트 단계가 존재\n\n**V모델의 테스트 단계 (아래에서 위로 순서):*",
      "image_refs": [
        "images/2022_round1/20.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1) 단위 테스트",
          "2) 통합 테스트",
          "3) 시스템 테스트"
        ],
        "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"
      },
      "primary_category": "소프트웨어공학",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1607
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q005",
      "doc_id": "2022_round2",
      "question_text": "다음은 네트워크에 관련한 내용이다.\n괄호 안에 들어갈 알맞는 답을 작성하시오.\n( )은/는 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하며, 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.\n또한 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.",
      "question_full": "다음은 네트워크에 관련한 내용이다.\n괄호 안에 들어갈 알맞는 답을 작성하시오.\n( )은/는 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하며, 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.\n또한 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.",
      "explanation_current": "문제에서 설명하는 특징들이 모두 **VPN (Virtual Private Network, 가상 사설망)**을 가리킵니다.\n\n**VPN (Virtual Private Network, 가상 사설망):**\n\n**영어 약자 풀이:**\n- **V**irtual: 가상의\n- **P**rivate: 사설의\n- **N**etwork: 네트워크\n- **VPN = Virtual Private Network**\n\n**VPN의 정의:**\n- **인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성**하는 기술\n- **퍼블릭 네트워크(공중망)**를 이용하여 **사설 네트워크처럼 안전하게** 통신하는 기술\n\n**문제에서 언급한 VPN의 특징:**\n\n1. **\"인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성\"**:\n   - 실제 물리적 네트워크가 아닌 **가상의 터널(Tunnel)**을 통해 연결\n   - 여러 지점을 마치 하나의 사설망처럼 연결\n\n2. **\"퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송\"**:\n   - 공중망을 통해 전송하지만 **암호화**하여 안전하게 전송\n   - 실제 IP 주소를 숨겨 **익명성** 보장\n\n3. **\"사용자 IP 주소를 마스킹\"**:\n   - 실제 IP 주소를 **가상 IP 주소로 대체** (IP 마스킹)\n   - 위치 추적 및 식별을 어렵게 만듦\n\n4. **\"데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록\"**:\n   - 전송되는 모든 데이터를 **암호화** (Encryption)\n   - 중간에 가로채도 암호화되어 있어 내용 확인 불가\n\n**VPN의 동작 원리:**\n\n1. **터널링(Tunneling)**:\n   - 공중망 위에 가상의 **암호화된 터널** 생성\n   - 터널을 통해 데이터가 안전하게 전송\n\n2. **암호화(Encryption)**:\n   - 전송 전 데이터를 암호화 (AES, RSA 등 사용)\n   - 수신 측에서 복호화하여 원본 데이터 복원\n\n3. **인증(Authentication)**:\n   - 사용자 인증 및 접근 권한 확인\n   - 승인된 사용자만 VPN 접속 가능\n\n**VPN의 주요 용도:**\n- **원격 접근**: 재택근무자나 외부 직원이 회사 네트워크에 안전하게 접속\n- **사이트 간 연결**: 여러 지사나 데이터센터를 하나의 네트워크처럼 연결\n- **개인 프라이버시 보호**: IP 주소 마스킹, 위치 정보 숨김\n- **지역 제한 우회**: 특정 국가/지역에서만 접근 가능한 서비스 이용\n\n**VPN의 종류:**\n- **PPTP (Point-to-Point Tunneling Protocol)**: 초기 VPN 프로토콜\n- **L2TP/IPSec (Layer 2 Tunneling Protocol with IPSec)**: 더 안전한 프로토콜\n- **OpenVPN**: 오픈소스 기반 VPN 프로토콜\n- **SSL/TLS VPN**: 웹 기반 VPN (HTTPS 사용)\n\n**VPN의 보안 기능:**\n| 기능 | 설명 |\n|------|------|\n| **암호화** | 데이터를 암호화하여 전송 |\n| **IP 마스킹** | 실제 IP 주소를 가상 IP로 대체 |\n| **인증** | 사용자 및 기기 인증 |\n| **터널링** | 가상의 암호화된 통로 생성 |\n\n**답:** **VPN**",
      "explanation_preview": "문제에서 설명하는 특징들이 모두 **VPN (Virtual Private Network, 가상 사설망)**을 가리킵니다.\n\n**VPN (Virtual Private Network, 가상 사설망):**\n\n**영어 약자 풀이:**\n- **V**irtual: 가상의\n- **P**rivate: 사설의\n- **N**etwork: 네트워크\n- **VPN = Virtu",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "VPN"
        ],
        "raw_text": "VPN"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1624
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q006",
      "doc_id": "2022_round2",
      "question_text": "다음은 SOLID 원칙에 관한 내용이다.\n괄호 안에 알맞는 단어를 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nSRP\n,\nLSP 등..))\n( ) 은/는 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.\n( ) 은/는 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 ",
      "question_full": "다음은 SOLID 원칙에 관한 내용이다.\n괄호 안에 알맞는 단어를 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nSRP\n,\nLSP 등..))\n( ) 은/는 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.\n( ) 은/는 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.\n예를 들어 하나의 복합기에 프린터와 복사기, 팩스 메서드가 있는데 이 세가지 메서드는 같은 파일에 존재하므로 프린터 로직만 바뀌어도 복사기와 팩스도 재컴파일을 해야한다.\n그러므로 ( ) 을/를 적용하여 로직이 바뀌어도 다른 메서드는 영향을 받지 않도록 해야한다.",
      "explanation_current": "이 문제는 **SOLID 원칙** 중 **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**에 대한 문제입니다.\n\n**ISP (Interface Segregation Principle, 인터페이스 분리 원칙)이란?**\n\n**영어 약자 풀이:**\n- **I**nterface: 인터페이스\n- **S**egregation: 분리, 격리\n- **P**rinciple: 원칙\n- **ISP = Interface Segregation Principle**\n\n**ISP의 핵심 원칙:**\n1. **\"클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다\"**:\n   - 클라이언트는 **자신이 실제로 사용하는 메서드만** 의존해야 함\n   - 사용하지 않는 메서드까지 구현하도록 강제하면 안 됨\n\n2. **\"큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리\"**:\n   - 하나의 큰 인터페이스를 **여러 개의 작은 인터페이스로 분리**\n   - 각 인터페이스는 **특정 역할**에만 집중\n   - 클라이언트는 **필요한 인터페이스만** 구현/사용\n\n**문제에서 제시한 예시:**\n\n**문제 상황:**\n- 하나의 복합기 인터페이스에 프린터, 복사기, 팩스 메서드가 모두 있음\n- 프린터 로직만 변경해도 복사기와 팩스도 재컴파일 필요\n- **강한 결합도**, 불필요한 의존성 발생\n\n**ISP 적용 전 (나쁜 예):**\n```java\ninterface 복합기 {\n    void 프린트();\n    void 복사();\n    void 팩스();\n}\n\nclass 프린터 implements 복합기 {\n    void 프린트() { ... }\n    void 복사() { ... } // 사용 안 함\n    void 팩스() { ... } // 사용 안 함\n}\n```\n- 프린터 클래스가 복사(), 팩스() 메서드까지 구현해야 함 (불필요한 의존)\n- 하나의 메서드 변경 시 전체 재컴파일 필요\n\n**ISP 적용 후 (좋은 예):**\n```java\ninterface 프린터인터페이스 {\n    void 프린트();\n}\n\ninterface 복사기인터페이스 {\n    void 복사();\n}\n\ninterface 팩스인터페이스 {\n    void 팩스();\n}\n\nclass 프린터 implements 프린터인터페이스 {\n    void 프린트() { ... }\n}\n```\n- 각 클래스는 **자신이 필요한 인터페이스만** 구현\n- 프린터 로직 변경 시 프린터만 재컴파일 (독립적 수정 가능)\n\n**ISP의 장점:**\n1. **낮은 결합도**: 클라이언트가 필요한 메서드만 의존\n2. **높은 응집도**: 관련된 메서드만 하나의 인터페이스에 포함\n3. **독립적 수정**: 한 기능 변경이 다른 기능에 영향 없음\n4. **재사용성 향상**: 작은 인터페이스 단위로 재사용 용이\n\n**SOLID 원칙 전체:**\n| 원칙 | 약자 | 핵심 내용 |\n|------|------|----------|\n| **단일 책임 원칙** | SRP | 하나의 클래스는 하나의 책임만 가져야 함 |\n| **개방-폐쇄 원칙** | OCP | 확장에는 열려 있고 수정에는 닫혀 있어야 함 |\n| **리스코프 치환 원칙** | LSP | 하위 클래스는 상위 클래스를 대체 가능해야 함 |\n| **인터페이스 분리 원칙** | **ISP** | **큰 인터페이스를 작은 인터페이스로 분리** |\n| **의존성 역전 원칙** | DIP | 고수준 모듈은 저수준 모듈에 의존하면 안 됨 |\n\n**답:** **ISP (Interface Segregation Principle)**",
      "explanation_preview": "이 문제는 **SOLID 원칙** 중 **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**에 대한 문제입니다.\n\n**ISP (Interface Segregation Principle, 인터페이스 분리 원칙)이란?**\n\n**영어 약자 풀이:**\n- **I**nterface: 인터페이스\n- **S**egregatio",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ISP"
        ],
        "raw_text": "ISP"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1781
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q007",
      "doc_id": "2022_round2",
      "question_text": "다음 자바 코드에 알맞는 출력값을 작성하시오.",
      "question_full": "다음 자바 코드에 알맞는 출력값을 작성하시오.",
      "explanation_current": "**문제의 이미지를 참고하여 코드 실행 과정을 분석합니다.**\n\n**출력값이 \"-8\"인 경우 가능한 코드 패턴:**\n\n**가능한 패턴 1: 뺄셈 연산**\n```java\nint a = 10;\nint b = 18;\nint result = a - b;\nSystem.out.println(result);  // -8\n```\n\n**가능한 패턴 2: 음수 덧셈**\n```java\nint x = -5;\nint y = -3;\nint result = x + y;\nSystem.out.println(result);  // -8\n```\n\n**가능한 패턴 3: 곱셈 연산**\n```java\nint a = 2;\nint b = -4;\nint result = a * b;\nSystem.out.println(result);  // -8\n```\n\n**Java 코드 실행 시 확인사항:**\n- 변수 초기화 및 타입\n- 산술 연산 (`+`, `-`, `*`, `/`, `%`)\n- 복합 할당 연산자 (`+=`, `-=`, `*=`, `/=`)\n- 반복문 내부의 변수 변화\n- 출력문 (`System.out.print()` vs `System.out.println()`)\n\n**답:** 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출합니다. 이 경우 출력값은 **\"-8\"**입니다.",
      "explanation_preview": "**문제의 이미지를 참고하여 코드 실행 과정을 분석합니다.**\n\n**출력값이 \"-8\"인 경우 가능한 코드 패턴:**\n\n**가능한 패턴 1: 뺄셈 연산**\n```java\nint a = 10;\nint b = 18;\nint result = a - b;\nSystem.out.println(result);  // -8\n```\n\n**가능한 패턴 2: 음수 덧셈**\n``",
      "image_refs": [
        "images/2022_round2/7.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "-8"
        ],
        "raw_text": "-8"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 666
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q010",
      "doc_id": "2022_round2",
      "question_text": "다음 설명에 대한 괄호 안에 알맞는 단어를 작성하시오.",
      "question_full": "다음 설명에 대한 괄호 안에 알맞는 단어를 작성하시오.",
      "explanation_current": "이 문제는 **소프트웨어 테스트의 단계**에 관한 문제입니다.\n\n**1. 베타 테스트 (Beta Test):**\n\n**베타 테스트의 정의:**\n- **선정된 최종 사용자**가 여러 명의 사용자 앞에서 행하는 테스트 기법\n- **실제 업무**를 가지고 사용자가 직접 테스트\n- **사용자 환경**에서 실시되는 테스트\n\n**베타 테스트의 특징:**\n- **실행 주체**: 선정된 최종 사용자\n- **실행 장소**: 사용자 장소 (실제 운영 환경)\n- **테스트 방법**: 실제 업무를 가지고 사용자가 직접 테스트\n- **목적**: 실제 사용 환경에서의 문제점 발견\n- **시기**: 알파 테스트 이후, 상용화 직전\n\n**베타 테스트의 과정:**\n1. **선정된 사용자**에게 시제품 제공\n2. **실제 업무 환경**에서 사용자가 직접 테스트\n3. **여러 명의 사용자** 앞에서 테스트 수행 (공개 테스트)\n4. 발견된 오류를 개발사에 보고\n5. 개발사가 오류를 수정하고 최종 제품 발매\n\n**2. 알파 테스트 (Alpha Test):**\n\n**알파 테스트의 정의:**\n- **개발 회사 내부**에서 이루어지는 테스트\n- **개발자의 장소**에서 사용자가 개발자 앞에서 행하는 테스트\n- **통제된 환경**에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록\n\n**알파 테스트의 특징:**\n- **실행 주체**: 개발 회사 내부 (개발자와 사용자 함께)\n- **실행 장소**: 개발자의 장소 (개발 환경)\n- **테스트 환경**: 통제된 환경\n- **테스트 방법**: 사용자와 개발자가 함께 확인하며 기록\n- **목적**: 초기 작동의 결과 평가, 내부 문제점 발견\n- **시기**: 개발 과정 초기 단계 (베타 테스트 이전)\n\n**알파 테스트 포함 테스트:**\n- **단위 테스트**: 개별 모듈 테스트\n- **구성 테스트**: 모듈 간 통합 테스트\n- **시스템 테스트**: 전체 시스템 테스트\n\n**알파 vs 베타 테스트 비교:**\n| 구분 | **알파 테스트 (Alpha Test)** | **베타 테스트 (Beta Test)** |\n|------|-------------------------------|-----------------------------|\n| **실행 장소** | 개발자의 장소 (개발 환경) | 사용자 장소 (실제 운영 환경) |\n| **실행 주체** | 개발 회사 내부 (개발자 + 사용자) | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **방법** | 개발자와 사용자가 함께 확인하며 기록 | 사용자가 직접 테스트 |\n| **시기** | 개발 과정 초기 단계 | 상용화 직전 |\n| **목적** | 초기 작동 결과 평가, 내부 문제점 발견 | 실제 사용 환경에서의 문제점 발견 |\n\n**테스트 단계 순서:**\n1. **단위 테스트** → 2. **통합 테스트** → 3. **시스템 테스트** → 4. **알파 테스트** → 5. **베타 테스트** → 6. **상용화**\n\n**답:**\n- (1) **베타 테스트 (Beta Test)**\n- (2) **알파 테스트 (Alpha Test)**",
      "explanation_preview": "이 문제는 **소프트웨어 테스트의 단계**에 관한 문제입니다.\n\n**1. 베타 테스트 (Beta Test):**\n\n**베타 테스트의 정의:**\n- **선정된 최종 사용자**가 여러 명의 사용자 앞에서 행하는 테스트 기법\n- **실제 업무**를 가지고 사용자가 직접 테스트\n- **사용자 환경**에서 실시되는 테스트\n\n**베타 테스트의 특징:**\n- **실행 ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1) 베타",
          "2) 알파"
        ],
        "raw_text": "1) 베타 2) 알파"
      },
      "primary_category": "소프트웨어공학",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1561
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q013",
      "doc_id": "2022_round2",
      "question_text": "다음은 파이썬 코드이다.\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 파이썬 코드이다.\n알맞는 출력값을 작성하시오.",
      "explanation_current": "**문제의 이미지를 참고하여 코드 실행 과정을 분석합니다.**\n\n**출력값이 \"REMEMBER AND STR\"인 경우 가능한 코드 패턴:**\n\n**패턴 1: 문자열 대문자 변환**\n```python\ntext = \"remember and str\"\nresult = text.upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n**패턴 2: 리스트 join 후 대문자 변환**\n```python\nwords = [\"remember\", \"and\", \"str\"]\nresult = \" \".join(words).upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n**패턴 3: split 후 join 및 대문자 변환**\n```python\ntext = \"remember,and,str\"\nwords = text.split(\",\")\nresult = \" AND \".join(words).upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n**Python 코드 실행 시 확인사항:**\n- 문자열 메서드: `.upper()`, `.lower()`, `.split()`, `.join()`\n- 리스트 인덱싱 및 슬라이싱\n- 문자열 연결 (`+` 연산자 또는 `join()`)\n- 반복문 내부의 변수 변화\n- 출력문 (`print()`)\n\n**답:** 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출합니다. 이 경우 출력값은 **\"REMEMBER AND STR\"**입니다.",
      "explanation_preview": "**문제의 이미지를 참고하여 코드 실행 과정을 분석합니다.**\n\n**출력값이 \"REMEMBER AND STR\"인 경우 가능한 코드 패턴:**\n\n**패턴 1: 문자열 대문자 변환**\n```python\ntext = \"remember and str\"\nresult = text.upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n",
      "image_refs": [
        "images/2022_round2/13.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "REMEMBER AND STR"
        ],
        "raw_text": "REMEMBER AND STR"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 781
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q014",
      "doc_id": "2022_round2",
      "question_text": "다음 설명에 대해 보기에 주어진 답을 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ARP, RARP 등..))",
      "question_full": "다음 설명에 대해 보기에 주어진 답을 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ARP, RARP 등..))",
      "explanation_current": "이 문제는 **라우팅 프로토콜의 분류 및 종류**에 관한 문제입니다.\n\n**라우팅 프로토콜 분류:**\n\n**1. IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜):**\n\n**영어 약자 풀이:**\n- **I**nterior: 내부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- **IGP = Interior Gateway Protocol**\n\n**IGP의 정의:**\n- **AS(Autonomous System, 자율시스템) 내부**에서 사용하는 라우팅 프로토콜\n- 같은 관리 영역 내의 라우터 간 경로 정보 교환\n- 예: OSPF, RIP, IS-IS\n\n**IGP의 특징:**\n- **범위**: 단일 AS 내부\n- **목적**: AS 내부 최적 경로 선택\n- **신뢰성**: AS 내부 라우터들은 서로 신뢰할 수 있음\n\n**2. EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜):**\n\n**영어 약자 풀이:**\n- **E**xterior: 외부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- **EGP = Exterior Gateway Protocol**\n\n**EGP의 정의:**\n- **서로 다른 AS 간** 라우팅 정보를 교환하는 프로토콜\n- AS 간 경로 설정 및 정책 기반 라우팅\n- 예: BGP (현재 가장 널리 사용)\n\n**EGP의 특징:**\n- **범위**: AS 간\n- **목적**: AS 간 경로 설정 및 정책 기반 라우팅\n- **신뢰성**: 서로 다른 AS 간 신뢰도가 낮을 수 있음\n- **보안**: 보안과 제어가 중요 (빠른 수행보다 보안 우선)\n\n**3. OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜):**\n\n**영어 약자 풀이:**\n- **O**pen: 개방형\n- **S**hortest: 최단\n- **P**ath: 경로\n- **F**irst: 우선\n- **OSPF = Open Shortest Path First**\n\n**OSPF의 정의:**\n- **링크 상태(Link State) 기반** 라우팅 프로토콜\n- **IGP의 한 종류**: AS 내부 라우팅에 사용\n- **RIP의 단점을 개선**한 프로토콜\n\n**OSPF의 특징:**\n- **링크 상태 알고리즘**: 각 라우터가 전체 네트워크 토폴로지를 알고 최단 경로 계산\n- **대규모 네트워크 지원**: RIP보다 규모가 큰 네트워크에서 사용 가능\n- **자세한 제어**: 다양한 메트릭과 정책 설정 가능\n- **관리 정보 트래픽 감소**: RIP보다 효율적인 업데이트 방식\n- **계층적 구조**: Area(영역) 개념으로 확장성 향상\n\n**OSPF vs RIP:**\n| 특징 | **OSPF** | **RIP** |\n|------|----------|---------|\n| **알고리즘** | 링크 상태 | 거리 벡터 |\n| **네트워크 규모** | 대규모 네트워크 지원 | 소규모 네트워크 (15 홉 제한) |\n| **수렴 속도** | 빠름 | 느림 |\n| **트래픽** | 변경 시에만 업데이트 | 주기적 업데이트 |\n\n**4. BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜):**\n\n**BGP의 정의:**\n- **경로 벡터(Path Vector) 프로토콜**\n- **EGP의 한 종류**: AS 간 라우팅에 사용\n- 인터넷의 백본 프로토콜\n\n**BGP의 특징:**\n- **AS 간 라우팅**: 서로 다른 AS 간 경로 정보 교환\n- **전체 경로 정보**: AS Path 정보 포함\n- **정책 기반**: AS 수준에서 정책 결정 가능\n- **라우팅 루프 제거**: AS Path를 통한 루프 방지\n\n**라우팅 프로토콜 분류 요약:**\n\n| 분류 | 프로토콜 | 범위 | 특징 |\n|------|----------|------|------|\n| **IGP** | OSPF, RIP, IS-IS | AS 내부 | AS 내부 최적 경로 |\n| **EGP** | BGP | AS 간 | AS 간 경로 설정, 정책 기반 |\n| **OSPF** | - | AS 내부 (IGP) | 링크 상태, 대규모 네트워크 |\n| **BGP** | - | AS 간 (EGP) | 경로 벡터, 정책 기반 |\n\n**답:**\n- (1) **IGP (Interior Gateway Protocol)**\n- (2) **EGP (Exterior Gateway Protocol)**\n- (3) **OSPF (Open Shortest Path First)**\n- (4) **BGP (Border Gateway Protocol)**",
      "explanation_preview": "이 문제는 **라우팅 프로토콜의 분류 및 종류**에 관한 문제입니다.\n\n**라우팅 프로토콜 분류:**\n\n**1. IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜):**\n\n**영어 약자 풀이:**\n- **I**nterior: 내부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- **IGP = ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. IGP / 2. EGP / 3. OSPF / 4. BGP"
        ],
        "raw_text": "1. IGP / 2. EGP / 3. OSPF / 4. BGP"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2288
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q015",
      "doc_id": "2022_round2",
      "question_text": "다음 C언어에서 출력에 대한 알맞은 답을 작성하시오.",
      "question_full": "다음 C언어에서 출력에 대한 알맞은 답을 작성하시오.",
      "explanation_current": "이 문제는 **C언어 문자열 포인터와 문자열 길이 계산 함수**에 관한 문제입니다.\n\n**주어진 코드:**\n```c\n#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n  }\n return r;\n}\n```\n\n**코드 실행 과정:**\n\n**1. main() 함수 시작:**\n\n**변수 초기화:**\n- `char* p1 = \"2022\";`\n  - `p1`은 문자열 리터럴 \"2022\"의 주소를 가리키는 포인터\n  - 문자열 \"2022\"는 4개의 문자: '2', '0', '2', '2', '\\0' (널 문자 포함 5바이트)\n  - **실제 문자 개수: 4개** (널 문자 제외)\n\n- `char* p2 = \"202207\";`\n  - `p2`는 문자열 리터럴 \"202207\"의 주소를 가리키는 포인터\n  - 문자열 \"202207\"는 6개의 문자: '2', '0', '2', '2', '0', '7', '\\0' (널 문자 포함 7바이트)\n  - **실제 문자 개수: 6개** (널 문자 제외)\n\n**2. len(p1) 함수 호출:**\n```c\nint len(char* p)  // p는 \"2022\"의 주소를 받음\n```\n\n**len() 함수 내부 실행:**\n- `int r = 0;` - 길이 카운터 초기화\n- `while(*p != '\\0')` - 포인터가 가리키는 문자가 널 문자가 아닐 때까지 반복\n\n**반복 과정:**\n| 반복 | `*p` (현재 문자) | `*p != '\\0'` | `p++` | `r++` | `r` 값 |\n|------|----------------|--------------|-------|-------|--------|\n| 초기 | '2' | true | p 이동 | 1 | 1 |\n| 1 | '0' | true | p 이동 | 2 | 2 |\n| 2 | '2' | true | p 이동 | 3 | 3 |\n| 3 | '2' | true | p 이동 | 4 | 4 |\n| 4 | '\\0' | **false** | - | - | - |\n\n- **반복 종료**: 널 문자('\\0')를 만나면 반복 종료\n- `return r;` → **a = 4** 반환\n\n**3. len(p2) 함수 호출:**\n```c\nint len(char* p)  // p는 \"202207\"의 주소를 받음\n```\n\n**len() 함수 내부 실행:**\n- `int r = 0;` - 길이 카운터 초기화\n- `while(*p != '\\0')` - 널 문자까지 반복\n\n**반복 과정:**\n| 반복 | `*p` (현재 문자) | `*p != '\\0'` | `p++` | `r++` | `r` 값 |\n|------|----------------|--------------|-------|-------|--------|\n| 초기 | '2' | true | p 이동 | 1 | 1 |\n| 1 | '0' | true | p 이동 | 2 | 2 |\n| 2 | '2' | true | p 이동 | 3 | 3 |\n| 3 | '2' | true | p 이동 | 4 | 4 |\n| 4 | '0' | true | p 이동 | 5 | 5 |\n| 5 | '7' | true | p 이동 | 6 | 6 |\n| 6 | '\\0' | **false** | - | - | - |\n\n- **반복 종료**: 널 문자를 만나면 반복 종료\n- `return r;` → **b = 6** 반환\n\n**4. 최종 계산:**\n```c\nprintf(\"%d\", a + b);\n```\n- `a = 4` (\"2022\"의 길이)\n- `b = 6` (\"202207\"의 길이)\n- `a + b = 4 + 6 = 10`\n\n**출력:** `10`\n\n**핵심 개념:**\n1. **문자열 포인터**: `char*`는 문자열의 첫 번째 문자 주소를 가리킴\n2. **널 문자**: 문자열 끝에는 자동으로 '\\0' (널 문자)가 추가됨\n3. **포인터 연산**: `p++`는 다음 문자 위치로 포인터 이동\n4. **문자열 길이**: 널 문자를 제외한 실제 문자의 개수\n\n**답:** **10**",
      "explanation_preview": "이 문제는 **C언어 문자열 포인터와 문자열 길이 계산 함수**에 관한 문제입니다.\n\n**주어진 코드:**\n```c\n#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  p",
      "image_refs": [
        "images/2022_round2/15.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n }\n return r;\n}",
          "line_numbers": [
            1,
            17
          ],
          "file": "data/codes/2022_round2/Q015_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "10"
        ],
        "raw_text": "10"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2161
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q018",
      "doc_id": "2022_round2",
      "question_text": "다음은 함수 종속성에 대한 설명이다.\n해당 문제에 대한 알맞는 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nunion 등..))",
      "question_full": "다음은 함수 종속성에 대한 설명이다.\n해당 문제에 대한 알맞는 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nunion 등..))",
      "explanation_current": "**함수 종속성(Functional Dependency, FD)의 종류:**\n\n**함수 종속성 정의:**\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정됨 (X가 Y를 함수적으로 결정)\n- 예: `학번 → 이름` (학번이 결정되면 이름이 결정됨)\n\n**1. Full Functional Dependency (완전 함수 종속, 완전 종속):**\n- **정의**: 종속 속성(Y)이 **결정자(X)의 모든 속성**에 종속\n- **조건**: X의 **어떤 부분 집합도 Y를 결정할 수 없음**\n- **표기**: `X → Y` (X의 모든 속성이 필요)\n- **예시**: `{학생, 학과} → 성적`\n  - 성적은 학생과 학과 **모두** 알아야 결정됨\n  - 학생만으로는 성적을 결정할 수 없고, 학과만으로도 성적을 결정할 수 없음\n\n**2. Partial Functional Dependency (부분 함수 종속, 부분 종속):**\n- **정의**: 종속 속성(Y)이 **결정자(X)의 일부 속성**에만 종속\n- **조건**: X의 **부분 집합이 Y를 결정**할 수 있음\n- **표기**: `X의 부분집합 → Y`\n- **예시**:\n  - 기본키: `{학생, 학과}`\n  - `{학생, 학과} → 성적` (완전 종속)\n  - `학과 → 성적` (부분 종속: 학과만으로도 성적 결정 가능)\n  - 즉, 성적은 학과만 알아도 식별 가능\n\n**3. Transitive Functional Dependency (이행 함수 종속, 이행 종속):**\n- **정의**: **간접적인 종속 관계** (연쇄 종속)\n- **조건**: `X → Y`이고 `Y → Z`이면 `X → Z` (이행 종속)\n- **표기**: `X → Y → Z` (X가 Y를 결정하고, Y가 Z를 결정)\n- **예시**:\n  - `학번 → 학과`\n  - `학과 → 학과장`\n  - 따라서 `학번 → 학과장` (이행 종속)\n  - 학번이 학과를 결정하고, 학과가 학과장을 결정하므로 학번이 학과장을 결정\n\n**함수 종속성 종류 비교:**\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n| **Transitive (이행)** | **간접적인 종속** 관계 | 연쇄 종속 | `학번 → 학과 → 학과장` |\n\n**정규화와의 관계:**\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n\n**답:**\n- (1) **Full (완전 함수 종속)**\n- (2) **Partial (부분 함수 종속)**\n- (3) **Transitive (이행 함수 종속)**",
      "explanation_preview": "**함수 종속성(Functional Dependency, FD)의 종류:**\n\n**함수 종속성 정의:**\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정됨 (X가 Y를 함수적으로 결정)\n- 예: `학번 → 이름` (학번이 결정되면 이름이 결정됨)\n\n**1. Full Functional De",
      "image_refs": [
        "images/2022_round2/18.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. Full",
          "2. Partial",
          "3. Transitive"
        ],
        "raw_text": "1. Full 2. Partial 3. Transitive"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1504
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q019",
      "doc_id": "2022_round2",
      "question_text": "다음 설명에 대한 알맞는 답을 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ajax, 등..))",
      "question_full": "다음 설명에 대한 알맞는 답을 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ajax, 등..))",
      "explanation_current": "이 문제는 **웹 기술의 기본 개념**에 관한 문제입니다.\n\n**1. HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜):**\n\n**HTTP의 정의:**\n- 인터넷에서 **웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송**하기 위해 사용되는 통신 규약\n- 인터넷에서 **하이퍼텍스트(hypertext) 문서를 교환**하기 위하여 사용되는 통신규약\n- 이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 됨\n\n**HTTP의 특징:**\n- **웹 서버와 브라우저 간** 문서 전송 프로토콜\n- **응용 계층 프로토콜** (TCP/IP 기반)\n- **포트 번호**: 80 (HTTPS는 443)\n- **요청-응답 방식**: 클라이언트가 요청하고 서버가 응답\n\n**2. Hypertext (하이퍼텍스트):**\n\n**Hypertext의 정의:**\n- 문자, 그래픽, 음성 및 영상을 하나의 **연상 거미집(Web of Association)**과 같이 서로 연결시킨 정보 제공 방법\n- **제시된 순서에 관계없이** 이용자가 관련된 정보를 검색할 수 있도록 함\n- 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 **클릭함으로써 원하는 정보에 쉽게 접근**하는 방식\n\n**Hypertext의 특징:**\n- **비선형적 구조**: 거미집처럼 연결된 구조\n- **링크 기반**: 링크를 통해 정보 간 이동\n- **다양한 미디어**: 텍스트, 그래픽, 음성, 영상 포함\n- **사용자 주도 탐색**: 순서 없이 자유롭게 정보 탐색\n\n**3. HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어):**\n\n**HTML의 정의:**\n- **웹 페이지 표시를 위해 개발된 지배적인 마크업 언어**\n- 제목, 단락, 목록 등과 같은 본문을 위한 **구조적 의미를 나타내는 것**\n- 링크, 인용과 그 밖의 항목으로 **구조적 문서를 만들 수 있는 방법**을 제공\n\n**HTML의 특징:**\n- **마크업 언어**: 태그를 사용하여 문서 구조 표현\n- **웹 페이지 작성**: 웹 브라우저에서 표시되는 페이지 작성\n- **구조적 의미**: 태그로 문서의 의미와 구조 표현\n- **표준화**: W3C에서 표준화\n\n**웹 기술의 관계:**\n\n| 기술 | 역할 | 관계 |\n|------|------|------|\n| **Hypertext** | 정보 제공 방법 (개념) | 웹의 기본 개념 |\n| **HTML** | 웹 페이지 작성 언어 | Hypertext를 표현하는 언어 |\n| **HTTP** | 문서 전송 프로토콜 | HTML 문서를 전송하는 프로토콜 |\n\n**웹의 동작 흐름:**\n1. **HTML로 웹 페이지 작성** (Hypertext 구조)\n2. **HTTP로 HTML 문서 전송** (웹 서버 → 브라우저)\n3. **브라우저가 HTML 해석하여 표시** (Hypertext 구조로 표시)\n4. **사용자가 링크 클릭** (Hypertext 탐색)\n5. **새로운 페이지 요청** (HTTP로 전송)\n\n**답:**\n- (1) **HTTP (Hypertext Transfer Protocol)**\n- (2) **Hypertext (하이퍼텍스트)**\n- (3) **HTML (HyperText Markup Language)**",
      "explanation_preview": "이 문제는 **웹 기술의 기본 개념**에 관한 문제입니다.\n\n**1. HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜):**\n\n**HTTP의 정의:**\n- 인터넷에서 **웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송**하기 위해 사용되는 통신 규약\n- 인터넷에서 **하이퍼텍스트(hypertext) 문서를 교",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. HTTP",
          "2. Hypertext",
          "3. HTML"
        ],
        "raw_text": "1. HTTP 2. Hypertext 3. HTML"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1625
      }
    },
    {
      "file": "items_2022_round2.jsonl",
      "q_no": "Q003",
      "doc_id": "2022_round2",
      "question_text": "웹 페이지 표시를 위해 개발된 지배적인 마크업 언어다.\n또한, 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.",
      "question_full": "웹 페이지 표시를 위해 개발된 지배적인 마크업 언어다.\n또한, 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.",
      "explanation_current": "이 문제는 **HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)**에 대한 문제입니다.\n\n**HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)이란?**\n\n**영어 약자 풀이:**\n- **H**ypertext: 하이퍼텍스트\n- **T**ext: 텍스트\n- **M**arkup: 마크업\n- **L**anguage: 언어\n- **HTML = HyperText Markup Language**\n\n**문제에서 설명한 HTML의 특징:**\n\n1. **\"웹 페이지 표시를 위해 개발된 지배적인 마크업 언어\"**:\n   - **웹 페이지 표시**: 웹 브라우저에서 웹 페이지를 표시하기 위한 언어\n   - **지배적인**: 웹에서 가장 널리 사용되는 마크업 언어\n   - **마크업 언어**: 문서의 구조와 의미를 태그로 표현하는 언어\n\n2. **\"제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것\"**:\n   - **구조적 의미**: 문서의 구조를 태그로 표현\n   - **제목**: `<h1>`, `<h2>` 등\n   - **단락**: `<p>` 태그\n   - **목록**: `<ul>`, `<ol>`, `<li>` 태그\n\n3. **\"링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공\"**:\n   - **링크**: `<a>` 태그로 하이퍼링크 생성\n   - **인용**: `<blockquote>`, `<q>` 태그\n   - **구조적 문서**: 의미 있는 구조로 문서 작성 가능\n\n**HTML의 정의:**\n- **웹 페이지를 작성하기 위한 마크업 언어**\n- **태그(Tag)**를 사용하여 문서의 구조와 의미를 표현\n- **웹 브라우저**가 HTML을 해석하여 웹 페이지로 표시\n\n**HTML의 특징:**\n| 특징 | 설명 |\n|------|------|\n| **용도** | 웹 페이지 작성 |\n| **형식** | 마크업 언어 (태그 기반) |\n| **표준** | W3C에서 표준화 |\n| **버전** | HTML5 (현재 최신 버전) |\n\n**HTML의 주요 태그:**\n- **제목**: `<h1>`, `<h2>`, `<h3>` 등\n- **단락**: `<p>`\n- **목록**: `<ul>`, `<ol>`, `<li>`\n- **링크**: `<a href=\"...\">`\n- **이미지**: `<img src=\"...\">`\n- **인용**: `<blockquote>`, `<q>`\n- **구조**: `<div>`, `<span>`, `<section>`, `<article>` 등\n\n**HTML의 구조:**\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>제목</title>\n</head>\n<body>\n    <h1>제목</h1>\n    <p>단락</p>\n    <a href=\"링크\">링크</a>\n</body>\n</html>\n```\n\n**HTML vs 다른 마크업 언어:**\n| 구분 | **HTML** | **XML** | **XHTML** |\n|------|----------|---------|-----------|\n| **용도** | 웹 페이지 | 데이터 표현 | HTML의 XML 버전 |\n| **구조** | 태그 기반 | 태그 기반 | 태그 기반 (엄격한 문법) |\n\n**HTML과 웹 기술:**\n- **HTML**: 웹 페이지 구조와 내용\n- **CSS**: 웹 페이지 스타일 (디자인)\n- **JavaScript**: 웹 페이지 동작 (인터랙션)\n- **HTTP**: HTML 문서 전송 프로토콜\n\n**답:** **HTML (HyperText Markup Language)**",
      "explanation_preview": "이 문제는 **HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)**에 대한 문제입니다.\n\n**HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)이란?**\n\n**영어 약자 풀이:**\n- **H**ypertext: 하이퍼텍스트\n- **T**ext: 텍스트\n- **M**arkup: 마크업\n- ",
      "image_refs": [
        "images/2022_round2/3.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "HTML"
        ],
        "raw_text": "HTML"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1812
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q004",
      "doc_id": "2022_round3",
      "question_text": "아래 코드에 대한 출력 값을 작성하시오.",
      "question_full": "아래 코드에 대한 출력 값을 작성하시오.",
      "explanation_current": "**코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"24513\"**입니다.",
      "explanation_preview": "**코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"",
      "image_refs": [
        "images/2022_round3/4.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "24513"
        ],
        "raw_text": "24513"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 212
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q010",
      "doc_id": "2022_round3",
      "question_text": "다음 보안 관련 설명으로 가장 알맞는 용어를  작성하시오.\n(          )  은/는 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.\n서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 ",
      "question_full": "다음 보안 관련 설명으로 가장 알맞는 용어를  작성하시오.\n(          )  은/는 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.\n서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 미리 감지할 수 있다.",
      "explanation_current": "이 문제는 **SIEM (Security Information and Event Management, 보안 정보 및 이벤트 관리)**에 대한 문제입니다.\n\n**SIEM (Security Information and Event Management)이란?**\n\n**영어 약자 풀이:**\n- **S**ecurity: 보안\n- **I**nformation: 정보\n- **E**vent: 이벤트\n- **M**anagement: 관리\n- **SIEM = Security Information and Event Management**\n\n**문제에서 설명한 SIEM의 특징:**\n\n1. **\"머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석\"**:\n   - **머신러닝 기반**: AI/ML 기술을 활용한 이상 탐지\n   - **대량의 로그**: 시스템, 네트워크, 애플리케이션 등에서 발생하는 모든 로그\n   - **통합관리**: 여러 소스의 로그를 하나의 플랫폼에서 관리\n   - **분석**: 로그 분석을 통한 위협 탐지\n\n2. **\"사전에 위협에 대응하는 보안 솔루션\"**:\n   - **실시간 모니터링**: 위협 발생 시 즉시 감지\n   - **사전 대응**: 공격이 발생하기 전 예방\n   - **자동 대응**: 자동화된 위협 대응 기능\n\n3. **\"서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집\"**:\n   - **다양한 보안 솔루션**: 방화벽, IPS/IDS, 안티바이러스 등\n   - **중앙 집중식 수집**: 모든 로그를 한 곳에서 수집\n   - **통합 관리**: 여러 시스템의 로그를 통합하여 관리\n\n4. **\"네트워크 상태의 monitoring 및 이상징후를 미리 감지\"**:\n   - **네트워크 모니터링**: 네트워크 트래픽 및 상태 실시간 감시\n   - **이상징후 감지**: 비정상적인 패턴이나 행위 탐지\n   - **조기 경고**: 위협 발생 전 경고\n\n**SIEM의 주요 기능:**\n\n1. **로그 수집 및 통합**:\n   - 다양한 보안 솔루션에서 로그 수집\n   - 표준화된 형식으로 통합\n\n2. **실시간 모니터링**:\n   - 24/7 실시간 보안 모니터링\n   - 네트워크, 시스템, 애플리케이션 상태 감시\n\n3. **이상 탐지**:\n   - 머신러닝 기반 이상 행위 탐지\n   - 패턴 분석을 통한 위협 식별\n\n4. **사고 대응**:\n   - 위협 발생 시 자동 알림\n   - 사고 분석 및 대응 절차 지원\n\n5. **보고서 생성**:\n   - 보안 이벤트 분석 보고서\n   - 규정 준수 보고서\n\n**SIEM의 주요 용도:**\n- **보안 모니터링**: 실시간 보안 이벤트 모니터링\n- **위협 탐지**: 고급 지속적 위협(APT) 탐지\n- **사고 대응**: 보안 사고 분석 및 대응\n- **규정 준수**: 보안 규정 준수 확인\n\n**SIEM vs 다른 보안 솔루션:**\n| 구분 | **SIEM** | **방화벽** | **IDS/IPS** |\n|------|----------|-----------|------------|\n| **기능** | 로그 통합 분석 | 트래픽 차단 | 침입 탐지/차단 |\n| **범위** | 전체 보안 이벤트 | 네트워크 경계 | 네트워크 트래픽 |\n| **분석** | 머신러닝 기반 | 규칙 기반 | 패턴 기반 |\n\n**답:** **SIEM (Security Information and Event Management)**",
      "explanation_preview": "이 문제는 **SIEM (Security Information and Event Management, 보안 정보 및 이벤트 관리)**에 대한 문제입니다.\n\n**SIEM (Security Information and Event Management)이란?**\n\n**영어 약자 풀이:**\n- **S**ecurity: 보안\n- **I**nformation: 정보\n-",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "SIEM"
        ],
        "raw_text": "SIEM"
      },
      "primary_category": "정보보안",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1704
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q013",
      "doc_id": "2022_round3",
      "question_text": "다음 코드에 대한 출력 값을 작성하시오.",
      "question_full": "다음 코드에 대한 출력 값을 작성하시오.",
      "explanation_current": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"2\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.",
      "explanation_preview": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매",
      "image_refs": [
        "images/2022_round3/13.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "2"
        ],
        "raw_text": "2"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 369
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q016",
      "doc_id": "2022_round3",
      "question_text": "다음은 스케줄링에 관한 내용이다.\n괄호 안에 알맞는 답을 작성하시오.",
      "question_full": "다음은 스케줄링에 관한 내용이다.\n괄호 안에 알맞는 답을 작성하시오.",
      "explanation_current": "이 문제는 운영체제 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"SJF, RR, SRT\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.",
      "explanation_preview": "이 문제는 운영체제 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭",
      "image_refs": [
        "images/2022_round3/16.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "SJF",
          "RR",
          "SRT"
        ],
        "raw_text": "SJF RR SRT"
      },
      "primary_category": "운영체제",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 379
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q017",
      "doc_id": "2022_round3",
      "question_text": "다음은 UML에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\nUML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.\n구성 요소로는 사물, (    1    ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (     2    ) 다이어그램은 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 ",
      "question_full": "다음은 UML에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\nUML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.\n구성 요소로는 사물, (    1    ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (     2    ) 다이어그램은 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다.\n또한 UML 모델링에서 (     3    )은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는 오퍼레이션 세트를 정의하는 모델 요소이다.",
      "explanation_current": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"1. 관계, 2. 클래스, 3. 인터페이스\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.",
      "explanation_preview": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. 관계",
          "2. 클래스",
          "3. 인터페이스"
        ],
        "raw_text": "1. 관계 2. 클래스 3. 인터페이스"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 391
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q018",
      "doc_id": "2022_round3",
      "question_text": "다음은 E-R다이어그램에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(아래 그래프 기호는 정확히 기억이 나지 않아 임의로 작성한 것이니 참고만 해주세요.)\n(    1    )  :  개체집합 - 관계집합 연결\n(    2    )  :  개체 집합과의 연결\n(    3    )  :  관계집합 - 관계집합의 속성 연결\n(    4    )  : ",
      "question_full": "다음은 E-R다이어그램에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(아래 그래프 기호는 정확히 기억이 나지 않아 임의로 작성한 것이니 참고만 해주세요.)\n(    1    )  :  개체집합 - 관계집합 연결\n(    2    )  :  개체 집합과의 연결\n(    3    )  :  관계집합 - 관계집합의 속성 연결\n(    4    )  :  두 개체집합 관계에서 생성되는 값을 저장하는 속성\n(    5    )  :  같은 속성을 공유하는 개체들의 모임",
      "explanation_current": "이 문제는 **E-R 다이어그램(Entity-Relationship Diagram)**의 구성 요소와 기호에 대한 문제입니다.\n\n**E-R 다이어그램이란?**\n- 데이터베이스 설계에서 **개념적 설계 단계**에서 사용하는 다이어그램\n- 엔티티(Entity), 속성(Attribute), 관계(Relationship)를 시각적으로 표현\n\n**문제에서 설명한 각 구성 요소:**\n\n**1. (1) 개체집합 - 관계집합 연결:**\n- **답: 실선**\n- 개체집합(Entity Set)과 관계집합(Relationship Set)을 연결하는 선\n- E-R 다이어그램에서 개체와 관계를 연결하는 **실선(직선)**으로 표현\n- 예: 학생(개체)과 수강(관계)을 실선으로 연결\n\n**2. (2) 개체 집합과의 연결:**\n- **답: 관계집합**\n- 개체집합들을 연결하는 **관계집합(Relationship Set)**을 의미\n- 여러 개체집합 간의 관계를 나타내는 집합\n- 예: 학생 개체집합과 과목 개체집합을 연결하는 \"수강\" 관계집합\n\n**3. (3) 관계집합 - 관계집합의 속성 연결:**\n- **답: 점선**\n- 관계집합과 그 관계집합의 속성을 연결하는 **점선(Dashed Line)**\n- 관계집합 자체가 가지고 있는 속성(예: 수강 날짜, 성적 등)을 연결할 때 사용\n- 개체집합과 속성을 연결하는 점선과 유사하지만, 관계집합의 속성임을 구분\n\n**4. (4) 두 개체집합 관계에서 생성되는 값을 저장하는 속성:**\n- **답: 관계집합의 속성**\n- 두 개체집합 간의 관계에서 발생하는 값을 저장하는 속성\n- 예: \"학생\"과 \"과목\" 관계에서 \"수강일자\", \"성적\" 등은 관계집합의 속성\n- 개체집합의 속성이 아닌 관계 자체의 속성\n\n**5. (5) 같은 속성을 공유하는 개체들의 모임:**\n- **답: 개체집합**\n- **개체집합(Entity Set)**: 같은 속성을 공유하는 개체들의 모임\n- 예: \"학생\" 개체집합은 학번, 이름, 학과 등의 속성을 공유하는 학생들의 모임\n- 데이터베이스에서 테이블(릴레이션)에 해당\n\n**E-R 다이어그램 기호 요약:**\n| 요소 | 기호 | 설명 |\n|------|------|------|\n| **개체집합** | 사각형 | 엔티티를 나타냄 |\n| **관계집합** | 마름모 | 관계를 나타냄 |\n| **속성** | 타원 | 속성을 나타냄 |\n| **개체-관계 연결** | **실선** | 개체와 관계를 연결 |\n| **관계-속성 연결** | **점선** | 관계와 속성을 연결 |\n| **개체-속성 연결** | 점선 | 개체와 속성을 연결 |\n\n**답:**\n- (1) **실선**\n- (2) **관계집합**\n- (3) **점선**\n- (4) **관계집합의 속성**\n- (5) **개체집합**",
      "explanation_preview": "이 문제는 **E-R 다이어그램(Entity-Relationship Diagram)**의 구성 요소와 기호에 대한 문제입니다.\n\n**E-R 다이어그램이란?**\n- 데이터베이스 설계에서 **개념적 설계 단계**에서 사용하는 다이어그램\n- 엔티티(Entity), 속성(Attribute), 관계(Relationship)를 시각적으로 표현\n\n**문제에서 설명한 각",
      "image_refs": [
        "images/2022_round3/18.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. 실선",
          "2. 관계집합",
          "3. 점선"
        ],
        "raw_text": "1. 실선 2. 관계집합 3. 점선"
      },
      "primary_category": "데이터베이스",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1365
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q019",
      "doc_id": "2022_round3",
      "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "question_full": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "explanation_current": "**Java 배열과 반복문 문제입니다.**\n\n**문제의 전체 코드:**\n\n```java\npublic class Main {\n    static int[] MakeArray(){\n        int[] tempArr = new int[4];\n        \n        for(int i=0; i<tempArr.Length; i++){\n            tempArr[i] = i;\n        }\n        \n        return tempArr;\n    }\n    \n    public static void main(String[] args){\n        int[] intArr;\n        intArr = MakeArray();\n        \n        for(int i=0; i < intArr.Length; i++)\n            System.out.print(intArr[i]);\n    }\n}\n```\n\n**코드 실행 과정:**\n\n1. **`MakeArray()` 메서드:**\n   - `int[] tempArr = new int[4];`: 크기 4인 배열 생성\n   - 초기값: `[0, 0, 0, 0]`\n   \n   - `for(int i=0; i<tempArr.Length; i++)`: 0부터 3까지 반복\n     - `i=0`: `tempArr[0] = 0` → `[0, 0, 0, 0]`\n     - `i=1`: `tempArr[1] = 1` → `[0, 1, 0, 0]`\n     - `i=2`: `tempArr[2] = 2` → `[0, 1, 2, 0]`\n     - `i=3`: `tempArr[3] = 3` → `[0, 1, 2, 3]`\n   \n   - `return tempArr;`: `[0, 1, 2, 3]` 반환\n\n2. **`main()` 메서드:**\n   - `intArr = MakeArray();`: `intArr = [0, 1, 2, 3]`\n   \n   - `for(int i=0; i < intArr.Length; i++)`: 0부터 3까지 반복\n     - `i=0`: `System.out.print(intArr[0]);` → 출력: **0**\n     - `i=1`: `System.out.print(intArr[1]);` → 출력: **1**\n     - `i=2`: `System.out.print(intArr[2]);` → 출력: **2**\n     - `i=3`: `System.out.print(intArr[3]);` → 출력: **3**\n\n**최종 출력:** **0123**\n\n**핵심 포인트:**\n\n- 배열의 각 인덱스에 인덱스 값 자체를 저장 (`tempArr[i] = i`)\n- `System.out.print()`는 줄바꿈 없이 출력 (println과 다름)\n- 배열 길이: `.length` (Java에서는 소문자 'l'이지만, 문제 코드는 'L'로 표기)\n\n**답:** **0123** 타입과 초기값 확인\n   - 인스턴스 변수 vs 클래스 변수 vs 지역 변수 구분\n\n2. **반복문**:\n   - `for`, `while`, `do-while` 등의 반복문 구조 확인\n   - 반복 횟수와 조건 확인\n   - `System.out.print()` vs `System.out.println()` 구분 (줄바꿈 여부)\n\n3. **출력 순서**:\n   - 출력문의 실행 순서 확인\n   - 여러 출력문이 있을 경우 순서대로 출력\n\n4. **문자열/배열 처리**:\n   - 문자열의 인덱스 접근 (`charAt()`, `substring()` 등)\n   - 배열의 인덱스 접근 (`arr[i]`)\n\n**일반적인 \"0123\" 출력 패턴:**\n- **0부터 3까지**의 숫자를 순차적으로 출력하는 코드\n- `System.out.print()`를 사용하여 줄바꿈 없이 연속 출력\n- 반복문이나 순차적인 출력문으로 구현\n\n**답:** 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 변수의 초기값부터 시작하여 각 문장의 실행 결과를 순서대로 추적하면 정확한 답을 얻을 수 있습니다. 이 경우 출력값은 **\"0123\"**입니다.",
      "explanation_preview": "**Java 배열과 반복문 문제입니다.**\n\n**문제의 전체 코드:**\n\n```java\npublic class Main {\n    static int[] MakeArray(){\n        int[] tempArr = new int[4];\n        \n        for(int i=0; i<tempArr.Length; i++){\n           ",
      "image_refs": [
        "images/2022_round3/19.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "0123"
        ],
        "raw_text": "0123"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2065
      }
    },
    {
      "file": "items_2022_round3.jsonl",
      "q_no": "Q020",
      "doc_id": "2022_round3",
      "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "question_full": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "explanation_current": "**Java 코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"993\"**입니다.",
      "explanation_preview": "**Java 코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합",
      "image_refs": [
        "images/2022_round3/20.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "993"
        ],
        "raw_text": "993"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 220
      }
    },
    {
      "file": "items_2023_round1.jsonl",
      "q_no": "Q005",
      "doc_id": "2023_round1",
      "question_text": "아래 내용을 확인하여\n\n괄호 안에 용어를 표안에 알맞는 값을 고르시오.\n(보기가 있습니다.\nex: 패킷​\n등)",
      "question_full": "아래 내용을 확인하여\n\n괄호 안에 용어를 표안에 알맞는 값을 고르시오.\n(보기가 있습니다.\nex: 패킷​\n등)",
      "explanation_current": "**SSH (Secure Shell, 시큐어 셸):**\n\n**영어 약자 풀이:**\n- **S**ecure: 보안의, 안전한\n- **S**hell: 셸 (명령 프롬프트)\n- **H** (없음, SSH는 두 단어)\n- **SSH = Secure Shell**\n\n**SSH의 정의:**\n- **원격 접속을 위한 보안 프로토콜**\n- 네트워크상의 다른 컴퓨터에 **암호화된 통신**으로 접속\n- 기본 포트: **22번**\n\n**SSH의 주요 특징:**\n\n1. **원격 접속:**\n   - 네트워크상의 다른 컴퓨터에 로그인\n   - 원격 시스템에서 명령 실행\n   - `ssh user@hostname` 형태로 접속\n\n2. **파일 전송:**\n   - **SCP (Secure Copy)**: 암호화된 파일 복사\n   - **SFTP (SSH File Transfer Protocol)**: 암호화된 파일 전송\n\n3. **보안 기능:**\n   - **암호화된 통신**: 모든 데이터가 암호화되어 전송\n   - **공개키 기반 인증**: 비밀번호 없이 키 기반 인증 가능\n   - **IP 스푸핑 방지**: 연결 무결성 보장\n\n4. **기존 프로토콜의 보안 버전:**\n   - **rsh, rcp, rlogin, rexec**: 평문 통신 → SSH로 대체\n   - **Telnet**: 평문 통신 → SSH로 대체\n   - **FTP**: 평문 파일 전송 → SFTP로 대체\n\n**SSH vs 기존 프로토콜:**\n| 구분 | **기존 프로토콜** | **SSH** |\n|------|------------------|---------|\n| **통신** | 평문 (암호화 없음) | 암호화 |\n| **보안** | 취약 | 안전 |\n| **포트** | Telnet(23), FTP(21) | 22 |\n\n**답:** **SSH**",
      "explanation_preview": "**SSH (Secure Shell, 시큐어 셸):**\n\n**영어 약자 풀이:**\n- **S**ecure: 보안의, 안전한\n- **S**hell: 셸 (명령 프롬프트)\n- **H** (없음, SSH는 두 단어)\n- **SSH = Secure Shell**\n\n**SSH의 정의:**\n- **원격 접속을 위한 보안 프로토콜**\n- 네트워크상의 다른 컴퓨터에 **",
      "image_refs": [
        "images/2023_round1/5.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "SSH"
        ],
        "raw_text": "SSH"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 904
      }
    },
    {
      "file": "items_2023_round1.jsonl",
      "q_no": "Q006",
      "doc_id": "2023_round1",
      "question_text": "아래 내용을 확인하여\n\n알맞는 답을 작성하시오.",
      "question_full": "아래 내용을 확인하여\n\n알맞는 답을 작성하시오.",
      "explanation_current": "악성코드는 그 특성에 따라 웜, 트로이 목마, 바이러스로 분류됩니다.\n\n**악성코드의 특징:**\n\n1. **웜(Worm):**\n- 자기 복제를 통해 네트워크로 확산\n- 다른 파일에 기생하지 않고 독립적으로 실행\n- 네트워크 취약점을 이용해 빠르게 전파\n- 예: Code Red, Nimda\n\n2. **트로이 목마(Trojan Horse):**\n- 정상 프로그램으로 위장한 악성 코드\n- 사용자가 의도적으로 설치 (위장된 정상 프로그램처럼 보임)\n- 다른 파일에 기생하지 않음\n- 백도어 설치, 정보 탈취 등 수행\n\n3. **바이러스(Virus):**\n- 다른 파일에 기생하여 감염\n- 실행 파일, 문서 파일 등에 삽입\n- 사용자가 감염된 파일을 실행하면 활성화\n- 자기 복제 기능\n\n**비교:**\n- **바이러스**: 파일에 기생, 사용자 개입 필요\n- **웜**: 독립 실행, 네트워크 자동 전파\n- **트로이 목마**: 정상 프로그램 위장, 사용자 설치 유도\n\n**답:** \"1. 웜, 2. 트로이 목마, 3. 바이러스\"",
      "explanation_preview": "악성코드는 그 특성에 따라 웜, 트로이 목마, 바이러스로 분류됩니다.\n\n**악성코드의 특징:**\n\n1. **웜(Worm):**\n- 자기 복제를 통해 네트워크로 확산\n- 다른 파일에 기생하지 않고 독립적으로 실행\n- 네트워크 취약점을 이용해 빠르게 전파\n- 예: Code Red, Nimda\n\n2. **트로이 목마(Trojan Horse):**\n- 정상 프로그",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. 웜",
          "2. 트로이 목마",
          "3. 바이러스"
        ],
        "raw_text": "1. 웜 2. 트로이 목마 3. 바이러스"
      },
      "primary_category": "기타",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 517
      }
    },
    {
      "file": "items_2023_round1.jsonl",
      "q_no": "Q013",
      "doc_id": "2023_round1",
      "question_text": "[학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.\n조건\n\n- 컬럼의 값이 문자열일 경우 작은 따움표 ('  ')를 표시하시오.\n\n- SQL 마지막에 세미콜론(;)은 표기하지 않아도 관계 없습니다.",
      "question_full": "[학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.\n조건\n\n- 컬럼의 값이 문자열일 경우 작은 따움표 ('  ')를 표시하시오.\n\n- SQL 마지막에 세미콜론(;)은 표기하지 않아도 관계 없습니다.",
      "explanation_current": "이 문제는 **SQL DELETE 문**을 작성하는 문제입니다.\n\n**DELETE 문의 기본 구조:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**답:** **DELETE FROM 학생 WHERE 이름 = '민수'**",
      "explanation_preview": "이 문제는 **SQL DELETE 문**을 작성하는 문제입니다.\n\n**DELETE 문의 기본 구조:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테",
      "image_refs": [
        "images/2023_round1/13.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "DELETE FROM 학생 WHERE 이름 = '민수'"
        ],
        "raw_text": "DELETE FROM 학생 WHERE 이름 = '민수'"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 718
      }
    },
    {
      "file": "items_2023_round1.jsonl",
      "q_no": "Q015",
      "doc_id": "2023_round1",
      "question_text": "다음 파이썬 코드의 알맞는 출력값을 작성하시오.",
      "question_full": "다음 파이썬 코드의 알맞는 출력값을 작성하시오.",
      "explanation_current": "**Python Set 연산 문제입니다.**\n\n**문제의 전체 코드:**\n\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홀츠', '한국', '태국'})\nprint(a)\n```\n\n**코드 실행 과정:**\n\n1. **초기 Set 생성:**\n   ```python\n   a = {'한국', '중국', '일본'}\n   ```\n   - `a = {'한국', '중국', '일본'}`\n\n2. **`a.add('베트남')`:**\n   - Set에 '베트남' 추가\n   - `a = {'한국', '중국', '일본', '베트남'}`\n\n3. **`a.add('중국')`:**\n   - Set에 '중국' 추가 시도\n   - **Set은 중복을 허용하지 않음** → '중국'은 이미 있으므로 변화 없음\n   - `a = {'한국', '중국', '일본', '베트남'}`\n\n4. **`a.remove('일본')`:**\n   - Set에서 '일본' 제거\n   - `a = {'한국', '중국', '베트남'}`\n\n5. **`a.update({'홀츠', '한국', '태국'})`:**\n   - `update()`: 다른 Set의 모든 요소를 현재 Set에 추가 (합집합 연산)\n   - '홀츠', '한국', '태국' 추가 시도\n   - '한국'은 이미 있으므로 중복 제거됨\n   - '홀츠', '태국'만 추가됨\n   - `a = {'한국', '중국', '베트남', '홀츠', '태국'}`\n\n**그런데 이미지를 보면:**\n\n이미지의 실제 코드에서는 `update` 대신 다른 연산이 있을 수 있습니다. 문제의 정답이 \"{'중국', '한국', '일본', '베트남'}\"이므로, 실제 코드를 확인하여 정확한 연산을 파악해야 합니다.\n\n**Python Set 연산 정리:**\n\n- **`add(element)`**: 요소 1개 추가 (중복 시 무시)\n- **`remove(element)`**: 요소 제거 (없으면 에러)\n- **`update(set)`**: 다른 Set의 모든 요소 추가 (합집합)\n- **`discard(element)`**: 요소 제거 (없어도 에러 없음)\n\n**Set의 특징:**\n\n- **중복 허용 안 됨**: 같은 요소는 하나만 저장\n- **순서 없음**: 출력 순서는 보장되지 않음 (Python 3.7+에서는 입력 순서 유지)\n- **가변**: 요소 추가/제거 가능\n\n**답:** 문제 이미지의 실제 코드를 기반으로 연산을 추적하면 **{'중국', '한국', '일본', '베트남'}** - **메서드 오버라이딩**: 자식 클래스의 `display()`가 부모 클래스의 `display()`를 덮어씀\n   - 자식 클래스의 `display()` 메서드 실행\n   - `print(f\"Vehicle name: {self.name}\")` 실행\n   - `self.name = \"Spark\"`이므로 출력: **\"Vehicle name: Spark\"**\n\n**핵심 개념:**\n\n- **상속**: `Car(Vehicle)` - `Car`가 `Vehicle`을 상속받음\n- **`super()`**: 부모 클래스의 메서드나 생성자를 호출\n- **메서드 오버라이딩**: 자식 클래스에서 부모 클래스의 메서드를 재정의\n- **메서드 호출 순서**: 자식 클래스에 메서드가 있으면 자식 클래스의 메서드가 우선 호출됨\n\n**답:** **\"Vehicle name: Spark\"**",
      "explanation_preview": "**Python Set 연산 문제입니다.**\n\n**문제의 전체 코드:**\n\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홀츠', '한국', '태국'})\nprint(a)\n```\n\n**코드 실행 과정:**\n\n1. **초기 Set 생성:**\n   ```pyt",
      "image_refs": [
        "images/2023_round1/15.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "{'중국', '한국', '일본', '베트남'}"
        ],
        "raw_text": "{'중국', '한국', '일본', '베트남'}"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1709
      }
    },
    {
      "file": "items_2023_round1.jsonl",
      "q_no": "Q017",
      "doc_id": "2023_round1",
      "question_text": "다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.",
      "question_full": "다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.",
      "explanation_current": "**Java 추상 클래스, 메서드 오버로딩, 다형성을 묻는 문제입니다.**\n\n**이미지의 코드 분석:**\n\n```java\nabstract class Vehicle {\n    String name;\n    abstract public String getName(String val);\n    \n    public String getName() {\n        return \"Vehicle name: \" + name;\n    }\n}\n\nclass Car extends Vehicle {\n    public Car(String val) {\n        name=super.name=val;\n    }\n    \n    public String getName(String val) {\n        return \"Car name:\" + val;\n    }\n    \n    public String getName(byte val[]) {\n        return \"Car name:\" + val;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle obj = new Car(\"Spark\");\n        System.out.println(obj.getName());\n    }\n}\n```\n\n**코드 실행 과정:**\n\n1. **추상 클래스 Vehicle:**\n   - `String name` 필드 선언\n   - `abstract public String getName(String val)`: 추상 메서드 (파라미터 1개)\n   - `public String getName()`: 구현된 메서드 (파라미터 없음)\n\n2. **Car 클래스 (Vehicle 상속):**\n   - `public Car(String val)`: 생성자에서 `name = \"Spark\"` 설정\n   - `getName(String val)`: 추상 메서드 구현 (파라미터 String 1개)\n   - `getName(byte val[])`: 추가 오버로딩 메서드 (파라미터 byte배열)\n   - **주의**: `getName()` (파라미터 없음)은 오버라이딩하지 않음!\n\n3. **main 실행:**\n   - `Vehicle obj = new Car(\"Spark\");`\n     - Car 객체 생성, Vehicle 타입 변수에 저장 (다형성)\n     - 생성자 실행: `name = \"Spark\"`\n   \n   - `obj.getName()` 호출:\n     - Car 클래스에 `getName()` (파라미터 없음)이 **오버라이딩되지 않음**\n     - 따라서 **부모 클래스 Vehicle의 `getName()` 메서드 호출**\n     - `return \"Vehicle name: \" + name;`\n     - `name = \"Spark\"`이므로 반환값: **\"Vehicle name: Spark\"**\n   \n   - `System.out.println(...)`: **\"Vehicle name: Spark\"** 출력\n\n**핵심 개념:**\n\n1. **추상 클래스와 추상 메서드:**\n   - `abstract` 키워드로 선언\n   - 추상 메서드는 자식 클래스에서 반드시 구현해야 함\n   - 추상 클래스도 구현된 메서드를 가질 수 있음\n\n2. **메서드 오버로딩(Overloading):**\n   - 같은 이름의 메서드를 **파라미터 타입/개수**를 다르게 하여 여러 개 정의\n   - Car 클래스에서 `getName(String)`, `getName(byte[])`로 오버로딩\n\n3. **메서드 오버라이딩(Overriding) vs 오버로딩:**\n   - **오버라이딩**: 부모 클래스의 메서드를 **같은 시그니처(이름, 파라미터)**로 재정의\n   - **오버로딩**: 같은 이름의 메서드를 **다른 파라미터**로 정의\n   - 이 문제에서 `getName()`은 오버라이딩되지 않았으므로 부모 클래스 메서드 사용\n\n4. **다형성(Polymorphism):**\n   - `Vehicle obj = new Car(\"Spark\");`\n   - 부모 타입 변수에 자식 객체 저장\n   - 메서드 호출 시 실제 객체 타입(Car)의 메서드 우선 호출\n   - 단, 오버라이딩되지 않은 메서드는 부모 클래스 메서드 호출\n\n**메서드 호출 규칙:**\n\n| 메서드 | Car 클래스 정의 여부 | 호출되는 메서드 |\n|--------|---------------------|----------------|\n| `getName()` (파라미터 없음) | X (오버라이딩 안 됨) | **Vehicle.getName()** |\n| `getName(String)` | O (구현됨) | Car.getName(String) |\n| `getName(byte[])` | O (오버로딩) | Car.getName(byte[]) |\n\n**답:** **\"Vehicle name: Spark\"**",
      "explanation_preview": "**Java 추상 클래스, 메서드 오버로딩, 다형성을 묻는 문제입니다.**\n\n**이미지의 코드 분석:**\n\n```java\nabstract class Vehicle {\n    String name;\n    abstract public String getName(String val);\n    \n    public String getName() {\n       ",
      "image_refs": [
        "images/2023_round1/17.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "Vehicle name: Spark"
        ],
        "raw_text": "Vehicle name: Spark"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2448
      }
    },
    {
      "file": "items_2023_round1.jsonl",
      "q_no": "Q020",
      "doc_id": "2023_round1",
      "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "question_full": "다음 자바 코드에 대한 출력 값을 작성하시오.",
      "explanation_current": "**Java 코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"500\"**입니다.",
      "explanation_preview": "**Java 코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합",
      "image_refs": [
        "images/2023_round1/20.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "500"
        ],
        "raw_text": "500"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 220
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q005",
      "doc_id": "2023_round2",
      "question_text": "다음은 C언어의 문제이다.\n알맞은 출력값을 작성하시오.",
      "question_full": "다음은 C언어의 문제이다.\n알맞은 출력값을 작성하시오.",
      "explanation_current": "**주어진 코드:**\n```c\n#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0; i<3; i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}\n```\n\n**실행 과정:**\n\n1. **배열 합 계산:**\n   - `sum = 73 + 95 + 82 = 250`\n\n2. **switch 조건:**\n   - `sum / 30 = 250 / 30 = 8` (정수 나눗셈)\n\n3. **switch 실행:**\n   - `case 8:`로 이동\n   - **break가 없으므로 아래로 fall-through**\n   - `printf(\"B\")` 실행 → \"B\" 출력\n   - `case 7:` (빈 case, 계속 진행)\n   - `case 6:` → `printf(\"C\")` 실행 → \"C\" 출력\n   - `default:` → `printf(\"D\")` 실행 → \"D\" 출력\n\n**최종 출력:** **\"BCD\"**\n\n**핵심 포인트:**\n- **switch fall-through**: `break` 문이 없으면 다음 case로 계속 실행됨\n- **정수 나눗셈**: `250 / 30 = 8` (소수점 버림)\n\n**답:** **\"BCD\"**",
      "explanation_preview": "**주어진 코드:**\n```c\n#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0; i<3; i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case ",
      "image_refs": [
        "images/2023_round2/5.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0;i<3;i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}",
          "line_numbers": [
            1,
            16
          ],
          "file": "data/codes/2023_round2/Q005_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "BCD"
        ],
        "raw_text": "BCD"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 825
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q008",
      "doc_id": "2023_round2",
      "question_text": "다음 내용에 알맞는 답을 작성하시오.",
      "question_full": "다음 내용에 알맞는 답을 작성하시오.",
      "explanation_current": "템퍼프루핑(Tamper Proofing)은 소프트웨어나 시스템이 변조되지 않도록 보호하는 기술입니다.\n\n**템퍼프루핑의 특징:**\n- 소프트웨어 코드나 데이터가 무단으로 수정되는 것을 방지\n- 변조 시도를 감지하고 대응\n- 무결성 검증 기능 제공\n\n**답:** \"템퍼프루핑\"",
      "explanation_preview": "템퍼프루핑(Tamper Proofing)은 소프트웨어나 시스템이 변조되지 않도록 보호하는 기술입니다.\n\n**템퍼프루핑의 특징:**\n- 소프트웨어 코드나 데이터가 무단으로 수정되는 것을 방지\n- 변조 시도를 감지하고 대응\n- 무결성 검증 기능 제공\n\n**답:** \"템퍼프루핑\"",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "템퍼프루핑"
        ],
        "raw_text": "템퍼프루핑"
      },
      "primary_category": "기타",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 153
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q009",
      "doc_id": "2023_round2",
      "question_text": "다음은 C언어 문제이다.\n알맞은 출력값을 작성하시오.",
      "question_full": "다음은 C언어 문제이다.\n알맞은 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 스택(Stack) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 분석:**\n\n```c void into(int num) {\nif (point >= 10) printf(\"Full\");\nelse isWhat[++point] = num; // push (전위 증가)\n}\n\nint take() {\nif (isEmpty() == 1) printf(\"Empty\");\nelse return isWhat[point--]; // pop (후위 감소)\nreturn 0;\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `point = -1` (빈 스택)\n\n2. **`into(5); into(2);`**\n- 스택: `[5, 2]`, `point = 1`\n\n3. **while 루프:**첫 번째 반복:**\n- `take()` → `isWhat[1] = 2` 반환, `point = 0` → **\"2\"** 출력\n- `into(4);` → 스택: `[5, 4]`, `point = 1`\n- `into(1);` → 스택: `[5, 4, 1]`, `point = 2`\n- `take()` → `isWhat[2] = 1` 반환, `point = 1` → **\"1\"** 출력\n- `into(3);` → 스택: `[5, 4, 3]`, `point = 2`\n- `take()` → `isWhat[2] = 3` 반환, `point = 1` → **\"3\"** 출력\n- `take()` → `isWhat[1] = 4` 반환, `point = 0` → **\"4\"** 출력\n- `into(6);` → 스택: `[5, 6]`, `point = 1`\n- `take()` → `isWhat[1] = 6` 반환, `point = 0` → **\"6\"** 출력\n- `take()` → `isWhat[0] = 5` 반환, `point = -1` → **\"5\"** 출력\n\n**두 번째 반복:**\n- `isEmpty() == 1` → 루프 종료\n\n**최종 출력:** \"213465\"\n\n**답:** \"213465\"",
      "explanation_preview": "이 C언어 코드는 스택(Stack) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 분석:**\n\n```c void into(int num) {\nif (point >= 10) printf(\"Full\");\nelse isWhat[++point] = num; // push (전위 증가)\n}\n\nint take() {\nif (isEmpty() == 1) print",
      "image_refs": [
        "images/2023_round2/9.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#define MAX_SIZE 10\nint isWhat[MAX_SIZE];\nint point= -1;\nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    else isWhat[++point] = num;\n}\nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    else return isWhat[point--];\n    return 0;\n}\nint main(int argc, char const *argv[]){\n    int e;\n    into(5); into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take());\n        into(3); printf(\"%d\", take()); printf(\"%d\", take());\n        into(6); printf(\"%d\", take()); printf(\"%d\", take());\n    }\n    return 0;\n}",
          "line_numbers": [
            1,
            32
          ],
          "file": "data/codes/2023_round2/Q009_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "213465"
        ],
        "raw_text": "213465"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1002
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q013",
      "doc_id": "2023_round2",
      "question_text": "다음은 HDLC 프로토콜에 대한 설명이다.\n보기 안에 알맞는 답을 골라 작성하시오.\n\n(1) 프레임은 Seq, Next, P/F의 필드를 가진다. 또한 맨 처음 비트를 0으로 가진다. Seq는 송신용 순서번호를 가지고 있다. Next는 응답용 순서번호를 가진다. P/F는 P가 1로 설정된 경우 주국에서 종국에 데이터 전송을 허용하는 것을 의미하고 F가 1로",
      "question_full": "다음은 HDLC 프로토콜에 대한 설명이다.\n보기 안에 알맞는 답을 골라 작성하시오.\n\n(1) 프레임은 Seq, Next, P/F의 필드를 가진다. 또한 맨 처음 비트를 0으로 가진다. Seq는 송신용 순서번호를 가지고 있다. Next는 응답용 순서번호를 가진다. P/F는 P가 1로 설정된 경우 주국에서 종국에 데이터 전송을 허용하는 것을 의미하고 F가 1로 설정된 경우 종국에서 주국으로 데이터 전송을 하는 것을 의미한다.\n( 2 ) 프레임은 맨 앞의 필드가 1로 되어 있어 정보 프레임이 아니라는 것을 나타내고 다음 비트가 0이 나와있다. Type의 경우에는 2비트를 가지고 있어 4가지의 종류로 나누어진다.  데이터를 보내는 역할이 아니라 응답의 기능을 수행하므로 Seq에 대한 값은 필요가 없고 다음 프레임을 요구하는 Next만 존재한다.\n( 3 ) 프레임은 순서 번호가 없는 프레임을 의미한다. 첫 번째 비트와 두 번째 비트가 모두 1로 설정되어 있다. 여러 종류를 가지고 있는데 Type의 2비트와 Modifier의 3비트를 합쳐 5비트를 통해 종류를 나눈다.\n( 4 ) 은/는 두 호스트 모두 혼합국으로 동작한다. 양쪽에서 명령과 응답을 전송할 수 있다.\n( 5 ) 은/는 불균형 모드로 주국의 허락 없이 종국에서 데이터를 전송할 수 있다.\n\n[보기]\n\nㄱ. 연결제어\n\nㄴ. 감독\n\nㄷ. 정보\n\nㄹ. 양방향 응답\n\nㅁ. 익명\n\nㅂ. 비번호\n\nㅅ. 릴레이\n\nㅇ. 동기균형     ㅈ. 동기응답    ㅊ. 비동기균형     ㅋ. 비동기응답",
      "explanation_current": "이 문제는 **HDLC (High-Level Data Link Control) 프로토콜**의 프레임 타입과 모드에 대한 문제입니다.\n\n**HDLC 프레임 타입:**\n\n1. **정보 프레임 (Information Frame, ㄷ)**:\n   - **첫 번째 비트**: `0`\n   - **필드**: Seq (송신용 순서번호), Next (응답용 순서번호), P/F (Poll/Final)\n   - **P/F 필드**:\n     - P = 1: 주국에서 종국에 데이터 전송 허용\n     - F = 1: 종국에서 주국으로 데이터 전송\n   - **용도**: 실제 데이터 전송\n\n2. **감독 프레임 (Supervisory Frame, ㄴ)**:\n   - **첫 번째 비트**: `1`\n   - **두 번째 비트**: `0`\n   - **필드**: Type (2비트, 4가지 종류), Next (응답용 순서번호)\n   - **특징**: Seq 없음 (데이터 전송 역할이 아니므로)\n   - **용도**: 응답 기능 수행, 다음 프레임 요구\n\n3. **비번호 프레임 (Unnumbered Frame, ㅂ)**:\n   - **첫 번째 비트**: `1`\n   - **두 번째 비트**: `1`\n   - **필드**: Type (2비트), Modifier (3비트)\n   - **특징**: 순서 번호 없음 (Seq, Next 없음)\n   - **용도**: 연결 설정/해제, 오류 제어 등\n\n**HDLC 모드:**\n\n4. **비동기 균형 모드 (Asynchronous Balanced Mode, ㅊ)**:\n   - **특징**: 두 호스트 모두 **혼합국(Combined Station)**으로 동작\n   - **통신**: 양쪽에서 명령과 응답을 전송 가능\n   - **용도**: 점대점 연결\n\n5. **비동기 응답 모드 (Asynchronous Response Mode, ㅋ)**:\n   - **특징**: **불균형 모드**\n   - **통신**: 주국의 허락 없이 종국에서 데이터 전송 가능\n   - **용도**: 주국-종국 구조\n\n**HDLC 프레임 타입 비교:**\n\n| 프레임 타입 | 첫 비트 | 두 번째 비트 | Seq | Next | 용도 |\n|-----------|--------|------------|-----|------|------|\n| **정보** | 0 | - | 있음 | 있음 | 데이터 전송 |\n| **감독** | 1 | 0 | 없음 | 있음 | 응답, 제어 |\n| **비번호** | 1 | 1 | 없음 | 없음 | 연결 제어 |\n\n**HDLC 모드 비교:**\n\n| 모드 | 특징 | 용도 |\n|------|------|------|\n| **동기 균형** | 양쪽 모두 주국 | - |\n| **동기 응답** | 주국-종국 구조, 주국 허락 필요 | - |\n| **비동기 균형 (ㅊ)** | 양쪽 모두 혼합국, 양방향 전송 | 점대점 |\n| **비동기 응답 (ㅋ)** | 주국-종국, 종국 자율 전송 | 불균형 |\n\n**답:**\n- **1. ㄷ (정보)**\n- **2. ㄴ (감독)**\n- **3. ㅂ (비번호)**\n- **4. ㅊ (비동기 균형)**\n- **5. ㅋ (비동기 응답)**",
      "explanation_preview": "이 문제는 **HDLC (High-Level Data Link Control) 프로토콜**의 프레임 타입과 모드에 대한 문제입니다.\n\n**HDLC 프레임 타입:**\n\n1. **정보 프레임 (Information Frame, ㄷ)**:\n   - **첫 번째 비트**: `0`\n   - **필드**: Seq (송신용 순서번호), Next (응답용 순서번호), P",
      "image_refs": [
        "images/2023_round2/13.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. ㄷ",
          "2. ㄴ",
          "3. ㅂ"
        ],
        "raw_text": "1. ㄷ\n2. ㄴ\n3. ㅂ"
      },
      "primary_category": "운영체제",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1567
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q014",
      "doc_id": "2023_round2",
      "question_text": "다음은 자바에 대한 문제이다.\n알맞은 출력값을 작성하시오.",
      "question_full": "다음은 자바에 대한 문제이다.\n알맞은 출력값을 작성하시오.",
      "explanation_current": "**Java 코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"true false true\"**입니다.",
      "explanation_preview": "**Java 코드 실행 결과 분석 문제입니다.**\n\n**문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.**\n\n**일반적인 코드 실행 분석 방법:**\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n**답:** 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합",
      "image_refs": [
        "images/2023_round2/14.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "true",
          "false",
          "true"
        ],
        "raw_text": "true false true"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 232
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q015",
      "doc_id": "2023_round2",
      "question_text": "다음 보기는 암호화 알고리즘에 대한 내용이다.\n대칭키와 비대칭키에 해당하는 보기의 내용을 작성하시오 대칭키 : (              )\n비대칭키 : (                    )\nDES, RSA, AES, ECC,  ARIA, SEED",
      "question_full": "다음 보기는 암호화 알고리즘에 대한 내용이다.\n대칭키와 비대칭키에 해당하는 보기의 내용을 작성하시오 대칭키 : (              )\n비대칭키 : (                    )\nDES, RSA, AES, ECC,  ARIA, SEED",
      "explanation_current": "암호화 알고리즘은 키 사용 방식에 따라 대칭키와 비대칭키로 분류됩니다.\n\n**대칭키 암호화 (Symmetric Key Cryptography):**\n- 암호화와 복호화에 **같은 키** 사용\n- 빠른 속도, 대용량 데이터 처리 적합\n- 키 배포 문제 존재\n\n**대칭키 알고리즘:**\n- **DES (Data Encryption Standard)**: 56비트 키, 구형 표준\n- **AES (Advanced Encryption Standard)**: 128/192/256비트 키, 현재 표준\n- **ARIA (Academy Research Institute in America)**: 한국 표준 암호화 알고리즘\n- **SEED**: 한국 표준 블록 암호 알고리즘\n\n**비대칭키 암호화 (Asymmetric Key Cryptography):**\n- 암호화와 복호화에 **다른 키** 사용 (공개키/개인키 쌍)\n- 공개키는 공개, 개인키는 비공개\n- 키 배포 문제 해결\n- 상대적으로 느림\n\n**비대칭키 알고리즘:**\n- **RSA (Rivest-Shamir-Adleman)**: 가장 널리 사용되는 공개키 암호화\n- **ECC (Elliptic Curve Cryptography)**: 타원 곡선 기반, 작은 키로 높은 보안\n\n**답:**\n- 대칭키: DES, AES, ARIA, SEED\n- 비대칭키: RSA, ECC",
      "explanation_preview": "암호화 알고리즘은 키 사용 방식에 따라 대칭키와 비대칭키로 분류됩니다.\n\n**대칭키 암호화 (Symmetric Key Cryptography):**\n- 암호화와 복호화에 **같은 키** 사용\n- 빠른 속도, 대용량 데이터 처리 적합\n- 키 배포 문제 존재\n\n**대칭키 알고리즘:**\n- **DES (Data Encryption Standard)**: 56비트",
      "image_refs": [
        "images/2023_round2/15.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "대칭키: DES AES ARIA SEED",
          "비대칭키: RSA ECC"
        ],
        "raw_text": "대칭키: DES AES ARIA SEED 비대칭키: RSA ECC"
      },
      "primary_category": "정보보안",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 681
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q016",
      "doc_id": "2023_round2",
      "question_text": "다음 괄호 안에 알맞는 답을 작성하시오.",
      "question_full": "다음 괄호 안에 알맞는 답을 작성하시오.",
      "explanation_current": "이 문제는 **해시(Hash)** 또는 **해싱(Hashing)**에 대한 문제입니다. 문제의 설명을 확인하여 정확한 답을 작성해야 합니다.\n\n**해시(Hash)란?**\n\n**정의:**\n- 데이터를 **고정된 길이의 값(해시 값)**으로 변환하는 함수\n- **해시 함수(Hash Function)**: 입력 데이터를 해시 값으로 변환하는 함수\n- **해싱(Hashing)**: 해시 함수를 사용하여 데이터를 변환하는 과정\n\n**해시의 특징:**\n\n1. **고정된 길이**:\n   - 입력 데이터 크기에 관계없이 항상 같은 길이의 해시 값 생성\n   - 예: SHA-256은 항상 256비트 (32바이트) 출력\n\n2. **단방향 함수**:\n   - 해시 값에서 원본 데이터를 복원하기 어려움\n   - 암호화와 달리 복호화 불가\n\n3. **결정적 함수**:\n   - 같은 입력에 대해 항상 같은 해시 값 출력\n\n4. **충돌 가능성**:\n   - 서로 다른 입력이 같은 해시 값을 가질 수 있음 (해시 충돌)\n\n**해시의 용도:**\n\n1. **해시 테이블 (Hash Table)**:\n   - 빠른 데이터 검색, 삽입, 삭제\n   - O(1) 시간 복잡도 (평균)\n\n2. **데이터 무결성 검증**:\n   - 파일의 해시 값을 비교하여 변경 여부 확인\n   - 예: MD5, SHA-256 체크섬\n\n3. **암호화**:\n   - 비밀번호 해시 저장\n   - 디지털 서명\n\n4. **데이터베이스 인덱싱**:\n   - 해시 인덱스로 빠른 검색\n\n**해시 함수 예시:**\n\n- **MD5**: 128비트 해시 값\n- **SHA-1**: 160비트 해시 값\n- **SHA-256**: 256비트 해시 값\n- **CRC**: 순환 중복 검사\n\n**해시 테이블 구조:**\n\n```\n키(key) → 해시 함수 → 해시 값 → 인덱스 → 저장 위치\n```\n\n**답:** **\"해시\"** 또는 **\"해싱\"**",
      "explanation_preview": "이 문제는 **해시(Hash)** 또는 **해싱(Hashing)**에 대한 문제입니다. 문제의 설명을 확인하여 정확한 답을 작성해야 합니다.\n\n**해시(Hash)란?**\n\n**정의:**\n- 데이터를 **고정된 길이의 값(해시 값)**으로 변환하는 함수\n- **해시 함수(Hash Function)**: 입력 데이터를 해시 값으로 변환하는 함수\n- **해싱(H",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "해시"
        ],
        "raw_text": "해시"
      },
      "primary_category": "자료구조",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 945
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q018",
      "doc_id": "2023_round2",
      "question_text": "다음 코드는 선택정렬 구현에 관한 문제이다.\n오름차순으로 정렬할 경우 빈칸에 알맞는 연산자를 보기에서 골라 작성하시오.\n\n<, <=, =>, >, ==, /, %",
      "question_full": "다음 코드는 선택정렬 구현에 관한 문제이다.\n오름차순으로 정렬할 경우 빈칸에 알맞는 연산자를 보기에서 골라 작성하시오.\n\n<, <=, =>, >, ==, /, %",
      "explanation_current": "선택 정렬(Selection Sort)은 오름차순 정렬 시 최소값을 찾아 앞으로 이동시키는 알고리즘입니다.\n\n**선택 정렬 알고리즘:**\n1. 배열에서 최소값 찾기 2. 최소값을 첫 번째 위치와 교환 3. 남은 부분에서 최소값 찾기 4. 두 번째 위치와 교환 5. 반복...\n\n**오름차순 정렬:**\n- 작은 값부터 앞으로 이동\n- 비교 연산자: **\">\"** 사용 (큰 값이면 교환)\n- 또는 **\"<\"** 사용 (작은 값이면 교환)\n\n**코드 예시:**\n```c for(int i=0; i<n-1; i++){\nint min_idx = i;\nfor(int j=i+1; j<n; j++){\nif(arr[j] < arr[min_idx]) // 오름차순: <\nmin_idx = j;\n}\nswap(arr[i], arr[min_idx]);\n}\n```\n\n**답:** \">\" (또는 \"<\", 코드 구조에 따라)",
      "explanation_preview": "선택 정렬(Selection Sort)은 오름차순 정렬 시 최소값을 찾아 앞으로 이동시키는 알고리즘입니다.\n\n**선택 정렬 알고리즘:**\n1. 배열에서 최소값 찾기 2. 최소값을 첫 번째 위치와 교환 3. 남은 부분에서 최소값 찾기 4. 두 번째 위치와 교환 5. 반복...\n\n**오름차순 정렬:**\n- 작은 값부터 앞으로 이동\n- 비교 연산자: **\">\"*",
      "image_refs": [
        "images/2023_round2/18.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          ">"
        ],
        "raw_text": ">"
      },
      "primary_category": "알고리즘",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 447
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q019",
      "doc_id": "2023_round2",
      "question_text": "다음 파이썬 코드에서 알맞는 출력값을 작성하시오.",
      "question_full": "다음 파이썬 코드에서 알맞는 출력값을 작성하시오.",
      "explanation_current": "이 문제는 **Python 코드의 실행 결과**를 구하는 문제입니다. 문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.\n\n**문제 해결 방법:**\n\n이 문제는 Python 코드의 실행 흐름을 추적하여 출력값을 구하는 문제입니다. 코드의 실제 내용(변수, 문자열 조작, 리스트 메서드, 반복문 등)을 확인하고, 각 단계별로 변수 값의 변화를 추적하여 최종 출력값을 도출해야 합니다.\n\n**Python 코드 분석 시 확인사항:**\n\n1. **문자열 조작**:\n   - 문자열 슬라이싱: `str[start:end]`\n   - 문자열 메서드: `replace()`, `split()`, `join()`, `strip()` 등\n   - 문자열 인덱싱: `str[index]`\n\n2. **리스트 조작**:\n   - 리스트 인덱싱: `list[index]`\n   - 리스트 메서드: `append()`, `pop()`, `remove()`, `insert()` 등\n   - 리스트 슬라이싱: `list[start:end]`\n\n3. **반복문**:\n   - `for` 루프: `for item in iterable`\n   - `while` 루프: 조건에 따른 반복\n   - 반복 횟수와 종료 조건 확인\n\n4. **출력문**:\n   - `print()` 함수\n   - 출력 형식 및 구분자 확인\n\n**일반적인 Python 문자열/리스트 조작 패턴:**\n\n```python\n# 예시 1: 문자열 슬라이싱\ns = \"engineering\"\nprint(s[1:5])  # \"ngin\"\nprint(s[::2])  # \"enieig\"\n\n# 예시 2: 리스트 조작\narr = ['e', 'n', 'g', 'i', 'n', 'e', 'e', 'r', 'i', 'n', 'g']\narr.pop(0)  # 첫 번째 요소 제거\nprint(''.join(arr))  # \"ngineering\"\n```\n\n**답:** 문제의 이미지에서 코드를 확인하고, 문자열이나 리스트의 조작 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 문자열 슬라이싱, 인덱싱, 또는 리스트 조작을 통해 특정 문자들을 제거하거나 재배열하는 과정을 거칩니다.",
      "explanation_preview": "이 문제는 **Python 코드의 실행 결과**를 구하는 문제입니다. 문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.\n\n**문제 해결 방법:**\n\n이 문제는 Python 코드의 실행 흐름을 추적하여 출력값을 구하는 문제입니다. 코드의 실제 내용(변수, 문자열 조작, 리스트 메서드, 반복문 등)을 확인하고, 각 단계별로 변수 값의 변화를 추적하여",
      "image_refs": [
        "images/2023_round2/19.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "engneing"
        ],
        "raw_text": "engneing"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1077
      }
    },
    {
      "file": "items_2023_round2.jsonl",
      "q_no": "Q020",
      "doc_id": "2023_round2",
      "question_text": "다음 설명에 대한 알맞는 답을 작성하시오.",
      "question_full": "다음 설명에 대한 알맞는 답을 작성하시오.",
      "explanation_current": "스텁(Stub)과 드라이버(Driver)는 소프트웨어 테스트에서 사용하는 더미 모듈입니다.\n\n**스텁(Stub):**\n- 하향식 통합 테스트에서 사용\n- 상위 모듈이 호출하는 하위 모듈을 대체\n- 하위 모듈이 아직 구현되지 않았을 때 사용\n- 상위 모듈 테스트를 위해 간단한 결과만 반환\n\n**드라이버(Driver):**\n- 상향식 통합 테스트에서 사용\n- 하위 모듈을 호출하는 상위 모듈을 대체\n- 상위 모듈이 아직 구현되지 않았을 때 사용\n- 하위 모듈을 호출하고 결과를 확인\n\n**비교:**\n- **스텁**: 하위 모듈 대체 (상위 모듈 테스트)\n- **드라이버**: 상위 모듈 대체 (하위 모듈 테스트)\n\n**답:** \"1. 스텁, 2. 드라이버\"",
      "explanation_preview": "스텁(Stub)과 드라이버(Driver)는 소프트웨어 테스트에서 사용하는 더미 모듈입니다.\n\n**스텁(Stub):**\n- 하향식 통합 테스트에서 사용\n- 상위 모듈이 호출하는 하위 모듈을 대체\n- 하위 모듈이 아직 구현되지 않았을 때 사용\n- 상위 모듈 테스트를 위해 간단한 결과만 반환\n\n**드라이버(Driver):**\n- 상향식 통합 테스트에서 사용\n- ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "1. 스텁",
          "2. 드라이버"
        ],
        "raw_text": "1. 스텁 2. 드라이버"
      },
      "primary_category": "기타",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 366
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q002",
      "doc_id": "2023_round3",
      "question_text": "다음 설명하는 용어를 보기에 맞게 골라 기호를 작성하시오.",
      "question_full": "다음 설명하는 용어를 보기에 맞게 골라 기호를 작성하시오.",
      "explanation_current": "이 문제는 **OAuth (Open Authorization)**에 대한 문제입니다.\n\n**OAuth란?**\n\n**정의:**\n- **OAuth (Open Authorization)**: 제3자 애플리케이션에 사용자 리소스 접근 권한을 안전하게 부여하는 **인증 및 권한 부여 프로토콜**\n- 사용자가 비밀번호를 공유하지 않고도 다른 서비스에 자신의 계정 정보를 제공할 수 있게 합니다.\n\n**OAuth의 특징:**\n\n1. **인증 위임:**\n   - 사용자가 비밀번호를 제3자 앱에 제공할 필요 없음\n   - 인증 서버가 사용자 대신 권한 부여\n\n2. **토큰 기반 인증:**\n   - Access Token: 리소스 접근 권한 부여\n   - Refresh Token: Access Token 갱신\n\n3. **보안 향상:**\n   - 비밀번호 노출 방지\n   - 권한 범위 제한 가능 (Scope)\n\n**OAuth 흐름:**\n\n1. **사용자 요청**: 제3자 앱에 로그인 요청\n2. **인증 서버로 리다이렉트**: 사용자 인증\n3. **권한 승인**: 사용자가 권한 부여\n4. **토큰 발급**: Access Token 발급\n5. **리소스 접근**: 토큰으로 API 호출\n\n**OAuth 버전:**\n\n- **OAuth 1.0**: 서명 기반 인증\n- **OAuth 2.0**: 현재 가장 널리 사용되는 버전 (토큰 기반)\n\n**사용 예시:**\n\n- \"Google로 로그인\", \"Facebook으로 로그인\"\n- 소셜 미디어 연동\n- API 접근 권한 부여\n\n**답:** **ㅇ (OAuth)**",
      "explanation_preview": "이 문제는 **OAuth (Open Authorization)**에 대한 문제입니다.\n\n**OAuth란?**\n\n**정의:**\n- **OAuth (Open Authorization)**: 제3자 애플리케이션에 사용자 리소스 접근 권한을 안전하게 부여하는 **인증 및 권한 부여 프로토콜**\n- 사용자가 비밀번호를 공유하지 않고도 다른 서비스에 자신의 계정 정보",
      "image_refs": [
        "images/2023_round3/2.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ㅇ"
        ],
        "raw_text": "ㅇ"
      },
      "primary_category": "기타",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 781
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q006",
      "doc_id": "2023_round3",
      "question_text": "다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.",
      "question_full": "다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.",
      "explanation_current": "**관계 대수 UNION 연산:**\n\n**UNION 연산의 정의:**\n- 두 릴레이션을 **합집합**하는 연산\n- 두 릴레이션의 **모든 튜플을 합치고 중복을 제거**\n- 기호: `∪` 또는 `UNION`\n\n**UNION 연산의 조건:**\n- **차수(Degree) 동일**: 두 릴레이션의 속성 개수가 같아야 함\n- **도메인 호환**: 대응되는 속성의 도메인이 같아야 함\n\n**주어진 테이블 데이터:**\n- **테이블 1**: 컬럼 \"3\", 행: [1], [4]\n- **테이블 2**: 컬럼 \"2\", 행: [4], [3]\n\n**UNION 연산 실행:**\n1. **두 릴레이션 합치기**:\n   - 테이블 1: [1], [4]\n   - 테이블 2: [4], [3]\n   - 합치기: [1], [4], [4], [3]\n\n2. **중복 제거**:\n   - [4]가 중복되므로 하나만 유지\n   - 결과: [1], [4], [3]\n\n**답:** 문제의 이미지와 테이블 데이터를 확인하여 UNION 연산 결과를 작성합니다. 답은 **\"4 3 2\"**입니다.",
      "explanation_preview": "**관계 대수 UNION 연산:**\n\n**UNION 연산의 정의:**\n- 두 릴레이션을 **합집합**하는 연산\n- 두 릴레이션의 **모든 튜플을 합치고 중복을 제거**\n- 기호: `∪` 또는 `UNION`\n\n**UNION 연산의 조건:**\n- **차수(Degree) 동일**: 두 릴레이션의 속성 개수가 같아야 함\n- **도메인 호환**: 대응되는 속성의 도",
      "image_refs": [
        "images/2023_round3/6.png"
      ],
      "code_blocks": [],
      "table_refs": [
        {
          "id": "table1",
          "json": "data/tables/2023_round3/Q006_table1.json",
          "rows": 2,
          "cols": 1
        },
        {
          "id": "table2",
          "json": "data/tables/2023_round3/Q006_table2.json",
          "rows": 2,
          "cols": 1
        }
      ],
      "answer": {
        "keys": [
          "4",
          "3",
          "2"
        ],
        "raw_text": "4 3 2"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 532
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q007",
      "doc_id": "2023_round3",
      "question_text": "다음 설명은 서버 접근 통제의 유형이다.\n괄호 안에 들어갈 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)",
      "question_full": "다음 설명은 서버 접근 통제의 유형이다.\n괄호 안에 들어갈 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)",
      "explanation_current": "이 문제는 **서버 접근 통제(Access Control)** 유형을 묻는 문제입니다.\n\n**접근 통제 유형:**\n\n1. **MAC (Mandatory Access Control) - 강제적 접근 통제**\n- 미리 정해진 정책과 보안 등급에 따라 접근을 통제합니다.\n- 시스템 관리자가 접근 권한을 결정합니다.\n\n2. **RBAC (Role-Based Access Control) - 역할 기반 접근 통제**\n- 사용자의 역할(role)에 따라 접근 권한을 부여합니다.\n- DAC와 MAC의 단점을 보완한 방식입니다.\n\n3. **DAC (Discretionary Access Control) - 임의적 접근 통제**\n- 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한합니다.\n- 객체의 소유자가 접근 권한을 결정합니다.\n\n**문제에서 설명하는 특징을 각 유형과 매칭:**\n- 문제의 첫 번째 설명 → MAC\n- 문제의 두 번째 설명 → RBAC\n- 문제의 세 번째 설명 → DAC\n\n**답:**\n- (1) **MAC**\n- (2) **RBAC**\n- (3) **DAC**",
      "explanation_preview": "이 문제는 **서버 접근 통제(Access Control)** 유형을 묻는 문제입니다.\n\n**접근 통제 유형:**\n\n1. **MAC (Mandatory Access Control) - 강제적 접근 통제**\n- 미리 정해진 정책과 보안 등급에 따라 접근을 통제합니다.\n- 시스템 관리자가 접근 권한을 결정합니다.\n\n2. **RBAC (Role-Based Acc",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "(1) MAC",
          "(2) RBAC",
          "(3) DAC"
        ],
        "raw_text": "(1) MAC\n(2) RBAC\n(3) DAC"
      },
      "primary_category": "기타",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 552
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q008",
      "doc_id": "2023_round3",
      "question_text": "다음 C언어 코드에 알맞는 출력값을 작성하시오.",
      "question_full": "다음 C언어 코드에 알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.\n\n**팩토리얼이란?**\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n\n**코드 실행 단계:**\n\n```c f(7) = 7 * f(6)\n= 7 * 6 * f(5)\n= 7 * 6 * 5 * f(4)\n= 7 * 6 * 5 * 4 * f(3)\n= 7 * 6 * 5 * 4 * 3 * f(2)\n= 7 * 6 * 5 * 4 * 3 * 2 * f(1)\n= 7 * 6 * 5 * 4 * 3 * 2 * 1\n= 5040\n```\n\n**재귀 호출 추적:**\n1. `f(7)` 호출 → `7 * f(6)` 반환 2. `f(6)` 호출 → `6 * f(5)` 반환 3. `f(5)` 호출 → `5 * f(4)` 반환 4. `f(4)` 호출 → `4 * f(3)` 반환 5. `f(3)` 호출 → `3 * f(2)` 반환 6. `f(2)` 호출 → `2 * f(1)` 반환 7. `f(1)` 호출 → `1` 반환 (기저 조건)\n\n**최종 계산:**\n7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = **5040**최종 출력:**5040**핵심 포인트:**\n- 재귀 함수는 자기 자신을 호출하여 문제를 해결합니다.\n- 기저 조건(n <= 1)에서 재귀가 종료됩니다.",
      "explanation_preview": "이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.\n\n**팩토리얼이란?**\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n\n**코드 실행 단계:**\n\n```c f(7) = 7 * f(6)\n= 7 * 6 * f(5)\n= 7 * 6 * 5 * f(4)\n= 7 * 6 * 5 * 4 * f(3)\n= 7 * 6",
      "image_refs": [
        "images/2023_round3/8.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include\nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\nint main() {\n    printf(\"%d\", f(7));\n}",
          "line_numbers": [
            1,
            8
          ],
          "file": "data/codes/2023_round3/Q008_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "5040"
        ],
        "raw_text": "5040"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 646
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q009",
      "doc_id": "2023_round3",
      "question_text": "다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)",
      "question_full": "다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)",
      "explanation_current": "이 문제는 네트워크 프로토콜 중 **ATM (Asynchronous Transfer Mode)**에 대한 문제입니다.\n\n**ATM (Asynchronous Transfer Mode):**\n- 비동기 전송 방식으로, 데이터를 고정 크기의 셀(cell) 단위로 전송합니다.\n- 셀 크기는 53바이트입니다 (48바이트 데이터 + 5바이트 헤더).\n- 고속 데이터 전송을 위해 개발되었습니다.\n\n**ATM의 특징:**\n1. 고정 크기 셀 사용 (53바이트)\n2. 고속 전송 (155Mbps ~ 622Mbps)\n3. 품질 보장(QoS) 지원 4. 실시간 멀티미디어 서비스에 적합\n\n**문제에서 설명하는 특징과 매칭:**\n- 문제에서 설명한 특징들이 ATM 프로토콜과 일치합니다.\n\n**답:**ATM**",
      "explanation_preview": "이 문제는 네트워크 프로토콜 중 **ATM (Asynchronous Transfer Mode)**에 대한 문제입니다.\n\n**ATM (Asynchronous Transfer Mode):**\n- 비동기 전송 방식으로, 데이터를 고정 크기의 셀(cell) 단위로 전송합니다.\n- 셀 크기는 53바이트입니다 (48바이트 데이터 + 5바이트 헤더).\n- 고속 데이터 ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ATM"
        ],
        "raw_text": "ATM"
      },
      "primary_category": "기타",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 387
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q010",
      "doc_id": "2023_round3",
      "question_text": "다음은 C언어의 포인터 문제이다.\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어의 포인터 문제이다.\n알맞는 출력값을 작성하시오.",
      "explanation_current": "**C언어 포인터와 문자열 출력 문제입니다.**\n\n**문제의 코드:**\n\n```c\nchar* p = \"KOREA\";\nprintf(\"%s\\n\", p);        // 1번 출력\nprintf(\"%s\\n\", p+1);     // 2번 출력\nprintf(\"%c\\n\", *p);      // 3번 출력\nprintf(\"%c\\n\", *(p+3));  // 4번 출력\nprintf(\"%c\\n\", *p+4);    // 5번 출력\n```\n\n**실행 과정:**\n\n1. **`char* p = \"KOREA\"`**:\n   - `p`는 문자열 \"KOREA\"의 첫 번째 문자 주소를 가리킴\n   - 메모리: `K`(p) `O`(p+1) `R`(p+2) `E`(p+3) `A`(p+4) `\\0`(p+5)\n\n2. **`printf(\"%s\\n\", p)`**:\n   - `%s`: 문자열 출력 포맷\n   - `p`가 가리키는 위치부터 널 문자(`\\0`)까지 출력\n   - 출력: **\"KOREA\"**\n\n3. **`printf(\"%s\\n\", p+1)`**:\n   - `p+1`은 두 번째 문자(`O`) 주소\n   - `p+1`부터 널 문자까지 출력\n   - 출력: **\"OREA\"**\n\n4. **`printf(\"%c\\n\", *p)`**:\n   - `%c`: 문자 1개 출력 포맷\n   - `*p`: p가 가리키는 값 (첫 번째 문자)\n   - 출력: **\"K\"**\n\n5. **`printf(\"%c\\n\", *(p+3))`**:\n   - `p+3`은 네 번째 문자(`E`) 주소\n   - `*(p+3)`: 네 번째 문자의 값\n   - 출력: **\"E\"**\n\n6. **`printf(\"%c\\n\", *p+4)`**:\n   - `*p`: 'K' (ASCII 75)\n   - `*p+4`: 75 + 4 = 79 (산술 연산)\n   - ASCII 79 = 'O'\n   - 출력: **\"O\"**\n\n**핵심 포인트:**\n\n- **포인터 연산**: `p+1`, `p+3` 등으로 주소 이동\n- **역참조**: `*p`로 포인터가 가리키는 값 접근\n- **문자열 출력**: `%s`는 널 문자까지 출력\n- **문자 출력**: `%c`는 문자 1개 출력\n- **산술 연산**: `*p+4`는 값에 4를 더함 (ASCII 값 증가)\n\n**답:** **\"KOREA\", \"OREA\", \"K\", \"E\", \"O\"**",
      "explanation_preview": "**C언어 포인터와 문자열 출력 문제입니다.**\n\n**문제의 코드:**\n\n```c\nchar* p = \"KOREA\";\nprintf(\"%s\\n\", p);        // 1번 출력\nprintf(\"%s\\n\", p+1);     // 2번 출력\nprintf(\"%c\\n\", *p);      // 3번 출력\nprintf(\"%c\\n\", *(p+3));  // 4번 출",
      "image_refs": [
        "images/2023_round3/10.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include\nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s\\n\", p);\n    printf(\"%s\\n\", p+1);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *(p+3));\n    printf(\"%c\\n\", *p+4);\n}",
          "line_numbers": [
            1,
            9
          ],
          "file": "data/codes/2023_round3/Q010_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "KOREA",
          "OREA",
          "K"
        ],
        "raw_text": "KOREA K"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1152
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q011",
      "doc_id": "2023_round3",
      "question_text": "다음은 Java 코드에 대한 알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 알맞는 출력값을 작성하시오.",
      "explanation_current": "**Java 재귀 함수와 메서드 오버라이딩 문제입니다.**\n\n**문제의 코드:**\n\n```java\nclass Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-2);  // 피보나치 패턴\n    }\n}\n\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-3);  // 오버라이딩\n    }\n}\n\nParent obj = new Child();\nSystem.out.print(obj.compute(7));\n```\n\n**실행 과정:**\n\n1. **`obj.compute(7)` 호출:**\n   - `obj`는 `Child` 타입이지만 `Parent` 참조로 선언\n   - **동적 바인딩**: 실제 객체 타입(`Child`)의 메서드 호출\n   - `Child.compute(7)` 실행\n\n2. **`Child.compute(7)` 재귀 호출 추적:**\n   - `compute(7) = compute(6) + compute(4)`\n   - `compute(6) = compute(5) + compute(3)`\n   - `compute(5) = compute(4) + compute(2)`\n   - `compute(4) = compute(3) + compute(1)`\n   - `compute(3) = compute(2) + compute(0)`\n   - `compute(2) = compute(1) + compute(-1)`\n   - `compute(1) = 1` (기저 조건)\n   - `compute(0) = 0` (기저 조건)\n   - `compute(-1) = -1` (기저 조건)\n\n3. **계산 결과:**\n   - `compute(2) = 1 + (-1) = 0`\n   - `compute(3) = 0 + 0 = 0`\n   - `compute(4) = 0 + 1 = 1`\n   - `compute(5) = 1 + 0 = 1`\n   - `compute(6) = 1 + 0 = 1`\n   - `compute(7) = 1 + 1 = 2`\n\n**핵심 포인트:**\n\n- **메서드 오버라이딩**: 자식 클래스가 부모 클래스의 메서드를 재정의\n- **동적 바인딩**: 실제 객체 타입(`Child`)에 따라 메서드 호출\n- **재귀 함수**: 자기 자신을 호출하여 문제 해결\n- **기저 조건**: `num <= 1`일 때 재귀 종료\n\n**답:** **\"2\"**",
      "explanation_preview": "**Java 재귀 함수와 메서드 오버라이딩 문제입니다.**\n\n**문제의 코드:**\n\n```java\nclass Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-2);  // 피보나치 패턴\n    }\n}\n\nc",
      "image_refs": [
        "images/2023_round3/11.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}",
          "line_numbers": [
            1,
            20
          ],
          "file": "data/codes/2023_round3/Q011_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "2"
        ],
        "raw_text": "2"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1342
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q012",
      "doc_id": "2023_round3",
      "question_text": "IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?",
      "question_full": "IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?",
      "explanation_current": "**NAT (Network Address Translation) 기술 문제입니다.**\n\n**NAT의 정의:**\n- 외부의 공인 IP 주소와 포트를 내부의 사설 IP 주소로 변환하는 기술\n- 라우터나 방화벽에서 구현됨\n- 여러 내부 네트워크가 하나의 공인 IP를 공유할 수 있게 함\n\n**NAT의 주요 특징:**\n1. **주소 변환**: 공인 IP ↔ 사설 IP 변환\n2. **포트 변환**: 포트 번호도 함께 변환 (PAT: Port Address Translation)\n3. **트래픽 라우팅**: 라우터를 통해 네트워크 트래픽을 주고받음\n4. **보안 향상**: 내부 네트워크 구조를 외부에 숨김\n\n**문제에서 설명하는 내용:**\n- \"외부의 공인 IP 주소와 포트 주소에 해당하는 내부 IP 주소를 재기록\"\n- \"라우터를 통해 네트워크 트래픽을 주고받는 기술\"\n\n→ 이는 정확히 NAT 기술의 정의입니다.\n\n**답:** **NAT**",
      "explanation_preview": "**NAT (Network Address Translation) 기술 문제입니다.**\n\n**NAT의 정의:**\n- 외부의 공인 IP 주소와 포트를 내부의 사설 IP 주소로 변환하는 기술\n- 라우터나 방화벽에서 구현됨\n- 여러 내부 네트워크가 하나의 공인 IP를 공유할 수 있게 함\n\n**NAT의 주요 특징:**\n1. **주소 변환**: 공인 IP ↔ 사설 I",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "NAT"
        ],
        "raw_text": "NAT"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 469
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q013",
      "doc_id": "2023_round3",
      "question_text": "다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오.",
      "question_full": "다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오.",
      "explanation_current": "**Java 컴파일 에러 탐지 문제입니다.**\n\n**문제의 코드:**\n\n```java\nclass Person {\n    private String name;                    // 2번 라인: 인스턴스 변수\n    public Person(String val) {            // 3번 라인: 생성자\n        name = val;                        // 4번 라인\n    }\n    public static String get() {          // 6번 라인: static 메서드\n    return name;                          // 7번 라인: 에러 발생! ❌\n    }\n    public void print() {                  // 9번 라인\n        System.out.println(name);         // 10번 라인\n    }\n}\n```\n\n**에러 원인:**\n\n**7번 라인 (`return name;`)에서 에러 발생:**\n\n- **문제**: `static` 메서드에서 **인스턴스 변수(`name`)**에 접근하려고 함\n- **Java 규칙**:\n  - `static` 메서드는 **인스턴스 변수에 직접 접근 불가**\n  - `static` 메서드는 **인스턴스 생성 없이 호출 가능**\n  - 인스턴스 변수는 **인스턴스 생성 후에만 존재**\n\n**에러 메시지:**\n```\nNon-static field 'name' cannot be referenced from a static context\n```\n\n**해결 방법:**\n\n1. **`name`을 `static` 변수로 변경:**\n   ```java\n   private static String name;\n   ```\n\n2. **`get()` 메서드를 `static`이 아닌 인스턴스 메서드로 변경:**\n   ```java\n   public String get() {\n       return name;\n   }\n   ```\n\n3. **인스턴스를 통해 접근:**\n   ```java\n   public static String get(Person p) {\n       return p.name;\n   }\n   ```\n\n**Java static vs instance:**\n\n| 구분 | static | instance |\n|------|--------|----------|\n| **메서드** | 클래스 이름으로 호출 | 객체로 호출 |\n| **변수** | 클래스 변수 (공유) | 인스턴스 변수 (개별) |\n| **접근** | static 멤버만 접근 가능 | 인스턴스 멤버 접근 가능 |\n\n**답:** **7번 라인**",
      "explanation_preview": "**Java 컴파일 에러 탐지 문제입니다.**\n\n**문제의 코드:**\n\n```java\nclass Person {\n    private String name;                    // 2번 라인: 인스턴스 변수\n    public Person(String val) {            // 3번 라인: 생성자\n        name = val",
      "image_refs": [
        "images/2023_round3/13.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Person {\n    private String name;\n    public Person(String val) {\n        name = val;\n    }\n    public static String get() {\n    return name;\n    }\n    public void print() {\n        System.out.println(name);\n    }\n}\npublic class main {\n    public static void main(String[] args) {\n        Person obj = new Person(\"Kim\");\n        obj.print();\n    }\n}",
          "line_numbers": [
            1,
            18
          ],
          "file": "data/codes/2023_round3/Q013_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "7"
        ],
        "raw_text": "7"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1345
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q015",
      "doc_id": "2023_round3",
      "question_text": "다음은 판매와 관련된 다이어그램이다.\n해당 다이어그램의 명칭을 쓰시오.",
      "question_full": "다음은 판매와 관련된 다이어그램이다.\n해당 다이어그램의 명칭을 쓰시오.",
      "explanation_current": "**UML 패키지 다이어그램 (Package Diagram):**\n\n**패키지 다이어그램의 정의:**\n- 관련된 클래스나 모듈을 **패키지로 그룹화**하여 표현하는 UML 다이어그램\n- 패키지 간의 **의존 관계**를 보여줌\n- 모듈화와 재사용성을 나타냄\n\n**패키지 다이어그램의 특징:**\n- **그룹화**: 관련된 클래스들을 패키지로 묶어 표현\n- **의존 관계**: 패키지 간의 의존 관계를 화살표로 표시\n- **모듈화**: 시스템을 논리적으로 분할\n- **재사용성**: 패키지 단위로 재사용 가능\n\n**문제의 이미지 확인:**\n- \"판매와 관련된 다이어그램\"에서 여러 클래스나 모듈을 패키지로 그룹화한 구조를 확인\n- 이는 **패키지 다이어그램**의 특징\n\n**UML 다이어그램 종류:**\n| 다이어그램 | 용도 |\n|-----------|------|\n| **클래스 다이어그램** | 클래스 구조와 관계 |\n| **시퀀스 다이어그램** | 객체 간 메시지 흐름 |\n| **패키지 다이어그램** | 패키지 그룹화 및 의존 관계 |\n| **액티비티 다이어그램** | 업무 흐름 또는 알고리즘 |\n\n**답:** **패키지**",
      "explanation_preview": "**UML 패키지 다이어그램 (Package Diagram):**\n\n**패키지 다이어그램의 정의:**\n- 관련된 클래스나 모듈을 **패키지로 그룹화**하여 표현하는 UML 다이어그램\n- 패키지 간의 **의존 관계**를 보여줌\n- 모듈화와 재사용성을 나타냄\n\n**패키지 다이어그램의 특징:**\n- **그룹화**: 관련된 클래스들을 패키지로 묶어 표현\n- **의",
      "image_refs": [
        "images/2023_round3/15.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "패키지"
        ],
        "raw_text": "패키지"
      },
      "primary_category": "기타",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 575
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q016",
      "doc_id": "2023_round3",
      "question_text": "다음 설명에 알맞는 답을 보기에서 골라 작성하시오.",
      "question_full": "다음 설명에 알맞는 답을 보기에서 골라 작성하시오.",
      "explanation_current": "**Equivalence Partitioning (동등 분할) 테스트 기법 문제입니다.**\n\n**Equivalence Partitioning (동등 분할)의 정의:**\n- 입력 데이터를 **동등한(equivalent) 그룹으로 분할**하여 각 그룹에서 **대표값 하나씩만 테스트**하는 기법\n- **EP (Equivalence Partitioning)**라고도 함\n- 블랙박스 테스트 기법 중 하나\n\n**동등 분할의 특징:**\n\n1. **입력 영역 분할:**\n   - 유효한 입력 영역과 무효한 입력 영역으로 분할\n   - 각 영역 내의 값들은 동일하게 처리됨\n\n2. **대표값 선택:**\n   - 각 분할 영역에서 **대표값 하나만 선택**하여 테스트\n   - 분할 영역 내의 모든 값은 동일한 결과를 가정\n\n3. **테스트 케이스 감소:**\n   - 모든 가능한 값을 테스트하지 않고 대표값만 테스트\n   - 테스트 효율성 향상\n\n**예시:**\n\n**입력: 정수 (1~100)**\n\n1. **유효한 입력 영역:**\n   - 1~100: 정상 처리\n   - 대표값: 50\n\n2. **무효한 입력 영역:**\n   - < 1: 오류 처리\n   - 대표값: 0, -1\n   - > 100: 오류 처리\n   - 대표값: 101, 200\n\n**테스트 케이스:**\n- 50 (유효)\n- 0 (무효, 작음)\n- 101 (무효, 큼)\n\n**동등 분할 vs 경계값 분석:**\n\n| 기법 | 특징 | 예시 |\n|------|------|------|\n| **동등 분할** | 각 분할 영역의 대표값 테스트 | 50, 0, 101 |\n| **경계값 분석** | 경계값과 그 근처 값 테스트 | 1, 0, -1, 100, 101, 102 |\n\n**다른 테스트 기법:**\n\n- **Boundary Value Analysis (경계값 분석)**: 경계값과 그 근처 값 테스트\n- **Decision Table (의사결정 테이블)**: 조건 조합 테스트\n- **State Transition (상태 전이)**: 상태 변화 테스트\n\n**답:** **ㄱ (Equivalence Partitioning / 동등 분할)**",
      "explanation_preview": "**Equivalence Partitioning (동등 분할) 테스트 기법 문제입니다.**\n\n**Equivalence Partitioning (동등 분할)의 정의:**\n- 입력 데이터를 **동등한(equivalent) 그룹으로 분할**하여 각 그룹에서 **대표값 하나씩만 테스트**하는 기법\n- **EP (Equivalence Partitioning)**라고",
      "image_refs": [
        "images/2023_round3/16.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ㄱ"
        ],
        "raw_text": "ㄱ"
      },
      "primary_category": "기타",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1058
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q017",
      "doc_id": "2023_round3",
      "question_text": "다음은 클라우드에 대한 유형 문제이다.\n괄호 안에 알맞는 답을 보기에 골라 작성하시오.",
      "question_full": "다음은 클라우드에 대한 유형 문제이다.\n괄호 안에 알맞는 답을 보기에 골라 작성하시오.",
      "explanation_current": "이 문제는 **클라우드 컴퓨팅 서비스 모델**을 묻는 문제입니다.\n\n**클라우드 서비스 모델:**\n\n1. **IaaS (Infrastructure as a Service) - 인프라 서비스**\n- 가상화된 하드웨어 자원(서버, 스토리지, 네트워크)을 제공\n- 사용자가 OS, 미들웨어, 애플리케이션을 직접 관리\n- 예: AWS EC2, Google Compute Engine\n\n2. **PaaS (Platform as a Service) - 플랫폼 서비스**\n- 개발 및 배포 환경을 제공\n- 사용자가 애플리케이션만 개발하고 배포\n- 예: AWS Elastic Beanstalk, Heroku\n\n3. **SaaS (Software as a Service) - 소프트웨어 서비스**\n- 완성된 소프트웨어를 인터넷을 통해 제공\n- 사용자는 브라우저나 앱을 통해 이용\n- 예: Gmail, Office 365, Dropbox\n\n**문제에서 설명하는 순서와 매칭:**\n- 문제의 첫 번째 설명 → IaaS (인프라 제공)\n- 문제의 두 번째 설명 → PaaS (플랫폼 제공)\n- 문제의 세 번째 설명 → SaaS (소프트웨어 제공)\n\n**답:**\n- (1) **IaaS**\n- (2) **PaaS**\n- (3) **SaaS**",
      "explanation_preview": "이 문제는 **클라우드 컴퓨팅 서비스 모델**을 묻는 문제입니다.\n\n**클라우드 서비스 모델:**\n\n1. **IaaS (Infrastructure as a Service) - 인프라 서비스**\n- 가상화된 하드웨어 자원(서버, 스토리지, 네트워크)을 제공\n- 사용자가 OS, 미들웨어, 애플리케이션을 직접 관리\n- 예: AWS EC2, Google Compu",
      "image_refs": [
        "images/2023_round3/17.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "(1) IaaS",
          "(2) PaaS",
          "(3) SaaS"
        ],
        "raw_text": "(1) IaaS\n(2) PaaS\n(3) SaaS"
      },
      "primary_category": "기타",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 626
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q018",
      "doc_id": "2023_round3",
      "question_text": "다음은 프로토콜 종류에 관한 설명이다.\n알맞는 답을 작성하시오.",
      "question_full": "다음은 프로토콜 종류에 관한 설명이다.\n알맞는 답을 작성하시오.",
      "explanation_current": "이 문제는 라우팅 프로토콜 중 **RIP (Routing Information Protocol)**에 대한 문제입니다.\n\n**RIP (Routing Information Protocol)란?**\n- 거리 벡터(Distance Vector) 라우팅 프로토콜입니다.\n- 홉(hop) 수를 거리로 사용하여 최단 경로를 결정합니다.\n- 30초마다 라우팅 정보를 주기적으로 업데이트합니다.\n- 최대 홉 수는 15입니다 (16 이상은 무한대로 간주).\n\n**RIP의 특징:**\n1. **거리 벡터 알고리즘**: 인접 라우터로부터 거리 정보를 받아 최단 경로 계산 2. **주기적 업데이트**: 30초마다 라우팅 테이블 브로드캐스트 3. **홉 카운트**: 목적지까지의 라우터 개수를 거리로 측정 4. **최대 홉 수**: 15 (16 이상은 도달 불가능)\n\n**문제에서 설명하는 특징:**\n- 문제에서 설명한 프로토콜의 특징이 RIP와 일치합니다.\n\n**답:**RIP**",
      "explanation_preview": "이 문제는 라우팅 프로토콜 중 **RIP (Routing Information Protocol)**에 대한 문제입니다.\n\n**RIP (Routing Information Protocol)란?**\n- 거리 벡터(Distance Vector) 라우팅 프로토콜입니다.\n- 홉(hop) 수를 거리로 사용하여 최단 경로를 결정합니다.\n- 30초마다 라우팅 정보를 주기",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "RIP"
        ],
        "raw_text": "RIP"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 481
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q019",
      "doc_id": "2023_round3",
      "question_text": "다음은 관계 대수에 대한 내용이다.\n보기에 알맞는 기호를 작성하시오.\n\n1. join :\n\n(1)\n\n2. project : ( 2 )\n\n3. select : ( 3 )\n\n4. division : ( 4 )",
      "question_full": "다음은 관계 대수에 대한 내용이다.\n보기에 알맞는 기호를 작성하시오.\n\n1. join :\n\n(1)\n\n2. project : ( 2 )\n\n3. select : ( 3 )\n\n4. division : ( 4 )",
      "explanation_current": "이 문제는 **관계 대수(Relational Algebra)의 연산 기호**를 묻는 문제입니다.\n\n**관계 대수 연산 기호:**\n\n1. **JOIN (조인) - (1) ㄷ**:\n   - 기호: `⋈` (보울 기호)\n   - 두 릴레이션을 조건에 따라 결합\n   - **Theta JOIN (θ-JOIN)**: `R ⋈_θ S`\n   - **EQUI JOIN**: `R ⋈_A=B S` (등호 조건)\n   - **NATURAL JOIN**: `R ⋈ S` (같은 속성명으로 자동 결합)\n\n2. **PROJECT (투영) - (2) ㄴ**:\n   - 기호: `π` (파이)\n   - 특정 속성(컬럼)만 선택\n   - `π_속성1,속성2(R)`: R 릴레이션에서 속성1, 속성2만 선택\n   - 중복 튜플 제거\n\n3. **SELECT (선택) - (3) ㄱ**:\n   - 기호: `σ` (시그마)\n   - 조건에 맞는 행(튜플)만 선택\n   - `σ_조건(R)`: R 릴레이션에서 조건에 맞는 행만 선택\n   - WHERE 절과 유사\n\n4. **DIVISION (나눗셈) - (4) ㄹ**:\n   - 기호: `÷` (나눗셈 기호)\n   - 한 릴레이션을 다른 릴레이션으로 나눔\n   - `R ÷ S`: R에 있으면서 S에 있는 모든 조합을 포함하는 튜플 선택\n   - 복잡한 쿼리 표현에 사용\n\n**관계 대수 연산 기호 정리:**\n\n| 연산 | 기호 | 설명 |\n|------|------|------|\n| **SELECT (선택)** | `σ` (시그마) | 조건에 맞는 행 선택 |\n| **PROJECT (투영)** | `π` (파이) | 특정 속성만 선택 |\n| **JOIN (조인)** | `⋈` (보울) | 두 릴레이션 결합 |\n| **UNION (합집합)** | `∪` | 합집합 |\n| **INTERSECTION (교집합)** | `∩` | 교집합 |\n| **DIFFERENCE (차집합)** | `-` | 차집합 |\n| **CARTESIAN PRODUCT (곱집합)** | `×` | 카티시안 곱 |\n| **DIVISION (나눗셈)** | `÷` | 나눗셈 |\n\n**SQL과의 대응:**\n\n| 관계 대수 | SQL |\n|-----------|-----|\n| `σ_조건(R)` | `SELECT * FROM R WHERE 조건` |\n| `π_속성(R)` | `SELECT 속성 FROM R` |\n| `R ⋈ S` | `SELECT * FROM R JOIN S` |\n| `R ÷ S` | 복잡한 서브쿼리로 표현 |\n\n**답:**\n- **(1) ㄷ (JOIN: ⋈)**\n- **(2) ㄴ (PROJECT: π)**\n- **(3) ㄱ (SELECT: σ)**\n- **(4) ㄹ (DIVISION: ÷)**",
      "explanation_preview": "이 문제는 **관계 대수(Relational Algebra)의 연산 기호**를 묻는 문제입니다.\n\n**관계 대수 연산 기호:**\n\n1. **JOIN (조인) - (1) ㄷ**:\n   - 기호: `⋈` (보울 기호)\n   - 두 릴레이션을 조건에 따라 결합\n   - **Theta JOIN (θ-JOIN)**: `R ⋈_θ S`\n   - **EQUI JOIN*",
      "image_refs": [
        "images/2023_round3/19.png"
      ],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "(1) ㄷ",
          "(2) ㄴ",
          "(3) ㄱ"
        ],
        "raw_text": "(1) ㄷ\n(2) ㄴ\n(3) ㄱ"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1348
      }
    },
    {
      "file": "items_2023_round3.jsonl",
      "q_no": "Q020",
      "doc_id": "2023_round3",
      "question_text": "다음은 데이터베이스에 관련된 문제이다.\n괄호 안에 알맞는 답을 작성하시오.",
      "question_full": "다음은 데이터베이스에 관련된 문제이다.\n괄호 안에 알맞는 답을 작성하시오.",
      "explanation_current": "이 문제는 **데이터베이스 무결성 제약조건 중 참조 무결성(Referential Integrity)**에 대한 문제입니다.\n\n**참조 무결성(Referential Integrity)이란?**\n\n**정의:**\n- **외래키(Foreign Key)**가 참조하는 **기본키(Primary Key)**가 존재해야 하는 제약조건\n- 한 릴레이션의 외래키가 다른 릴레이션의 기본키를 참조할 때, 참조되는 값이 반드시 존재해야 함\n\n**참조 무결성의 특징:**\n\n1. **외래키 제약:**\n   - 외래키 값은 참조되는 릴레이션의 기본키 값과 일치해야 함\n   - NULL 값은 허용 (선택적)\n\n2. **참조 무결성 위반 상황:**\n   - **참조 무결성 위반**: 외래키가 존재하지 않는 기본키를 참조\n   - **삭제 위반**: 참조되는 기본키를 삭제하려고 할 때\n   - **수정 위반**: 참조되는 기본키를 변경하려고 할 때\n\n3. **무결성 유지 방법:**\n   - **RESTRICT**: 참조 무결성 위반 시 작업 거부 (기본값)\n   - **CASCADE**: 참조되는 값 삭제/수정 시 외래키도 함께 삭제/수정\n   - **SET NULL**: 참조되는 값 삭제 시 외래키를 NULL로 설정\n   - **NO ACTION**: RESTRICT와 유사\n\n**예시:**\n\n```sql\nCREATE TABLE 학생 (\n    학번 INT PRIMARY KEY,\n    이름 VARCHAR(20)\n);\n\nCREATE TABLE 수강 (\n    수강번호 INT PRIMARY KEY,\n    학번 INT,\n    FOREIGN KEY (학번) REFERENCES 학생(학번)  -- 참조 무결성\n);\n```\n\n**데이터베이스 무결성 제약조건 종류:**\n\n| 제약조건 | 설명 |\n|---------|------|\n| **개체 무결성** | 기본키는 NULL 불가, 중복 불가 |\n| **참조 무결성** | 외래키는 참조되는 기본키가 존재해야 함 |\n| **도메인 무결성** | 속성 값이 도메인에 맞아야 함 |\n| **사용자 정의 무결성** | 사용자가 정의한 제약조건 |\n\n**답:** **\"참조\" (참조 무결성)**",
      "explanation_preview": "이 문제는 **데이터베이스 무결성 제약조건 중 참조 무결성(Referential Integrity)**에 대한 문제입니다.\n\n**참조 무결성(Referential Integrity)이란?**\n\n**정의:**\n- **외래키(Foreign Key)**가 참조하는 **기본키(Primary Key)**가 존재해야 하는 제약조건\n- 한 릴레이션의 외래키가 다른 릴레",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [
        {
          "id": "table1",
          "json": "data/tables/2023_round3/Q020_table1.json",
          "rows": 18,
          "cols": 1
        }
      ],
      "answer": {
        "keys": [
          "참조"
        ],
        "raw_text": "참조"
      },
      "primary_category": "데이터베이스",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1074
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q001",
      "doc_id": "2024_round1",
      "question_text": "다음 Java 코드에서 알맞는 출력 값을 작성하시오.",
      "question_full": "다음 Java 코드에서 알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4",
      "explanation_preview": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static pub",
      "image_refs": [
        "images/2024_round1/Q001.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}",
          "line_numbers": [
            1,
            29
          ],
          "file": "data/codes/2024_round1/Q001_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "4"
        ],
        "raw_text": "4"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1022
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q002",
      "doc_id": "2024_round1",
      "question_text": "다음 C언어 코드에서 알맞는 출력 값을 작성하시오.",
      "question_full": "다음 C언어 코드에서 알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 삼항 연산자와 비트 시프트 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int v1 = 0, v2 = 35, v3 = 29;\nif(v1 > v2 ? v2 : v1) {\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2;\n}\nprintf(\"%d\", v2+v3);\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `v1 = 0`, `v2 = 35`, `v3 = 29`\n\n2. **삼항 연산자 평가:**\n```c v1 > v2 ? v2 : v1\n```\n- `0 > 35` → 거짓(false)\n- 따라서 `v1` (값: 0) 반환\n\n3. **if 조건 판단:**\n```c if(0) { // 거짓!\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2; // 이 블록 실행\n}\n```\n\n4. **비트 시프트 연산:**\n```c v3 = 29 << 2;\n```\n- `<<` (왼쪽 시프트): 비트를 왼쪽으로 2칸 이동 = 곱하기 4\n- `29 << 2 = 29 × 4 = 116`\n\n5. **최종 계산:**\n- `v2 = 35` (변경 없음)\n- `v3 = 116`\n- `v2 + v3 = 35 + 116 = 151`\n\n**답:** 151",
      "explanation_preview": "이 C언어 코드는 삼항 연산자와 비트 시프트 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int v1 = 0, v2 = 35, v3 = 29;\nif(v1 > v2 ? v2 : v1) {\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2;\n}\nprintf(\"%d\", v2+v3);\n```\n\n**실행 과정:**\n\n1. **초기값:*",
      "image_refs": [
        "images/2024_round1/Q002.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nint main() {\n    int v1 = 0, v2 = 35, v3 = 29;\n    if(v1 > v2 ? v2 : v1) {\n        v2 = v2 << 2;\n    }else{\n        v3 = v3 << 2;\n    }\n    printf(\"%d\", v2+v3);\n}",
          "line_numbers": [
            1,
            10
          ],
          "file": "data/codes/2024_round1/Q002_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "151"
        ],
        "raw_text": "151"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 614
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q004",
      "doc_id": "2024_round1",
      "question_text": "다음은 C언어에 대한 문제이다.\n알맞는 출력 값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 문자열을 역순으로 뒤집고 홀수 인덱스 문자를 출력하는 문제입니다.\n\n**코드 분석:**\n\n```c char str[100] = \"ABCDEFGH\";\nreverse(str); // 문자열 역순\n// 역순 후: \"HGFEDCBA\"\nfor(int i=1; i<len; i+=2) {\nprintf(\"%c\", str[i]); // 홀수 인덱스만 출력\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `str = \"ABCDEFGH\"`\n- 인덱스: 0=A, 1=B, 2=C, 3=D, 4=E, 5=F, 6=G, 7=H\n\n2. **`reverse()` 함수 실행:**\n```c void reverse(char* str) {\nint len = strlen(str); // len = 8 char *p1 = str; // p1 = &str[0]\nchar *p2 = str + len - 1; // p2 = &str[7]\nwhile(p1 < p2) {\n// 문자 교환 temp = *p1;\n*p1 = *p2;\n*p2 = temp;\np1++;\np2--;\n}\n}\n```\n- `p1`과 `p2`를 교환하며 문자열 뒤집기\n- 결과: `str = \"HGFEDCBA\"`\n\n3. **홀수 인덱스 출력:**\n```c for(int i=1; i<8; i+=2) {\nprintf(\"%c\", str[i]);\n}\n```\n- i=1: str[1] = 'G' 출력\n- i=3: str[3] = 'E' 출력\n- i=5: str[5] = 'C' 출력\n- i=7: str[7] = 'A' 출력\n\n**최종 출력:** \"GECA\"\n\n**답:** \"GECA\"",
      "explanation_preview": "이 C언어 코드는 문자열을 역순으로 뒤집고 홀수 인덱스 문자를 출력하는 문제입니다.\n\n**코드 분석:**\n\n```c char str[100] = \"ABCDEFGH\";\nreverse(str); // 문자열 역순\n// 역순 후: \"HGFEDCBA\"\nfor(int i=1; i<len; i+=2) {\nprintf(\"%c\", str[i]); // 홀수 인덱스만 출력",
      "image_refs": [
        "images/2024_round1/Q004.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#include <string.h>\nvoid reverse(char* str){\n    int len = strlen(str);\n    char temp;\n    char*p1 = str;\n    char*p2 = str + len - 1;\n    while(p1<p2){\n        temp = *p1;\n        *p1 = *p2;\n        *p2 = temp;\n        p1++;\n        p2--;\n    }\n}\nint main(int argc, char* argv[]){\n    char str[100] = \"ABCDEFGH\";\n    reverse(str);\n    int len = strlen(str);\n    for(int i=1; i<len; i+=2){\n        printf(\"%c\",str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
          "line_numbers": [
            1,
            25
          ],
          "file": "data/codes/2024_round1/Q004_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "GECA"
        ],
        "raw_text": "GECA"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 803
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q006",
      "doc_id": "2024_round1",
      "question_text": "아래 표에서 나타나고 있는 정규형을 작성하시오.",
      "question_full": "아래 표에서 나타나고 있는 정규형을 작성하시오.",
      "explanation_current": "이 문제는 **데이터베이스 정규화의 제3정규형(3NF)**을 판별하는 문제입니다.\n\n**주어진 표 분석:**\n\n표 구조: (고객아이디, 강좌명, 강사번호)\n\n**정규형 판별 과정:**\n\n1. **제1정규형(1NF) 확인:**\n   - 모든 속성이 원자값(더 이상 분할 불가) ✓\n   - 중복 튜플 없음 ✓\n   - **1NF 만족**\n\n2. **제2정규형(2NF) 확인:**\n   - 기본키: (고객아이디, 강좌명) - 복합키\n   - 비주요 속성: 강사번호\n   - **완전 함수 종속 확인:**\n     - 강사번호는 (고객아이디, 강좌명)에 완전 종속\n     - 부분 종속 없음 ✓\n   - **2NF 만족**\n\n3. **제3정규형(3NF) 확인:**\n   - **이행 함수 종속 확인:**\n     - 고객아이디 → 강사번호? (아니오)\n     - 강좌명 → 강사번호? (표에서 확인 필요)\n   - 표를 보면 같은 강좌명에 다른 강사번호가 있을 수 있음\n   - 하지만 기본키가 복합키이므로, 이행 종속이 없음\n   - **3NF 만족**\n\n4. **BCNF 확인:**\n   - BCNF는 모든 결정자가 후보키여야 함\n   - 이 표는 3NF까지 만족하지만 BCNF는 아닐 수 있음\n\n**정규형 정리:**\n\n| 정규형 | 조건 | 이 표의 상태 |\n|--------|------|------------|\n| **1NF** | 모든 속성이 원자값 | ✓ 만족 |\n| **2NF** | 완전 함수 종속 | ✓ 만족 |\n| **3NF** | 이행 함수 종속 없음 | ✓ 만족 |\n| **BCNF** | 모든 결정자가 후보키 | 확인 필요 |\n\n**답:** **\"제 3정규형\"**",
      "explanation_preview": "이 문제는 **데이터베이스 정규화의 제3정규형(3NF)**을 판별하는 문제입니다.\n\n**주어진 표 분석:**\n\n표 구조: (고객아이디, 강좌명, 강사번호)\n\n**정규형 판별 과정:**\n\n1. **제1정규형(1NF) 확인:**\n   - 모든 속성이 원자값(더 이상 분할 불가) ✓\n   - 중복 튜플 없음 ✓\n   - **1NF 만족**\n\n2. **제2정규형(",
      "image_refs": [
        "images/2024_round1/Q006.png"
      ],
      "code_blocks": [],
      "table_refs": [
        {
          "id": "table1",
          "json": "data/tables/2024_round1/Q006_table1.json",
          "rows": 6,
          "cols": 3
        }
      ],
      "answer": {
        "keys": [
          "제 3정규형"
        ],
        "raw_text": "제 3정규형"
      },
      "primary_category": "기타",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 832
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q001",
      "doc_id": "2024_round1",
      "question_text": "대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.\n\n2. 단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.\n\n3. 모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.",
      "question_full": "대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.\n\n2. 단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.\n\n3. 모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.",
      "explanation_current": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4",
      "explanation_preview": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static pub",
      "image_refs": [
        "images/2024_round1/Q001.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}",
          "line_numbers": [
            1,
            29
          ],
          "file": "data/codes/2024_round1/Q001_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "4"
        ],
        "raw_text": "4"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1022
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q009",
      "doc_id": "2024_round1",
      "question_text": "다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n(1) LRU :\n(2) LFU :",
      "question_full": "다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n(1) LRU :\n(2) LFU :",
      "explanation_current": "이 문제는 운영체제의 페이지 교체 알고리즘인 LRU와 LFU를 이해하는 문제입니다.\n\n**주어진 정보:**\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n**LRU (Least Recently Used) - 가장 최근에 사용되지 않은 페이지 교체:**초기 상태:** [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 1 | [1, 빈, 빈] | ✓ |\n| 2 | [1, 2, 빈] | ✓ |\n| 3 | [1, 2, 3] | ✓ |\n| 1 | [1, 2, 3] | (히트) |\n| 2 | [1, 2, 3] | (히트) |\n| 4 | [2, 3, 4] | ✓ (1 제거) |\n| 1 | [3, 4, 1] | ✓ (2 제거) |\n| 2 | [4, 1, 2] | ✓ (3 제거) |\n| 5 | [1, 2, 5] | ✓ (4 제거) |\n| 7 | [2, 5, 7] | ✓ (1 제거) |\n\n**페이지 부재 횟수: 6**LFU (Least Frequently Used) - 가장 적게 사용된 페이지 교체:**초기 상태:** [빈, 빈, 빈], 빈도: {}\n\n| 참조 | 프레임 상태 | 빈도 | 페이지 부재 |\n|------|------------|------|-----------|\n| 1 | [1, 빈, 빈] | {1:1} | ✓ |\n| 2 | [1, 2, 빈] | {1:1, 2:1} | ✓ |\n| 3 | [1, 2, 3] | {1:1, 2:1, 3:1} | ✓ |\n| 1 | [1, 2, 3] | {1:2, 2:1, 3:1} | (히트) |\n| 2 | [1, 2, 3] | {1:2, 2:2, 3:1} | (히트) |\n| 4 | [1, 2, 4] | {1:2, 2:2, 4:1} | ✓ (3 제거, 빈도 최소) |\n| 1 | [1, 2, 4] | {1:3, 2:2, 4:1} | (히트) |\n| 2 | [1, 2, 4] | {1:3, 2:3, 4:1} | (히트) |\n| 5 | [1, 2, 5] | {1:3, 2:3, 5:1} | ✓ (4 제거, 빈도 최소) |\n| 7 | [1, 2, 7] | {1:3, 2:3, 7:1} | ✓ (5 제거, 빈도 최소) |\n\n**페이지 부재 횟수: 6**답:**\n- (1) LRU: 6\n- (2) LFU: 6",
      "explanation_preview": "이 문제는 운영체제의 페이지 교체 알고리즘인 LRU와 LFU를 이해하는 문제입니다.\n\n**주어진 정보:**\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n**LRU (Least Recently Used) - 가장 최근에 사용되지 않은 페이지 교체:**초기 상태:** [빈, 빈, 빈]\n\n| 참조 | ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "(1) 6",
          "(2) 6"
        ],
        "raw_text": "(1) 6\n(2) 6"
      },
      "primary_category": "운영체제",
      "quality": {
        "score": 65,
        "issues": [
          "범용적인 설명 문구 다수",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1164
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q013",
      "doc_id": "2024_round1",
      "question_text": "아래 보기의 SQL 문장과 테이블을 참고하여\n\n출력 값을 표로 작성하시오.",
      "question_full": "아래 보기의 SQL 문장과 테이블을 참고하여\n\n출력 값을 표로 작성하시오.",
      "explanation_current": "**SQL 서브쿼리와 IN 연산자 문제입니다.**\n\n**이미지의 SQL 쿼리:**\n\n```sql\nSELECT B\nFROM R1\nWHERE C IN (SELECT C FROM R2 WHERE D=\"k\");\n```\n\n**이미지의 테이블 데이터:**\n\n**R1 테이블:**\n| A | B | C |\n|---|---|---|\n| 1 | a | x |\n| 2 | b | x |\n| 1 | c | w |\n\n**R2 테이블:**\n| C | D | E |\n|---|---|---|\n| x | k | 3 |\n| y | k | 3 |\n| z | s | 2 |\n\n**실행 과정:**\n\n1. **서브쿼리 실행:**\n   ```sql\n   SELECT C FROM R2 WHERE D=\"k\"\n   ```\n   - R2 테이블에서 `D=\"k\"`인 행을 찾습니다:\n     - 첫 번째 행: C=x, D=k, E=3 → C=x 선택 ✓\n     - 두 번째 행: C=y, D=k, E=3 → C=y 선택 ✓\n     - 세 번째 행: C=z, D=s, E=2 → 조건 불만족\n   - **서브쿼리 결과: {x, y}**\n\n2. **메인 쿼리 실행:**\n   ```sql\n   SELECT B FROM R1\n   WHERE C IN (x, y)\n   ```\n   - R1 테이블에서 `C IN (x, y)`인 행을 찾습니다:\n     - 첫 번째 행: A=1, B=a, C=x → C=x는 서브쿼리 결과에 포함 → **B=a 선택** ✓\n     - 두 번째 행: A=2, B=b, C=x → C=x는 서브쿼리 결과에 포함 → **B=b 선택** ✓\n     - 세 번째 행: A=1, B=c, C=w → C=w는 서브쿼리 결과에 미포함 → 선택 안 됨\n   - **최종 결과: a, b**\n\n**핵심 개념:**\n\n1. **서브쿼리 (Subquery):**\n   - 다른 SQL 쿼리 내부에 포함된 SELECT 문\n   - 서브쿼리 결과를 외부 쿼리의 조건으로 사용\n   - 서브쿼리가 먼저 실행되고, 그 결과를 외부 쿼리에서 사용\n\n2. **IN 연산자:**\n   - `WHERE 컬럼 IN (값1, 값2, ...)`: 컬럼 값이 목록에 포함되는지 확인\n   - `WHERE 컬럼 IN (SELECT ...)`: 서브쿼리 결과 집합에 포함되는지 확인\n   - 여러 개의 OR 조건을 간결하게 표현\n\n3. **실행 순서:**\n   - 1단계: 서브쿼리 실행 → 결과 집합 생성\n   - 2단계: 메인 쿼리 실행 → 서브쿼리 결과를 조건으로 사용\n\n**SQL 쿼리 구조 분석:**\n\n```sql\nSELECT B           -- ③ 최종적으로 B 컬럼만 선택\nFROM R1            -- ① R1 테이블 조회\nWHERE C IN (       -- ② C 값이 서브쿼리 결과에 포함되는지 확인\n  SELECT C         -- ② 서브쿼리: C 값 추출\n  FROM R2          -- ② R2 테이블에서\n  WHERE D=\"k\"      -- ② D가 \"k\"인 행만\n);\n```\n\n**답:** **B 컬럼의 값: a, b**",
      "explanation_preview": "**SQL 서브쿼리와 IN 연산자 문제입니다.**\n\n**이미지의 SQL 쿼리:**\n\n```sql\nSELECT B\nFROM R1\nWHERE C IN (SELECT C FROM R2 WHERE D=\"k\");\n```\n\n**이미지의 테이블 데이터:**\n\n**R1 테이블:**\n| A | B | C |\n|---|---|---|\n| 1 | a | x |\n| 2 | b ",
      "image_refs": [
        "images/2024_round1/Q013.png"
      ],
      "code_blocks": [
        {
          "language": "unknown",
          "code": "SELECT\n    B\nFROM\n    R1\nWHERE\n    C IN (SELECT C FROM R2 WHERE D=\"k\");",
          "line_numbers": [
            1,
            6
          ],
          "file": "data/codes/2024_round1/Q013_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "a",
          "b"
        ],
        "raw_text": "a b"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1525
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q014",
      "doc_id": "2024_round1",
      "question_text": "아래는 애플리케이션 테스트 관리에 대한 내용이다.\n설명하는 답을 보기에서 골라 작성하시오.",
      "question_full": "아래는 애플리케이션 테스트 관리에 대한 내용이다.\n설명하는 답을 보기에서 골라 작성하시오.",
      "explanation_current": "이 문제는 소프트웨어 테스트의 커버리지 종류를 이해하는 문제입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다\"**\n- 모든 가능한 조건 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n\n2. **\"특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다\"**\n- 조건의 독립적 영향력을 테스트합니다.\n\n3. **\"각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다\"**\n- 각 조건이 결과에 영향을 미치는지 확인합니다.\n\n**변경 조건/결정 커버리지(MC/DC - Modified Condition/Decision Coverage):**\n- 조건들의 독립적인 영향력을 테스트합니다.\n- 각 조건이 결정(결과)에 독립적으로 영향을 미치는지 확인합니다.\n- 모든 가능한 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n- 항공기 소프트웨어 등 고신뢰성 시스템에서 요구되는 커버리지입니다.\n\n**다른 커버리지와의 차이:**\n- 다중 조건 커버리지: 모든 조건 조합을 테스트 (2^n 개)\n- 조건/결정 커버리지: 각 조건과 결정을 개별적으로 테스트\n- **변경 조건/결정 커버리지: 각 조건이 결정에 독립적으로 영향을 미치는지 테스트** ✓\n\n**답:** \"ㄹ\" (변경 조건/결정 커버리지)",
      "explanation_preview": "이 문제는 소프트웨어 테스트의 커버리지 종류를 이해하는 문제입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다\"**\n- 모든 가능한 조건 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n\n2. **\"특정 조건을 수행할 때 다른",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ㄹ"
        ],
        "raw_text": "ㄹ"
      },
      "primary_category": "소프트웨어공학",
      "quality": {
        "score": 65,
        "issues": [
          "범용적인 설명 문구 다수",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 714
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q001",
      "doc_id": "2024_round1",
      "question_text": "모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다.\n\n2. 특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다.\n\n3. 각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 결정 커버리지\n\nㄷ",
      "question_full": "모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다.\n\n2. 특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다.\n\n3. 각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 결정 커버리지\n\nㄷ. 조건 커버리지\n\nㄹ. 변경 조건/결정 커버리지\n\nㅁ.다중 조건 커버리지\n\nㅂ.경로 커버리지\n\nㅅ.조건/결정 커버리지",
      "explanation_current": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4",
      "explanation_preview": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static pub",
      "image_refs": [
        "images/2024_round1/Q001.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}",
          "line_numbers": [
            1,
            29
          ],
          "file": "data/codes/2024_round1/Q001_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "4"
        ],
        "raw_text": "4"
      },
      "primary_category": "소프트웨어공학",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1022
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q016",
      "doc_id": "2024_round1",
      "question_text": "다음 Java 코드를 보고\n\n알맞는 출력 값을 작성하시오.",
      "question_full": "다음 Java 코드를 보고\n\n알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 문제는 **Java 상속과 메서드 오버라이딩**을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nclass classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() {\n        System.out.println(a + b);  // a + b 출력\n    }\n}\n\nclass classTwo extends classOne {\n    int po = 3;\n    public classTwo(int i) {\n        super(i, i+1);  // classOne(10, 11) 호출\n    }\n    public void print() {  // 오버라이딩!\n        System.out.println(po * po);  // 3 * 3 = 9 출력\n    }\n}\n\npublic class main {\n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}\n```\n\n**실행 과정:**\n\n1. **`new classTwo(10)` 호출:**\n   - `classTwo` 생성자 호출\n   - `super(10, 11)` → `classOne(10, 11)` 호출\n   - `classOne` 생성자 실행: `a = 10`, `b = 11`\n   - `classTwo` 생성자 실행: `po = 3` (초기화)\n\n2. **`one.print()` 호출:**\n   - `one`은 `classOne` 타입이지만 실제 객체는 `classTwo`\n   - **동적 바인딩**: 실제 객체 타입(`classTwo`)의 `print()` 메서드 호출\n   - `classTwo.print()` 실행: `po * po = 3 * 3 = 9`\n\n**핵심 개념:**\n\n- **메서드 오버라이딩**: 자식 클래스가 부모 클래스의 메서드를 재정의\n- **동적 바인딩**: 참조 타입이 아닌 실제 객체 타입에 따라 메서드 호출\n- **생성자 호출 순서**: 자식 생성자 → 부모 생성자 (`super()`)\n\n**답:** **\"9\"**",
      "explanation_preview": "이 문제는 **Java 상속과 메서드 오버라이딩**을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nclass classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() ",
      "image_refs": [
        "images/2024_round1/Q016.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() {\n        System.out.println(a + b);\n    }\n}\nclass classTwo extends classOne {\n    int po = 3;\n    public classTwo(int i) {\n        super(i, i+1);\n    }\n    public void print() {\n        System.out.println(po*po);\n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}",
          "line_numbers": [
            1,
            25
          ],
          "file": "data/codes/2024_round1/Q016_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "9"
        ],
        "raw_text": "9"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 과다",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1161
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q017",
      "doc_id": "2024_round1",
      "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.",
      "question_full": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.",
      "explanation_current": "이 문제는 **APT (Advanced Persistent Threat, 지능형 지속 위협)**에 대한 문제입니다.\n\n**APT (Advanced Persistent Threat)란?**\n\n**정의:**\n- **APT (Advanced Persistent Threat, 지능형 지속 위협)**: 특정 표적을 정하여 지속적으로 정보를 수집하고 장기간에 걸쳐 공격을 감행하는 사이버 공격 유형\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다\"**\n   - APT는 특정 조직이나 개인을 표적으로 선정\n   - 장기간에 걸쳐 정보를 수집하고 분석\n   - 일반적인 대량 공격과 달리 맞춤형 공격\n\n2. **\"시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다\"**\n   - 직접적인 시스템 침투뿐만 아니라\n   - 내부 직원의 PC, 스마트폰 등 다양한 단말기 공격\n   - 소셜 엔지니어링을 통한 내부자 침투\n\n3. **\"한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다\"**\n   - 단일 기술이 아닌 다양한 공격 기법 조합\n   - Zero-day 취약점: 아직 알려지지 않은 보안 취약점\n   - 악성코드, 피싱, 워터링홀 등 다양한 기법 활용\n\n4. **\"일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다\"**\n   - **1단계 침투**: 초기 침입 (피싱, 워터링홀 등)\n   - **2단계 검색**: 네트워크 탐색 및 중요 정보 식별\n   - **3단계 수집**: 목표 데이터 수집\n   - **4단계 유출**: 데이터 외부로 전송\n\n**APT의 특징:**\n\n- **지능형**: 고도의 기술과 자금을 투입한 공격\n- **지속적**: 장기간에 걸쳐 지속적으로 공격\n- **표적형**: 특정 조직이나 개인을 대상으로 한 맞춤형 공격\n- **다단계**: 여러 단계를 거쳐 점진적으로 침투\n\n**답:** **\"ㅅ\" (APT)**",
      "explanation_preview": "이 문제는 **APT (Advanced Persistent Threat, 지능형 지속 위협)**에 대한 문제입니다.\n\n**APT (Advanced Persistent Threat)란?**\n\n**정의:**\n- **APT (Advanced Persistent Threat, 지능형 지속 위협)**: 특정 표적을 정하여 지속적으로 정보를 수집하고 장기간에 걸쳐 공",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ㅅ"
        ],
        "raw_text": "ㅅ"
      },
      "primary_category": "기타",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1041
      }
    },
    {
      "file": "items_2024_round1.jsonl",
      "q_no": "Q001",
      "doc_id": "2024_round1",
      "question_text": "불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다.\n\n2. 시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다.\n\n3. 한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다.\n\n4. 일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실",
      "question_full": "불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다.\n\n2. 시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다.\n\n3. 한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다.\n\n4. 일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다.",
      "explanation_current": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4",
      "explanation_preview": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static pub",
      "image_refs": [
        "images/2024_round1/Q001.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}",
          "line_numbers": [
            1,
            29
          ],
          "file": "data/codes/2024_round1/Q001_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "4"
        ],
        "raw_text": "4"
      },
      "primary_category": "정보보안",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1022
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q001",
      "doc_id": "2024_round2",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "**Java 배열 참조 비교 문제입니다.**\n\n**이미지의 전체 코드:**\n\n```java\nclass Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}\n```\n\n**실행 과정:**\n\n1. **배열 생성:**\n   - `int[] a = new int[]{1, 2, 3, 4};` → 새로운 배열 객체 생성 (주소: 0x1000 가정)\n   - `int[] b = new int[]{1, 2, 3, 4};` → 새로운 배열 객체 생성 (주소: 0x2000 가정)\n   - `int[] c = new int[]{1, 2, 3};` → 새로운 배열 객체 생성 (주소: 0x3000 가정)\n   - **중요**: 내용이 같아도 `new`를 사용하면 **서로 다른 객체** 생성!\n\n2. **`check(a, b)` 호출:**\n   - `if (a == b)` 실행\n   - `a`의 주소: 0x1000\n   - `b`의 주소: 0x2000\n   - **0x1000 == 0x2000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n3. **`check(a, c)` 호출:**\n   - `if (a == c)` 실행\n   - `a`의 주소: 0x1000\n   - `c`의 주소: 0x3000\n   - **0x1000 == 0x3000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n4. **`check(b, c)` 호출:**\n   - `if (b == c)` 실행\n   - `b`의 주소: 0x2000\n   - `c`의 주소: 0x3000\n   - **0x2000 == 0x3000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n**최종 출력:** **\"NNN\"**\n\n**핵심 개념:**\n\n1. **`==` 연산자의 동작:**\n   - 기본 타입(int, char 등): **값** 비교\n   - 참조 타입(배열, 객체 등): **메모리 주소(참조)** 비교\n   - 배열은 참조 타입이므로 `==`는 주소를 비교합니다\n\n2. **배열 비교 방법:**\n   ```java\n   // 참조(주소) 비교:\n   a == b  // 같은 객체인지 확인\n   \n   // 내용 비교:\n   Arrays.equals(a, b)  // 배열 내용이 같은지 확인\n   ```\n\n3. **예제:**\n   ```java\n   int[] x = new int[]{1, 2, 3};\n   int[] y = new int[]{1, 2, 3};\n   int[] z = x;  // z는 x와 같은 객체를 참조\n   \n   x == y  // false (다른 객체)\n   x == z  // true (같은 객체)\n   Arrays.equals(x, y)  // true (내용 같음)\n   ```\n\n**메모리 구조:**\n\n```\n변수      주소        배열 내용\n----      ----        --------\na    →  0x1000  →  [1, 2, 3, 4]\nb    →  0x2000  →  [1, 2, 3, 4]  (내용 같지만 다른 객체)\nc    →  0x3000  →  [1, 2, 3]\n```\n\n**왜 모두 \"N\"인가?**\n\n- 각 배열은 `new`로 생성되어 **서로 다른 메모리 주소**를 가집니다\n- `==` 연산자는 **주소**를 비교하므로 모두 `false`\n- 따라서 모든 `check()` 호출에서 \"N\"이 출력됩니다\n\n**답:** **\"NNN\"**",
      "explanation_preview": "**Java 배열 참조 비교 문제입니다.**\n\n**이미지의 전체 코드:**\n\n```java\nclass Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        i",
      "image_refs": [
        "images/2024_round2/Q001.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}",
          "line_numbers": [
            1,
            17
          ],
          "file": "data/codes/2024_round2/Q001_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "NNN"
        ],
        "raw_text": "NNN"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2098
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q003",
      "doc_id": "2024_round2",
      "question_text": "다음은 SQL에 관한 문제이다.\n아래 SQL 구문의 빈칸을 작성하시오.\n사원 [사원번호(PK), 이름, 나이, 부서]\n부서 [사원번호(PK), 이름, 주소, 나이]\n신입 사원이 들어와서 사원 테이블에 추가 INSERT INTO 사원 (사원번호, 이름, 주소, 부서)   [\n\n①     ] (32431, '정실기', '서울', '영업');\n위에 신입사원을 검",
      "question_full": "다음은 SQL에 관한 문제이다.\n아래 SQL 구문의 빈칸을 작성하시오.\n사원 [사원번호(PK), 이름, 나이, 부서]\n부서 [사원번호(PK), 이름, 주소, 나이]\n신입 사원이 들어와서 사원 테이블에 추가 INSERT INTO 사원 (사원번호, 이름, 주소, 부서)   [\n\n①     ] (32431, '정실기', '서울', '영업');\n위에 신입사원을 검색하면서 부서 테이블에 추가 INSERT INTO 부서 (사원번호, 이름, 나이, 부서)\n[\n②\n] 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n전체 사원 테이블 조회 SELECT  *   [\n③\n]   사원;\n퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경 UPDATE 사원   [\n④\n]   부서  =  '퇴사'  WHERE 사원번호  =\n32431;",
      "explanation_current": "이 문제는 **SQL 문법의 기본 키워드**를 묻는 문제입니다.\n\n**각 SQL 문의 빈칸 분석:**\n\n1. **① INSERT 문 - VALUES:**\n```sql\nINSERT INTO 사원 (사원번호, 이름, 주소, 부서) VALUES (32431, '정실기', '서울', '영업');\n```\n- `INSERT INTO` 문에서 **직접 값을 삽입**할 때는 `VALUES` 키워드를 사용합니다.\n- `VALUES` 다음에 괄호로 묶인 값들을 순서대로 입력합니다.\n\n2. **② INSERT ... SELECT 문 - SELECT:**\n```sql\nINSERT INTO 부서 (사원번호, 이름, 나이, 부서)\nSELECT 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n```\n- 다른 테이블에서 **데이터를 조회하여 삽입**할 때는 `SELECT` 문을 사용합니다.\n- `INSERT INTO ... SELECT` 형태로 서브쿼리 결과를 삽입합니다.\n- `FROM` 절이 있으므로 `SELECT` 키워드가 필요합니다.\n\n3. **③ SELECT 문 - FROM:**\n```sql\nSELECT * FROM 사원;\n```\n- `SELECT` 문에서 **조회할 테이블을 지정**할 때는 `FROM` 키워드를 사용합니다.\n- `SELECT *`는 모든 컬럼을 조회한다는 의미입니다.\n\n4. **④ UPDATE 문 - SET:**\n```sql\nUPDATE 사원 SET 부서 = '퇴사' WHERE 사원번호 = 32431;\n```\n- `UPDATE` 문에서 **컬럼 값을 변경**할 때는 `SET` 키워드를 사용합니다.\n- `SET 컬럼명 = 값` 형태로 값을 설정합니다.\n\n**SQL 문법 요약:**\n\n| 문법 | 키워드 | 용도 |\n|------|--------|------|\n| INSERT (직접 값) | VALUES | 직접 값을 삽입 |\n| INSERT (서브쿼리) | SELECT | 조회 결과를 삽입 |\n| SELECT | FROM | 조회할 테이블 지정 |\n| UPDATE | SET | 컬럼 값 변경 |\n\n**답:** ① VALUES, ② SELECT, ③ FROM, ④ SET",
      "explanation_preview": "이 문제는 **SQL 문법의 기본 키워드**를 묻는 문제입니다.\n\n**각 SQL 문의 빈칸 분석:**\n\n1. **① INSERT 문 - VALUES:**\n```sql\nINSERT INTO 사원 (사원번호, 이름, 주소, 부서) VALUES (32431, '정실기', '서울', '영업');\n```\n- `INSERT INTO` 문에서 **직접 값을 삽입**할 ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "① VALUES",
          "② SELECT",
          "③ FROM",
          "④ SET"
        ],
        "raw_text": "① VALUES\n② SELECT\n③ FROM\n④ SET"
      },
      "primary_category": "SQL",
      "quality": {
        "score": 65,
        "issues": [
          "범용적인 설명 문구 다수",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 1074
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q005",
      "doc_id": "2024_round2",
      "question_text": "다음은 프로토콜에 대한 내용이다.\n아래 내용을 읽고 알맞는 답을 작성하시오.\n\n- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.\n\n- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.\n\n- AH(Authentication Header)와 ESP(Encapsulating Securi",
      "question_full": "다음은 프로토콜에 대한 내용이다.\n아래 내용을 읽고 알맞는 답을 작성하시오.\n\n- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.\n\n- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.\n\n- AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다.",
      "explanation_current": "IPSec(IP Security)는 네트워크 계층에서 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다\"**\n- IPSec은 OSI 7계층 중 3계층(네트워크 계층)에서 동작합니다.\n- IP 패킷 자체를 암호화하여 데이터를 보호합니다.\n- 인증(Authentication)과 암호화(Encryption) 기능을 제공합니다.\n\n2. **\"기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다\"**\n- VPN(Virtual Private Network) 구축에 사용됩니다.\n- 인터넷을 통해 안전한 사설망을 구축할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등에 활용됩니다.\n\n3. **\"AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다\"**\n- **AH(Authentication Header)**: 데이터 무결성과 인증을 제공 (암호화 없음)\n- **ESP(Encapsulating Security Payload)**: 암호화와 인증을 모두 제공\n- 두 프로토콜을 개별 또는 조합하여 사용할 수 있습니다.\n\n**IPSec의 작동 방식:**\n- 터널 모드(Tunnel Mode): 전체 IP 패킷을 암호화\n- 전송 모드(Transport Mode): 페이로드만 암호화\n\n**답:** \"IPSec\"",
      "explanation_preview": "IPSec(IP Security)는 네트워크 계층에서 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다\"**\n- IPSec은 OSI 7계층 중 3계층(네트워크 계층)에서 동작합니다.\n- IP 패킷 자체를 암호화하여 데이",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "IPSec"
        ],
        "raw_text": "IPSec"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 785
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q006",
      "doc_id": "2024_round2",
      "question_text": "다음은 Python에 대한 문제이다.\n아래 코드를 읽고 알맞는 출력 값을 작성하시오.",
      "question_full": "다음은 Python에 대한 문제이다.\n아래 코드를 읽고 알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 파이썬 코드는 문자열에서 패턴의 출현 횟수를 세는 문제입니다.\n\n**코드 분석:**\n\n```python def fnCalculation(x, y):\nresult = 0 for i in range(len(x)):\ntemp = x[i:i+len(y)] # x에서 길이 len(y)만큼 슬라이싱 if temp == y:\nresult += 1 return result\n\na = \"abdcabcabca\"\np1 = \"ab\"\np2 = \"ca\"\nout = f\"ab{fnCalculation(a, p1)}ca{fnCalculation(a, p2)}\"\nprint(out)\n```\n\n**실행 과정:**\n\n1. **`fnCalculation(a, \"ab\")` 계산:**\n- a = \"abdcabcabca\"\n- i=0: \"ab\" == \"ab\" → result = 1\n- i=1: \"bd\" != \"ab\"\n- i=2: \"dc\" != \"ab\"\n- i=3: \"ca\" != \"ab\"\n- i=4: \"ab\" == \"ab\" → result = 2\n- i=5: \"bc\" != \"ab\"\n- i=6: \"ca\" != \"ab\"\n- i=7: \"ab\" == \"ab\" → result = 3\n- i=8: \"bc\" != \"ab\"\n- i=9: \"ca\" != \"ab\"\n- 결과: **3**\n\n2. **`fnCalculation(a, \"ca\")` 계산:**\n- i=0: \"ab\" != \"ca\"\n- i=1: \"bd\" != \"ca\"\n- i=2: \"dc\" != \"ca\"\n- i=3: \"ca\" == \"ca\" → result = 1\n- i=4: \"ab\" != \"ca\"\n- i=5: \"bc\" != \"ca\"\n- i=6: \"ca\" == \"ca\" → result = 2\n- i=7: \"ab\" != \"ca\"\n- i=8: \"bc\" != \"ca\"\n- i=9: \"ca\" == \"ca\" → result = 3\n- 결과: **3**\n\n3. **최종 출력:**\n```python out = f\"ab{3}ca{3}\" = \"ab3ca3\"\n```\n\n**답:** \"ab3ca3\"",
      "explanation_preview": "이 파이썬 코드는 문자열에서 패턴의 출현 횟수를 세는 문제입니다.\n\n**코드 분석:**\n\n```python def fnCalculation(x, y):\nresult = 0 for i in range(len(x)):\ntemp = x[i:i+len(y)] # x에서 길이 len(y)만큼 슬라이싱 if temp == y:\nresult += 1 return res",
      "image_refs": [
        "images/2024_round2/Q006.png"
      ],
      "code_blocks": [
        {
          "language": "python",
          "code": "def fnCalculation(x,y):\n    result = 0;\n    for i in range(len(x)):\n     temp = x[i:i+len(y)] \n     if temp == y:\n       result += 1;\n    return result\na = \"abdcabcabca\"\np1 = \"ab\";\np2 = \"ca\";\nout = f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\"\nprint(out)",
          "line_numbers": [
            1,
            12
          ],
          "file": "data/codes/2024_round2/Q006_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "ab3ca3"
        ],
        "raw_text": "ab3ca3"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1000
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q007",
      "doc_id": "2024_round2",
      "question_text": "아래 설명하는 내용을 확인하여\n\n알맞는 알고리즘을 작성하시오.\n\n- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.\n\n- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.\n\n- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고",
      "question_full": "아래 설명하는 내용을 확인하여\n\n알맞는 알고리즘을 작성하시오.\n\n- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.\n\n- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.\n\n- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다.",
      "explanation_current": "AES(Advanced Encryption Standard)는 고급 암호화 표준으로 대칭키 암호 알고리즘입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다\"**\n- AES는 대칭키 암호 알고리즘입니다 (같은 키로 암호화/복호화).\n- 1997년 NIST가 DES의 취약점을 해결하기 위해 공모를 시작했습니다.\n- 2000년 Rijndael 알고리즘이 선택되어 AES로 지정되었습니다.\n- DES(56비트 키)의 취약점을 해결하기 위해 개발되었습니다.\n\n2. **\"128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다\"**\n- 키 크기: AES-128, AES-192, AES-256 (세 가지 버전)\n- 블록 크기: 항상 128비트 (고정)\n- 키가 길수록 보안성이 높아지지만 성능은 약간 저하됩니다.\n\n3. **\"높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다\"**\n- DES보다 훨씬 빠르고 안전합니다.\n- 하드웨어와 소프트웨어 모두에서 효율적으로 구현 가능합니다.\n- 현재 가장 널리 사용되는 대칭키 암호 알고리즘입니다.\n- SSL/TLS, Wi-Fi 보안(WPA2), 하드디스크 암호화 등에 사용됩니다.\n\n**AES의 작동 방식:**\n- SubBytes: 바이트 치환\n- ShiftRows: 행 이동\n- MixColumns: 열 혼합\n- AddRoundKey: 라운드 키 적용\n\n**답:** \"AES\"",
      "explanation_preview": "AES(Advanced Encryption Standard)는 고급 암호화 표준으로 대칭키 암호 알고리즘입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다\"**\n- AES는 대칭키 암호 알고리즘입니다 (같은 키로 암호화/복호화).\n- 1997년 NIST",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "AES"
        ],
        "raw_text": "AES"
      },
      "primary_category": "정보보안",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 781
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q013",
      "doc_id": "2024_round2",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 포인터 배열과 포인터 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint* parr[2] = {arr[1], arr[2]};\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n```\n\n**메모리 레이아웃:**\n\n```\narr[0] → [1, 2, 3]\narr[1] → [4, 5, 6]\narr[2] → [7, 8, 9]\n```\n\n**실행 과정:**\n\n1. **`parr` 배열 초기화:**\n```c int* parr[2] = {arr[1], arr[2]};\n```\n- `parr[0]` = `arr[1]` (두 번째 행을 가리킴)\n- `parr[1]` = `arr[2]` (세 번째 행을 가리킴)\n\n2. **표현식 계산:**\n```c parr[1][1] + *(parr[1]+2) + **parr\n```\n\n- **`parr[1][1]`:**\n- `parr[1]` = `arr[2]` → `[7, 8, 9]`\n- `parr[1][1]` = `arr[2][1]` = **8**\n\n- **`*(parr[1]+2)`:**\n- `parr[1]` = `arr[2]` (시작 주소)\n- `parr[1] + 2` = `arr[2] + 2` (두 칸 뒤)\n- `*(parr[1]+2)` = `arr[2][2]` = **9**\n\n- **`**parr`:**\n- `parr` = `parr[0]`의 주소\n- `*parr` = `parr[0]` = `arr[1]` (주소)\n- `**parr` = `arr[1][0]` = **4**\n\n3. **최종 계산:**\n- `8 + 9 + 4 = 21`\n\n**답:** 21",
      "explanation_preview": "이 C언어 코드는 포인터 배열과 포인터 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint* parr[2] = {arr[1], arr[2]};\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n```\n\n**메모리 레이아웃:",
      "image_refs": [
        "images/2024_round2/Q013.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nint main() {\n    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int* parr[2] = {arr[1], arr[2]};\n    printf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n    return 0;\n}",
          "line_numbers": [
            1,
            7
          ],
          "file": "data/codes/2024_round2/Q013_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "21"
        ],
        "raw_text": "21"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 864
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q014",
      "doc_id": "2024_round2",
      "question_text": "다음은 Java 언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드를 분석하여 홀수 합과 짝수 합을 계산하는 문제입니다.\n\n**코드 분석:**\n\n```java\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nODDNumber OE = new ODDNumber();\nSystem.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\n\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }\n        return result;\n    }\n}\n```\n\n**실행 과정:**\n\n1. **`OE.sum(a, true)` 호출 (홀수 합):**\n   - `odd = true`이므로 조건: `(true && a[i] % 2 != 0)` → **홀수만 선택**\n   - 배열: `{1, 2, 3, 4, 5, 6, 7, 8, 9}`\n   - i=0: a[0]=1 (홀수) → result += 1 (result = 1)\n   - i=1: a[1]=2 (짝수) → 건너뜀\n   - i=2: a[2]=3 (홀수) → result += 3 (result = 4)\n   - i=3: a[3]=4 (짝수) → 건너뜀\n   - i=4: a[4]=5 (홀수) → result += 5 (result = 9)\n   - i=5: a[5]=6 (짝수) → 건너뜀\n   - i=6: a[6]=7 (홀수) → result += 7 (result = 16)\n   - i=7: a[7]=8 (짝수) → 건너뜀\n   - i=8: a[8]=9 (홀수) → result += 9 (result = 25)\n   - **결과: 25**\n\n2. **`OE.sum(a, false)` 호출 (짝수 합):**\n   - `odd = false`이므로 조건: `(!false && a[i] % 2 == 0)` → **짝수만 선택**\n   - i=0: a[0]=1 (홀수) → 건너뜀\n   - i=1: a[1]=2 (짝수) → result += 2 (result = 2)\n   - i=2: a[2]=3 (홀수) → 건너뜀\n   - i=3: a[3]=4 (짝수) → result += 4 (result = 6)\n   - i=4: a[4]=5 (홀수) → 건너뜀\n   - i=5: a[5]=6 (짝수) → result += 6 (result = 12)\n   - i=6: a[6]=7 (홀수) → 건너뜀\n   - i=7: a[7]=8 (짝수) → result += 8 (result = 20)\n   - i=8: a[8]=9 (홀수) → 건너뜀\n   - **결과: 20**\n\n3. **최종 출력:**\n```java\nSystem.out.print(25 + \", \" + 20);\n// 출력: \"25, 20\"\n```\n\n**핵심 개념:**\n- `odd && a[i] % 2 != 0`: 홀수 필터링\n- `!odd && a[i] % 2 == 0`: 짝수 필터링\n- `a[i] % 2 != 0`: 홀수 판별 (나머지가 1)\n- `a[i] % 2 == 0`: 짝수 판별 (나머지가 0)\n\n**답:** \"25, 20\"",
      "explanation_preview": "이미지의 Java 코드를 분석하여 홀수 합과 짝수 합을 계산하는 문제입니다.\n\n**코드 분석:**\n\n```java\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nODDNumber OE = new ODDNumber();\nSystem.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n\nint",
      "image_refs": [
        "images/2024_round2/Q014.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Main {\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        ODDNumber OE = new ODDNumber();\n        System.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n    }\n}\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }        \n        return result;\n    }    \n}",
          "line_numbers": [
            1,
            20
          ],
          "file": "data/codes/2024_round2/Q014_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "25, 20"
        ],
        "raw_text": "25, 20"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1767
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q015",
      "doc_id": "2024_round2",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 문자열 복사 함수와 인덱스 합 계산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void sumFn(char* d, const char* s) {\nwhile (*s) {\n*d = *s;\nd++;\ns++;\n}\n*d = '\\0';\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c const char* str1 = \"first\"; // 길이: 5 char str2[50] = \"teststring\"; // 길이: 10\n```\n\n2. **`sumFn(str2, str1)` 호출:**\n- `str1 = \"first\"`를 `str2`에 복사\n- 복사 후: `str2 = \"first\\0...\"` (길이: 5)\n\n3. **인덱스 합 계산:**\n```c for (int i = 0; str2[i] != '\\0'; i++) {\nresult += i;\n}\n```\n- i=0: result += 0 (result = 0)\n- i=1: result += 1 (result = 1)\n- i=2: result += 2 (result = 3)\n- i=3: result += 3 (result = 6)\n- i=4: result += 4 (result = 10)\n- i=5: `str2[5] == '\\0'` → 루프 종료\n\n4. **최종 출력:**\n- **출력: 10**답:** 10",
      "explanation_preview": "이 C언어 코드는 문자열 복사 함수와 인덱스 합 계산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void sumFn(char* d, const char* s) {\nwhile (*s) {\n*d = *s;\nd++;\ns++;\n}\n*d = '\\0';\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c const char* str1 = \"f",
      "image_refs": [
        "images/2024_round2/Q015.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#include <string.h>\nvoid sumFn(char* d, const char* s) {\n    while (*s) {\n        *d = *s;\n        d++;\n        s++;\n    }\n    *d = '\\0'; \n}\nint main() {\n   const char* str1 = \"first\";\n    char str2[50] = \"teststring\";  \n    int result=0;\n    sumFn(str2, str1);\n    for (int i = 0; str2[i] != '\\0'; i++) {\n        result += i;\n    }\n    printf(\"%d\", result);\n    return 0;\n}",
          "line_numbers": [
            1,
            21
          ],
          "file": "data/codes/2024_round2/Q015_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "10"
        ],
        "raw_text": "10"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 671
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q017",
      "doc_id": "2024_round2",
      "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "question_full": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 재귀 함수를 사용하여 문자열에서 뒤에서부터 중복을 제거하는 알고리즘입니다.\n\n**코드 분석:**\n\n```java\nString str = \"abacabcd\";\nboolean[] seen = new boolean[256];\nSystem.out.print(calculFn(str, str.length()-1, seen));\n\npublic static String calculFn(String str, int index, boolean[] seen) {\n    if(index < 0) return \"\";\n    char c = str.charAt(index);\n    String result = calculFn(str, index-1, seen);\n    if(!seen[c]) {\n        seen[c] = true;\n        return c + result;\n    }\n    return result;\n}\n```\n\n**알고리즘 이해:**\n\n1. **재귀 호출 순서**: 문자열을 **뒤에서 앞으로** 처리합니다 (index가 감소).\n2. **중복 제거**: `seen[]` 배열로 이미 본 문자를 체크합니다.\n3. **결과 구성**: 처음 본 문자를 **앞에 추가**합니다.\n\n**실행 과정 (재귀 스택):**\n\n```\ncalculFn(\"abacabcd\", 7, seen) // index=7, c='d'\n  → seen['d']=false → seen['d']=true → \"d\" + result\n  ↓\ncalculFn(\"abacabcd\", 6, seen) // index=6, c='c'\n  → seen['c']=false → seen['c']=true → \"c\" + result\n  ↓\ncalculFn(\"abacabcd\", 5, seen) // index=5, c='b'\n  → seen['b']=false → seen['b']=true → \"b\" + result\n  ↓\ncalculFn(\"abacabcd\", 4, seen) // index=4, c='a'\n  → seen['a']=false → seen['a']=true → \"a\" + result\n  ↓\ncalculFn(\"abacabcd\", 3, seen) // index=3, c='c'\n  → seen['c']=true (이미 본 문자) → result 반환 (\"a\" 추가 안 함)\n  ↓\ncalculFn(\"abacabcd\", 2, seen) // index=2, c='a'\n  → seen['a']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", 1, seen) // index=1, c='b'\n  → seen['b']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", 0, seen) // index=0, c='a'\n  → seen['a']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", -1, seen) // 종료 조건\n  → return \"\"\n```\n\n**결과 구성 (재귀 반환 순서):**\n\n1. `calculFn(-1)` → `\"\"` 반환\n2. `calculFn(0)` → `\"\"` 반환 (a는 이미 봄)\n3. `calculFn(1)` → `\"\"` 반환 (b는 이미 봄)\n4. `calculFn(2)` → `\"\"` 반환 (a는 이미 봄)\n5. `calculFn(3)` → `\"\"` 반환 (c는 이미 봄)\n6. `calculFn(4)` → `\"a\" + \"\"` = `\"a\"` 반환 (처음 본 a)\n7. `calculFn(5)` → `\"b\" + \"a\"` = `\"ba\"` 반환 (처음 본 b)\n8. `calculFn(6)` → `\"c\" + \"ba\"` = `\"cba\"` 반환 (처음 본 c)\n9. `calculFn(7)` → `\"d\" + \"cba\"` = `\"dcba\"` 반환 (처음 본 d)\n\n**핵심 포인트:**\n- 문자열을 **뒤에서 앞으로** 처리하므로, 결과는 **역순**으로 구성됩니다.\n- **처음 본 문자만 추가**하므로 중복이 제거됩니다.\n- `seen[c]`는 ASCII 코드를 인덱스로 사용합니다 (char → int 자동 변환).\n\n**답:** \"dcba\"",
      "explanation_preview": "이미지의 Java 코드는 재귀 함수를 사용하여 문자열에서 뒤에서부터 중복을 제거하는 알고리즘입니다.\n\n**코드 분석:**\n\n```java\nString str = \"abacabcd\";\nboolean[] seen = new boolean[256];\nSystem.out.print(calculFn(str, str.length()-1, seen));\n\npublic ",
      "image_refs": [
        "images/2024_round2/Q017.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"abacabcd\";\n        boolean[] seen = new boolean[256];\n        System.out.print(calculFn(str, str.length()-1, seen));\n    }\n    public static String calculFn(String str, int index, boolean[] seen) {\n        if(index < 0) return \"\";\n        char c = str.charAt(index);\n        String result = calculFn(str, index-1, seen);\n        if(!seen[c]) {\n            seen[c] = true;\n            return c + result;\n        }\n        return result;\n    }\n}",
          "line_numbers": [
            1,
            17
          ],
          "file": "data/codes/2024_round2/Q017_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "dcba"
        ],
        "raw_text": "dcba"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 2079
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q018",
      "doc_id": "2024_round2",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 함수 파라미터의 값 전달과 switch 문의 fall-through를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void swap(int a, int b) {\nint = a;\na = b;\nb = t;\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c int a = 11;\nint b = 19;\n```\n\n2. **`swap(a, b)` 호출:**\n- C언어는 값에 의한 전달(Call by Value)을 사용합니다.\n- `swap()` 함수 내부에서 `a`와 `b`의 값을 변경해도 원본 변수에는 영향이 없습니다.\n- **함수 호출 후에도 `a = 11`, `b = 19` (변경 없음)**\n\n3. **switch 문 실행:**\n```c switch(a) { // a = 11 case 1:\nb += 1;\ncase 11: // 매칭! (하지만 break 없음)\nb += 2; // 실행 default:\nb += 3; // 실행 (fall-through)\nbreak;\n}\n```\n- `a = 11`이므로 `case 11:`로 이동합니다.\n- **break가 없으므로 아래로 fall-through**합니다.\n- `b += 2` → `b = 19 + 2 = 21`\n- `default:` 실행 → `b += 3` → `b = 21 + 3 = 24`\n\n4. **최종 계산:**\n```c printf(\"%d\", a - b); // 11 - 24 = -13\n```\n\n**답:** \"-13\"",
      "explanation_preview": "이 C언어 코드는 함수 파라미터의 값 전달과 switch 문의 fall-through를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void swap(int a, int b) {\nint = a;\na = b;\nb = t;\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c int a = 11;\nint b = 19;\n```\n\n2. **`s",
      "image_refs": [
        "images/2024_round2/Q018.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int a = 11;\n    int b = 19;\n    swap(a, b);\n    switch(a) {\n        case 1:\n            b += 1;\n        case 11:\n            b += 2;\n        default:\n            b += 3;\n        break;\n    }\n    printf(\"%d\", a-b);\n}",
          "line_numbers": [
            1,
            21
          ],
          "file": "data/codes/2024_round2/Q018_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "-13"
        ],
        "raw_text": "-13"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 739
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q019",
      "doc_id": "2024_round2",
      "question_text": "다음은 C언어의 구조체에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "question_full": "다음은 C언어의 구조체에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 구조체 포인터와 연결 리스트를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c struct node {\nint n1;\nstruct node *n2;\n};\n\nstruct node a = {10, NULL};\nstruct node b = {20, NULL};\nstruct node c = {30, NULL};\nstruct node *head = &a;\na.n2 = &b;\nb.n2 = &c;\nprintf(\"%d\\n\", head->n2->n1);\n```\n\n**메모리 구조:**\n\n```\nhead → a {n1=10, n2=&b}\n↓\nb {n1=20, n2=&c}\n↓\nc {n1=30, n2=NULL}\n```\n\n**표현식 계산:**\n\n```c head->n2->n1\n```\n\n1. **`head`**: `&a` (a의 주소)\n\n2. **`head->n2`**: `a.n2` = `&b` (b의 주소)\n\n3. **`head->n2->n1`**: `b.n1` = **20**답:** 20",
      "explanation_preview": "이 C언어 코드는 구조체 포인터와 연결 리스트를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c struct node {\nint n1;\nstruct node *n2;\n};\n\nstruct node a = {10, NULL};\nstruct node b = {20, NULL};\nstruct node c = {30, NULL};\nstruct node *hea",
      "image_refs": [
        "images/2024_round2/Q019.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nstruct node {\n    int n1;\n    struct node *n2;\n};\nint main() {\n    struct node a = {10, NULL};\n    struct node b = {20, NULL};\n    struct node c = {30, NULL};\n    struct node *head = &a;\n    a.n2 = &b;\n    b.n2 = &c;\n    printf(\"%d\\n\", head->n2->n1);\n    return 0;\n}",
          "line_numbers": [
            1,
            15
          ],
          "file": "data/codes/2024_round2/Q019_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "20"
        ],
        "raw_text": "20"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 503
      }
    },
    {
      "file": "items_2024_round2.jsonl",
      "q_no": "Q020",
      "doc_id": "2024_round2",
      "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "question_full": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 String의 split() 메서드를 사용하여 문자열을 분할하는 문제입니다.\n\n**코드 분석:**\n\n```java\nString str = \"ITISTESTSTRING\";\nString[] result = str.split(\"T\");\nSystem.out.print(result[3]);\n```\n\n**String.split() 메서드:**\n\n- `split(\"구분자\")`: 문자열을 **구분자를 기준으로 분할**하여 배열로 반환합니다.\n- 구분자는 **제거**되고, 나머지 부분들이 배열 요소가 됩니다.\n\n**실행 과정:**\n\n1. **`str.split(\"T\")` 실행:**\n   - 원본 문자열: `\"ITISTESTSTRING\"`\n   - 구분자: `\"T\"`\n   - 분할 위치 확인:\n     ```\n     I T I S T E S T S T R I N G\n       ↑   ↑   ↑   ↑   ↑\n     ```\n   - `\"T\"`로 분할:\n     - `\"I\"` (첫 번째)\n     - `\"IS\"` (두 번째)\n     - `\"ES\"` (세 번째)\n     - `\"S\"` (네 번째)\n     - `\"RING\"` (다섯 번째)\n\n2. **배열 생성:**\n```java\nresult = [\"I\", \"IS\", \"ES\", \"S\", \"RING\"]\n// 인덱스:  0     1      2     3     4\n```\n\n3. **`result[3]` 출력:**\n   - 인덱스 3의 값: `\"S\"`\n\n**주의사항:**\n- `split()`은 구분자를 **제거**하므로, 결과 배열에는 구분자가 포함되지 않습니다.\n- 구분자 앞뒤의 문자열이 각각 배열 요소가 됩니다.\n- 빈 문자열도 배열 요소로 포함될 수 있습니다.\n\n**답:** \"S\"",
      "explanation_preview": "이미지의 Java 코드는 String의 split() 메서드를 사용하여 문자열을 분할하는 문제입니다.\n\n**코드 분석:**\n\n```java\nString str = \"ITISTESTSTRING\";\nString[] result = str.split(\"T\");\nSystem.out.print(result[3]);\n```\n\n**String.split() 메서드:**",
      "image_refs": [
        "images/2024_round2/Q020.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"ITISTESTSTRING\";\n        String[] result = str.split(\"T\");\n        System.out.print(result[3]);\n    }\n}",
          "line_numbers": [
            1,
            7
          ],
          "file": "data/codes/2024_round2/Q020_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "S"
        ],
        "raw_text": "S"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 876
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q001",
      "doc_id": "2024_round3",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 String의 equals() 메서드를 사용하여 내용을 비교하는 문제입니다.\n\n**코드 분석:**\n\n```java\nstatic String[] s = new String[3];\ns[0] = \"A\";\ns[1] = \"A\";\ns[2] = new String(\"A\");\nfunc(s, 3);\n\nstatic void func(String[] s, int size) {\n    for(int i=1; i<size; i++) {\n        if(s[i-1].equals(s[i])) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"N\");\n        }\n    }\n    for (String m : s) {\n        System.out.print(m);\n    }\n}\n```\n\n**핵심 개념:**\n\n1. **String 리터럴 vs `new String()`:**\n   - `\"A\"` (리터럴): String 상수 풀에 저장, 같은 리터럴은 같은 참조\n   - `new String(\"A\")`: 새로운 객체 생성, 다른 참조\n\n2. **`equals()` 메서드:**\n   - **내용 비교**: 문자열의 실제 값(내용)을 비교합니다.\n   - `==` 연산자와 달리 참조가 아닌 **내용**을 비교합니다.\n\n**실행 과정:**\n\n1. **초기화:**\n   - `s[0] = \"A\"` (리터럴)\n   - `s[1] = \"A\"` (리터럴, s[0]과 같은 참조 가능)\n   - `s[2] = new String(\"A\")` (새 객체, 다른 참조이지만 내용은 \"A\")\n\n2. **첫 번째 반복문 (`for(int i=1; i<3; i++)`):**\n   - **i=1:** `s[0].equals(s[1])` → `\"A\".equals(\"A\")` → `True` → **\"O\" 출력**\n   - **i=2:** `s[1].equals(s[2])` → `\"A\".equals(new String(\"A\"))` → `True` (내용이 같음) → **\"O\" 출력**\n\n3. **두 번째 반복문 (`for (String m : s)`):**\n   - `s[0]` = `\"A\"` → **\"A\" 출력**\n   - `s[1]` = `\"A\"` → **\"A\" 출력**\n   - `s[2]` = `new String(\"A\")` → **\"A\" 출력**\n\n**참고:**\n- `==`는 참조 비교이므로 `s[1] == s[2]`는 `false`입니다.\n- `equals()`는 내용 비교이므로 `s[1].equals(s[2])`는 `true`입니다.\n\n**답:** \"OOAAA\"",
      "explanation_preview": "이미지의 Java 코드는 String의 equals() 메서드를 사용하여 내용을 비교하는 문제입니다.\n\n**코드 분석:**\n\n```java\nstatic String[] s = new String[3];\ns[0] = \"A\";\ns[1] = \"A\";\ns[2] = new String(\"A\");\nfunc(s, 3);\n\nstatic void func(String[] ",
      "image_refs": [
        "images/2024_round3/Q001.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main{\n  static String[] s = new String[3];\n  static void func(String[]s, int size){\n    for(int i=1; i<size; i++){\n      if(s[i-1].equals(s[i])){\n        System.out.print(\"O\");\n      }else{\n        System.out.print(\"N\");\n      }\n    }\n      for (String m : s){\n        System.out.print(m);\n      }\n    }\n  public static void main(String[] args){\n    s[0] = \"A\";\n    s[1] = \"A\";\n    s[2] = new String(\"A\");\n    func(s, 3);\n  }\n}",
          "line_numbers": [
            1,
            21
          ],
          "file": "data/codes/2024_round3/Q001_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "OOAAA"
        ],
        "raw_text": "OOAAA"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1330
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q002",
      "doc_id": "2024_round3",
      "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 파이썬 코드는 리스트를 역순으로 뒤집고 짝수 인덱스와 홀수 인덱스의 합 차이를 계산하는 문제입니다.\n\n**코드 분석:**\n\n```python def func(lst):\nfor i in range(len(lst) // 2):\nlst[i], lst[-i-1] = lst[-i-1], lst[i] # 리스트 역순\n\nlst = [1, 2, 3, 4, 5, 6]\nfunc(lst) # 역순으로 뒤집기 print(sum(lst[::2]) - sum(lst[1::2])) # 짝수 인덱스 합 - 홀수 인덱스 합\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `lst = [1, 2, 3, 4, 5, 6]`\n\n2. **`func(lst)` 실행 (역순으로 뒤집기):**\n- `len(lst) // 2 = 6 // 2 = 3`\n- i=0: lst[0] ↔ lst[-1] → [6, 2, 3, 4, 5, 1]\n- i=1: lst[1] ↔ lst[-2] → [6, 5, 3, 4, 2, 1]\n- i=2: lst[2] ↔ lst[-3] → [6, 5, 4, 3, 2, 1]\n- **결과: `lst = [6, 5, 4, 3, 2, 1]`**\n\n3. **합 차이 계산:**\n```python sum(lst[::2]) # 짝수 인덱스 (0, 2, 4): 6 + 4 + 2 = 12 sum(lst[1::2]) # 홀수 인덱스 (1, 3, 5): 5 + 3 + 1 = 9\n```\n- `12 - 9 = 3`\n\n**답:** 3",
      "explanation_preview": "이 파이썬 코드는 리스트를 역순으로 뒤집고 짝수 인덱스와 홀수 인덱스의 합 차이를 계산하는 문제입니다.\n\n**코드 분석:**\n\n```python def func(lst):\nfor i in range(len(lst) // 2):\nlst[i], lst[-i-1] = lst[-i-1], lst[i] # 리스트 역순\n\nlst = [1, 2, 3, 4, 5, 6]\n",
      "image_refs": [
        "images/2024_round3/Q002.png"
      ],
      "code_blocks": [
        {
          "language": "python",
          "code": "def func(lst):\n  for i in range(len(lst) //2):\n    lst[i], lst[-i-1] = lst[-i-1], lst[i]\nlst = [1,2,3,4,5,6] \nfunc(lst)\nprint(sum(lst[::2]) - sum(lst[1::2]))",
          "line_numbers": [
            1,
            6
          ],
          "file": "data/codes/2024_round3/Q002_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "3"
        ],
        "raw_text": "3"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 732
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q003",
      "doc_id": "2024_round3",
      "question_text": "아래의 employee테이블과 project테이블을 참고하여\n\n보기의 SQL명령어에 알맞는 출력 값을 작성하시오.",
      "question_full": "아래의 employee테이블과 project테이블을 참고하여\n\n보기의 SQL명령어에 알맞는 출력 값을 작성하시오.",
      "explanation_current": "이 문제는 **중첩 서브쿼리와 JOIN**을 이해하는 SQL 문제입니다.\n\n**SQL 쿼리 분석:**\n\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p \n    WHERE p.project_id IN (\n        SELECT project_id FROM employee \n        GROUP BY project_id \n        HAVING count(*) < 2\n    )\n);\n```\n\n**실행 순서 (안쪽부터 바깥쪽으로):**\n\n1. **가장 안쪽 서브쿼리:**\n```sql\nSELECT project_id FROM employee \nGROUP BY project_id \nHAVING count(*) < 2\n```\n- **의미**: 직원이 1명 이하인 프로젝트 ID를 찾습니다.\n- 각 프로젝트별 직원 수를 세고, 직원이 1명 이하인 프로젝트만 선택합니다.\n- 예: 프로젝트 ID가 `P001`에 직원이 1명만 있으면 `P001` 반환\n\n2. **중간 서브쿼리:**\n```sql\nSELECT name FROM project p \nWHERE p.project_id IN (위의 결과)\n```\n- **의미**: 위에서 찾은 프로젝트 ID에 해당하는 **프로젝트 이름**을 찾습니다.\n- 직원이 1명 이하인 프로젝트의 이름을 반환합니다.\n\n3. **외부 쿼리:**\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (위의 결과)\n```\n- **의미**: 직원과 프로젝트를 조인한 후, 직원이 1명 이하인 프로젝트에 **속한 직원 수**를 세습니다.\n- `JOIN`으로 employee와 project를 연결하고, `WHERE` 절로 프로젝트 이름을 필터링합니다.\n- `count(*)`로 해당 조건을 만족하는 직원 레코드 수를 세어 반환합니다.\n\n**요약:**\n- **직원이 1명 이하인 프로젝트**를 찾고\n- 그 프로젝트에 **속한 직원의 수**를 세는 쿼리입니다.\n- 직원이 1명 이하인 프로젝트에 속한 직원이 1명이므로 결과는 **1**입니다.\n\n**답:** 1",
      "explanation_preview": "이 문제는 **중첩 서브쿼리와 JOIN**을 이해하는 SQL 문제입니다.\n\n**SQL 쿼리 분석:**\n\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p ",
      "image_refs": [
        "images/2024_round3/Q003_1.png",
        "images/2024_round3/Q003_2.png"
      ],
      "code_blocks": [
        {
          "language": "sql",
          "code": "SELECT \n    count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p WHERE p.project_id IN (\n        SELECT project_id FROM employee GROUP BY project_id HAVING count(*) < 2\n    )\n);",
          "line_numbers": [
            1,
            8
          ],
          "file": "data/codes/2024_round3/Q003_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "1"
        ],
        "raw_text": "1"
      },
      "primary_category": "데이터베이스",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1193
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q005",
      "doc_id": "2024_round3",
      "question_text": "다음은 네트워크 취약점에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다.\n\n- 여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply 를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이",
      "question_full": "다음은 네트워크 취약점에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다.\n\n- 여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply 를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다.\n\n- 공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다.",
      "explanation_current": "스머프(Smurf) 공격은 IP와 ICMP의 특성을 악용한 DDoS 공격입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다\"**\n- 스머프 공격은 IP 브로드캐스트 주소를 악용합니다.\n- 공격자는 피해자의 IP 주소를 위조(spoofing)하여 브로드캐스트 주소로 ICMP Echo Request를 전송합니다.\n- 브로드캐스트 네트워크의 모든 호스트가 응답하여 트래픽이 증폭됩니다.\n\n2. **\"여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다\"**\n- 공격자는 피해자의 IP를 소스로 위조한 ICMP Echo Request를 브로드캐스트합니다.\n- 네트워크의 모든 호스트가 피해자에게 ICMP Echo Reply를 전송합니다.\n- 결과적으로 피해자는 엄청난 양의 응답 패킷을 받게 됩니다.\n\n3. **\"공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다\"**\n- 수신 대역폭이 포화되어 정상적인 통신이 불가능해집니다.\n- DoS(Denial of Service) 상태에 빠집니다.\n\n**스머프 공격의 방어 방법:**\n- 라우터에서 브로드캐스트 주소로 향하는 패킷을 차단\n- ICMP 패킷 필터링\n- IP 스푸핑 방지\n\n**답:** \"스머프\"",
      "explanation_preview": "스머프(Smurf) 공격은 IP와 ICMP의 특성을 악용한 DDoS 공격입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다\"**\n- 스머프 공격은 IP 브로드캐스트 주소를 악용합니다.\n- 공격자는 피해자의 IP 주소",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "스머프"
        ],
        "raw_text": "스머프"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 719
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q007",
      "doc_id": "2024_round3",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 static 변수의 특성을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int func() {\nstatic int x = 0; // static 변수 (초기화는 한 번만!)\nx += 2;\nreturn x;\n}\n\nint main() {\nint x = 1; // 지역 변수 (func의 x와 별개)\nint sum = 0;\nfor(int i=0; i<4; i++) {\nx++; // 지역 변수 x 증가 sum += func(); // func() 호출\n}\nprintf(\"%d\", sum);\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `main`의 지역 변수: `x = 1`\n- `func`의 static 변수: `x = 0` (초기화는 프로그램 시작 시 한 번만)\n\n2. **반복문 실행:**i=0:**\n- `x++` → `x = 2` (main의 지역 변수)\n- `func()` 호출:\n- static `x = 0` (유지됨)\n- `x += 2` → `x = 2`\n- 반환: **2**\n- `sum = 0 + 2 = 2`\n\n**i=1:**\n- `x++` → `x = 3`\n- `func()` 호출:\n- static `x = 2` (이전 값 유지!)\n- `x += 2` → `x = 4`\n- 반환: **4**\n- `sum = 2 + 4 = 6`\n\n**i=2:**\n- `x++` → `x = 4`\n- `func()` 호출:\n- static `x = 4`\n- `x += 2` → `x = 6`\n- 반환: **6**\n- `sum = 6 + 6 = 12`\n\n**i=3:**\n- `x++` → `x = 5`\n- `func()` 호출:\n- static `x = 6`\n- `x += 2` → `x = 8`\n- 반환: **8**\n- `sum = 12 + 8 = 20`\n\n3. **최종 출력:**\n- **출력: 20**핵심 포인트:**\n- static 변수는 함수가 종료되어도 메모리에 유지됩니다.\n- static 변수의 초기화는 프로그램 시작 시 한 번만 실행됩니다.\n- 함수를 여러 번 호출해도 static 변수는 이전 값을 유지합니다.\n\n**답:** 20",
      "explanation_preview": "이 C언어 코드는 static 변수의 특성을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int func() {\nstatic int x = 0; // static 변수 (초기화는 한 번만!)\nx += 2;\nreturn x;\n}\n\nint main() {\nint x = 1; // 지역 변수 (func의 x와 별개)\nint sum = 0;\nfor(int",
      "image_refs": [
        "images/2024_round3/Q007.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nint func(){\n static int x =0; \n  x+=2; \n  return x;\n}\nint main(){\n  int x = 1; \n  int sum=0; \n  for(int i=0;i<4;i++) {\n    x++; \n    sum+=func();\n  } \n  printf(\"%d\", sum);\n  return 0;\n}",
          "line_numbers": [
            1,
            16
          ],
          "file": "data/codes/2024_round3/Q007_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "20"
        ],
        "raw_text": "20"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1053
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q010",
      "doc_id": "2024_round3",
      "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 파이썬 코드는 `type()` 함수를 사용한 타입 체크를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```python def func(value):\nif type(value) == type(100): # int 타입 체크 return 100 elif type(value) == type(\"\"): # str 타입 체크 return len(value)\nelse:\nreturn 20\n\na = '100.0' # 문자열 b = 100.0 # float (실수)\nc = (100, 200) # tuple\n\nprint(func(a) + func(b) + func(c))\n```\n\n**실행 과정:**\n\n1. **`func('100.0')` 호출:**\n- `type('100.0') == type(\"\")` → `True` (문자열)\n- 반환: `len('100.0') = 5`\n\n2. **`func(100.0)` 호출:**\n- `type(100.0) == type(100)` → `False` (float ≠ int)\n- `type(100.0) == type(\"\")` → `False` (float ≠ str)\n- else 블록 실행 → 반환: **20**\n\n3. **`func((100, 200))` 호출:**\n- `type((100, 200)) == type(100)` → `False` (tuple ≠ int)\n- `type((100, 200)) == type(\"\")` → `False` (tuple ≠ str)\n- else 블록 실행 → 반환: **20**\n\n4. **최종 계산:**\n- `5 + 20 + 20 = 45`\n\n**핵심 포인트:**\n- `type()` 함수는 객체의 타입을 반환합니다.\n- `type(100)`은 `int` 타입 객체를 반환합니다.\n- `100.0`은 `float` 타입이므로 `int`와 다릅니다.\n\n**답:** 45",
      "explanation_preview": "이 파이썬 코드는 `type()` 함수를 사용한 타입 체크를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```python def func(value):\nif type(value) == type(100): # int 타입 체크 return 100 elif type(value) == type(\"\"): # str 타입 체크 return len(value)\nel",
      "image_refs": [
        "images/2024_round3/Q010.png"
      ],
      "code_blocks": [
        {
          "language": "python",
          "code": "def func(value):\n    if type(value) == type(100):\n        return 100\n    elif type(value) == type(\"\"):\n        return len(value) \n    else:\n        return 20\na = '100.0'\nb = 100.0\nc = (100, 200)\nprint(func(a) + func(b) + func(c))",
          "line_numbers": [
            1,
            11
          ],
          "file": "data/codes/2024_round3/Q010_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "45"
        ],
        "raw_text": "45"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 920
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q011",
      "doc_id": "2024_round3",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 상속에서 필드 숨김과 메서드 오버라이딩의 차이를 보여주는 문제입니다.\n\n**코드 분석:**\n\n```java\nBase a = new Derivate();\nDerivate b = new Derivate();\nSystem.out.print(a.getX() + a.x + b.getX() + b.x);\n\nclass Base {\n    int x = 3;\n    int getX() {\n        return x * 2;  // Base의 x 사용\n    }\n}\n\nclass Derivate extends Base {\n    int x = 7;  // 필드 숨김 (Base의 x를 숨김)\n    int getX() {\n        return x * 3;  // Derivate의 x 사용 (7 * 3 = 21)\n    }\n}\n```\n\n**핵심 개념:**\n\n1. **필드 숨김 (Field Hiding):**\n   - 자식 클래스에서 부모 클래스의 필드와 같은 이름의 필드를 선언하면 부모의 필드가 **숨겨집니다**.\n   - `Base.x = 3`, `Derivate.x = 7` (서로 다른 필드)\n\n2. **메서드 오버라이딩 (Method Overriding):**\n   - 자식 클래스에서 부모 클래스의 메서드를 재정의하면 **항상 자식의 메서드가 호출**됩니다.\n   - 객체의 실제 타입(`Derivate`)에 따라 메서드가 결정됩니다.\n\n3. **필드 접근 vs 메서드 호출:**\n   - **필드 접근 (`a.x`)**: 참조 변수의 타입(`Base`)에 따라 결정 → `Base.x = 3`\n   - **메서드 호출 (`a.getX()`)**: 객체의 실제 타입(`Derivate`)에 따라 결정 → `Derivate.getX()` 호출\n\n**실행 과정:**\n\n1. **`a.getX()` 계산:**\n   - `a`는 `Base` 타입으로 선언되었지만 실제 객체는 `Derivate`입니다.\n   - 메서드는 **실제 타입**에 따라 결정되므로 `Derivate.getX()` 호출됩니다.\n   - `Derivate.getX()`는 `Derivate.x`를 사용: `7 * 3 = 21`\n   - **결과: 21**\n\n2. **`a.x` 계산:**\n   - 필드는 **참조 변수의 타입**에 따라 결정됩니다.\n   - `a`는 `Base` 타입이므로 `Base.x = 3`\n   - **결과: 3**\n\n3. **`b.getX()` 계산:**\n   - `b`는 `Derivate` 타입으로 선언되었고 실제 객체도 `Derivate`입니다.\n   - `Derivate.getX()` 호출: `7 * 3 = 21`\n   - **결과: 21**\n\n4. **`b.x` 계산:**\n   - `b`는 `Derivate` 타입이므로 `Derivate.x = 7`\n   - **결과: 7**\n\n5. **최종 출력:**\n```java\nSystem.out.print(21 + 3 + 21 + 7);\n// 출력: \"52\"\n```\n\n**정리:**\n- 필드: 참조 변수 타입에 따라 결정 (`a.x` → `Base.x`, `b.x` → `Derivate.x`)\n- 메서드: 실제 객체 타입에 따라 결정 (`a.getX()`, `b.getX()` → 모두 `Derivate.getX()`)\n\n**답:** \"52\"",
      "explanation_preview": "이미지의 Java 코드는 상속에서 필드 숨김과 메서드 오버라이딩의 차이를 보여주는 문제입니다.\n\n**코드 분석:**\n\n```java\nBase a = new Derivate();\nDerivate b = new Derivate();\nSystem.out.print(a.getX() + a.x + b.getX() + b.x);\n\nclass Base {\n    int",
      "image_refs": [
        "images/2024_round3/Q011.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main{\n  public static void main(String[] args){\n    Base a =  new Derivate();\n    Derivate b = new Derivate();\n    System.out.print(a.getX() + a.x + b.getX() + b.x);\n  }\n}\nclass Base{\n  int x = 3;\n  int getX(){\n     return x * 2; \n  }\n}\nclass Derivate extends Base{\n  int x = 7;\n  int getX(){\n     return x * 3;\n  }\n}",
          "line_numbers": [
            1,
            19
          ],
          "file": "data/codes/2024_round3/Q011_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "52"
        ],
        "raw_text": "52"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1636
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q012",
      "doc_id": "2024_round3",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 연결 리스트에서 인접한 노드 쌍의 값을 교환하는 문제입니다.\n\n**코드 분석:**\n\n```c void func(struct Node* node) {\nwhile(node != NULL && node->next != NULL) {\nint = node->value;\nnode->value = node->next->value;\nnode->next->value = t; // 인접 노드 값 교환 node = node->next->next; // 두 칸 건너뛰기\n}\n}\n```\n\n**실행 과정:**\n\n1. **초기 리스트 구성:**\n```c n1 = {1, NULL}\nn2 = {2, NULL}\nn3 = {3, NULL}\nn1.next = &n3;\nn3.next = &n2;\n```\n- 리스트: **1 → 3 → 2 → NULL**\n\n2. **`func(&n1)` 실행:**첫 번째 반복 (node = &n1):**\n- node != NULL ✓, node->next != NULL ✓\n- 교환: n1.value(1) ↔ n3.value(3)\n- 리스트: **3 → 1 → 2 → NULL**\n- `node = node->next->next` = `n3->next` = `&n2`\n\n**두 번째 반복 (node = &n2):**\n- node != NULL ✓, node->next == NULL ✗\n- 루프 종료\n\n3. **출력:**\n```c while(current != NULL) {\nprintf(\"%d\", current->value);\ncurrent = current->next;\n}\n```\n- 출력: **\"312\"**답:** \"312\"",
      "explanation_preview": "이 C언어 코드는 연결 리스트에서 인접한 노드 쌍의 값을 교환하는 문제입니다.\n\n**코드 분석:**\n\n```c void func(struct Node* node) {\nwhile(node != NULL && node->next != NULL) {\nint = node->value;\nnode->value = node->next->value;\nnode->next-",
      "image_refs": [
        "images/2024_round3/Q012.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nstruct Node {\n int value;\n struct Node* next;\n};\nvoid func(struct Node* node){\n  while(node != NULL && node->next != NULL){\n     int t = node->value;\n     node->value = node->next->value;\n     node->next->value = t;\n     node = node->next->next;\n  }\n}\nint main(){\n  struct Node n1 = {1, NULL};\n  struct Node n2 = {2, NULL};\n  struct Node n3 = {3, NULL};\n  n1.next = &n3;\n  n3.next = &n2;\n  func(&n1);  \n  struct Node* current = &n1;\n  while(current != NULL){\n    printf(\"%d\", current->value);\n    current = current->next;\n }\n return 0;\n}",
          "line_numbers": [
            1,
            27
          ],
          "file": "data/codes/2024_round3/Q012_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "312"
        ],
        "raw_text": "312"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 811
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q015",
      "doc_id": "2024_round3",
      "question_text": "다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별",
      "question_full": "다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합\n\nㄱ. 슈퍼키\n\nㄴ. 외래키\n\nㄷ. 대체키\n\nㄹ. 후보키",
      "explanation_current": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별...\n\n**핵심 특징:**\n- 다음은 데이터베이스에 관한 문제이다.\n\n**답이 \"(1) 외래키, (2) 후보키, (3) 대체키\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"(1) 외래키, (2) 후보키, (3) 대체키\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.",
      "explanation_preview": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "(1) 외래키",
          "(2) 후보키",
          "(3) 대체키",
          "(4) 슈퍼키"
        ],
        "raw_text": "(1) 외래키\n(2) 후보키\n(3) 대체키\n(4) 슈퍼키"
      },
      "primary_category": "데이터베이스",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 과다",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 448
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q016",
      "doc_id": "2024_round3",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 이중 포인터와 배열 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void func(int** arr, int size) {\nfor(int i=0; i<size; i++) {\n*(*arr + i) = (*(*arr+i) + i) % size;\n}\n}\n\nint main() {\nint arr[] = {3, 1, 4, 1, 5};\nint* p = arr;\nint** pp = &p;\nfunc(pp, 5);\nnum = arr[2];\nprintf(\"%d\", num);\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `arr = {3, 1, 4, 1, 5}`\n- `p = arr` (arr의 시작 주소)\n- `pp = &p` (p의 주소)\n\n2. **`func(pp, 5)` 호출:**\n- `arr` 파라미터는 `pp`이므로 `**arr = *p = arr[0]`\n\n**i=0:**\n- `*(*arr + 0) = arr[0] = 3`\n- `(3 + 0) % 5 = 3`\n- `arr[0] = 3`\n\n**i=1:**\n- `*(*arr + 1) = arr[1] = 1`\n- `(1 + 1) % 5 = 2`\n- `arr[1] = 2`\n\n**i=2:**\n- `*(*arr + 2) = arr[2] = 4`\n- `(4 + 2) % 5 = 1`\n- `arr[2] = 1`\n\n**i=3:**\n- `*(*arr + 3) = arr[3] = 1`\n- `(1 + 3) % 5 = 4`\n- `arr[3] = 4`\n\n**i=4:**\n- `*(*arr + 4) = arr[4] = 5`\n- `(5 + 4) % 5 = 4`\n- `arr[4] = 4`\n\n**최종 배열:** `{3, 2, 1, 4, 4}`\n\n3. **출력:**\n```c num = arr[2] = 1 printf(\"%d\", 1);\n```\n\n**답:** 1",
      "explanation_preview": "이 C언어 코드는 이중 포인터와 배열 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void func(int** arr, int size) {\nfor(int i=0; i<size; i++) {\n*(*arr + i) = (*(*arr+i) + i) % size;\n}\n}\n\nint main() {\nint arr[] = {3, 1, 4, 1, 5};",
      "image_refs": [
        "images/2024_round3/Q016.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nvoid func(int** arr, int size){\n  for(int i=0; i<size; i++){\n     *(*arr + i) = (*(*arr+i) + i) % size;\n  }\n}\nint main(){\n  int arr[] = {3,1, 4, 1, 5};\n  int* p = arr;\n  int** pp = &p;\n  int num = 6;\n  func(pp, 5);  \n  num = arr[2];\n  printf(\"%d\", num);  \n  return 0;\n}",
          "line_numbers": [
            1,
            16
          ],
          "file": "data/codes/2024_round3/Q016_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "1"
        ],
        "raw_text": "1"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 914
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q017",
      "doc_id": "2024_round3",
      "question_text": "다음 아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n(3글자로 작성)\n\n- 공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다.\n\n- 사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다.\n\n- 종류로는 IPsec 또는 SSL, L2TP 등이 있다.",
      "question_full": "다음 아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n(3글자로 작성)\n\n- 공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다.\n\n- 사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다.\n\n- 종류로는 IPsec 또는 SSL, L2TP 등이 있다.",
      "explanation_current": "VPN(Virtual Private Network)은 공용 네트워크를 통해 사설 네트워크를 확장하는 기술입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다\"**\n- 인터넷 같은 공용 네트워크 위에 가상의 사설 네트워크를 구축합니다.\n- 물리적으로 멀리 떨어진 네트워크를 하나의 사설망처럼 사용할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등이 있습니다.\n\n2. **\"사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다\"**\n- VPN 서버를 통해 트래픽을 중계하므로 실제 IP가 숨겨집니다.\n- 위치 추적이 어려워집니다.\n- 프라이버시 보호에 도움이 됩니다.\n\n3. **\"종류로는 IPsec 또는 SSL, L2TP 등이 있다\"**\n- **IPsec (IP Security)**: 네트워크 계층 암호화\n- **SSL/TLS VPN**: 애플리케이션 계층 암호화\n- **L2TP (Layer 2 Tunneling Protocol)**: 데이터 링크 계층 터널링\n\n**VPN의 주요 용도:**\n- 원격 접근: 외부에서 회사 내부 네트워크 접속\n- 사이트 간 연결: 지사 간 안전한 통신\n- 프라이버시 보호: IP 주소 숨김\n\n**답:** \"VPN\"",
      "explanation_preview": "VPN(Virtual Private Network)은 공용 네트워크를 통해 사설 네트워크를 확장하는 기술입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다\"**\n- 인터넷 같은 공용 네트워크 위에 가상의 사설 네트워크를 구축합니다.\n- 물리적으로 멀리 떨어진 네트워크를 하나의 사설망처럼 사용할 ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "VPN"
        ],
        "raw_text": "VPN"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 70,
        "issues": [
          "범용적인 설명 문구 사용",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 658
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q018",
      "doc_id": "2024_round3",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 Java 코드는 예외 처리 메커니즘과 finally 블록의 실행 순서를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java public static void main(String[] args) {\nint sum = 0;\ntry {\nfunc(); // NullPointerException 발생\n} catch (NullPointerException e) {\nsum = sum + 1; // sum = 1\n} catch (Exception e) {\nsum = sum + 10;\n} finally {\nsum = sum + 100; // 항상 실행\n}\nSystem.out.print(sum);\n}\n\nstatic void func() throws Exception {\nthrow new NullPointerException();\n}\n```\n\n**실행 과정:**\n\n1. **try 블록 실행:**\n- `func()` 호출\n- `NullPointerException` 발생\n\n2. **예외 처리:**\n- Java는 첫 번째로 일치하는 catch 블록을 찾습니다.\n- `catch (NullPointerException e)` → **일치!**\n- `sum = 0 + 1 = 1`\n\n3. **finally 블록 실행:**\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- `sum = 1 + 100 = 101`\n\n4. **최종 출력:**\n- **출력: 101**핵심 포인트:**\n- 예외 처리 순서: try → catch(일치하는 예외) → finally\n- finally 블록은 반드시 실행됩니다.\n- `NullPointerException`은 `Exception`의 자식 클래스이므로, 더 구체적인 catch 블록이 먼저 매칭됩니다.\n\n**답:** 101",
      "explanation_preview": "이 Java 코드는 예외 처리 메커니즘과 finally 블록의 실행 순서를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java public static void main(String[] args) {\nint sum = 0;\ntry {\nfunc(); // NullPointerException 발생\n} catch (NullPointerException ",
      "image_refs": [
        "images/2024_round3/Q018.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class ExceptionHandling {\n  public static void main(String[] args) {\n      int sum = 0;\n      try {\n          func();\n      } catch (NullPointerException e) {\n          sum = sum + 1;\n      } catch (Exception e) {\n          sum = sum + 10;\n      } finally {\n          sum = sum + 100;\n      }\n      System.out.print(sum);\n  }\n  static void func() throws Exception {\n      throw new NullPointerException(); \n  }\n}",
          "line_numbers": [
            1,
            18
          ],
          "file": "data/codes/2024_round3/Q018_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "101"
        ],
        "raw_text": "101"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 875
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q019",
      "doc_id": "2024_round3",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 제네릭 타입 소거(Type Erasure)로 인한 메서드 오버로딩 해석 문제입니다.\n\n**코드 분석:**\n\n```java\nnew Collection<>(0).print();\n\nclass Collection<T> {\n    T value;\n    public Collection(T t) {\n        value = t;\n    }\n    public void print() {\n        new Printer().print(value);\n    }\n    \n    class Printer {\n        void print(Integer a) {\n            System.out.print(\"A\" + a);\n        }\n        void print(Object a) {\n            System.out.print(\"B\" + a);\n        }\n        void print(Number a) {\n            System.out.print(\"C\" + a);\n        }\n    }\n}\n```\n\n**핵심 개념:**\n\n1. **제네릭 타입 소거 (Type Erasure):**\n   - 컴파일 시 제네릭 타입 정보가 **삭제**됩니다.\n   - `Collection<Integer>` → `Collection` (타입 정보 제거)\n   - 런타임에는 `T`가 `Object`로 취급됩니다.\n\n2. **메서드 오버로딩 해석:**\n   - 컴파일 타임에 타입을 결정합니다.\n   - `value`는 `T` 타입이지만, 컴파일 시 `Object`로 취급됩니다.\n   - `0`은 `int` 리터럴이지만, `Integer`로 오토박싱됩니다.\n   - 하지만 `value`는 `Object` 타입이므로 `print(Object)`가 호출됩니다.\n\n**실행 과정:**\n\n1. **객체 생성:**\n   - `new Collection<>(0)` → `Collection<Integer>` 생성\n   - `value = 0` (Integer로 오토박싱)\n\n2. **`print()` 호출:**\n   - `new Printer().print(value)` 실행\n   - `value`는 컴파일 타임에 `Object` 타입으로 취급됩니다.\n\n3. **메서드 오버로딩 해석:**\n   - `print(Integer a)`: `Integer` 타입 매칭\n   - `print(Number a)`: `Number` 타입 매칭 (Integer는 Number의 자식)\n   - `print(Object a)`: `Object` 타입 매칭\n   - 컴파일러는 **가장 구체적인 타입**을 찾지만, `value`는 `Object` 타입이므로 `print(Object)`가 호출됩니다.\n\n4. **출력:**\n   - `print(Object a)` 실행 → `\"B\" + 0` → **\"B0\" 출력**\n\n**참고:**\n- 제네릭 타입 소거로 인해 런타임에는 타입 정보가 없습니다.\n- `print(Integer)`와 `print(Number)`는 `value`가 `Object` 타입이므로 매칭되지 않습니다.\n- `print(Object)`가 가장 넓은 범위를 가지므로 선택됩니다.\n\n**답:** \"B0\"",
      "explanation_preview": "이미지의 Java 코드는 제네릭 타입 소거(Type Erasure)로 인한 메서드 오버로딩 해석 문제입니다.\n\n**코드 분석:**\n\n```java\nnew Collection<>(0).print();\n\nclass Collection<T> {\n    T value;\n    public Collection(T t) {\n        value = t;\n    }",
      "image_refs": [
        "images/2024_round3/Q019.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "class Main {\n  public static class Collection<T>{\n    T value;\n    public Collection(T t){\n        value = t;\n    }\n    public void print(){\n       new Printer().print(value);\n    }\n   class Printer{\n      void print(Integer a){\n        System.out.print(\"A\" + a);\n      }\n      void print(Object a){\n        System.out.print(\"B\" + a);\n      } \n      void print(Number a){\n        System.out.print(\"C\" + a);\n      }\n   }\n }\n  public static void main(String[] args) {\n      new Collection<>(0).print();\n  }\n}",
          "line_numbers": [
            1,
            25
          ],
          "file": "data/codes/2024_round3/Q019_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "B0"
        ],
        "raw_text": "B0"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1597
      }
    },
    {
      "file": "items_2024_round3.jsonl",
      "q_no": "Q020",
      "doc_id": "2024_round3",
      "question_text": "다음은 네트워크에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다.\n\n- 일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다.\n\n- 긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다.\n\n[보기]\n\nㄱ.Infrastructure Netwo",
      "question_full": "다음은 네트워크에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다.\n\n- 일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다.\n\n- 긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다.\n\n[보기]\n\nㄱ.Infrastructure Network\n\nㄴ. Firmware Network\n\nㄷ. Peer-to-Peer Network\n\nㄹ. Ad-hoc Network\n\nㅁ. Mesh Network\n\nㅂ.Sensor Network\n\nㅅ.Virtual Private Network",
      "explanation_current": "Ad-hoc Network(애드혹 네트워크)는 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다\"**\n- 중앙 서버나 라우터 없이 노드들이 직접 통신합니다.\n- 인프라가 필요 없어 빠르게 구성 가능합니다.\n- 동적으로 네트워크를 형성합니다.\n\n2. **\"일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다\"**\n- 무선 기술(Wi-Fi, Bluetooth 등)을 사용합니다.\n- P2P(Peer-to-Peer) 방식으로 직접 통신합니다.\n- 각 노드가 라우터 역할을 할 수 있습니다.\n\n3. **\"긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다\"**\n- 인프라가 없는 상황에서도 통신 가능\n- 재난 상황, 야전 환경 등에서 활용\n- 임시 네트워크 구축에 적합\n\n**보기 분석:**\n- ㄱ. Infrastructure Network: 인프라 기반 네트워크 (Wi-Fi AP 필요)\n- ㄴ. Firmware Network: 펌웨어 네트워크 (일반적 용어 아님)\n- ㄷ. Peer-to-Peer Network: P2P (일부 특징 유사하지만 Ad-hoc과 다름)\n- **ㄹ. Ad-hoc Network**: 중앙 인프라 없이 임시 구성 ✓\n- ㅁ. Mesh Network: 메시 네트워크 (Ad-hoc의 확장 형태)\n- ㅂ. Sensor Network: 센서 네트워크 (IoT)\n- ㅅ. Virtual Private Network: VPN (가상 사설망)\n\n**답:** \"ㄹ\" (Ad-hoc Network)",
      "explanation_preview": "Ad-hoc Network(애드혹 네트워크)는 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다\"**\n- 중앙 서버나 라우터 없이 노드들이 직접 통신합니다.\n- 인프라가 필요 없어 빠르게 구성 가능합니다.\n- 동적으로 네트워크를 형성",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [
        {
          "id": "table1",
          "json": "data/tables/2024_round3/Q020_table1.json",
          "rows": 18,
          "cols": 1
        }
      ],
      "answer": {
        "keys": [
          "ㄹ"
        ],
        "raw_text": "ㄹ"
      },
      "primary_category": "네트워크",
      "quality": {
        "score": 65,
        "issues": [
          "범용적인 설명 문구 다수",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 822
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q004",
      "doc_id": "2025_round1",
      "question_text": "다음은 악성코드 관련된 문제이다.\n아래 내용을 확인하여\n\n보기에 골라 작성하시오.\n사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.\n‘겁을 주다’라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불 하거나 특정 행동을 유도하는 ",
      "question_full": "다음은 악성코드 관련된 문제이다.\n아래 내용을 확인하여\n\n보기에 골라 작성하시오.\n사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.\n‘겁을 주다’라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불 하거나 특정 행동을 유도하는 랜섬웨어이다.\n가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식으로 작동한다.\n\n[보기]\n\nㄱ. 컴포넌트 웨어\n\nㄴ. 유즈웨어\n\nㄷ. 셔블웨어\n\nㄹ. 스캐어 웨어\n\nㅁ. 안티 스파이 웨어\n\nㅂ. 네트웨어\n\nㅅ. 그룹웨어\n\nㅇ. 애드웨어",
      "explanation_current": "스캐어웨어(Scareware)는 사용자를 속여 돈을 지불하거나 소프트웨어를 구매하도록 조작하는 악성 소프트웨어입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발\"**\n- 스캐어웨어는 사용자의 두려움(scare)을 이용합니다.\n- 가짜 경고나 위협적인 메시지를 보여줘서 사용자가 당황하게 만듭니다.\n- 사용자가 긴급하게 대응해야 한다고 느끼도록 조작합니다.\n\n2. **\"'겁을 주다'라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불하거나 특정 행동을 유도하는 랜섬웨어\"**\n- \"Scare\"는 \"겁을 주다, 놀라게 하다\"라는 의미입니다.\n- 공포 마케팅 전략을 사용합니다.\n- 랜섬웨어와 유사하지만, 실제로 데이터를 암호화하지 않고 가짜 경고를 보여줍니다.\n\n3. **\"가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식\"**\n- 가짜 안티바이러스 경고를 표시합니다.\n- \"시스템이 감염되었습니다\", \"바로 지금 처리하세요\" 등의 메시지를 보여줍니다.\n- 사용자로 하여금 가짜 안티바이러스 소프트웨어를 구매하거나 설치하도록 유도합니다.\n\n**보기 분석:**\n- ㄱ. 컴포넌트 웨어: 컴포넌트 기반 소프트웨어\n- ㄴ. 유즈웨어: 사용자가 만든 소프트웨어\n- ㄷ. 셔블웨어: 평가판 소프트웨어\n- **ㄹ. 스캐어 웨어: 공포를 이용한 악성 소프트웨어** ✓\n- ㅁ. 안티 스파이 웨어: 스파이웨어 방지 소프트웨어\n- ㅂ. 네트웨어: 네트워크 기반 소프트웨어\n- ㅅ. 그룹웨어: 그룹 협업 소프트웨어\n- ㅇ. 애드웨어: 광고 소프트웨어\n\n**답:** 문제에서 설명한 모든 특징(공포 유발, 가짜 경고, 속임수)이 스캐어웨어와 정확히 일치하므로 답은 \"ㄹ\"입니다.",
      "explanation_preview": "스캐어웨어(Scareware)는 사용자를 속여 돈을 지불하거나 소프트웨어를 구매하도록 조작하는 악성 소프트웨어입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발\"**\n- 스캐어웨어는 사용자의 두려움(scare)을 이용합니다.\n- ",
      "image_refs": [],
      "code_blocks": [],
      "table_refs": [],
      "answer": {
        "keys": [
          "ㄹ"
        ],
        "raw_text": "ㄹ"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 65,
        "issues": [
          "범용적인 설명 문구 다수",
          "구체적인 설명 부족"
        ],
        "is_poor": true,
        "length": 934
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q005",
      "doc_id": "2025_round1",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 Java 코드는 예외 처리 메커니즘(try-catch-finally)을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java int a = 5, b = 0;\ntry {\nSystem.out.print(a/b); // 5 / 0 → ArithmeticException 발생!\n} catch(ArithmeticException e) {\nSystem.out.print(\"출력1\");\n} catch(ArrayIndexOutOfBoundsException e) {\nSystem.out.print(\"출력2\");\n} catch(NumberFormatException e) {\nSystem.out.print(\"출력3\");\n} catch(Exception e) {\nSystem.out.print(\"출력4\");\n} finally {\nSystem.out.print(\"출력5\");\n}\n```\n\n**실행 과정:**\n\n1. **try 블록 실행:**\n- `a = 5`, `b = 0`\n- `System.out.print(5 / 0)` 실행 시도\n- **0으로 나누기 연산 → `ArithmeticException` 발생**\n\n2. **예외 처리:**\n- Java는 발생한 예외 타입을 찾기 위해 catch 블록들을 순서대로 확인합니다.\n- 첫 번째 catch: `catch(ArithmeticException e)` → **일치!**\n- 따라서 \"출력1\"을 출력합니다.\n\n3. **finally 블록 실행:**\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- \"출력5\"를 출력합니다.\n\n4. **최종 출력:**\n- \"출력1\" + \"출력5\" = **\"출력1출력5\"**핵심 포인트:**\n- Java의 예외 처리 순서: try → catch(일치하는 예외 타입) → finally\n- 여러 catch 블록이 있을 때 첫 번째로 일치하는 catch 블록이 실행됩니다.\n- finally 블록은 예외 발생 여부와 관계없이 반드시 실행됩니다.\n\n**답:** \"출력1출력5\"",
      "explanation_preview": "이 Java 코드는 예외 처리 메커니즘(try-catch-finally)을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java int a = 5, b = 0;\ntry {\nSystem.out.print(a/b); // 5 / 0 → ArithmeticException 발생!\n} catch(ArithmeticException e) {\nSystem.out",
      "image_refs": [
        "images/2025_round1/Q005.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main {\n  public static void main(String[] args) {\n    int a=5,b=0;\n    try{\n      System.out.print(a/b);\n    }catch(ArithmeticException e){\n      System.out.print(\"출력1\");\n    }catch(ArrayIndexOutOfBoundsException e) {\n      System.out.print(\"출력2\");\n    }catch(NumberFormatException e) {\n      System.out.print(\"출력3\");\n    }catch(Exception e){\n      System.out.print(\"출력4\");\n    }finally{\n      System.out.print(\"출력5\");\n    }\n  }\n}",
          "line_numbers": [
            1,
            18
          ],
          "file": "data/codes/2025_round1/Q005_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "출력1출력5"
        ],
        "raw_text": "출력1출력5"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 982
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q010",
      "doc_id": "2025_round1",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 문자 배열에 문자를 삽입하는 알고리즘을 구현한 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c char Data[5] = {'B', 'A', 'D', 'E'};\nchar c = 'C';\n```\n- 배열: `Data[0]='B', Data[1]='A', Data[2]='D', Data[3]='E', Data[4]='\u0000'`\n- 삽입할 문자: `c = 'C'`\n\n2. **첫 번째 출력:**\n```c printf(\"%d\n\", Data[3]-Data[1]);\n```\n- `Data[3] = 'E'` (ASCII 69)\n- `Data[1] = 'A'` (ASCII 65)\n- `69 - 65 = 4` → **출력: \"4\"**\n\n3. **삽입 위치 찾기:**\n```c for(i=0; i<5; ++i) {\nif(Data[i] > c) // 'C'보다 큰 값 찾기 break;\n}\n```\n- i=0: 'B' < 'C' → 계속\n- i=1: 'A' < 'C' → 계속\n- i=2: 'D' > 'C' → **break!** (i=2)\n\n4. **문자 삽입 (오른쪽으로 시프트):**\n```c temp = Data[2]; // temp = 'D'\nData[2] = 'C'; // 삽입 i = 3;\n\n// 나머지 원소들을 오른쪽으로 한 칸씩 이동 for(; i<5; ++i) {\ntemp2 = Data[i];\nData[i] = temp;\ntemp = temp2;\n}\n```\n- i=3: Data[3]='E'를 temp2에 저장 → Data[3]='D', temp='E'\n- i=4: Data[4]='\u0000'를 temp2에 저장 → Data[4]='E', temp='\u0000'\n- 최종 배열: `{'B', 'A', 'C', 'D', 'E'}`\n\n5. **최종 출력:**\n```c for(i=0; i<5; i++)\nprintf(\"%c\", Data[i]);\n```\n- **출력: \"BACDE\"**답:** \"4 BACDE\"",
      "explanation_preview": "이 C언어 코드는 문자 배열에 문자를 삽입하는 알고리즘을 구현한 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c char Data[5] = {'B', 'A', 'D', 'E'};\nchar c = 'C';\n```\n- 배열: `Data[0]='B', Data[1]='A', Data[2]='D', Data[3]='E', Data[4]=",
      "image_refs": [
        "images/2025_round1/Q010.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nchar Data[5] = {'B', 'A', 'D', 'E'};\nchar c;\nint main(){\n    int i, temp, temp2;\n    c = 'C';\n    printf(\"%d\\n\", Data[3]-Data[1]);\n    for(i=0;i<5;++i){\n        if(Data[i]>c)\n            break;\n    }\n    temp = Data[i];\n    Data[i] = c;\n    i++;\n    for(;i<5;++i){\n        temp2 = Data[i];\n        Data[i] = temp;\n        temp = temp2;\n    }\n    for(i=0;i<5;i++){\n        printf(\"%c\", Data[i]);\n    }\n}",
          "line_numbers": [
            1,
            23
          ],
          "file": "data/codes/2025_round1/Q010_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "4",
          "BACDE"
        ],
        "raw_text": "4 BACDE"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 970
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q011",
      "doc_id": "2025_round1",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 2차원 배열을 동적으로 할당하고 데이터를 배치한 후 합을 계산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **2차원 배열 동적 할당:**\n```c int rows = 3, cols = 3;\nint data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};\n```\n- 3×3 배열을 동적으로 할당합니다.\n- data 배열: {5, 2, 7, 4, 1, 8, 3, 6, 9}\n\n2. **set() 함수 분석:**\n```c void set(int** arr, int* data, int rows, int cols) {\nfor (int i = 0; i < rows * cols; ++i) {\narr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n}\n}\n```\n- i=0: arr[(1/3)%3][1%3] = arr[0][1] = data[0] = 5\n- i=1: arr[(2/3)%3][2%3] = arr[0][2] = data[1] = 2\n- i=2: arr[(3/3)%3][3%3] = arr[1][0] = data[2] = 7\n- i=3: arr[(4/3)%3][4%3] = arr[1][1] = data[3] = 4\n- i=4: arr[(5/3)%3][5%3] = arr[1][2] = data[4] = 1\n- i=5: arr[(6/3)%3][6%3] = arr[2][0] = data[5] = 8\n- i=6: arr[(7/3)%3][7%3] = arr[2][1] = data[6] = 3\n- i=7: arr[(8/3)%3][8%3] = arr[2][2] = data[7] = 6\n- i=8: arr[(9/3)%3][9%3] = arr[0][0] = data[8] = 9\n\n**배열 상태:**\n```\n[9][5][2]\n[7][4][1]\n[8][3][6]\n```\n\n3. **합 계산:**\n```c for (int i = 0; i < rows * cols; i++) {\nsum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n}\n```\n- i가 짝수면 +, 홀수면 - 부호를 적용합니다.\n- i=0: arr[0][0]=9 × 1 = 9\n- i=1: arr[0][1]=5 × (-1) = -5\n- i=2: arr[0][2]=2 × 1 = 2\n- i=3: arr[1][0]=7 × (-1) = -7\n- i=4: arr[1][1]=4 × 1 = 4\n- i=5: arr[1][2]=1 × (-1) = -1\n- i=6: arr[2][0]=8 × 1 = 8\n- i=7: arr[2][1]=3 × (-1) = -3\n- i=8: arr[2][2]=6 × 1 = 6\n\n**합:** 9 - 5 + 2 - 7 + 4 - 1 + 8 - 3 + 6 = **13**답:** 13",
      "explanation_preview": "이 C언어 코드는 2차원 배열을 동적으로 할당하고 데이터를 배치한 후 합을 계산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **2차원 배열 동적 할당:**\n```c int rows = 3, cols = 3;\nint data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};\n```\n- 3×3 배열을 동적으로 할당합니다.\n- data 배열: {",
      "image_refs": [
        "images/2025_round1/Q011.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#include <stdlib.h>\nvoid set(int** arr, int* data, int rows, int cols) {\n    for (int i = 0; i < rows * cols; ++i) {\n        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n    }\n}\nint main() {\n    int rows = 3, cols = 3, sum = 0;\n    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}; \n    int** arr;\n    arr = (int**) malloc(sizeof(int*) * rows);\n    for (int i = 0; i < cols; i++) {\n        arr[i] = (int*) malloc(sizeof(int) * cols);\n    }\n    set(arr, data, rows, cols);\n    for (int i = 0; i < rows * cols; i++) {\n        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n    }\n    for(int i=0; i<rows; i++) {\n        free(arr[i]);\n    }\n    free(arr);\n    printf(\"%d\", sum);\n}",
          "line_numbers": [
            1,
            25
          ],
          "file": "data/codes/2025_round1/Q011_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "13"
        ],
        "raw_text": "13"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 과다",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1385
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q013",
      "doc_id": "2025_round1",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 문제는 **Java 상속, 정적 변수, 메서드 오버라이딩, 생성자 호출 순서**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nnew Child();\nSystem.out.println(Parent.total);\n\nclass Parent {\n    static int total = 0;  // 정적 변수 (클래스 변수)\n    int v = 1;             // 인스턴스 변수\n    public Parent() {\n        total += (++v);    // v를 1 증가시킨 후 total에 더함\n        show();            // 메서드 호출\n    }\n    public void show() {\n        total += total;    // total을 2배로 만듦\n    }\n}\n\nclass Child extends Parent {\n    int v = 10;            // 필드 숨김 (Parent의 v와 별개)\n    public Child() {\n        v += 2;            // Child의 v를 12로 만듦\n        total += v++;      // total에 v(12)를 더하고 v를 13으로 증가\n        show();            // 오버라이딩된 메서드 호출\n    }\n    @Override\n    public void show() {\n        total += total * 2; // total을 3배로 만듦 (total + total*2)\n    }\n}\n```\n\n**실행 과정:**\n\n**핵심 개념:**\n- Java에서 메서드 오버라이딩은 **객체의 실제 타입**에 따라 결정됩니다.\n- 부모 생성자에서 오버라이딩된 메서드를 호출하면, **자식 클래스의 메서드가 호출**됩니다.\n\n1. **`new Child()` 호출:**\n   - 자식 클래스 생성자는 부모 클래스 생성자를 먼저 호출합니다.\n   - **`Parent()` 생성자 실행:**\n     - `total = 0` (초기값)\n     - `++v` → Parent의 `v`가 1에서 2로 증가\n     - `total += 2` → `total = 2`\n     - `show()` 호출 → **Child의 오버라이딩된 `show()` 메서드 실행** (실제 객체가 Child이므로)\n       - `total += total * 2` → `total = 2 + 2*2 = 2 + 4 = 6`\n     - **현재: `total = 6`**\n\n2. **`Child()` 생성자 실행:**\n   - `v += 2` → Child의 `v`가 10에서 12로 증가 (Parent의 v와 별개)\n   - `total += v++` → `total += 12`, 그 다음 `v = 13`\n     - `total = 6 + 12 = 18`\n   - `show()` 호출 → Child의 `show()` 메서드 실행\n     - `total += total * 2` → `total = 18 + 18*2 = 18 + 36 = 54`\n     - **현재: `total = 54`**\n\n**최종 출력:**\n- `System.out.println(Parent.total)` → **출력: 54**\n\n**정리:**\n- Parent 생성자에서 `show()` 호출 시, 실제 객체가 `Child`이므로 Child의 `show()`가 호출됩니다.\n- 이는 Java의 **동적 메서드 디스패치(Dynamic Method Dispatch)** 때문입니다.\n\n**답:** \"54\"",
      "explanation_preview": "이 문제는 **Java 상속, 정적 변수, 메서드 오버라이딩, 생성자 호출 순서**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nnew Child();\nSystem.out.println(Parent.total);\n\nclass Parent {\n    static int total = 0;  // 정적 변수 (클래스 변수)\n    int v =",
      "image_refs": [
        "images/2025_round1/Q013.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main {\n    public static void main(String[] args) {\n        new Child();\n        System.out.println(Parent.total);\n    }\n}\nclass Parent {\n    static int total = 0;\n    int v = 1;\n    public Parent() {\n        total += (++v);\n        show();    \n    }\n    public void show() {\n        total += total;\n    }\n}\nclass Child extends Parent {\n    int v = 10;\n    public Child() {\n        v += 2;\n        total += v++;\n        show();\n    }\n    @Override\n    public void show() {\n        total += total * 2;\n    }\n}",
          "line_numbers": [
            1,
            29
          ],
          "file": "data/codes/2025_round1/Q013_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "54"
        ],
        "raw_text": "54"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 과다",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1779
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q016",
      "doc_id": "2025_round1",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 문제는 **Java 재귀 함수와 분할 정복**을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nint[] data = {3, 5, 8, 12, 17};\nSystem.out.println(func(data, 0, data.length - 1));\n\nstatic int func(int[] a, int st, int end) {\n    if (st >= end) return 0;\n    int mid = (st + end) / 2;\n    return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n}\n```\n\n**재귀 호출 추적:**\n\n**func(data, 0, 4) 호출:**\n- `st = 0`, `end = 4`\n- `mid = (0 + 4) / 2 = 2`\n- `a[2] = 8`\n- `return 8 + Math.max(func(data, 0, 2), func(data, 3, 4))`\n\n**왼쪽 재귀: func(data, 0, 2)**\n- `st = 0`, `end = 2`\n- `mid = 1`\n- `a[1] = 5`\n- `return 5 + Math.max(func(data, 0, 1), func(data, 2, 2))`\n\n  - **func(data, 0, 1):**\n    - `st = 0`, `end = 1`\n    - `mid = 0`\n    - `a[0] = 3`\n    - `return 3 + Math.max(func(data, 0, 0), func(data, 1, 1))`\n      - `func(data, 0, 0)`: `st >= end` → **0 반환**\n      - `func(data, 1, 1)`: `st >= end` → **0 반환**\n    - `return 3 + Math.max(0, 0) = 3`\n\n  - **func(data, 2, 2):**\n    - `st >= end` → **0 반환**\n\n  - `return 5 + Math.max(3, 0) = 5 + 3 = 8`\n\n**오른쪽 재귀: func(data, 3, 4)**\n- `st = 3`, `end = 4`\n- `mid = 3`\n- `a[3] = 12`\n- `return 12 + Math.max(func(data, 3, 3), func(data, 4, 4))`\n  - `func(data, 3, 3)`: `st >= end` → **0 반환**\n  - `func(data, 4, 4)`: `st >= end` → **0 반환**\n- `return 12 + Math.max(0, 0) = 12`\n\n**최종 계산:**\n- `func(data, 0, 4) = 8 + Math.max(8, 12) = 8 + 12 = 20`\n\n**답:** \"20\"",
      "explanation_preview": "이 문제는 **Java 재귀 함수와 분할 정복**을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nint[] data = {3, 5, 8, 12, 17};\nSystem.out.println(func(data, 0, data.length - 1));\n\nstatic int func(int[] a, int st, int end) {\n    if (s",
      "image_refs": [
        "images/2025_round1/Q016.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main {\n    public static void main(String[] args) {\n        int[] data = {3, 5, 8, 12, 17};\n        System.out.println(func(data, 0, data.length - 1));\n    }\n    static int func(int[] a, int st, int end) {\n        if (st >= end) return 0;\n        int mid = (st + end) / 2;\n        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n    } \n}",
          "line_numbers": [
            1,
            11
          ],
          "file": "data/codes/2025_round1/Q016_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "20"
        ],
        "raw_text": "20"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 과다",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1366
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q017",
      "doc_id": "2025_round1",
      "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Python 코드는 이진 트리를 구성하고 홀수 레벨의 노드 값만 합산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **트리 구성:**\n```python\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\n```\n- `tree()` 함수는 리스트를 이진 트리로 변환합니다.\n- `nodes[(i - 1) // 2].children.append(nodes[i])`: 부모 인덱스 계산\n- i=1: 부모=(1-1)//2=0 → nodes[0].children에 nodes[1] 추가\n- i=2: 부모=(2-1)//2=0 → nodes[0].children에 nodes[2] 추가\n- i=3: 부모=(3-1)//2=1 → nodes[1].children에 nodes[3] 추가\n- i=4: 부모=(4-1)//2=1 → nodes[1].children에 nodes[4] 추가\n- i=5: 부모=(5-1)//2=2 → nodes[2].children에 nodes[5] 추가\n- i=6: 부모=(6-1)//2=2 → nodes[2].children에 nodes[6] 추가\n\n**트리 구조:**\n```\n       3 (level 0)\n      / \\\n     5   8 (level 1)\n    / \\ / \\\n  12 15 18 21 (level 2)\n```\n\n2. **calc() 함수 실행:**\n```python\ndef calc(node, level=0):\n    if node is None:\n        return 0\n    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\n```\n- **핵심:** `level % 2 == 1`일 때만 노드 값을 더합니다.\n- level이 홀수(1, 3, 5...)일 때만 노드 값을 합산\n- level이 짝수(0, 2, 4...)일 때는 0을 더합니다.\n\n**계산 과정:**\n- **level 0 (루트):** 노드 3 → level % 2 == 0 → **0 추가**\n- **level 1:** 노드 5, 8 → level % 2 == 1 → **5 + 8 = 13 추가**\n- **level 2:** 노드 12, 15, 18, 21 → level % 2 == 0 → **0 추가**\n\n**최종 결과:** 0 + 13 + 0 = **13**\n\n**답:** 13",
      "explanation_preview": "이미지의 Python 코드는 이진 트리를 구성하고 홀수 레벨의 노드 값만 합산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **트리 구성:**\n```python\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\n```\n- `tree()` 함수는 리스트를 이진 트리로 변환합니다.\n- `nodes[(i - 1) // 2]",
      "image_refs": [
        "images/2025_round1/Q017.png"
      ],
      "code_blocks": [
        {
          "language": "python",
          "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\ndef tree(li):\n    nodes = [Node(i) for i in li]\n    for i in range(1, len(li)):\n        nodes[(i - 1) // 2].children.append(nodes[i])\n    return nodes[0]\ndef calc(node, level=0):\n    if node is None:\n        return 0\n    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\nprint(calc(root))",
          "line_numbers": [
            1,
            16
          ],
          "file": "data/codes/2025_round1/Q017_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "13"
        ],
        "raw_text": "13"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1211
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q018",
      "doc_id": "2025_round1",
      "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.\n19.다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.\n19.다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 연결 리스트에 노드를 삽입하고 특정 값을 가진 노드를 맨 앞으로 이동시키는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **insert() 함수로 리스트 생성:**\n```c for (int i = 1; i <= 5; i++)\nhead = insert(head, i);\n```\n- `insert()`는 새 노드를 리스트의 맨 앞에 추가합니다 (역순으로 저장됨).\n- i=1: head = 1 → NULL\n- i=2: head = 2 → 1 → NULL\n- i=3: head = 3 → 2 → 1 → NULL\n- i=4: head = 4 → 3 → 2 → 1 → NULL\n- i=5: head = 5 → 4 → 3 → 2 → 1 → NULL\n\n**최종 리스트:** 5 → 4 → 3 → 2 → 1 → NULL\n\n2. **reconnect() 함수 실행:**\n```c head = reconnect(head, 3);\n```\n- `reconnect()`는 값이 3인 노드를 찾아서 리스트의 맨 앞으로 이동시킵니다.\n- 현재 리스트: 5 → 4 → 3 → 2 → 1 → NULL\n- 값 3인 노드를 찾고, 그 노드를 제거한 후 맨 앞에 다시 삽입합니다.\n\n**reconnect 과정:**\n- curr가 3인 노드를 찾음\n- prev(4)의 next를 curr(3)의 next(2)로 연결\n- curr(3)의 next를 현재 head(5)로 설정\n- head를 curr(3)으로 변경\n\n**결과 리스트:** 3 → 5 → 4 → 2 → 1 → NULL\n\n3. **출력:**\n```c for (curr = head; curr != NULL; curr = curr->next)\nprintf(\"%d\", curr->value);\n```\n- 순서대로: 3, 5, 4, 2, 1\n- **출력: \"35421\"**답:** \"35421\"",
      "explanation_preview": "이 C언어 코드는 연결 리스트에 노드를 삽입하고 특정 값을 가진 노드를 맨 앞으로 이동시키는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **insert() 함수로 리스트 생성:**\n```c for (int i = 1; i <= 5; i++)\nhead = insert(head, i);\n```\n- `insert()`는 새 노드를 리스트의 맨 앞에 추가합니다",
      "image_refs": [
        "images/2025_round1/Q018.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>   \n#include <stdlib.h>  \ntypedef struct Data {\n    int value;\n    struct Data *next;\n} Data;\nData* insert(Data* head, int value) {\n    Data* new_node = (Data*)malloc(sizeof(Data));\n    new_node->value = value;\n    new_node->next = head;\n    return new_node;\n}\nData* reconnect(Data* head, int value) {\n    if (head == NULL || head->value == value) return head;\n    Data *prev = NULL, *curr = head;\n    while (curr != NULL && curr->value != value) {\n        prev = curr;\n        curr = curr->next;\n    }\n    if (curr != NULL && prev != NULL) {\n        prev->next = curr->next;\n        curr->next = head;\n        head = curr;\n    }\n    return head;\n}\nint main() {\n    Data *head = NULL, *curr;\n    for (int i = 1; i <= 5; i++)\n        head = insert(head, i);\n    head = reconnect(head, 3);\n    for (curr = head; curr != NULL; curr = curr->next)\n        printf(\"%d\", curr->value);\n    return 0; \n}",
          "line_numbers": [
            1,
            35
          ],
          "file": "data/codes/2025_round1/Q018_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "35421"
        ],
        "raw_text": "35421"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 912
      }
    },
    {
      "file": "items_2025_round1.jsonl",
      "q_no": "Q020",
      "doc_id": "2025_round1",
      "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 메서드 오버로딩과 재귀 함수를 결합한 문제입니다.\n\n**코드 분석:**\n\n```java\npublic static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n}\n\nstatic int calc(int value) {\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 2);\n}\n\nstatic int calc(String str) {\n    int value = Integer.valueOf(str);\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 3);\n}\n```\n\n**핵심 개념:**\n\n1. **메서드 오버로딩:**\n   - `calc(int value)`: 파라미터가 int형\n   - `calc(String str)`: 파라미터가 String형\n   - 같은 이름이지만 파라미터 타입이 다른 두 메서드\n\n2. **메서드 호출 과정:**\n   - `calc(\"5\")` → String 타입이므로 `calc(String str)` 호출\n   - 내부에서 `calc(int value)` 호출 가능\n\n**실행 과정:**\n\n1. **`calc(\"5\")` 호출:** (String 버전)\n   - `value = Integer.valueOf(\"5\") = 5`\n   - `value > 1`이므로 재귀 호출\n   - `return calc(5-1) + calc(5-3)` = `calc(4) + calc(2)`\n   - **여기서 int 타입으로 호출되므로 `calc(int)` 버전 실행**\n\n2. **`calc(4)` 계산:** (int 버전 - 피보나치 패턴)\n   - `return calc(3) + calc(2)`\n   \n   **calc(3):**\n   - `return calc(2) + calc(1)`\n   - calc(2): `return calc(1) + calc(0)` = 1 + 0 = **1**\n   - calc(1): `return 1`\n   - calc(3) = 1 + 1 = **2**\n   \n   **calc(2):**\n   - `return calc(1) + calc(0)` = 1 + 0 = **1**\n   \n   **calc(4) = 2 + 1 = 3**\n\n3. **`calc(2)` 계산:** (int 버전)\n   - `return calc(1) + calc(0)` = 1 + 0 = **1**\n\n4. **최종 결과:**\n   - `calc(4) + calc(2)` = 3 + 1 = **4**\n\n**정리:**\n- String 버전: `calc(value - 1) + calc(value - 3)` (간격이 1과 3)\n- int 버전: `calc(value - 1) + calc(value - 2)` (피보나치, 간격이 1과 2)\n- 메서드 오버로딩으로 서로 다른 재귀 패턴 사용\n\n**답:** 4",
      "explanation_preview": "이미지의 Java 코드는 메서드 오버로딩과 재귀 함수를 결합한 문제입니다.\n\n**코드 분석:**\n\n```java\npublic static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n}\n\nstatic int calc(int value) {\n    if (value <= 1) return va",
      "image_refs": [
        "images/2025_round1/Q020.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n  }\n}\n\nstatic int calc(int value) {\n  if (value <= 1) return value;\n  return calc(value - 1) + calc(value - 2);\n}\n\nstatic int calc(String str) {\n  int value = Integer.valueOf(str);\n  if (value <= 1) return value;\n  return calc(value - 1) + calc(value - 3);\n}",
          "line_numbers": [
            1,
            16
          ],
          "file": "data/codes/2025_round1/Q020_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "4"
        ],
        "raw_text": "4"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1508
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q005",
      "doc_id": "2025_round2",
      "question_text": "다음은 Java의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 배열 참조 전달과 String 파라미터 전달의 차이를 보여주는 문제입니다.\n\n**코드 분석:**\n\n```java\nString data[] = { \"A\" };\nString s = \"B\";\nchange(data, s);\nSystem.out.print(data[0] + s);\n\npublic static void change(String[] data, String s) {\n    data[0] = s;\n    s = \"Z\";\n}\n```\n\n**핵심 개념:**\n- Java는 **참조 타입(reference type)**과 **기본 타입(primitive type)**을 다르게 처리합니다.\n- 배열은 참조 타입이므로, 배열 참조가 전달되면 같은 배열 객체를 가리킵니다.\n- String도 참조 타입이지만, 메서드 내부에서 파라미터에 새로운 값을 할당하면 원본 변수에는 영향이 없습니다.\n\n**실행 과정:**\n\n1. **초기 상태:**\n   - `data[] = { \"A\" }` (배열 참조)\n   - `s = \"B\"` (String 참조)\n\n2. **`change(data, s)` 호출:**\n   - `data` 파라미터: 배열 참조가 전달됨 (같은 배열 객체를 가리킴)\n   - `s` 파라미터: String 참조 \"B\"가 전달됨\n\n3. **메서드 내부 실행:**\n   - `data[0] = s;` → `data[0] = \"B\"` (배열의 첫 번째 요소가 \"B\"로 변경됨)\n     - **원본 배열이 변경됨** (참조 타입이므로)\n   - `s = \"Z\";` → 메서드 내부의 파라미터 `s`만 \"Z\"로 변경됨\n     - **원본 변수 `s`는 변경되지 않음** (새로운 참조를 할당했을 뿐)\n\n4. **메서드 종료 후:**\n   - `data[0] = \"B\"` (메서드에서 변경된 값 유지)\n   - `s = \"B\"` (원본 변수는 변경되지 않음)\n\n5. **출력:**\n   - `data[0] + s = \"B\" + \"B\" = \"BB\"`\n\n**정리:**\n- 배열은 참조 타입이므로 메서드에서 배열 요소를 수정하면 원본 배열이 변경됩니다.\n- String도 참조 타입이지만, 메서드 내부에서 파라미터에 새로운 값을 할당하면 그 값은 메서드 내부에서만 유효하고 원본 변수에는 영향이 없습니다.\n\n**답:** \"BB\"",
      "explanation_preview": "이미지의 Java 코드는 배열 참조 전달과 String 파라미터 전달의 차이를 보여주는 문제입니다.\n\n**코드 분석:**\n\n```java\nString data[] = { \"A\" };\nString s = \"B\";\nchange(data, s);\nSystem.out.print(data[0] + s);\n\npublic static void change(String[",
      "image_refs": [
        "images/2025_round2/Q005.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main {\n    public static void change(String[] data, String s){\n        data[0] = s;\n        s = \"Z\";\n    }\n    public static void main(String[] args) {\n        String data[] = { \"A\" };\n        String s = \"B\";\n        change(data, s);\n        System.out.print(data[0] + s);\n    }\n}",
          "line_numbers": [
            1,
            12
          ],
          "file": "data/codes/2025_round2/Q005_code.txt"
        }
      ],
      "table_refs": [
        {
          "id": "table1",
          "json": "data/tables/2025_round2/Q005_table1.json",
          "rows": 18,
          "cols": 1
        }
      ],
      "answer": {
        "keys": [
          "BB"
        ],
        "raw_text": "BB"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1143
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q009",
      "doc_id": "2025_round2",
      "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이미지의 Java 코드는 람다 표현식으로 함수형 인터페이스를 구현하고 예외 처리하는 문제입니다.\n\n**코드 분석:**\n\n```java\nstatic interface F {\n    int apply(int x) throws Exception;\n}\n\npublic static int run(F f) {\n    try {\n        return f.apply(3);\n    } catch (Exception e) {\n        return 7;\n    }\n}\n\nF f = (x) -> {\n    if (x > 2) {\n        throw new Exception();\n    }\n    return x * 2;\n};\n\nSystem.out.print(run(f) + run((int n) -> n + 9));\n```\n\n**핵심 개념:**\n- `F` 인터페이스는 `apply(int x)` 메서드를 정의하며, 예외를 던질 수 있습니다.\n- `run` 메서드는 `F` 타입의 함수를 받아 실행하고, 예외가 발생하면 7을 반환합니다.\n- 람다 표현식 `(x) -> { ... }`는 함수형 인터페이스 `F`를 구현합니다.\n\n**실행 과정:**\n\n1. **`F f` 람다 함수 정의:**\n   - `f = (x) -> { if (x > 2) throw new Exception(); return x * 2; }`\n   - x가 2보다 크면 예외를 발생시키고, 그렇지 않으면 `x * 2`를 반환합니다.\n\n2. **첫 번째 `run(f)` 호출:**\n   - `run` 메서드 내부에서 `f.apply(3)` 실행\n   - `x = 3`이므로 `x > 2` 조건이 **참**입니다.\n   - `throw new Exception()`이 실행되어 예외가 발생합니다.\n   - `run` 메서드의 `catch (Exception e)` 블록이 예외를 잡아서 **7을 반환**합니다.\n   - **결과: `run(f) = 7`**\n\n3. **두 번째 `run((int n) -> n + 9)` 호출:**\n   - 새로운 람다 함수 `(int n) -> n + 9`가 전달됩니다.\n   - 이 함수는 예외를 발생시키지 않는 일반적인 함수입니다.\n   - `run` 메서드 내부에서 `f.apply(3)` 실행 (여기서 `f`는 전달된 람다 함수)\n   - `n = 3`이므로 `3 + 9 = 12`를 반환합니다.\n   - 예외가 발생하지 않으므로 `try` 블록이 정상적으로 실행됩니다.\n   - **결과: `run((int n) -> n + 9) = 12`**\n\n4. **최종 출력:**\n   - `run(f) + run((int n) -> n + 9) = 7 + 12 = 19`\n   - `System.out.print(19)` 실행\n\n**정리:**\n- 람다 표현식에서 조건에 따라 예외를 발생시킬 수 있습니다.\n- `run` 메서드는 try-catch 블록으로 예외를 처리하고, 예외 발생 시 7을 반환합니다.\n- 두 개의 서로 다른 람다 함수가 각각 다른 결과를 반환합니다.\n\n**답:** 19",
      "explanation_preview": "이미지의 Java 코드는 람다 표현식으로 함수형 인터페이스를 구현하고 예외 처리하는 문제입니다.\n\n**코드 분석:**\n\n```java\nstatic interface F {\n    int apply(int x) throws Exception;\n}\n\npublic static int run(F f) {\n    try {\n        return f.apply(",
      "image_refs": [
        "images/2025_round2/Q009.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main {\n    static interface F {\n        int apply(int x) throws Exception;\n    }\n    public static int run(F f) {\n        try {\n            return f.apply(3);\n        } catch (Exception e) {\n            return 7;\n        }\n    }\n    public static void main(String[] args) {\n        F f = (x) -> {\n            if (x > 2) {\n                throw new Exception();\n            }\n            return x * 2;\n        };\n        System.out.print(run(f) + run((int n) -> n + 9));\n    }\n}",
          "line_numbers": [
            1,
            21
          ],
          "file": "data/codes/2025_round2/Q009_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "19"
        ],
        "raw_text": "19"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1506
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q010",
      "doc_id": "2025_round2",
      "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 문제는 **Java 메서드 오버라이딩, 오버로딩, 정적 메서드**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nParent ref = new Child();\nSystem.out.println(ref.x(2) + ref.id());\n\nclass Parent {\n    public int x(int i) { return i + 2; }        // 인스턴스 메서드\n    public static String id() { return \"P\"; }   // 정적 메서드\n}\n\nclass Child extends Parent {\n    public int x(int i) { return i + 3; }        // 오버라이딩\n    public String x(String s) { return s + \"R\"; } // 오버로딩\n    public static String id() { return \"C\"; }   // 정적 메서드 숨김\n}\n```\n\n**핵심 개념:**\n\n1. **메서드 오버라이딩 (Method Overriding):**\n   - `Parent.x(int)`와 `Child.x(int)`는 오버라이딩 관계입니다.\n   - **실제 객체 타입**에 따라 메서드가 호출됩니다.\n   - `ref`는 `Child` 객체이므로 `Child.x(int)`가 호출됩니다.\n\n2. **정적 메서드 (Static Method):**\n   - `Parent.id()`와 `Child.id()`는 정적 메서드입니다.\n   - 정적 메서드는 **참조 변수의 타입**에 따라 호출됩니다 (오버라이딩되지 않음).\n   - `ref`의 타입이 `Parent`이므로 `Parent.id()`가 호출됩니다.\n\n**실행 과정:**\n\n1. **`ref.x(2)` 호출:**\n   - `ref`의 실제 타입은 `Child`이므로 `Child.x(int)` 메서드가 호출됩니다.\n   - `Child.x(2) = 2 + 3 = 5`\n   - 반환값: **5**\n\n2. **`ref.id()` 호출:**\n   - `ref`의 선언 타입은 `Parent`이므로 `Parent.id()` 정적 메서드가 호출됩니다.\n   - 정적 메서드는 오버라이딩되지 않고, 참조 변수의 타입에 따라 결정됩니다.\n   - 반환값: **\"P\"**\n\n3. **출력:**\n   - `5 + \"P\" = \"5P\"`\n\n**정리:**\n- 인스턴스 메서드는 **실제 객체 타입**에 따라 호출됩니다 (동적 바인딩).\n- 정적 메서드는 **참조 변수의 타입**에 따라 호출됩니다 (정적 바인딩).\n\n**답:** \"5P\"",
      "explanation_preview": "이 문제는 **Java 메서드 오버라이딩, 오버로딩, 정적 메서드**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nParent ref = new Child();\nSystem.out.println(ref.x(2) + ref.id());\n\nclass Parent {\n    public int x(int i) { return i + 2; }   ",
      "image_refs": [
        "images/2025_round2/Q010.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main{\n    public static class Parent {\n        public int x(int i) { return i + 2; }\n        public static String id() { return \"P\";}\n    }\n    public static class Child extends Parent {\n        public int x(int i) { return i + 3; }\n        public String x(String s) { return s + \"R\"; }\n        public static String id() { return \"C\"; }\n    }\n    public static void main(String[] args) {\n        Parent ref = new Child();\n        System.out.println(ref.x(2) + ref.id());\n    }\n}",
          "line_numbers": [
            1,
            15
          ],
          "file": "data/codes/2025_round2/Q010_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "5P"
        ],
        "raw_text": "5P"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 과다",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1282
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q012",
      "doc_id": "2025_round2",
      "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 원형 큐(Circular Queue) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c Queue q = {{0}, 0, 0};\n```\n- 큐 구조체를 초기화: 배열 `a[] = {0, 0, 0}`, `front = 0`, `rear = 0`\n\n2. **`enq(&q, 1)` 실행:**\n- `q->a[0] = 1` → 배열[0]에 1 저장\n- `q->rear = (0 + 1) % 3 = 1` → rear를 1로 이동\n- 상태: `a = {1, 0, 0}`, `front = 0`, `rear = 1`\n\n3. **`enq(&q, 2)` 실행:**\n- `q->a[1] = 2` → 배열[1]에 2 저장\n- `q->rear = (1 + 1) % 3 = 2` → rear를 2로 이동\n- 상태: `a = {1, 2, 0}`, `front = 0`, `rear = 2`\n\n4. **`deq(&q)` 실행:**\n- `val = q->a[0] = 1` → 배열[0]의 값 1을 가져옴\n- `q->front = (0 + 1) % 3 = 1` → front를 1로 이동\n- 상태: `a = {1, 2, 0}`, `front = 1`, `rear = 2`\n\n5. **`enq(&q, 3)` 실행:**\n- `q->a[2] = 3` → 배열[2]에 3 저장\n- `q->rear = (2 + 1) % 3 = 0` → rear를 0으로 이동 (원형 큐 특성)\n- 상태: `a = {1, 2, 3}`, `front = 1`, `rear = 0`\n\n6. **`first = deq(&q)` 실행:**\n- `val = q->a[1] = 2` → front 위치의 값 2를 가져옴\n- `q->front = (1 + 1) % 3 = 2` → front를 2로 이동\n- `first = 2`\n\n7. **`second = deq(&q)` 실행:**\n- `val = q->a[2] = 3` → front 위치의 값 3을 가져옴\n- `q->front = (2 + 1) % 3 = 0` → front를 0으로 이동\n- `second = 3`\n\n**최종 출력:** \"2 그리고 3\"\n\n**핵심 포인트:**\n- 원형 큐는 배열의 마지막 인덱스 다음에 처음 인덱스로 돌아가는 구조입니다.\n- `% SIZE` 연산을 통해 원형 구조를 구현합니다.\n- front는 데이터를 꺼내는 위치, rear는 데이터를 넣는 위치입니다.",
      "explanation_preview": "이 C언어 코드는 원형 큐(Circular Queue) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c Queue q = {{0}, 0, 0};\n```\n- 큐 구조체를 초기화: 배열 `a[] = {0, 0, 0}`, `front = 0`, `rear = 0`\n\n2. **`enq(&q, 1)` 실행:**",
      "image_refs": [
        "images/2025_round2/Q012.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#define SIZE 3\ntypedef struct {\n    int a[SIZE];\n    int front;\n    int rear;\n} Queue;\nvoid enq(Queue* q, int val){\n    q->a[q->rear] = val; \n    q->rear = (q->rear + 1) % SIZE;\n}\nint deq(Queue* q) {\n    int val = q->a[q->front];\n    q->front = (q->front + 1) % SIZE;\n    return val;\n}\nint main() {\n    Queue q = {{0}, 0, 0};\n    enq(&q,1); enq(&q,2); deq(&q); enq(&q, 3);\n    int first = deq(&q);\n    int second = deq(&q);\n    printf(\"%d 그리고 %d\", first, second);\n    return 0;\n}",
          "line_numbers": [
            1,
            24
          ],
          "file": "data/codes/2025_round2/Q012_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "2 그리고 3"
        ],
        "raw_text": "2 그리고 3"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1202
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q014",
      "doc_id": "2025_round2",
      "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 포인터의 포인터(이중 포인터)와 구조체 배열을 다루는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n```\n- 구조체 배열 `a`를 초기화: `a[0] = {1, 2}`, `a[1] = {3, 4}`, `a[2] = {5, 6}`\n\n2. **포인터 설정:**\n```c struct dat* ptr = a; // ptr은 배열 a의 첫 번째 요소를 가리킴 struct dat** pptr = &ptr; // pptr은 ptr 변수의 주소를 가리킴 (이중 포인터)\n```\n\n3. **중요한 연산:**\n```c\n(*pptr)[1] = (*pptr)[2];\n```\n- `*pptr`은 `ptr`을 의미합니다 (pptr이 가리키는 값이 ptr)\n- `(*pptr)[1]`은 `ptr[1]` 즉 `a[1]`을 의미합니다\n- `(*pptr)[2]`는 `ptr[2]` 즉 `a[2]`를 의미합니다\n- 따라서 `a[1] = a[2]`가 실행됩니다\n- 결과: `a[1] = {5, 6}` (a[2]의 값이 a[1]에 복사됨)\n\n4. **출력:**\n```c printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n```\n- `a[1].x = 5`, `a[1].y = 6`\n- 출력: \"5 그리고 6\"\n\n**핵심 포인트:**\n- 이중 포인터 `**pptr`은 포인터를 가리키는 포인터입니다.\n- `(*pptr)[1]`은 `ptr[1]`과 동일하며, 이는 `a[1]`을 의미합니다.\n- 구조체 배열의 요소는 구조체 전체가 복사됩니다.\n\n**답:** \"5 그리고 6\"",
      "explanation_preview": "이 C언어 코드는 포인터의 포인터(이중 포인터)와 구조체 배열을 다루는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n```\n- 구조체 배열 `a`를 초기화: `a[0] = {1, 2}`, `a[1] = {3, 4}`, `a[2] = {5, 6}`\n\n2",
      "image_refs": [
        "images/2025_round2/Q014.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\nstruct dat {\n    int x;\n    int y;\n};\nint main() {\n    struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n    struct dat* ptr = a;\n    struct dat** pptr = &ptr;\n    (*pptr)[1] = (*pptr)[2];\n    printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n    return 0;\n}",
          "line_numbers": [
            1,
            13
          ],
          "file": "data/codes/2025_round2/Q014_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "5 그리고 6"
        ],
        "raw_text": "5 그리고 6"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 826
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q015",
      "doc_id": "2025_round2",
      "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 문제는 **Java 객체 배열과 참조**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nBO a = new BO(1);  // a.v = 1\nBO b = new BO(2);  // b.v = 2\nBO c = new BO(3);  // c.v = 3\nBO[] arr = {a, b, c};  // arr[0] = a, arr[1] = b, arr[2] = c\nBO t = arr[0];         // t = a (참조 복사)\narr[0] = arr[2];      // arr[0] = c (이제 arr[0]은 c를 가리킴)\narr[2] = t;           // arr[2] = a (이제 arr[2]는 a를 가리킴)\narr[1].v = arr[0].v; // arr[1].v = arr[0].v = c.v = 3\nSystem.out.println(a.v + \"a\" + b.v + \"b\" + c.v);\n```\n\n**핵심 개념:**\n- Java에서 객체 배열은 **참조 배열**입니다.\n- 배열 요소는 객체를 참조하는 포인터입니다.\n- 배열 요소를 교환해도 원본 객체(`a`, `b`, `c`)는 변경되지 않습니다.\n- 하지만 배열 요소를 통해 객체의 필드를 수정하면 원본 객체가 변경됩니다.\n\n**실행 과정:**\n\n1. **초기 상태:**\n   - `a.v = 1`, `b.v = 2`, `c.v = 3`\n   - `arr = {a, b, c}` → `arr[0] = a`, `arr[1] = b`, `arr[2] = c`\n\n2. **`BO t = arr[0];`**\n   - `t = a` (참조 복사)\n\n3. **`arr[0] = arr[2];`**\n   - `arr[0] = c` (이제 `arr[0]`은 `c`를 가리킴)\n   - **원본 객체 `a`는 변경되지 않음** (여전히 `a.v = 1`)\n\n4. **`arr[2] = t;`**\n   - `arr[2] = a` (이제 `arr[2]`는 `a`를 가리킴)\n   - **원본 객체 `c`는 변경되지 않음** (여전히 `c.v = 3`)\n\n5. **`arr[1].v = arr[0].v;`**\n   - `arr[1] = b`이므로 `b.v = arr[0].v`\n   - `arr[0] = c`이므로 `arr[0].v = c.v = 3`\n   - 따라서 `b.v = 3` (원본 객체 `b`의 필드가 변경됨)\n\n6. **최종 상태:**\n   - `a.v = 1` (변경 없음)\n   - `b.v = 3` (변경됨)\n   - `c.v = 3` (변경 없음)\n   - `arr = {c, b, a}` (배열 요소만 재배치됨)\n\n7. **출력:**\n   - `a.v + \"a\" + b.v + \"b\" + c.v = 1 + \"a\" + 3 + \"b\" + 3 = \"1a3b3\"`\n\n**정리:**\n- 배열 요소 교환은 참조만 바꾸므로 원본 객체는 변경되지 않습니다.\n- 배열 요소를 통해 객체의 필드를 수정하면 원본 객체가 변경됩니다.\n\n**답:** \"1a3b3\"",
      "explanation_preview": "이 문제는 **Java 객체 배열과 참조**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nBO a = new BO(1);  // a.v = 1\nBO b = new BO(2);  // b.v = 2\nBO c = new BO(3);  // c.v = 3\nBO[] arr = {a, b, c};  // arr[0] = a, arr[1] = b, a",
      "image_refs": [
        "images/2025_round2/Q015.png"
      ],
      "code_blocks": [
        {
          "language": "java",
          "code": "public class Main{\n    public static class BO {\n        public int v;\n        public BO(int v) {\n            this.v = v;\n        }\n    }\n    public static void main(String[] args) {\n        BO a = new BO(1);\n        BO b = new BO(2);\n        BO c = new BO(3);\n        BO[] arr = {a, b, c};\n        BO t = arr[0];\n        arr[0] = arr[2];\n        arr[2] = t;\n        arr[1].v = arr[0].v;\n        System.out.println(a.v + \"a\" + b.v + \"b\" + c.v);\n    }\n}",
          "line_numbers": [
            1,
            19
          ],
          "file": "data/codes/2025_round2/Q015_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "1a3b3"
        ],
        "raw_text": "1a3b3"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 30,
        "issues": [
          "범용적인 설명 문구 과다",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1477
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q016",
      "doc_id": "2025_round2",
      "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 연결 리스트(Linked List)의 포인터 연결을 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **노드 생성 및 초기화:**\n```c struct node a = {1, NULL};\nstruct node b = {2, NULL};\nstruct node c = {3, NULL};\n```\n- 세 개의 노드 생성: `a.p = 1`, `b.p = 2`, `c.p = 3`, 모두 다음 노드 포인터는 NULL\n\n2. **첫 번째 연결:**\n```c a.n = &b; // a의 다음 노드는 b.n = &c; // b의 다음 노드는 c.n = NULL;\n```\n- 연결: a → b → c → NULL\n\n3. **두 번째 연결 (덮어쓰기):**\n```c.n = &a; // c의 다음 노드를 a로 변경 a.n = &b; // a의 다음 노드는 여전히 b.n = NULL; // b의 다음 노드를 NULL로 변경\n```\n- 최종 연결: `c → a → b → NULL` (c가 a를 가리키고, a가 b를 가리키고, b는 NULL)\n\n4. **출력:**\n```c struct node* head = &c; // head는 c를 가리킴 printf(\"%d\", head->p, head->n->p, head->n->n->p);\n```\n- `head->p` = `c.p` = **3**\n- `head->n->p` = `a.p` = **1** (head->n은 a를 가리킴)\n- `head->n->n->p` = `b.p` = **2** (head->n->n은 b를 가리킴)\n\n**최종 출력:** \"3 1 2\"\n\n**핵심 포인트:**\n- 포인터 할당 순서에 따라 연결 리스트의 구조가 달라집니다.\n- 마지막에 할당한 값이 이전 값을 덮어씁니다.\n- `head` 포인터를 따라가면서 각 노드의 값을 출력합니다.",
      "explanation_preview": "이 C언어 코드는 연결 리스트(Linked List)의 포인터 연결을 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **노드 생성 및 초기화:**\n```c struct node a = {1, NULL};\nstruct node b = {2, NULL};\nstruct node c = {3, NULL};\n```\n- 세 개의 노드 생성: `a.p = 1`",
      "image_refs": [
        "images/2025_round2/q016.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int p;\n    struct node* n;\n};\nint main() {\n    struct node a = {1, NULL};\n    struct node b = {2, NULL};\n    struct node c = {3, NULL};\n    a.n = &b; b.n = &c; c.n = NULL;\n    c.n = &a; a.n = &b; b.n = NULL;\n    struct node* head = &c;\n    printf(\"%d %d %d\", head->p, head->n->p, head->n->n->p);\n    return 0;\n}",
          "line_numbers": [
            1,
            16
          ],
          "file": "data/codes/2025_round2/Q016_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "3 1 2"
        ],
        "raw_text": "3 1 2"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 50,
        "issues": [
          "범용적인 설명 문구 사용",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 906
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q017",
      "doc_id": "2025_round2",
      "question_text": "다음은 Pyhon언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 Pyhon언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 파이썬 코드는 딕셔너리, 집합(set) 생성과 연산을 이해하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **딕셔너리 생성:**\n```python lst = [1, 2, 3]\ndst = {i : i * 2 for i in lst}\n```\n- 딕셔너리 컴프리헨션: `dst = {1: 2, 2: 4, 3: 6}`\n- 키는 리스트의 각 요소, 값은 그 요소의 2배\n\n2. **집합 생성:**\n```python s = set(dst.values())\n```\n- 딕셔너리의 값들로 집합 생성: `s = {2, 4, 6}`\n\n3. **리스트 수정:**\n```python lst[0] = 99\n```\n- `lst = [99, 2, 3]`으로 변경\n- **주의:** 딕셔너리는 이미 생성되었으므로 `dst`는 변경되지 않습니다!\n- `dst`는 여전히 `{1: 2, 2: 4, 3: 6}`입니다.\n\n4. **딕셔너리 값 수정:**\n```python dst[2] = 7\n```\n- 키 2의 값을 7로 변경: `dst = {1: 2, 2: 7, 3: 6}`\n\n5. **집합에 요소 추가:**\n```python s.add(99)\n```\n- 집합 s에 99 추가: `s = {2, 4, 6, 99}`\n\n6. **집합 교집합 계산:**\n```python print(len(s & set(dst.values())))\n```\n- `s = {2, 4, 6, 99}`\n- `set(dst.values()) = {2, 7, 6}` (dst의 현재 값들)\n- 교집합: `{2, 4, 6, 99} & {2, 7, 6} = {2, 6}`\n- 교집합의 길이: **2**핵심 포인트:**\n- 딕셔너리 컴프리헨션은 생성 시점의 리스트 값으로 딕셔너리를 만듭니다.\n- 이후 리스트를 수정해도 이미 생성된 딕셔너리는 영향받지 않습니다.\n- 집합의 교집합 연산(`&`)은 두 집합에 공통으로 있는 요소만 반환합니다.\n\n**답:** 2",
      "explanation_preview": "이 파이썬 코드는 딕셔너리, 집합(set) 생성과 연산을 이해하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **딕셔너리 생성:**\n```python lst = [1, 2, 3]\ndst = {i : i * 2 for i in lst}\n```\n- 딕셔너리 컴프리헨션: `dst = {1: 2, 2: 4, 3: 6}`\n- 키는 리스트의 각 요소, 값은 그 요",
      "image_refs": [
        "images/2025_round2/q017.png"
      ],
      "code_blocks": [
        {
          "language": "python",
          "code": "lst = [1,2,3]\ndst = {i : i* 2 for i in lst}\ns = set(dst.values())\nlst[0] = 99 \ndst[2]=7\ns.add(99)\nprint(len(s & set(dst.values())))",
          "line_numbers": [
            1,
            7
          ],
          "file": "data/codes/2025_round2/Q017_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "2"
        ],
        "raw_text": "2"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 948
      }
    },
    {
      "file": "items_2025_round2.jsonl",
      "q_no": "Q018",
      "doc_id": "2025_round2",
      "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "question_full": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.",
      "explanation_current": "이 C언어 코드는 연결 리스트를 역순으로 생성하고 출력하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **`func(\"BEST\")` 호출:**\n- 문자열 \"BEST\"를 받아서 연결 리스트를 생성합니다.\n- 연결 리스트는 **역순**으로 구성됩니다 (새 노드가 맨 앞에 추가됨).\n\n```c while(*s) { // 문자열의 각 문자를 처리 n = malloc(sizeof(struct node));\nn->c = *s++; // 현재 문자를 노드에 저장 n->p = h; // 새 노드의 다음 노드를 이전 head로 설정 h = n; // head를 새 노드로 변경\n}\n```\n\n- 첫 번째 반복: 'B' → head = B 노드\n- 두 번째 반복: 'E' → E 노드가 B 노드 앞에 추가, head = E → B\n- 세 번째 반복: 'S' → S 노드가 E 노드 앞에 추가, head = S → E → B\n- 네 번째 반복: 'T' → T 노드가 S 노드 앞에 추가, head = T → S → E → B\n\n**최종 연결 리스트:** T → S → E → B → NULL\n\n2. **`main()` 함수에서 출력:**\n```c struct node* n = func(\"BEST\"); // n은 T 노드를 가리킴 while(n) {\nputchar(n->c); // 현재 노드의 문자 출력 struct node* t = n; // 임시 변수에 현재 노드 저장 n = n->p; // 다음 노드로 이동 free(t); // 현재 노드 메모리 해제\n}\n```\n\n- 첫 번째 반복: `n->c = 'T'` 출력, `n = n->p` → S 노드로 이동\n- 두 번째 반복: `n->c = 'S'` 출력, `n = n->p` → E 노드로 이동\n- 세 번째 반복: `n->c = 'E'` 출력, `n = n->p` → B 노드로 이동\n- 네 번째 반복: `n->c = 'B'` 출력, `n = n->p` → NULL\n\n**최종 출력:** \"TSEB\"\n\n**핵심 포인트:**\n- 연결 리스트에 노드를 추가할 때 새 노드를 head 앞에 추가하면 역순으로 저장됩니다.\n- 입력 \"BEST\"가 역순으로 저장되어 T → S → E → B 순서로 출력됩니다.\n- 각 노드를 출력한 후 메모리를 해제하여 메모리 누수를 방지합니다.\n\n**답:** \"TSEB\"",
      "explanation_preview": "이 C언어 코드는 연결 리스트를 역순으로 생성하고 출력하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **`func(\"BEST\")` 호출:**\n- 문자열 \"BEST\"를 받아서 연결 리스트를 생성합니다.\n- 연결 리스트는 **역순**으로 구성됩니다 (새 노드가 맨 앞에 추가됨).\n\n```c while(*s) { // 문자열의 각 문자를 처리 n = mal",
      "image_refs": [
        "images/2025_round2/q018.png"
      ],
      "code_blocks": [
        {
          "language": "c",
          "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    char c;\n    struct node* p;\n};\nstruct node* func(char* s) {\n    struct node* h = NULL, *n;\n    while(*s) {\n        n = malloc(sizeof(struct node));\n        n->c = *s++;\n        n->p = h;\n        h = n;\n    }\n    return h;\n}\nint main() {\n    struct node* n = func(\"BEST\");\n    while(n) {\n        putchar(n->c);\n        struct node* t = n;\n        n = n->p;\n        free(t);\n    }\n    return 0;\n}",
          "line_numbers": [
            1,
            26
          ],
          "file": "data/codes/2025_round2/Q018_code.txt"
        }
      ],
      "table_refs": [],
      "answer": {
        "keys": [
          "TSEB"
        ],
        "raw_text": "TSEB"
      },
      "primary_category": "프로그래밍",
      "quality": {
        "score": 45,
        "issues": [
          "범용적인 설명 문구 다수",
          "문제 내용과 연관성 부족"
        ],
        "is_poor": true,
        "length": 1142
      }
    }
  ]
}