{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드이다.\n올바른 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["BDCDD"], "raw_text": "BDCDD"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 BDCDD을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round3/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "java", "code": "public class main{\n    public static void main(String[] args) {\n        A b = new B();\n        b.paint();\n        b.draw();\n    }\n}\nclass A {\n    public void paint() {\n        System.out.print(\"A\");\n        draw();\n    }\n    public void draw() {\n        System.out.print(\"B\");\n        draw();\n    }\n}\nclass B extends A {\n    public void paint() {\n        super.draw();\n        System.out.print(\"C\");\n        this.draw();\n    }\n    public void draw() {\n        System.out.print(\"D\");\n    }\n}", "line_numbers": [1, 27], "file": "data/codes/2023_round3/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 설명하는 용어를 보기에 맞게 골라 기호를 작성하시오.", "choices": [], "answer": {"keys": ["ㅇ"], "raw_text": "ㅇ"}, "explanation": "이 문제는 **OAuth (Open Authorization)**에 대한 문제입니다.\n\n**OAuth란?**\n\n**정의:**\n- **OAuth (Open Authorization)**: 제3자 애플리케이션에 사용자 리소스 접근 권한을 안전하게 부여하는 **인증 및 권한 부여 프로토콜**\n- 사용자가 비밀번호를 공유하지 않고도 다른 서비스에 자신의 계정 정보를 제공할 수 있게 합니다.\n\n**OAuth의 특징:**\n\n1. **인증 위임:**\n   - 사용자가 비밀번호를 제3자 앱에 제공할 필요 없음\n   - 인증 서버가 사용자 대신 권한 부여\n\n2. **토큰 기반 인증:**\n   - Access Token: 리소스 접근 권한 부여\n   - Refresh Token: Access Token 갱신\n\n3. **보안 향상:**\n   - 비밀번호 노출 방지\n   - 권한 범위 제한 가능 (Scope)\n\n**OAuth 흐름:**\n\n1. **사용자 요청**: 제3자 앱에 로그인 요청\n2. **인증 서버로 리다이렉트**: 사용자 인증\n3. **권한 승인**: 사용자가 권한 부여\n4. **토큰 발급**: Access Token 발급\n5. **리소스 접근**: 토큰으로 API 호출\n\n**OAuth 버전:**\n\n- **OAuth 1.0**: 서명 기반 인증\n- **OAuth 2.0**: 현재 가장 널리 사용되는 버전 (토큰 기반)\n\n**사용 예시:**\n\n- \"Google로 로그인\", \"Facebook으로 로그인\"\n- 소셜 미디어 연동\n- API 접근 권한 부여\n\n**답:** **ㅇ (OAuth)**", "table_refs": [], "image_refs": ["images/2023_round3/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "리눅스(Linux)에서 사용자에게 읽기/쓰기/실행 권한을 부여하고, 그룹에게는 읽기/실행을 부여하고, 그 이외에는 실행 권한을 test.txt 파일에 부여하는 위한 명령어는 다음과 같다. 빈칸에 들어갈 답을 작성하시오.\n\n(8진법 사용)\n(1)    ) (2)    ) test.txt", "choices": [], "answer": {"keys": ["(1) chmod", "(2) 751"], "raw_text": "(1) chmod\n(2) 751"}, "explanation": "이 문제는 리눅스(Linux) 파일 권한 관리 명령어인 `chmod`에 대한 문제입니다.\n\n**문제 요구사항:**\n- 사용자: 읽기(r), 쓰기(w), 실행(x) 권한 = 4+2+1 = 7\n- 그룹: 읽기(r), 실행(x) 권한 = 4+1 = 5\n- 기타: 실행(x) 권한 = 1\n- 8진법으로 표현: **751**chmod 명령어:**\n- `chmod`는 파일이나 디렉토리의 권한을 변경하는 명령어입니다.\n- 8진법으로 권한을 지정할 수 있습니다.\n- 각 자릿수는 사용자/그룹/기타의 순서로 권한을 나타냅니다.\n\n**권한 계산:**\n- 읽기(Read): 4\n- 쓰기(Write): 2\n- 실행(Execute): 1\n\n**최종 답:**\n- (1) **chmod**\n- (2) **751**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 C 언어 코드이다.\n알맞는 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["34"], "raw_text": "34"}, "explanation": "이 C언어 코드는 **완전수(Perfect Number)**를 찾아 그 합을 계산하는 문제입니다.\n\n**완전수란?**\n자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.\n\n**코드 실행 단계:**\n\n1. **`test(n)` 함수:**\n- `n`이 완전수인지 확인하는 함수입니다.\n- `for (i = 1; i <= n / 2; i++)`: 1부터 n/2까지 반복 (약수는 n/2를 넘을 수 없음)\n- `if (n % i == 0)`: i가 n의 약수인지 확인\n- `sum += i`: 약수를 sum에 누적\n- `if (n == sum)`: 자기 자신과 약수의 합이 같으면 완전수 → `return 1`\n- 그렇지 않으면 `return 0`\n\n2. **완전수 확인 (2부터 100까지):**\n- **6**: 약수 1, 2, 3 → 1+2+3 = 6 ✓ (완전수)\n- **28**: 약수 1, 2, 4, 7, 14 → 1+2+4+7+14 = 28 ✓ (완전수)\n\n3. **main() 함수:**\n- `for (i = 2; i <= 100; i++)`: 2부터 100까지 반복\n- `if (test(i))`: i가 완전수이면\n- `sum += i`: 완전수를 sum에 누적\n- 완전수: 6, 28\n- 합: 6 + 28 = **34**최종 출력:**34**핵심 포인트:**\n- 완전수는 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.\n- 2부터 100까지의 완전수는 6과 28입니다.", "table_refs": [], "image_refs": ["images/2023_round3/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint test(int n) {\n    int i, sum = 0;\n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n    if (n == sum) \n        return 1;\n    ​\n    return 0;\n}\nint main(){\n    int i, sum=0;\n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n    printf(\"%d \", sum); \n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2023_round3/Q004_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 기호를 작성하시오.", "choices": [], "answer": {"keys": ["→"], "raw_text": "→"}, "explanation": "**C언어 구조체 포인터 멤버 접근 문제입니다.**\n\n**문제의 전체 코드:**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\n\nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    \n    d1.numPtr = &num;  \n    d2 ( ) numPtr = &num;  // 15번 줄: 여기에 들어갈 기호는?\n    \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);  // 18번 줄: 여기에 들어갈 기호는?\n    \n    free(d2); \n    return 0;\n}\n```\n\n**문제 분석:**\n\n15번 줄과 18번 줄의 괄호 안에 들어갈 기호를 찾아야 합니다.\n\n**구조체 멤버 접근 방법:**\n\n1. **구조체 변수 (`d1`)**:\n   - 타입: `Data` (일반 변수)\n   - 멤버 접근: `.` (점) 연산자 사용\n   - 예: `d1.numPtr = &num;`\n\n2. **구조체 포인터 (`d2`)**:\n   - 타입: `Data*` (포인터 변수)\n   - 멤버 접근: `->` (화살표) 연산자 사용\n   - 예: `d2->numPtr = &num;`\n\n**화살표 연산자 (`->`)의 의미:**\n\n`d2->numPtr`는 `(*d2).numPtr`와 동일합니다.\n- 먼저 포인터 `d2`를 역참조 (`*d2`)하여 구조체에 접근\n- 그 다음 `.`로 멤버에 접근\n- 이를 간편하게 표현한 것이 `->` 연산자\n\n**코드 실행 결과:**\n\n```c\nd1.numPtr = &num;      // d1의 numPtr에 num의 주소 저장\nd2->numPtr = &num;     // d2의 numPtr에 num의 주소 저장\n\nprintf(\"%d\\n\", *d1.numPtr);   // d1.numPtr이 가리키는 값 출력: 10\nprintf(\"%d\\n\", *d2->numPtr);  // d2->numPtr이 가리키는 값 출력: 10\n```\n\n**답:** **→** (화살표 연산자)", "table_refs": [], "image_refs": ["images/2023_round3/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    d1.numPtr = &num;  \n   d2 ( ) numPtr = &num; \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n    free(d2); \n    return 0;\n}", "line_numbers": [1, 17], "file": "data/codes/2023_round3/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.", "choices": [], "answer": {"keys": ["4", "3", "2"], "raw_text": "4 3 2"}, "explanation": "**관계 대수 UNION 연산:**\n\n**UNION 연산의 정의:**\n- 두 릴레이션을 **합집합**하는 연산\n- 두 릴레이션의 **모든 튜플을 합치고 중복을 제거**\n- 기호: `∪` 또는 `UNION`\n\n**UNION 연산의 조건:**\n- **차수(Degree) 동일**: 두 릴레이션의 속성 개수가 같아야 함\n- **도메인 호환**: 대응되는 속성의 도메인이 같아야 함\n\n**주어진 테이블 데이터:**\n- **테이블 1**: 컬럼 \"3\", 행: [1], [4]\n- **테이블 2**: 컬럼 \"2\", 행: [4], [3]\n\n**UNION 연산 실행:**\n1. **두 릴레이션 합치기**:\n   - 테이블 1: [1], [4]\n   - 테이블 2: [4], [3]\n   - 합치기: [1], [4], [4], [3]\n\n2. **중복 제거**:\n   - [4]가 중복되므로 하나만 유지\n   - 결과: [1], [4], [3]\n\n**답:** 문제의 이미지와 테이블 데이터를 확인하여 UNION 연산 결과를 작성합니다. 답은 **\"4 3 2\"**입니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round3/Q006_table1.json", "rows": 2, "cols": 1}, {"id": "table2", "json": "data/tables/2023_round3/Q006_table2.json", "rows": 2, "cols": 1}], "image_refs": ["images/2023_round3/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 설명은 서버 접근 통제의 유형이다.\n괄호 안에 들어갈 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)", "choices": [], "answer": {"keys": ["(1) MAC", "(2) RBAC", "(3) DAC"], "raw_text": "(1) MAC\n(2) RBAC\n(3) DAC"}, "explanation": "이 문제는 **서버 접근 통제(Access Control)** 유형을 묻는 문제입니다.\n\n**접근 통제 유형:**\n\n1. **MAC (Mandatory Access Control) - 강제적 접근 통제**\n- 미리 정해진 정책과 보안 등급에 따라 접근을 통제합니다.\n- 시스템 관리자가 접근 권한을 결정합니다.\n\n2. **RBAC (Role-Based Access Control) - 역할 기반 접근 통제**\n- 사용자의 역할(role)에 따라 접근 권한을 부여합니다.\n- DAC와 MAC의 단점을 보완한 방식입니다.\n\n3. **DAC (Discretionary Access Control) - 임의적 접근 통제**\n- 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한합니다.\n- 객체의 소유자가 접근 권한을 결정합니다.\n\n**문제에서 설명하는 특징을 각 유형과 매칭:**\n- 문제의 첫 번째 설명 → MAC\n- 문제의 두 번째 설명 → RBAC\n- 문제의 세 번째 설명 → DAC\n\n**답:**\n- (1) **MAC**\n- (2) **RBAC**\n- (3) **DAC**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 C언어 코드에 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5040"], "raw_text": "5040"}, "explanation": "이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.\n\n**팩토리얼이란?**\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n\n**코드 실행 단계:**\n\n```c f(7) = 7 * f(6)\n= 7 * 6 * f(5)\n= 7 * 6 * 5 * f(4)\n= 7 * 6 * 5 * 4 * f(3)\n= 7 * 6 * 5 * 4 * 3 * f(2)\n= 7 * 6 * 5 * 4 * 3 * 2 * f(1)\n= 7 * 6 * 5 * 4 * 3 * 2 * 1\n= 5040\n```\n\n**재귀 호출 추적:**\n1. `f(7)` 호출 → `7 * f(6)` 반환 2. `f(6)` 호출 → `6 * f(5)` 반환 3. `f(5)` 호출 → `5 * f(4)` 반환 4. `f(4)` 호출 → `4 * f(3)` 반환 5. `f(3)` 호출 → `3 * f(2)` 반환 6. `f(2)` 호출 → `2 * f(1)` 반환 7. `f(1)` 호출 → `1` 반환 (기저 조건)\n\n**최종 계산:**\n7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = **5040**최종 출력:**5040**핵심 포인트:**\n- 재귀 함수는 자기 자신을 호출하여 문제를 해결합니다.\n- 기저 조건(n <= 1)에서 재귀가 종료됩니다.", "table_refs": [], "image_refs": ["images/2023_round3/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include\nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\nint main() {\n    printf(\"%d\", f(7));\n}", "line_numbers": [1, 8], "file": "data/codes/2023_round3/Q008_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)", "choices": [], "answer": {"keys": ["ATM"], "raw_text": "ATM"}, "explanation": "이 문제는 네트워크 프로토콜 중 **ATM (Asynchronous Transfer Mode)**에 대한 문제입니다.\n\n**ATM (Asynchronous Transfer Mode):**\n- 비동기 전송 방식으로, 데이터를 고정 크기의 셀(cell) 단위로 전송합니다.\n- 셀 크기는 53바이트입니다 (48바이트 데이터 + 5바이트 헤더).\n- 고속 데이터 전송을 위해 개발되었습니다.\n\n**ATM의 특징:**\n1. 고정 크기 셀 사용 (53바이트)\n2. 고속 전송 (155Mbps ~ 622Mbps)\n3. 품질 보장(QoS) 지원 4. 실시간 멀티미디어 서비스에 적합\n\n**문제에서 설명하는 특징과 매칭:**\n- 문제에서 설명한 특징들이 ATM 프로토콜과 일치합니다.\n\n**답:**ATM**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 C언어의 포인터 문제이다.\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["KOREA", "OREA", "K"], "raw_text": "KOREA K"}, "explanation": "**C언어 포인터와 문자열 출력 문제입니다.**\n\n**문제의 코드:**\n\n```c\nchar* p = \"KOREA\";\nprintf(\"%s\\n\", p);        // 1번 출력\nprintf(\"%s\\n\", p+1);     // 2번 출력\nprintf(\"%c\\n\", *p);      // 3번 출력\nprintf(\"%c\\n\", *(p+3));  // 4번 출력\nprintf(\"%c\\n\", *p+4);    // 5번 출력\n```\n\n**실행 과정:**\n\n1. **`char* p = \"KOREA\"`**:\n   - `p`는 문자열 \"KOREA\"의 첫 번째 문자 주소를 가리킴\n   - 메모리: `K`(p) `O`(p+1) `R`(p+2) `E`(p+3) `A`(p+4) `\\0`(p+5)\n\n2. **`printf(\"%s\\n\", p)`**:\n   - `%s`: 문자열 출력 포맷\n   - `p`가 가리키는 위치부터 널 문자(`\\0`)까지 출력\n   - 출력: **\"KOREA\"**\n\n3. **`printf(\"%s\\n\", p+1)`**:\n   - `p+1`은 두 번째 문자(`O`) 주소\n   - `p+1`부터 널 문자까지 출력\n   - 출력: **\"OREA\"**\n\n4. **`printf(\"%c\\n\", *p)`**:\n   - `%c`: 문자 1개 출력 포맷\n   - `*p`: p가 가리키는 값 (첫 번째 문자)\n   - 출력: **\"K\"**\n\n5. **`printf(\"%c\\n\", *(p+3))`**:\n   - `p+3`은 네 번째 문자(`E`) 주소\n   - `*(p+3)`: 네 번째 문자의 값\n   - 출력: **\"E\"**\n\n6. **`printf(\"%c\\n\", *p+4)`**:\n   - `*p`: 'K' (ASCII 75)\n   - `*p+4`: 75 + 4 = 79 (산술 연산)\n   - ASCII 79 = 'O'\n   - 출력: **\"O\"**\n\n**핵심 포인트:**\n\n- **포인터 연산**: `p+1`, `p+3` 등으로 주소 이동\n- **역참조**: `*p`로 포인터가 가리키는 값 접근\n- **문자열 출력**: `%s`는 널 문자까지 출력\n- **문자 출력**: `%c`는 문자 1개 출력\n- **산술 연산**: `*p+4`는 값에 4를 더함 (ASCII 값 증가)\n\n**답:** **\"KOREA\", \"OREA\", \"K\", \"E\", \"O\"**", "table_refs": [], "image_refs": ["images/2023_round3/10.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include\nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s\\n\", p);\n    printf(\"%s\\n\", p+1);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *(p+3));\n    printf(\"%c\\n\", *p+4);\n}", "line_numbers": [1, 9], "file": "data/codes/2023_round3/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 Java 코드에 대한 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "**Java 재귀 함수와 메서드 오버라이딩 문제입니다.**\n\n**문제의 코드:**\n\n```java\nclass Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-2);  // 피보나치 패턴\n    }\n}\n\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-3);  // 오버라이딩\n    }\n}\n\nParent obj = new Child();\nSystem.out.print(obj.compute(7));\n```\n\n**실행 과정:**\n\n1. **`obj.compute(7)` 호출:**\n   - `obj`는 `Child` 타입이지만 `Parent` 참조로 선언\n   - **동적 바인딩**: 실제 객체 타입(`Child`)의 메서드 호출\n   - `Child.compute(7)` 실행\n\n2. **`Child.compute(7)` 재귀 호출 추적:**\n   - `compute(7) = compute(6) + compute(4)`\n   - `compute(6) = compute(5) + compute(3)`\n   - `compute(5) = compute(4) + compute(2)`\n   - `compute(4) = compute(3) + compute(1)`\n   - `compute(3) = compute(2) + compute(0)`\n   - `compute(2) = compute(1) + compute(-1)`\n   - `compute(1) = 1` (기저 조건)\n   - `compute(0) = 0` (기저 조건)\n   - `compute(-1) = -1` (기저 조건)\n\n3. **계산 결과:**\n   - `compute(2) = 1 + (-1) = 0`\n   - `compute(3) = 0 + 0 = 0`\n   - `compute(4) = 0 + 1 = 1`\n   - `compute(5) = 1 + 0 = 1`\n   - `compute(6) = 1 + 0 = 1`\n   - `compute(7) = 1 + 1 = 2`\n\n**핵심 포인트:**\n\n- **메서드 오버라이딩**: 자식 클래스가 부모 클래스의 메서드를 재정의\n- **동적 바인딩**: 실제 객체 타입(`Child`)에 따라 메서드 호출\n- **재귀 함수**: 자기 자신을 호출하여 문제 해결\n- **기저 조건**: `num <= 1`일 때 재귀 종료\n\n**답:** **\"2\"**", "table_refs": [], "image_refs": ["images/2023_round3/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "java", "code": "class Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}", "line_numbers": [1, 20], "file": "data/codes/2023_round3/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?", "choices": [], "answer": {"keys": ["NAT"], "raw_text": "NAT"}, "explanation": "**NAT (Network Address Translation) 기술 문제입니다.**\n\n**NAT의 정의:**\n- 외부의 공인 IP 주소와 포트를 내부의 사설 IP 주소로 변환하는 기술\n- 라우터나 방화벽에서 구현됨\n- 여러 내부 네트워크가 하나의 공인 IP를 공유할 수 있게 함\n\n**NAT의 주요 특징:**\n1. **주소 변환**: 공인 IP ↔ 사설 IP 변환\n2. **포트 변환**: 포트 번호도 함께 변환 (PAT: Port Address Translation)\n3. **트래픽 라우팅**: 라우터를 통해 네트워크 트래픽을 주고받음\n4. **보안 향상**: 내부 네트워크 구조를 외부에 숨김\n\n**문제에서 설명하는 내용:**\n- \"외부의 공인 IP 주소와 포트 주소에 해당하는 내부 IP 주소를 재기록\"\n- \"라우터를 통해 네트워크 트래픽을 주고받는 기술\"\n\n→ 이는 정확히 NAT 기술의 정의입니다.\n\n**답:** **NAT**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오.", "choices": [], "answer": {"keys": ["7"], "raw_text": "7"}, "explanation": "**Java 컴파일 에러 탐지 문제입니다.**\n\n**문제의 코드:**\n\n```java\nclass Person {\n    private String name;                    // 2번 라인: 인스턴스 변수\n    public Person(String val) {            // 3번 라인: 생성자\n        name = val;                        // 4번 라인\n    }\n    public static String get() {          // 6번 라인: static 메서드\n    return name;                          // 7번 라인: 에러 발생! ❌\n    }\n    public void print() {                  // 9번 라인\n        System.out.println(name);         // 10번 라인\n    }\n}\n```\n\n**에러 원인:**\n\n**7번 라인 (`return name;`)에서 에러 발생:**\n\n- **문제**: `static` 메서드에서 **인스턴스 변수(`name`)**에 접근하려고 함\n- **Java 규칙**:\n  - `static` 메서드는 **인스턴스 변수에 직접 접근 불가**\n  - `static` 메서드는 **인스턴스 생성 없이 호출 가능**\n  - 인스턴스 변수는 **인스턴스 생성 후에만 존재**\n\n**에러 메시지:**\n```\nNon-static field 'name' cannot be referenced from a static context\n```\n\n**해결 방법:**\n\n1. **`name`을 `static` 변수로 변경:**\n   ```java\n   private static String name;\n   ```\n\n2. **`get()` 메서드를 `static`이 아닌 인스턴스 메서드로 변경:**\n   ```java\n   public String get() {\n       return name;\n   }\n   ```\n\n3. **인스턴스를 통해 접근:**\n   ```java\n   public static String get(Person p) {\n       return p.name;\n   }\n   ```\n\n**Java static vs instance:**\n\n| 구분 | static | instance |\n|------|--------|----------|\n| **메서드** | 클래스 이름으로 호출 | 객체로 호출 |\n| **변수** | 클래스 변수 (공유) | 인스턴스 변수 (개별) |\n| **접근** | static 멤버만 접근 가능 | 인스턴스 멤버 접근 가능 |\n\n**답:** **7번 라인**", "table_refs": [], "image_refs": ["images/2023_round3/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [{"language": "java", "code": "class Person {\n    private String name;\n    public Person(String val) {\n        name = val;\n    }\n    public static String get() {\n    return name;\n    }\n    public void print() {\n        System.out.println(name);\n    }\n}\npublic class main {\n    public static void main(String[] args) {\n        Person obj = new Person(\"Kim\");\n        obj.print();\n    }\n}", "line_numbers": [1, 18], "file": "data/codes/2023_round3/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 파이썬에 대한 문제이다.\n밑줄친 부분에 알맞는 답을 작성하시오.\n입력값은 2와 3이다.\n파이썬 입력출에 대한 문제입니다.\n2 3 2 + 3 = 5", "choices": [], "answer": {"keys": ["split"], "raw_text": "split"}, "explanation": "이 파이썬 코드는 **입력 처리와 문자열 분할**을 이해하는 문제입니다.\n\n**문제 요구사항:**\n- 입력값: \"2 3\" (공백으로 구분된 두 숫자)\n- 출력값: \"2 3\" 및 \"2 + 3 = 5\"\n\n**코드 분석:**\n\n```python num1, num2 = input().split() # 입력을 받아 공백으로 분할 num1 = int(num1) # 문자열을 정수로 변환 num2 = int(num2)\n```\n\n**입력 처리 과정:**\n1. **`input()`**: 사용자로부터 \"2 3\" 문자열 입력 2. **`.split()`**: 공백을 기준으로 문자열을 분할\n- \"2 3\" → [\"2\", \"3\"]\n3. **`num1, num2 = ...`**: 언패킹으로 각각 할당\n- `num1 = \"2\"`, `num2 = \"3\"`\n4. **`int()` 변환**: 문자열을 정수로 변환\n- `num1 = 2`, `num2 = 3`\n\n**빈칸에 들어갈 답:**\n- 입력 문자열을 공백으로 분할하는 메서드는 `split()`입니다.\n\n**답:**split**핵심 포인트:**\n- `input()`: 사용자 입력을 문자열로 받음\n- `.split()`: 문자열을 지정된 구분자(기본값: 공백)로 분할하여 리스트로 반환\n- 언패킹: 여러 변수에 한 번에 할당", "table_refs": [], "image_refs": ["images/2023_round3/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [{"language": "python", "code": "print(\"파이썬 입출력에 대한 문제입니다.\")\nnum1, num2 = input()._____()\nnum1 = int(num1)\nnum2 = int(num2)\nprint(num1,num2)\nnum3 = num1 + num2\nprint(num1 + \" + \"  + num2 + \" = \" + num3)", "line_numbers": [1, 7], "file": "data/codes/2023_round3/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 판매와 관련된 다이어그램이다.\n해당 다이어그램의 명칭을 쓰시오.", "choices": [], "answer": {"keys": ["패키지"], "raw_text": "패키지"}, "explanation": "**UML 패키지 다이어그램 (Package Diagram):**\n\n**패키지 다이어그램의 정의:**\n- 관련된 클래스나 모듈을 **패키지로 그룹화**하여 표현하는 UML 다이어그램\n- 패키지 간의 **의존 관계**를 보여줌\n- 모듈화와 재사용성을 나타냄\n\n**패키지 다이어그램의 특징:**\n- **그룹화**: 관련된 클래스들을 패키지로 묶어 표현\n- **의존 관계**: 패키지 간의 의존 관계를 화살표로 표시\n- **모듈화**: 시스템을 논리적으로 분할\n- **재사용성**: 패키지 단위로 재사용 가능\n\n**문제의 이미지 확인:**\n- \"판매와 관련된 다이어그램\"에서 여러 클래스나 모듈을 패키지로 그룹화한 구조를 확인\n- 이는 **패키지 다이어그램**의 특징\n\n**UML 다이어그램 종류:**\n| 다이어그램 | 용도 |\n|-----------|------|\n| **클래스 다이어그램** | 클래스 구조와 관계 |\n| **시퀀스 다이어그램** | 객체 간 메시지 흐름 |\n| **패키지 다이어그램** | 패키지 그룹화 및 의존 관계 |\n| **액티비티 다이어그램** | 업무 흐름 또는 알고리즘 |\n\n**답:** **패키지**", "table_refs": [], "image_refs": ["images/2023_round3/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 설명에 알맞는 답을 보기에서 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄱ"], "raw_text": "ㄱ"}, "explanation": "**Equivalence Partitioning (동등 분할) 테스트 기법 문제입니다.**\n\n**Equivalence Partitioning (동등 분할)의 정의:**\n- 입력 데이터를 **동등한(equivalent) 그룹으로 분할**하여 각 그룹에서 **대표값 하나씩만 테스트**하는 기법\n- **EP (Equivalence Partitioning)**라고도 함\n- 블랙박스 테스트 기법 중 하나\n\n**동등 분할의 특징:**\n\n1. **입력 영역 분할:**\n   - 유효한 입력 영역과 무효한 입력 영역으로 분할\n   - 각 영역 내의 값들은 동일하게 처리됨\n\n2. **대표값 선택:**\n   - 각 분할 영역에서 **대표값 하나만 선택**하여 테스트\n   - 분할 영역 내의 모든 값은 동일한 결과를 가정\n\n3. **테스트 케이스 감소:**\n   - 모든 가능한 값을 테스트하지 않고 대표값만 테스트\n   - 테스트 효율성 향상\n\n**예시:**\n\n**입력: 정수 (1~100)**\n\n1. **유효한 입력 영역:**\n   - 1~100: 정상 처리\n   - 대표값: 50\n\n2. **무효한 입력 영역:**\n   - < 1: 오류 처리\n   - 대표값: 0, -1\n   - > 100: 오류 처리\n   - 대표값: 101, 200\n\n**테스트 케이스:**\n- 50 (유효)\n- 0 (무효, 작음)\n- 101 (무효, 큼)\n\n**동등 분할 vs 경계값 분석:**\n\n| 기법 | 특징 | 예시 |\n|------|------|------|\n| **동등 분할** | 각 분할 영역의 대표값 테스트 | 50, 0, 101 |\n| **경계값 분석** | 경계값과 그 근처 값 테스트 | 1, 0, -1, 100, 101, 102 |\n\n**다른 테스트 기법:**\n\n- **Boundary Value Analysis (경계값 분석)**: 경계값과 그 근처 값 테스트\n- **Decision Table (의사결정 테이블)**: 조건 조합 테스트\n- **State Transition (상태 전이)**: 상태 변화 테스트\n\n**답:** **ㄱ (Equivalence Partitioning / 동등 분할)**", "table_refs": [], "image_refs": ["images/2023_round3/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 클라우드에 대한 유형 문제이다.\n괄호 안에 알맞는 답을 보기에 골라 작성하시오.", "choices": [], "answer": {"keys": ["(1) IaaS", "(2) PaaS", "(3) SaaS"], "raw_text": "(1) IaaS\n(2) PaaS\n(3) SaaS"}, "explanation": "이 문제는 **클라우드 컴퓨팅 서비스 모델**을 묻는 문제입니다.\n\n**클라우드 서비스 모델:**\n\n1. **IaaS (Infrastructure as a Service) - 인프라 서비스**\n- 가상화된 하드웨어 자원(서버, 스토리지, 네트워크)을 제공\n- 사용자가 OS, 미들웨어, 애플리케이션을 직접 관리\n- 예: AWS EC2, Google Compute Engine\n\n2. **PaaS (Platform as a Service) - 플랫폼 서비스**\n- 개발 및 배포 환경을 제공\n- 사용자가 애플리케이션만 개발하고 배포\n- 예: AWS Elastic Beanstalk, Heroku\n\n3. **SaaS (Software as a Service) - 소프트웨어 서비스**\n- 완성된 소프트웨어를 인터넷을 통해 제공\n- 사용자는 브라우저나 앱을 통해 이용\n- 예: Gmail, Office 365, Dropbox\n\n**문제에서 설명하는 순서와 매칭:**\n- 문제의 첫 번째 설명 → IaaS (인프라 제공)\n- 문제의 두 번째 설명 → PaaS (플랫폼 제공)\n- 문제의 세 번째 설명 → SaaS (소프트웨어 제공)\n\n**답:**\n- (1) **IaaS**\n- (2) **PaaS**\n- (3) **SaaS**", "table_refs": [], "image_refs": ["images/2023_round3/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 프로토콜 종류에 관한 설명이다.\n알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["RIP"], "raw_text": "RIP"}, "explanation": "이 문제는 라우팅 프로토콜 중 **RIP (Routing Information Protocol)**에 대한 문제입니다.\n\n**RIP (Routing Information Protocol)란?**\n- 거리 벡터(Distance Vector) 라우팅 프로토콜입니다.\n- 홉(hop) 수를 거리로 사용하여 최단 경로를 결정합니다.\n- 30초마다 라우팅 정보를 주기적으로 업데이트합니다.\n- 최대 홉 수는 15입니다 (16 이상은 무한대로 간주).\n\n**RIP의 특징:**\n1. **거리 벡터 알고리즘**: 인접 라우터로부터 거리 정보를 받아 최단 경로 계산 2. **주기적 업데이트**: 30초마다 라우팅 테이블 브로드캐스트 3. **홉 카운트**: 목적지까지의 라우터 개수를 거리로 측정 4. **최대 홉 수**: 15 (16 이상은 도달 불가능)\n\n**문제에서 설명하는 특징:**\n- 문제에서 설명한 프로토콜의 특징이 RIP와 일치합니다.\n\n**답:**RIP**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 관계 대수에 대한 내용이다.\n보기에 알맞는 기호를 작성하시오.\n\n1. join :\n\n(1)\n\n2. project : ( 2 )\n\n3. select : ( 3 )\n\n4. division : ( 4 )", "choices": [], "answer": {"keys": ["(1) ㄷ", "(2) ㄴ", "(3) ㄱ"], "raw_text": "(1) ㄷ\n(2) ㄴ\n(3) ㄱ"}, "explanation": "이 문제는 **관계 대수(Relational Algebra)의 연산 기호**를 묻는 문제입니다.\n\n**관계 대수 연산 기호:**\n\n1. **JOIN (조인) - (1) ㄷ**:\n   - 기호: `⋈` (보울 기호)\n   - 두 릴레이션을 조건에 따라 결합\n   - **Theta JOIN (θ-JOIN)**: `R ⋈_θ S`\n   - **EQUI JOIN**: `R ⋈_A=B S` (등호 조건)\n   - **NATURAL JOIN**: `R ⋈ S` (같은 속성명으로 자동 결합)\n\n2. **PROJECT (투영) - (2) ㄴ**:\n   - 기호: `π` (파이)\n   - 특정 속성(컬럼)만 선택\n   - `π_속성1,속성2(R)`: R 릴레이션에서 속성1, 속성2만 선택\n   - 중복 튜플 제거\n\n3. **SELECT (선택) - (3) ㄱ**:\n   - 기호: `σ` (시그마)\n   - 조건에 맞는 행(튜플)만 선택\n   - `σ_조건(R)`: R 릴레이션에서 조건에 맞는 행만 선택\n   - WHERE 절과 유사\n\n4. **DIVISION (나눗셈) - (4) ㄹ**:\n   - 기호: `÷` (나눗셈 기호)\n   - 한 릴레이션을 다른 릴레이션으로 나눔\n   - `R ÷ S`: R에 있으면서 S에 있는 모든 조합을 포함하는 튜플 선택\n   - 복잡한 쿼리 표현에 사용\n\n**관계 대수 연산 기호 정리:**\n\n| 연산 | 기호 | 설명 |\n|------|------|------|\n| **SELECT (선택)** | `σ` (시그마) | 조건에 맞는 행 선택 |\n| **PROJECT (투영)** | `π` (파이) | 특정 속성만 선택 |\n| **JOIN (조인)** | `⋈` (보울) | 두 릴레이션 결합 |\n| **UNION (합집합)** | `∪` | 합집합 |\n| **INTERSECTION (교집합)** | `∩` | 교집합 |\n| **DIFFERENCE (차집합)** | `-` | 차집합 |\n| **CARTESIAN PRODUCT (곱집합)** | `×` | 카티시안 곱 |\n| **DIVISION (나눗셈)** | `÷` | 나눗셈 |\n\n**SQL과의 대응:**\n\n| 관계 대수 | SQL |\n|-----------|-----|\n| `σ_조건(R)` | `SELECT * FROM R WHERE 조건` |\n| `π_속성(R)` | `SELECT 속성 FROM R` |\n| `R ⋈ S` | `SELECT * FROM R JOIN S` |\n| `R ÷ S` | 복잡한 서브쿼리로 표현 |\n\n**답:**\n- **(1) ㄷ (JOIN: ⋈)**\n- **(2) ㄴ (PROJECT: π)**\n- **(3) ㄱ (SELECT: σ)**\n- **(4) ㄹ (DIVISION: ÷)**", "table_refs": [], "image_refs": ["images/2023_round3/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 데이터베이스에 관련된 문제이다.\n괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["참조"], "raw_text": "참조"}, "explanation": "이 문제는 **데이터베이스 무결성 제약조건 중 참조 무결성(Referential Integrity)**에 대한 문제입니다.\n\n**참조 무결성(Referential Integrity)이란?**\n\n**정의:**\n- **외래키(Foreign Key)**가 참조하는 **기본키(Primary Key)**가 존재해야 하는 제약조건\n- 한 릴레이션의 외래키가 다른 릴레이션의 기본키를 참조할 때, 참조되는 값이 반드시 존재해야 함\n\n**참조 무결성의 특징:**\n\n1. **외래키 제약:**\n   - 외래키 값은 참조되는 릴레이션의 기본키 값과 일치해야 함\n   - NULL 값은 허용 (선택적)\n\n2. **참조 무결성 위반 상황:**\n   - **참조 무결성 위반**: 외래키가 존재하지 않는 기본키를 참조\n   - **삭제 위반**: 참조되는 기본키를 삭제하려고 할 때\n   - **수정 위반**: 참조되는 기본키를 변경하려고 할 때\n\n3. **무결성 유지 방법:**\n   - **RESTRICT**: 참조 무결성 위반 시 작업 거부 (기본값)\n   - **CASCADE**: 참조되는 값 삭제/수정 시 외래키도 함께 삭제/수정\n   - **SET NULL**: 참조되는 값 삭제 시 외래키를 NULL로 설정\n   - **NO ACTION**: RESTRICT와 유사\n\n**예시:**\n\n```sql\nCREATE TABLE 학생 (\n    학번 INT PRIMARY KEY,\n    이름 VARCHAR(20)\n);\n\nCREATE TABLE 수강 (\n    수강번호 INT PRIMARY KEY,\n    학번 INT,\n    FOREIGN KEY (학번) REFERENCES 학생(학번)  -- 참조 무결성\n);\n```\n\n**데이터베이스 무결성 제약조건 종류:**\n\n| 제약조건 | 설명 |\n|---------|------|\n| **개체 무결성** | 기본키는 NULL 불가, 중복 불가 |\n| **참조 무결성** | 외래키는 참조되는 기본키가 존재해야 함 |\n| **도메인 무결성** | 속성 값이 도메인에 맞아야 함 |\n| **사용자 정의 무결성** | 사용자가 정의한 제약조건 |\n\n**답:** **\"참조\" (참조 무결성)**", "table_refs": [{"id": "table1", "json": "data/tables/2023_round3/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.962937", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
