{"doc_id": "theory_001", "category": "기타", "subcategory": "살충제 패러독스", "term": "살충제 패러독스", "abbreviations": [], "description": "동일한 테스트 케스트에 의한 반복적 테스트는 새로운 버그를 찾지 못한다는 테스트의 원리", "accept_answers": ["살충제 패러독스"]}
{"doc_id": "theory_002", "category": "네트워크", "subcategory": "프로토콜의 3요소", "term": "구문", "abbreviations": ["Syntax"], "description": "시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등을 규정", "accept_answers": ["구문", "Syntax"]}
{"doc_id": "theory_003", "category": "네트워크", "subcategory": "프로토콜의 3요소", "term": "의미", "abbreviations": ["Semantic"], "description": "시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정", "accept_answers": ["의미", "Semantic"]}
{"doc_id": "theory_004", "category": "네트워크", "subcategory": "프로토콜의 3요소", "term": "타이밍", "abbreviations": ["Timing"], "description": "시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정", "accept_answers": ["타이밍", "Timing"]}
{"doc_id": "theory_005", "category": "기타", "subcategory": "XML", "term": "XML", "abbreviations": [], "description": "송.수신 시스템 간 데이터 연계의 편의성을 위해서 전송되는 데이터 구조를 동일한 형태로 정의", "accept_answers": ["XML"]}
{"doc_id": "theory_006", "category": "알고리즘", "subcategory": "선점형 스케줄링 알고리즘 유형", "term": "RR", "abbreviations": ["Round Robin"], "description": "시분할 시스템에서 사용 / FCFS와 비슷하지만 제한시간이 지난 후, 다음 프로세스에게 자원을 할당", "accept_answers": ["RR", "Round Robin"]}
{"doc_id": "theory_007", "category": "알고리즘", "subcategory": "선점형 스케줄링 알고리즘 유형", "term": "SRT", "abbreviations": ["Shortest Remaining Time"], "description": "SJF기법을 선점형으로 바꾼 스케줄링", "accept_answers": ["SRT", "Shortest Remaining Time"]}
{"doc_id": "theory_008", "category": "알고리즘", "subcategory": "선점형 스케줄링 알고리즘 유형", "term": "선점 우선순위", "abbreviations": [], "description": "비선점 우선순위를 선점형으로 바꾼 것", "accept_answers": ["선점 우선순위"]}
{"doc_id": "theory_009", "category": "알고리즘", "subcategory": "선점형 스케줄링 알고리즘 유형", "term": "다단계 큐", "abbreviations": [], "description": "프로세스의 우선순위에 따라 시스템 프로세스, 대화형 프로세스, 일괄처리 프로세스 등으로 나누어 준비상태 큐를 상위 중위 하위단계로 배치", "accept_answers": ["다단계 큐"]}
{"doc_id": "theory_010", "category": "알고리즘", "subcategory": "선점형 스케줄링 알고리즘 유형", "term": "다단계 피드백 큐", "abbreviations": [], "description": "다단계 큐의 단점을 보완함 / 큐마다 timeout을 설정하여 timeout초과시 우선순위가 낮은 다음단계 큐로 이동", "accept_answers": ["다단계 피드백 큐"]}
{"doc_id": "theory_011", "category": "데이터베이스", "subcategory": "트랜잭션 특성", "term": "원자성", "abbreviations": ["Atomicity"], "description": "분해가 불가능한 작업의 최소단위", "accept_answers": ["원자성", "Atomicity"]}
{"doc_id": "theory_012", "category": "데이터베이스", "subcategory": "트랜잭션 특성", "term": "일관성", "abbreviations": ["Consistency"], "description": "트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상태를 보존해야하는 특성", "accept_answers": ["일관성", "Consistency"]}
{"doc_id": "theory_013", "category": "데이터베이스", "subcategory": "트랜잭션 특성", "term": "격리성/독립성", "abbreviations": ["Isolation"], "description": "트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가한 특성", "accept_answers": ["격리성/독립성", "Isolation"]}
{"doc_id": "theory_014", "category": "데이터베이스", "subcategory": "트랜잭션 특성", "term": "트랜잭션 특성", "abbreviations": [], "description": "영속성/지속성(Durability)-  성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장하는 특성", "accept_answers": ["트랜잭션 특성"]}
{"doc_id": "theory_015", "category": "기타", "subcategory": "TCL(Transaction Control Language)의 명령어", "term": "커밋", "abbreviations": [], "description": "트랜잭션 확정 트랜잭션을 메모리에 영구적으로 저장하는 명령어", "accept_answers": ["커밋"]}
{"doc_id": "theory_016", "category": "기타", "subcategory": "TCL(Transaction Control Language)의 명령어", "term": "롤백", "abbreviations": [], "description": "트랜잭션 취소 트랜잭션 내역을 저장 무효화시키는 명령어", "accept_answers": ["롤백"]}
{"doc_id": "theory_017", "category": "기타", "subcategory": "TCL(Transaction Control Language)의 명령어", "term": "체크 포인트", "abbreviations": [], "description": "저장 시기 설정 롤백을 위한 시점을 지정하는 명령어", "accept_answers": ["체크 포인트"]}
{"doc_id": "theory_018", "category": "기타", "subcategory": "랜드 어택", "term": "랜드 어택", "abbreviations": [], "description": "출발지(Source) IP와 목적지(Destination) IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격 기법이다", "accept_answers": ["랜드 어택"]}
{"doc_id": "theory_019", "category": "자료구조", "subcategory": "해시 암호화 알고리즘 종류", "term": "MD5", "abbreviations": ["Message-Digest algorithm 5"], "description": "각각의 512bit짜리 입력 메세지 블록에 대해 차례로 동작하여 128bit의 해시값을 생성하는 해시 알고리즘", "accept_answers": ["MD5", "Message-Digest algorithm 5"]}
{"doc_id": "theory_020", "category": "자료구조", "subcategory": "해시 암호화 알고리즘 종류", "term": "SHA-1", "abbreviations": ["Secure Hash Algorithm"], "description": "160bit의 해시값을 생성하는 해시 알고리즘", "accept_answers": ["SHA-1", "Secure Hash Algorithm"]}
{"doc_id": "theory_021", "category": "자료구조", "subcategory": "해시 암호화 알고리즘 종류", "term": "SHA-256/384/512", "abbreviations": ["Secure Hash Algorithm"], "description": "SHA알고리즘의 한 종류로써 256bit의 해시값을 생성하는 해시 함수", "accept_answers": ["SHA-256/384/512", "Secure Hash Algorithm"]}
{"doc_id": "theory_022", "category": "자료구조", "subcategory": "해시 암호화 알고리즘 종류", "term": "HAS-160", "abbreviations": [], "description": "국내 표준 서명 알고리즘 KCDSA(Korean Certificate-based Digital Signature Algorithm)를 위하여 개발된 해시 함수", "accept_answers": ["HAS-160"]}
{"doc_id": "theory_023", "category": "소프트웨어공학", "subcategory": "결합도의 유형", "term": "내용 결합도", "abbreviations": ["Content Coupling"], "description": "다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도", "accept_answers": ["내용 결합도", "Content Coupling"]}
{"doc_id": "theory_024", "category": "소프트웨어공학", "subcategory": "결합도의 유형", "term": "공통 결합도", "abbreviations": ["Common Coupling"], "description": "파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고, 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도", "accept_answers": ["공통 결합도", "Common Coupling"]}
{"doc_id": "theory_025", "category": "소프트웨어공학", "subcategory": "결합도의 유형", "term": "외부 결합도", "abbreviations": ["External Coupling"], "description": "두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우의 결합도", "accept_answers": ["외부 결합도", "External Coupling"]}
{"doc_id": "theory_026", "category": "소프트웨어공학", "subcategory": "결합도의 유형", "term": "제어 결합도", "abbreviations": ["Control Coupling"], "description": "단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우의 결합도", "accept_answers": ["제어 결합도", "Control Coupling"]}
{"doc_id": "theory_027", "category": "소프트웨어공학", "subcategory": "결합도의 유형", "term": "스탬프 결합도", "abbreviations": ["Stamp Coupling"], "description": "모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도", "accept_answers": ["스탬프 결합도", "Stamp Coupling"]}
{"doc_id": "theory_028", "category": "소프트웨어공학", "subcategory": "결합도의 유형", "term": "자료 결합도", "abbreviations": ["Data Coupling"], "description": "모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈간의 상호작용이 일어나는 경우의 결합도", "accept_answers": ["자료 결합도", "Data Coupling"]}
{"doc_id": "theory_029", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "우연적 응집도", "abbreviations": ["Coincidental Cohesion"], "description": "모듈 내부의 각 구성요소가 연관이 없을 경우의 응집도", "accept_answers": ["우연적 응집도", "Coincidental Cohesion"]}
{"doc_id": "theory_030", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "논리적 응집도", "abbreviations": ["Logical Cohesion"], "description": "유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우의 응집도", "accept_answers": ["논리적 응집도", "Logical Cohesion"]}
{"doc_id": "theory_031", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "시간적 응집도", "abbreviations": ["Temporal Cohesion"], "description": "연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도", "accept_answers": ["시간적 응집도", "Temporal Cohesion"]}
{"doc_id": "theory_032", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "절차적 응집도", "abbreviations": ["Procedural Cohesion"], "description": "모듈 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도", "accept_answers": ["절차적 응집도", "Procedural Cohesion"]}
{"doc_id": "theory_033", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "교환적 응집도", "abbreviations": ["Communication Cohesion"], "description": "동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도", "accept_answers": ["교환적 응집도", "Communication Cohesion"]}
{"doc_id": "theory_034", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "순차적 응집도", "abbreviations": ["Sequential Cohesion"], "description": "모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우의 응집도", "accept_answers": ["순차적 응집도", "Sequential Cohesion"]}
{"doc_id": "theory_035", "category": "소프트웨어공학", "subcategory": "응집도의 유형", "term": "기능적 응집도", "abbreviations": ["Functional Cohesion"], "description": "모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우의 응집도", "accept_answers": ["기능적 응집도", "Functional Cohesion"]}
{"doc_id": "theory_036", "category": "소프트웨어공학", "subcategory": "응집도 낮음(나쁜 품질)에서 응집도 높음(좋은 품질)의 순서", "term": "응집도 낮음에서 응집도 높음의 순서", "abbreviations": ["나쁜 품질", "좋은 품질"], "description": "우연적 응집도 < 논리적 응집도 < 시간적 응집도 < 절차적 응집도 < 통신적 응집도 < 순차적 응집도 <기능적 응집도", "accept_answers": ["응집도 낮음에서 응집도 높음의 순서", "나쁜 품질", "좋은 품질"]}
{"doc_id": "theory_037", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "해더", "abbreviations": [], "description": "문서이름, 제품이름 , 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등의 정보", "accept_answers": ["해더"]}
{"doc_id": "theory_038", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "개요", "abbreviations": [], "description": "제품 및 변경에 대한 간략한 전반적 개요", "accept_answers": ["개요"]}
{"doc_id": "theory_039", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "목적", "abbreviations": [], "description": "릴리스 버전의 새로운 기능목록과 릴리스 노트의 목적에 대한 개요, 버그 수정 및 새로운 기능 기술", "accept_answers": ["목적"]}
{"doc_id": "theory_040", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "이슈 요약", "abbreviations": [], "description": "버그의 간단한 설명 또는 릴리즈 추가 항목 요약", "accept_answers": ["이슈 요약"]}
{"doc_id": "theory_041", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "재현 항목", "abbreviations": [], "description": "버그 발견에 따른 재현 단계 기술", "accept_answers": ["재현 항목"]}
{"doc_id": "theory_042", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "수정 . 개선 내용", "abbreviations": [], "description": "수정 . 개선의 간단한 설명 기술", "accept_answers": ["수정 . 개선 내용"]}
{"doc_id": "theory_043", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "사용자 영향도", "abbreviations": [], "description": "버전 변경에 따른 최종 사용자 기준의 기능 및 응용 프로그램상의 영향도 기술", "accept_answers": ["사용자 영향도"]}
{"doc_id": "theory_044", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "소프트웨어 지원 영향도", "abbreviations": [], "description": "버전 변경에 따른 소프트웨어의 지원 프로세스 및 영향도 기술", "accept_answers": ["소프트웨어 지원 영향도"]}
{"doc_id": "theory_045", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "노트", "abbreviations": [], "description": "소프트웨어 및 하드웨어 설치 항목, 제품 문서를 포함한 업그레이드 항목 메모", "accept_answers": ["노트"]}
{"doc_id": "theory_046", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "면책 조항", "abbreviations": [], "description": "회사 및 표준 제품과 관련된 메세지, 프리웨어 및 불법 복제 방지, 중복 등 참조에 대한 고지 사항", "accept_answers": ["면책 조항"]}
{"doc_id": "theory_047", "category": "소프트웨어공학", "subcategory": "릴리즈 노트의 주요 작성 항목", "term": "연락 정보", "abbreviations": [], "description": "사용자 지원 및 문의에 관련한 연락처 정보", "accept_answers": ["연락 정보"]}
{"doc_id": "theory_048", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "응용 계층", "abbreviations": ["Application Layer"], "description": "사용자와 네트워크 간 응용서비스 연결, 데이터 생성", "accept_answers": ["응용 계층", "Application Layer"]}
{"doc_id": "theory_049", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "표현 계층", "abbreviations": ["Presentation Layer"], "description": "데이터 형식 설정, 부호교환, 암.복호화", "accept_answers": ["표현 계층", "Presentation Layer"]}
{"doc_id": "theory_050", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "세션 계층", "abbreviations": ["Session Layer"], "description": "송수신 간의 논리적 연결 / 연결 접속, 동기제어", "accept_answers": ["세션 계층", "Session Layer"]}
{"doc_id": "theory_051", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "전송 계층", "abbreviations": ["Transport Layer"], "description": "송수신 프로세스 간의 연결 / 신뢰성 있는 통신 보장 / 데이터 분할, 제조립, 흐름제어, 오류 제어, 혼잡 제어", "accept_answers": ["전송 계층", "Transport Layer"]}
{"doc_id": "theory_052", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "네트워크 계층", "abbreviations": ["Network Layer"], "description": "단말기 간 데이터를 전송하기 위한 최적화된 경로 제공", "accept_answers": ["네트워크 계층", "Network Layer"]}
{"doc_id": "theory_053", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "데이터링크 계층", "abbreviations": ["DataLink Layer"], "description": "인접 시스템 간 데이터 전송, 전송 오류 제어 / 동기화, 오류 제어, 흐름 제어, 회선 제어", "accept_answers": ["데이터링크 계층", "DataLink Layer"]}
{"doc_id": "theory_054", "category": "운영체제", "subcategory": "OSI 7계층의 특징", "term": "물리 계층", "abbreviations": ["Physical Layer"], "description": "0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환", "accept_answers": ["물리 계층", "Physical Layer"]}
{"doc_id": "theory_055", "category": "데이터베이스", "subcategory": "비즈니스 연속성 계획(BCP)의 주요 용어", "term": "BIA", "abbreviations": ["Business Impact Analysis"], "description": "장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석", "accept_answers": ["BIA", "Business Impact Analysis"]}
{"doc_id": "theory_056", "category": "데이터베이스", "subcategory": "비즈니스 연속성 계획(BCP)의 주요 용어", "term": "RTO", "abbreviations": ["Recovery Time Objective"], "description": "업무중단 시점부터 업무가 복구되어 다시 가동될 때까지의 시간", "accept_answers": ["RTO", "Recovery Time Objective"]}
{"doc_id": "theory_057", "category": "데이터베이스", "subcategory": "비즈니스 연속성 계획(BCP)의 주요 용어", "term": "RPO", "abbreviations": ["Recovery Point Objective"], "description": "업무중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점", "accept_answers": ["RPO", "Recovery Point Objective"]}
{"doc_id": "theory_058", "category": "데이터베이스", "subcategory": "비즈니스 연속성 계획(BCP)의 주요 용어", "term": "DRP", "abbreviations": ["Disaster Recovery Plan"], "description": "재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획", "accept_answers": ["DRP", "Disaster Recovery Plan"]}
{"doc_id": "theory_059", "category": "데이터베이스", "subcategory": "비즈니스 연속성 계획(BCP)의 주요 용어", "term": "DRS", "abbreviations": ["Disaster Recovery System"], "description": "재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적,물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터", "accept_answers": ["DRS", "Disaster Recovery System"]}
{"doc_id": "theory_060", "category": "프로그래밍", "subcategory": "AJAX(Asynchronous JavaScript and XML) 비동기 통신 기법", "term": "AJAX 비동기 통신 기법", "abbreviations": ["Asynchronous JavaScript and XML"], "description": "- 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지 일부만을 위한 데이터를 로드하는 기법", "accept_answers": ["AJAX 비동기 통신 기법", "Asynchronous JavaScript and XML"]}
{"doc_id": "theory_061", "category": "소프트웨어공학", "subcategory": "소프트웨어 개발방법론 종류", "term": "구조적 방법론", "abbreviations": ["Structured Development"], "description": "전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론", "accept_answers": ["구조적 방법론", "Structured Development"]}
{"doc_id": "theory_062", "category": "소프트웨어공학", "subcategory": "소프트웨어 개발방법론 종류", "term": "정보공학 방법론", "abbreviations": ["Information Engineering Development"], "description": "정보시스템 개발에 필요한 관리 절차와 작업 기반을 체계화한 방법론", "accept_answers": ["정보공학 방법론", "Information Engineering Development"]}
{"doc_id": "theory_063", "category": "소프트웨어공학", "subcategory": "소프트웨어 개발방법론 종류", "term": "개체지향 방법론", "abbreviations": ["Object-Oriented Development"], "description": "'객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론", "accept_answers": ["개체지향 방법론", "Object-Oriented Development"]}
{"doc_id": "theory_064", "category": "소프트웨어공학", "subcategory": "소프트웨어 개발방법론 종류", "term": "컴포넌트 기반 방법론", "abbreviations": ["CBD", "Component Based Development"], "description": "소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론", "accept_answers": ["컴포넌트 기반 방법론", "CBD", "Component Based Development"]}
{"doc_id": "theory_065", "category": "소프트웨어공학", "subcategory": "소프트웨어 개발방법론 종류", "term": "애자일 방법론", "abbreviations": ["Agile Development"], "description": "절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론", "accept_answers": ["애자일 방법론", "Agile Development"]}
{"doc_id": "theory_066", "category": "네트워크", "subcategory": "IPSec의 주요 프로토콜", "term": "인증 프로토콜", "abbreviations": ["AH"], "description": "메세지 인증 코드(MAC)를 이용하여 인증과 송신처 인증을 제공해주는 프로토콜로 기밀성(암호화)은 제공하지 않는 프로토콜", "accept_answers": ["인증 프로토콜", "AH"]}
{"doc_id": "theory_067", "category": "네트워크", "subcategory": "IPSec의 주요 프로토콜", "term": "암호화 프로토콜", "abbreviations": ["ESP"], "description": "메세지 인증 코드(MAC)와 암호화를 이용하여 인증과 송신처 인증과 기밀성을 제공하는 프로토콜", "accept_answers": ["암호화 프로토콜", "ESP"]}
{"doc_id": "theory_068", "category": "네트워크", "subcategory": "IPSec의 주요 프로토콜", "term": "키 관리 프로토콜", "abbreviations": ["IKE"], "description": "Key를 주고 받는 알고리즘 / 공개된 네트워크를 통하여 Key를 어떻게 할 것인가를 정의", "accept_answers": ["키 관리 프로토콜", "IKE"]}
{"doc_id": "theory_069", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Mediator", "abbreviations": [], "description": "객체지향 설계에서 객체 수가 많아지면 서로 간 통신을 위해 복잡해져서 객체지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기에 중간에서 이를 통제하고 지시할 수 있는 역할의 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도를 줄여 객체지향의 목표를 달성하게 해줌", "accept_answers": ["Mediator"]}
{"doc_id": "theory_070", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Interpreter", "abbreviations": [], "description": "언어의 다양한 해석, 구체적으로 구문을 나누고, 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만듬", "accept_answers": ["Interpreter"]}
{"doc_id": "theory_071", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Iterator", "abbreviations": [], "description": "컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어가있는 모든 항목에 접근할 방법을 제공", "accept_answers": ["Iterator"]}
{"doc_id": "theory_072", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Template Method", "abbreviations": [], "description": "어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꿈", "accept_answers": ["Template Method"]}
{"doc_id": "theory_073", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Observer", "abbreviations": [], "description": "한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법", "accept_answers": ["Observer"]}
{"doc_id": "theory_074", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "State", "abbreviations": [], "description": "객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식", "accept_answers": ["State"]}
{"doc_id": "theory_075", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Visitor", "abbreviations": [], "description": "각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만듬", "accept_answers": ["Visitor"]}
{"doc_id": "theory_076", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Command", "abbreviations": [], "description": "실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용이 높은 클래스를 설계", "accept_answers": ["Command"]}
{"doc_id": "theory_077", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Strategy", "abbreviations": [], "description": "알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴", "accept_answers": ["Strategy"]}
{"doc_id": "theory_078", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Memento", "abbreviations": [], "description": "클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴", "accept_answers": ["Memento"]}
{"doc_id": "theory_079", "category": "소프트웨어공학", "subcategory": "디자인 패턴 중 행위 패턴", "term": "Chain of Responsibility", "abbreviations": [], "description": "정적으로 어떤 기능에 대한 처리의 연결이 하드 코딩되어 있을 때 기능처리의 연결 변경이 불가능한데, 이를 동적으로 연결된 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴", "accept_answers": ["Chain of Responsibility"]}
{"doc_id": "theory_080", "category": "기타", "subcategory": "안드로이드의 특징", "term": "리눅스 기반", "abbreviations": [], "description": "안드로이드는 리눅스 커널 위에서 동작", "accept_answers": ["리눅스 기반"]}
{"doc_id": "theory_081", "category": "기타", "subcategory": "안드로이드의 특징", "term": "자바와 코틀린 언어", "abbreviations": [], "description": "고수준 언어를 사용해 응용 프로그램을 작성", "accept_answers": ["자바와 코틀린 언어"]}
{"doc_id": "theory_082", "category": "기타", "subcategory": "안드로이드의 특징", "term": "런타임 라이브러리", "abbreviations": [], "description": "컴파일된 바이트 코드 구동 기능", "accept_answers": ["런타임 라이브러리"]}
{"doc_id": "theory_083", "category": "기타", "subcategory": "안드로이드의 특징", "term": "안드로이드 소프트웨어 개발", "abbreviations": [], "description": "응용 프로그램을 개발하는데 필요한 각종 도구와 API를 제공", "accept_answers": ["안드로이드 소프트웨어 개발"]}
{"doc_id": "theory_084", "category": "네트워크", "subcategory": "SOAP(Simple Object Access Protocol)", "term": "SOAP", "abbreviations": ["Simple Object Access Protocol"], "description": "SOAP는 HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메세지를 네트워크 상태에서 교환하는 프로토콜", "accept_answers": ["SOAP", "Simple Object Access Protocol"]}
{"doc_id": "theory_085", "category": "기타", "subcategory": "입력 데이터 검증 및 표현에 대한 취약점", "term": "XSS", "abbreviations": ["Cross Site Script"], "description": "검증되지 않은 외부 입력 데이터가 포함된 웹 페이지가 전송되는 경우, 사용자가 해당 웹 페이지를 열람함으로써 웹 페이지에 포함된 부적절한 스크립트가 실행되는 공격", "accept_answers": ["XSS", "Cross Site Script"]}
{"doc_id": "theory_086", "category": "기타", "subcategory": "입력 데이터 검증 및 표현에 대한 취약점", "term": "사이트 간 요청 위조", "abbreviations": ["CSRF"], "description": "사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 하는 공격", "accept_answers": ["사이트 간 요청 위조", "CSRF"]}
{"doc_id": "theory_087", "category": "기타", "subcategory": "입력 데이터 검증 및 표현에 대한 취약점", "term": "SQL 삽입", "abbreviations": ["Injection"], "description": "응용 프로그램의 보안 취약점을 이용해서 악의적인 sql 구문을 삽입, 실행시켜서 데이터베이스의 접근을 통해 정보를 탕취하거나 조작 등을 행위하는 공격 기법", "accept_answers": ["SQL 삽입", "Injection"]}
{"doc_id": "theory_088", "category": "소프트웨어공학", "subcategory": "UI 설계 원칙", "term": "직관성", "abbreviations": ["Intuitiveness"], "description": "누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 함", "accept_answers": ["직관성", "Intuitiveness"]}
{"doc_id": "theory_089", "category": "소프트웨어공학", "subcategory": "UI 설계 원칙", "term": "유효성", "abbreviations": ["Effciency"], "description": "정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작", "accept_answers": ["유효성", "Effciency"]}
{"doc_id": "theory_090", "category": "소프트웨어공학", "subcategory": "UI 설계 원칙", "term": "학습성", "abbreviations": ["Learnability"], "description": "초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작", "accept_answers": ["학습성", "Learnability"]}
{"doc_id": "theory_091", "category": "소프트웨어공학", "subcategory": "UI 설계 원칙", "term": "유연성", "abbreviations": ["Flexibility"], "description": "사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작", "accept_answers": ["유연성", "Flexibility"]}
{"doc_id": "theory_092", "category": "기타", "subcategory": "LOD(Linked Open Data)", "term": "LOD", "abbreviations": ["Linked Open Data"], "description": "웹상에 존재하는 데이터를 개별 RUI(Uniform Resource Identifier)로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 데이터", "accept_answers": ["LOD", "Linked Open Data"]}
{"doc_id": "theory_093", "category": "기타", "subcategory": "데이터모델링의 절차", "term": "개념적 데이터 모델", "abbreviations": ["Conceptual Data Modeling"], "description": "현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델", "accept_answers": ["개념적 데이터 모델", "Conceptual Data Modeling"]}
{"doc_id": "theory_094", "category": "기타", "subcategory": "데이터모델링의 절차", "term": "논리적 데이터 모델", "abbreviations": ["Logical Data Modeling"], "description": "업무의 모습을 모델링 표기법으로 형상화화여 사람이 이해하기 쉽게 표현한 데이터 모델", "accept_answers": ["논리적 데이터 모델", "Logical Data Modeling"]}
{"doc_id": "theory_095", "category": "기타", "subcategory": "데이터모델링의 절차", "term": "물리적 모델", "abbreviations": ["Physical Data Modeling"], "description": "논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 모델", "accept_answers": ["물리적 모델", "Physical Data Modeling"]}
{"doc_id": "theory_096", "category": "소프트웨어공학", "subcategory": "형상관리의 절차", "term": "형상 식별", "abbreviations": [], "description": "형상 관리 대상을 정의 및 식별하는 활동", "accept_answers": ["형상 식별"]}
{"doc_id": "theory_097", "category": "소프트웨어공학", "subcategory": "형상관리의 절차", "term": "형상 통제", "abbreviations": [], "description": "형상 항목의 버전 관리를 위한 형상통제위원회 운영", "accept_answers": ["형상 통제"]}
{"doc_id": "theory_098", "category": "소프트웨어공학", "subcategory": "형상관리의 절차", "term": "형상 감사", "abbreviations": [], "description": "소프트웨어 베이스라인의 무결성 평가", "accept_answers": ["형상 감사"]}
{"doc_id": "theory_099", "category": "소프트웨어공학", "subcategory": "형상관리의 절차", "term": "형상 기록", "abbreviations": [], "description": "소프트웨어 형상 및 변경관리에 대한 각종 수행결과를 기록", "accept_answers": ["형상 기록"]}
{"doc_id": "theory_100", "category": "소프트웨어공학", "subcategory": "리팩토링의 목적", "term": "유지보수성 향상", "abbreviations": [], "description": "복잡한 코드의 단순화, 소스의 가독성 향상", "accept_answers": ["유지보수성 향상"]}
{"doc_id": "theory_101", "category": "소프트웨어공학", "subcategory": "리팩토링의 목적", "term": "유연한 시스템", "abbreviations": [], "description": "소프트웨어 요구사항 변경에 유연한 대응", "accept_answers": ["유연한 시스템"]}
{"doc_id": "theory_102", "category": "소프트웨어공학", "subcategory": "리팩토링의 목적", "term": "생산성 향상", "abbreviations": [], "description": "정제 및 최적화된 소스의 재사용", "accept_answers": ["생산성 향상"]}
{"doc_id": "theory_103", "category": "소프트웨어공학", "subcategory": "리팩토링의 목적", "term": "품질 향상", "abbreviations": [], "description": "소프트웨어 오류발견이 용이하여 품질향상", "accept_answers": ["품질 향상"]}
{"doc_id": "theory_104", "category": "운영체제", "subcategory": "OSPF의 특징", "term": "다익스트라 알고리즘 사용", "abbreviations": [], "description": "다익스트라 알고리즘을 사용하는 내부 라우팅 프로토콜", "accept_answers": ["다익스트라 알고리즘 사용"]}
{"doc_id": "theory_105", "category": "운영체제", "subcategory": "OSPF의 특징", "term": "라우팅 메트릭 지정", "abbreviations": [], "description": "최조, 지연 , 최대 처리량 등 관리자가 라우팅 메트릭 지정", "accept_answers": ["라우팅 메트릭 지정"]}
{"doc_id": "theory_106", "category": "운영체제", "subcategory": "OSPF의 특징", "term": "AS분할 사용", "abbreviations": [], "description": "자치 시스템을 지역으로 나누어 라우팅을 효과적으로 관리", "accept_answers": ["AS분할 사용"]}
{"doc_id": "theory_107", "category": "운영체제", "subcategory": "OSPF의 특징", "term": "홉 카운트 무제한", "abbreviations": [], "description": "홉 카운트에 제한이 없음", "accept_answers": ["홉 카운트 무제한"]}
{"doc_id": "theory_108", "category": "네트워크", "subcategory": "ICMP(Internet Control Message Protocol)", "term": "ICMP", "abbreviations": ["Internet Control Message Protocol"], "description": "IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜로, 메세지 형식은 8비트의 헤더와 가변 길이의 데이터 영역으로 분리되어 있음", "accept_answers": ["ICMP", "Internet Control Message Protocol"]}
{"doc_id": "theory_109", "category": "기타", "subcategory": "식별자 표기법", "term": "가멜 표기법", "abbreviations": [], "description": "식별자 표기 시에 여러 단어가 이어지면 첫 단어 시작만 소문자로 표시하고, 각 단어의 첫 글자는 대문자로 지정하는 표기법 (ex : goodMan)", "accept_answers": ["가멜 표기법"]}
{"doc_id": "theory_110", "category": "기타", "subcategory": "식별자 표기법", "term": "파스칼 표기법", "abbreviations": [], "description": "식별자 표기 시에 여러 단어가 이어지면 각 단어의 첫 글자는 대문자로 지정하는 표기법", "accept_answers": ["파스칼 표기법"]}
{"doc_id": "theory_111", "category": "기타", "subcategory": "식별자 표기법", "term": "식별자 표기법", "abbreviations": [], "description": "(ex : GoodMan)", "accept_answers": ["식별자 표기법"]}
{"doc_id": "theory_112", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "동등분할 테스트", "abbreviations": [], "description": "입력 데이터의 영역을 유사한 도메인별로 유효 값/ 무효 값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법", "accept_answers": ["동등분할 테스트"]}
{"doc_id": "theory_113", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "경곗값 분석 테스트", "abbreviations": [], "description": "등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법", "accept_answers": ["경곗값 분석 테스트"]}
{"doc_id": "theory_114", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "결정 테이블 테스트", "abbreviations": [], "description": "요구사항의 논리와 발생 조건을 테이블 형태로 나열하여 조건과 행위를 모두 조합하여 테스트하는 기법", "accept_answers": ["결정 테이블 테스트"]}
{"doc_id": "theory_115", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "상태 전이 테스트", "abbreviations": [], "description": "테스트 대상, 시스템이나 객체의 상태를 구분하고 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법", "accept_answers": ["상태 전이 테스트"]}
{"doc_id": "theory_116", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "유스케이스 테스트", "abbreviations": [], "description": "시스템이 실제 사용되는 유스케이스로 모델링 되어있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법", "accept_answers": ["유스케이스 테스트"]}
{"doc_id": "theory_117", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "분류 트리 테스트", "abbreviations": [], "description": "SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법", "accept_answers": ["분류 트리 테스트"]}
{"doc_id": "theory_118", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "페어와이즈 테스트", "abbreviations": [], "description": "테스트 데이터값 간에 최소한 한번씩 조합하는 방식", "accept_answers": ["페어와이즈 테스트"]}
{"doc_id": "theory_119", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "원인-결과 그래프 테스트", "abbreviations": [], "description": "그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법", "accept_answers": ["원인-결과 그래프 테스트"]}
{"doc_id": "theory_120", "category": "소프트웨어공학", "subcategory": "블랙박스 테스트의 유형", "term": "비교 테스트", "abbreviations": [], "description": "여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법", "accept_answers": ["비교 테스트"]}
{"doc_id": "theory_121", "category": "네트워크", "subcategory": "EAI의 구축 유형", "term": "포인트 투 포인트", "abbreviations": [], "description": "가장 기초적인 애플리케이션 통합방법으로 1:1 단순 통합방법", "accept_answers": ["포인트 투 포인트"]}
{"doc_id": "theory_122", "category": "네트워크", "subcategory": "EAI의 구축 유형", "term": "허브 앤 스포크", "abbreviations": [], "description": "단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식", "accept_answers": ["허브 앤 스포크"]}
{"doc_id": "theory_123", "category": "네트워크", "subcategory": "EAI의 구축 유형", "term": "메시지 버스", "abbreviations": [], "description": "애플리케이션 사이 미들웨어(버스)를 두어 연계하는 미들웨어 통합 방식", "accept_answers": ["메시지 버스"]}
{"doc_id": "theory_124", "category": "네트워크", "subcategory": "EAI의 구축 유형", "term": "하이브리드", "abbreviations": [], "description": "그룹 내부는 허브 앤 스포크 방식을 사용하고, 그룹 간에는 메세지 버스 방식을 사용하는 통합 방식", "accept_answers": ["하이브리드"]}
{"doc_id": "theory_125", "category": "네트워크", "subcategory": "IPv4 주소", "term": "IPv4 주소", "abbreviations": [], "description": "- 주소체계는 10진수로 총 12자리이며, 네 부분으로 나뉜다.", "accept_answers": ["IPv4 주소"]}
{"doc_id": "theory_126", "category": "소프트웨어공학", "subcategory": "디자인 패턴의 유형", "term": "디자인 패턴의 유형", "abbreviations": [], "description": "목적", "accept_answers": ["디자인 패턴의 유형"]}
{"doc_id": "theory_127", "category": "알고리즘", "subcategory": "하둡(Hadoop)의 구성", "term": "하둡 분산 파일 시스템", "abbreviations": ["HDFS"], "description": "대용량 파일을 분산된 서버에 저장하고 그 저장된 데이터를 빠르게 처리할 수 있게 하는 시스템", "accept_answers": ["하둡 분산 파일 시스템", "HDFS"]}
{"doc_id": "theory_128", "category": "알고리즘", "subcategory": "하둡(Hadoop)의 구성", "term": "맵리듀스", "abbreviations": ["Map Reduce"], "description": "대용량 데이터 세트를 분산 병렬 컴퓨팅에서 처리하거나 생성하기 위한 목적으로 만들어진 소프트웨어 프레임워크", "accept_answers": ["맵리듀스", "Map Reduce"]}
{"doc_id": "theory_129", "category": "데이터베이스", "subcategory": "데이터베이스 이상 현상", "term": "삽입 이상", "abbreviations": [], "description": "정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우", "accept_answers": ["삽입 이상"]}
{"doc_id": "theory_130", "category": "데이터베이스", "subcategory": "데이터베이스 이상 현상", "term": "삭제 이상", "abbreviations": [], "description": "정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우", "accept_answers": ["삭제 이상"]}
{"doc_id": "theory_131", "category": "데이터베이스", "subcategory": "데이터베이스 이상 현상", "term": "갱신 이상", "abbreviations": [], "description": "중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우", "accept_answers": ["갱신 이상"]}
{"doc_id": "theory_132", "category": "운영체제", "subcategory": "프로세스 상태 전이", "term": "생성 상태", "abbreviations": [], "description": "사용자에 의해 프로세스가 생성된 상태", "accept_answers": ["생성 상태"]}
{"doc_id": "theory_133", "category": "운영체제", "subcategory": "프로세스 상태 전이", "term": "준비 상태", "abbreviations": [], "description": "CPU를 할당받을 수 있는 상태", "accept_answers": ["준비 상태"]}
{"doc_id": "theory_134", "category": "운영체제", "subcategory": "프로세스 상태 전이", "term": "살행 상태", "abbreviations": [], "description": "프로세스가 CPU를 할당받아 동작 중인 상태", "accept_answers": ["살행 상태"]}
{"doc_id": "theory_135", "category": "운영체제", "subcategory": "프로세스 상태 전이", "term": "대기 상태", "abbreviations": [], "description": "프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태", "accept_answers": ["대기 상태"]}
{"doc_id": "theory_136", "category": "운영체제", "subcategory": "프로세스 상태 전이", "term": "완료 상태", "abbreviations": [], "description": "프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태", "accept_answers": ["완료 상태"]}
{"doc_id": "theory_137", "category": "소프트웨어공학", "subcategory": "테스트 오라클 유형", "term": "참 오라클", "abbreviations": [], "description": "모든 입력값에 대하여 기대하는 결과를 생성함으로써 발행된 오류를 모두 검출할 수 있는 오라클", "accept_answers": ["참 오라클"]}
{"doc_id": "theory_138", "category": "소프트웨어공학", "subcategory": "테스트 오라클 유형", "term": "샘플링 오라클", "abbreviations": [], "description": "특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클", "accept_answers": ["샘플링 오라클"]}
{"doc_id": "theory_139", "category": "소프트웨어공학", "subcategory": "테스트 오라클 유형", "term": "휴리스틱 오라클", "abbreviations": [], "description": "샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클", "accept_answers": ["휴리스틱 오라클"]}
{"doc_id": "theory_140", "category": "소프트웨어공학", "subcategory": "테스트 오라클 유형", "term": "일관성 검사 오라클", "abbreviations": [], "description": "애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클", "accept_answers": ["일관성 검사 오라클"]}
{"doc_id": "theory_141", "category": "네트워크", "subcategory": "네트워크 계층(3계층) 프로토콜 종류", "term": "IP", "abbreviations": ["Internet Protocol"], "description": "송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜", "accept_answers": ["IP", "Internet Protocol"]}
{"doc_id": "theory_142", "category": "네트워크", "subcategory": "네트워크 계층(3계층) 프로토콜 종류", "term": "ARP", "abbreviations": ["Address Resolution Protocol"], "description": "IP 네트워크상에서 IP 주소를 MAC 주소(물리 주소)로 변환하는 프로토콜", "accept_answers": ["ARP", "Address Resolution Protocol"]}
{"doc_id": "theory_143", "category": "네트워크", "subcategory": "네트워크 계층(3계층) 프로토콜 종류", "term": "RARP", "abbreviations": ["Reverse Address Resolution Protocol"], "description": "IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜", "accept_answers": ["RARP", "Reverse Address Resolution Protocol"]}
{"doc_id": "theory_144", "category": "네트워크", "subcategory": "네트워크 계층(3계층) 프로토콜 종류", "term": "ICMP", "abbreviations": ["Internet Control Message Protocol"], "description": "IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜 메세지 형식은 8bit 헤더와 가변 길이의 데이터 영역으로 분리", "accept_answers": ["ICMP", "Internet Control Message Protocol"]}
{"doc_id": "theory_145", "category": "네트워크", "subcategory": "네트워크 계층(3계층) 프로토콜 종류", "term": "IGMP", "abbreviations": ["Internet Group Management Protocol"], "description": "인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜", "accept_answers": ["IGMP", "Internet Group Management Protocol"]}
{"doc_id": "theory_146", "category": "네트워크", "subcategory": "네트워크 계층(3계층) 프로토콜 종류", "term": "라우팅 프로토콜", "abbreviations": ["Routing Protocol"], "description": "데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해 주는 라우터 간의 상호 통신 프로토콜", "accept_answers": ["라우팅 프로토콜", "Routing Protocol"]}
{"doc_id": "theory_147", "category": "데이터베이스", "subcategory": "DB설계 절차", "term": "요구사항 분석", "abbreviations": [], "description": "사용자에게서 데이터베이스를 사용하는 용도를 파악", "accept_answers": ["요구사항 분석"]}
{"doc_id": "theory_148", "category": "데이터베이스", "subcategory": "DB설계 절차", "term": "개념적 설계", "abbreviations": [], "description": "요구사항 명세서를 기반으로 개념적 데이터 모델을 표현하며 E-R다이어그램으로 표현할 수 있음", "accept_answers": ["개념적 설계"]}
{"doc_id": "theory_149", "category": "데이터베이스", "subcategory": "DB설계 절차", "term": "논리적 설계", "abbreviations": [], "description": "목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행함", "accept_answers": ["논리적 설계"]}
{"doc_id": "theory_150", "category": "데이터베이스", "subcategory": "DB설계 절차", "term": "물리적 설계", "abbreviations": [], "description": "특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 저의서 등이 있음", "accept_answers": ["물리적 설계"]}
{"doc_id": "theory_151", "category": "데이터베이스", "subcategory": "DB설계 절차", "term": "구현", "abbreviations": [], "description": "SQL문을 실행하여 데이터베이스를 실제로 생성함", "accept_answers": ["구현"]}
{"doc_id": "theory_152", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "단위 테스트", "abbreviations": [], "description": "사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계 (개발)", "accept_answers": ["단위 테스트"]}
{"doc_id": "theory_153", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "통합 테스트", "abbreviations": [], "description": "단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계 (설계)", "accept_answers": ["통합 테스트"]}
{"doc_id": "theory_154", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "시스템 테스트", "abbreviations": [], "description": "통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 단계 (기계 명세 분석)", "accept_answers": ["시스템 테스트"]}
{"doc_id": "theory_155", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "인수 테스트", "abbreviations": [], "description": "계약상의 요구사항이 만족하였는지 확인하기 위한 테스트 단계 (요구사항 분석)", "accept_answers": ["인수 테스트"]}
{"doc_id": "theory_156", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "알파 테스트", "abbreviations": [], "description": "선택된 사용자가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트", "accept_answers": ["알파 테스트"]}
{"doc_id": "theory_157", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "베타 테스트", "abbreviations": [], "description": "실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트", "accept_answers": ["베타 테스트"]}
{"doc_id": "theory_158", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "회귀 테스트", "abbreviations": [], "description": "회귀 테스트는 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정 때문에 새로이 유입된 오류가 없는", "accept_answers": ["회귀 테스트"]}
{"doc_id": "theory_159", "category": "소프트웨어공학", "subcategory": "테스트 레벨 종류", "term": "테스트 레벨 종류", "abbreviations": [], "description": "지 확인하는 일종의 반복 테스트 기법", "accept_answers": ["테스트 레벨 종류"]}
{"doc_id": "theory_160", "category": "운영체제", "subcategory": "IPC  기법", "term": "메시지 큐", "abbreviations": [], "description": "메시지 단위로 동작하여 프로세스 간 통신함", "accept_answers": ["메시지 큐"]}
{"doc_id": "theory_161", "category": "운영체제", "subcategory": "IPC  기법", "term": "공유메모리", "abbreviations": [], "description": "한 프로세스의 일부분을 다른 프로세스와 공유", "accept_answers": ["공유메모리"]}
{"doc_id": "theory_162", "category": "운영체제", "subcategory": "IPC  기법", "term": "소켓", "abbreviations": [], "description": "클라이언트와 서버 프로세스 둘 사이에 통신을 가능하게 함", "accept_answers": ["소켓"]}
{"doc_id": "theory_163", "category": "운영체제", "subcategory": "IPC  기법", "term": "세마포어", "abbreviations": [], "description": "프로세스 사이의 동기를 맞추는 기능을 제공함", "accept_answers": ["세마포어"]}
{"doc_id": "theory_164", "category": "기타", "subcategory": "데이터 모델 구성요소", "term": "연산", "abbreviations": [], "description": "데이터베이스에서 저장된 실제 데이터를 처리하는 작업에 대한 명세", "accept_answers": ["연산"]}
{"doc_id": "theory_165", "category": "기타", "subcategory": "데이터 모델 구성요소", "term": "구조", "abbreviations": [], "description": "논리적으로 표현된 개체 타입 간의 관계", "accept_answers": ["구조"]}
{"doc_id": "theory_166", "category": "기타", "subcategory": "데이터 모델 구성요소", "term": "제약조건", "abbreviations": [], "description": "데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약조건", "accept_answers": ["제약조건"]}
{"doc_id": "theory_167", "category": "정보보안", "subcategory": "서버 접근통제 유형", "term": "임의적 접근통제", "abbreviations": ["DAC", "Discretionary Access Control"], "description": "시스템에 대한 접근을 사용자/그룹의 신분 기반으로 제한하는 방법", "accept_answers": ["임의적 접근통제", "DAC", "Discretionary Access Control"]}
{"doc_id": "theory_168", "category": "정보보안", "subcategory": "서버 접근통제 유형", "term": "강제적 접근통제", "abbreviations": ["MAC", "Mandatory Access Control"], "description": "시스템 정보의 허용등급을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법", "accept_answers": ["강제적 접근통제", "MAC", "Mandatory Access Control"]}
{"doc_id": "theory_169", "category": "정보보안", "subcategory": "서버 접근통제 유형", "term": "역할 기반 접근통제", "abbreviations": ["RBAC", "Role Based Access Control"], "description": "중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법", "accept_answers": ["역할 기반 접근통제", "RBAC", "Role Based Access Control"]}
{"doc_id": "theory_170", "category": "데이터베이스", "subcategory": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "term": "테이블 병합", "abbreviations": [], "description": "1:1관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능을 향상", "accept_answers": ["테이블 병합"]}
{"doc_id": "theory_171", "category": "데이터베이스", "subcategory": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "term": "테이블 분할", "abbreviations": [], "description": "테이블을 수직 또는 수평으로 분할하는 것으로 파티셔닝이라고 함", "accept_answers": ["테이블 분할"]}
{"doc_id": "theory_172", "category": "데이터베이스", "subcategory": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "term": "중복 테이블 추가", "abbreviations": [], "description": "대량의 데이터들에 대한 집계 함수(group by, sum 등)를 사용하여 실시간 통계 정보를 계산하는 경우에 효과적인 수행을 위해 별도의 통계 테이블을 두거나 중복 테이블을 추가", "accept_answers": ["중복 테이블 추가"]}
{"doc_id": "theory_173", "category": "데이터베이스", "subcategory": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "term": "컬럼 중복화", "abbreviations": [], "description": "조인 성능 향상을 위해 중복 허용", "accept_answers": ["컬럼 중복화"]}
{"doc_id": "theory_174", "category": "데이터베이스", "subcategory": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "term": "중복 관계 추가", "abbreviations": [], "description": "데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만, 이때 발생할 수 있는 성능 저하를 예방하기 위해 추가적 관계를 맺는 방법", "accept_answers": ["중복 관계 추가"]}
{"doc_id": "theory_175", "category": "데이터베이스", "subcategory": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "term": "반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법", "abbreviations": [], "description": "(", "accept_answers": ["반정규화 반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위입니다.) 의 주요 기법"]}
