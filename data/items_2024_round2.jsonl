{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["NNN"], "raw_text": "NNN"}, "explanation": "Java 배열 참조 비교 문제입니다.\n\n[이미지의 전체 코드]\n\n```java\nclass Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}\n```\n\n[실행 과정]\n\n1. [배열 생성]\n   - `int[] a = new int[]{1, 2, 3, 4};` → 새로운 배열 객체 생성 (주소: 0x1000 가정)\n   - `int[] b = new int[]{1, 2, 3, 4};` → 새로운 배열 객체 생성 (주소: 0x2000 가정)\n   - `int[] c = new int[]{1, 2, 3};` → 새로운 배열 객체 생성 (주소: 0x3000 가정)\n   - **중요**: 내용이 같아도 `new`를 사용하면 **서로 다른 객체** 생성!\n\n2. [`check(a, b)` 호출]\n   - `if (a == b)` 실행\n   - `a`의 주소: 0x1000\n   - `b`의 주소: 0x2000\n   - **0x1000 == 0x2000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n3. [`check(a, c)` 호출]\n   - `if (a == c)` 실행\n   - `a`의 주소: 0x1000\n   - `c`의 주소: 0x3000\n   - **0x1000 == 0x3000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n4. [`check(b, c)` 호출]\n   - `if (b == c)` 실행\n   - `b`의 주소: 0x2000\n   - `c`의 주소: 0x3000\n   - **0x2000 == 0x3000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n[최종 출력] **\"NNN\"**\n\n[핵심 개념]\n\n1. [`==` 연산자의 동작]\n   - 기본 타입(int, char 등): **값** 비교\n   - 참조 타입(배열, 객체 등): **메모리 주소(참조)** 비교\n   - 배열은 참조 타입이므로 `==`는 주소를 비교합니다\n\n2. [배열 비교 방법]\n   ```java\n   // 참조(주소) 비교:\n   a == b  // 같은 객체인지 확인\n   \n   // 내용 비교:\n   Arrays.equals(a, b)  // 배열 내용이 같은지 확인\n   ```\n\n3. [예제]\n   ```java\n   int[] x = new int[]{1, 2, 3};\n   int[] y = new int[]{1, 2, 3};\n   int[] z = x;  // z는 x와 같은 객체를 참조\n   \n   x == y  // false (다른 객체)\n   x == z  // true (같은 객체)\n   Arrays.equals(x, y)  // true (내용 같음)\n   ```\n\n[메모리 구조]\n\n```\n변수      주소        배열 내용\n----      ----        --------\na    →  0x1000  →  [1, 2, 3, 4]\nb    →  0x2000  →  [1, 2, 3, 4]  (내용 같지만 다른 객체)\nc    →  0x3000  →  [1, 2, 3]\n```\n\n[왜 모두 \"N\"인가?]\n\n- 각 배열은 `new`로 생성되어 **서로 다른 메모리 주소**를 가집니다\n- `==` 연산자는 **주소**를 비교하므로 모두 `false`\n- 따라서 모든 `check()` 호출에서 \"N\"이 출력됩니다\n\n[답] **\"NNN\"**", "table_refs": [], "image_refs": ["images/2024_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.025449"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 문제에서 설명하는 용어를 작성하시오.\n데이터를 중복시켜 성능을 향상시키기 위한 기법으로 데이터를 중복 저장하거나 테이블을 합치는 등으로 성능을 향상시키지만 데이터 무결성이 저하될 수 있는 기법", "choices": [], "answer": {"keys": ["반정규화"], "raw_text": "반정규화"}, "explanation": "이 문제는 반정규화(Denormalization)에 대한 문제입니다.\n\n[반정규화(Denormalization)란?]\n\n[정의]\n- 정규화(Normalization)의 반대 개념으로, 데이터베이스 성능 향상을 위해 **의도적으로 중복을 허용**하는 기법\n- 정규화로 인해 분리된 테이블을 다시 합치거나, 중복 데이터를 저장하는 방식\n\n[반정규화의 특징]\n\n1. [성능 향상]\n   - JOIN 연산 감소로 **조회 속도 향상**\n   - 테이블 수 감소로 **쿼리 복잡도 감소**\n   - 자주 조회되는 데이터를 중복 저장하여 **I/O 감소**\n\n2. [데이터 무결성 저하]\n   - 중복 데이터로 인해 **일관성 유지 어려움**\n   - 수정 시 여러 곳을 동시에 업데이트해야 함\n   - 저장 공간 증가\n\n3. [반정규화 기법]\n   - **테이블 합치기**: 1:1 관계나 1:N 관계를 하나의 테이블로 통합\n   - **중복 컬럼 추가**: 자주 조회되는 컬럼을 다른 테이블에 중복 저장\n   - **파생 컬럼 추가**: 계산 결과를 미리 저장 (예: 합계, 평균)\n   - **테이블 분할**: 수평 분할(행 분할) 또는 수직 분할(컬럼 분할)\n\n[정규화 vs 반정규화]\n\n| 구분 | 정규화 | 반정규화 |\n|------|--------|----------|\n| 목적 | 데이터 무결성 | 성능 향상 |\n| 중복 | 제거 | 허용 |\n| 테이블 수 | 증가 | 감소 |\n| 조회 성능 | 저하 (JOIN 증가) | 향상 (JOIN 감소) |\n| 무결성 | 향상 | 저하 |\n\n[답] \"반정규화\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.025449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 SQL에 관한 문제이다.\n아래 SQL 구문의 빈칸을 작성하시오.\n사원 [사원번호(PK), 이름, 나이, 부서]\n부서 [사원번호(PK), 이름, 주소, 나이]\n신입 사원이 들어와서 사원 테이블에 추가 INSERT INTO 사원 (사원번호, 이름, 주소, 부서)   [\n\n①     ] (32431, '정실기', '서울', '영업');\n위에 신입사원을 검색하면서 부서 테이블에 추가 INSERT INTO 부서 (사원번호, 이름, 나이, 부서)\n[\n②\n] 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n전체 사원 테이블 조회 SELECT  *   [\n③\n]   사원;\n퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경 UPDATE 사원   [\n④\n]   부서  =  '퇴사'  WHERE 사원번호  =\n32431;", "choices": [], "answer": {"keys": ["① VALUES", "② SELECT", "③ FROM", "④ SET"], "raw_text": "① VALUES\n② SELECT\n③ FROM\n④ SET"}, "explanation": "이 문제는 **SQL 문법의 기본 키워드**를 묻는 문제입니다.\n\n[각 SQL 문의 빈칸 분석]\n\n1. [① INSERT 문 - VALUES]\n```sql\nINSERT INTO 사원 (사원번호, 이름, 주소, 부서) VALUES (32431, '정실기', '서울', '영업');\n```\n- `INSERT INTO` 문에서 **직접 값을 삽입**할 때는 `VALUES` 키워드를 사용합니다.\n- `VALUES` 다음에 괄호로 묶인 값들을 순서대로 입력합니다.\n\n2. [② INSERT ... SELECT 문 - SELECT]\n```sql\nINSERT INTO 부서 (사원번호, 이름, 나이, 부서)\nSELECT 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n```\n- 다른 테이블에서 **데이터를 조회하여 삽입**할 때는 `SELECT` 문을 사용합니다.\n- `INSERT INTO ... SELECT` 형태로 서브쿼리 결과를 삽입합니다.\n- `FROM` 절이 있으므로 `SELECT` 키워드가 필요합니다.\n\n3. [③ SELECT 문 - FROM]\n```sql\nSELECT * FROM 사원;\n```\n- `SELECT` 문에서 **조회할 테이블을 지정**할 때는 `FROM` 키워드를 사용합니다.\n- `SELECT *`는 모든 컬럼을 조회한다는 의미입니다.\n\n4. [④ UPDATE 문 - SET]\n```sql\nUPDATE 사원 SET 부서 = '퇴사' WHERE 사원번호 = 32431;\n```\n- `UPDATE` 문에서 **컬럼 값을 변경**할 때는 `SET` 키워드를 사용합니다.\n- `SET 컬럼명 = 값` 형태로 값을 설정합니다.\n\n[SQL 문법 요약]\n\n| 문법 | 키워드 | 용도 |\n|------|--------|------|\n| INSERT (직접 값) | VALUES | 직접 값을 삽입 |\n| INSERT (서브쿼리) | SELECT | 조회 결과를 삽입 |\n| SELECT | FROM | 조회할 테이블 지정 |\n| UPDATE | SET | 컬럼 값 변경 |\n\n[답] ① VALUES, ② SELECT, ③ FROM, ④ SET", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 릴레이션의 Cardinality와 Degree를 작성하시오.\nCardinality : (\n\n①  )\nDegree\n: (  ②  )", "choices": [], "answer": {"keys": ["① 5", "② 4"], "raw_text": "① 5\n② 4"}, "explanation": "이 문제는 릴레이션의 Cardinality와 Degree를 구하는 문제입니다.\n\n[Cardinality와 Degree란?]\n\n1. [Cardinality (카디널리티)]\n   - 릴레이션(테이블)에 포함된 튜플(행)의 개수\n   - 즉, **행의 개수**를 의미합니다.\n   - 예: 학생 테이블에 100명의 학생이 있으면 Cardinality = 100\n\n2. [Degree (차수)]\n   - **릴레이션에 포함된 속성(컬럼)의 개수**\n   - 즉, **컬럼의 개수**를 의미합니다.\n   - 예: 학생 테이블에 학번, 이름, 나이, 주소가 있으면 Degree = 4\n\n[문제 분석]\n\n문제에서 제공된 릴레이션 그림을 보면:\n- **행의 개수**: 5개 (튜플 5개)\n- **컬럼의 개수**: 4개 (속성 4개)\n\n[정리]\n- **Cardinality (①)**: 5 (행의 개수)\n- **Degree (②)**: 4 (컬럼의 개수)\n\n[참고]\n- Cardinality는 **동적**: 데이터 삽입/삭제에 따라 변경됨\n- Degree는 **정적**: 스키마가 변경되지 않는 한 고정됨\n\n[답] ① 5, ② 4", "table_refs": [], "image_refs": ["images/2024_round2/Q004_1.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 프로토콜에 대한 내용이다.\n아래 내용을 읽고 알맞는 답을 작성하시오.\n\n- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.\n\n- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.\n\n- AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다.", "choices": [], "answer": {"keys": ["IPSec"], "raw_text": "IPSec"}, "explanation": "IPSec(IP Security)는 네트워크 계층에서 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다\"\n- IPSec은 OSI 7계층 중 3계층(네트워크 계층)에서 동작합니다.\n- IP 패킷 자체를 암호화하여 데이터를 보호합니다.\n- 인증(Authentication)과 암호화(Encryption) 기능을 제공합니다.\n\n2. \"기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다\"\n- VPN(Virtual Private Network) 구축에 사용됩니다.\n- 인터넷을 통해 안전한 사설망을 구축할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등에 활용됩니다.\n\n3. \"AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다\"\n- AH(Authentication Header): 데이터 무결성과 인증을 제공 (암호화 없음)\n- ESP(Encapsulating Security Payload): 암호화와 인증을 모두 제공\n- 두 프로토콜을 개별 또는 조합하여 사용할 수 있습니다.\n\n[IPSec의 작동 방식]\n- 터널 모드(Tunnel Mode): 전체 IP 패킷을 암호화\n- 전송 모드(Transport Mode): 페이로드만 암호화\n\n[답] \"IPSec\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 Python에 대한 문제이다.\n아래 코드를 읽고 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["ab3ca3"], "raw_text": "ab3ca3"}, "explanation": "이 파이썬 코드는 문자열에서 패턴의 출현 횟수를 세는 문제입니다.\n\n[코드 분석]\n\n```python def fnCalculation(x, y):\nresult = 0 for i in range(len(x)):\ntemp = x[i:i+len(y)] # x에서 길이 len(y)만큼 슬라이싱 if temp == y:\nresult += 1 return result\n\na = \"abdcabcabca\"\np1 = \"ab\"\np2 = \"ca\"\nout = f\"ab{fnCalculation(a, p1)}ca{fnCalculation(a, p2)}\"\nprint(out)\n```\n\n[실행 과정]\n\n1. [`fnCalculation(a, \"ab\")` 계산]\n- a = \"abdcabcabca\"\n- i=0: \"ab\" == \"ab\" → result = 1\n- i=1: \"bd\" != \"ab\"\n- i=2: \"dc\" != \"ab\"\n- i=3: \"ca\" != \"ab\"\n- i=4: \"ab\" == \"ab\" → result = 2\n- i=5: \"bc\" != \"ab\"\n- i=6: \"ca\" != \"ab\"\n- i=7: \"ab\" == \"ab\" → result = 3\n- i=8: \"bc\" != \"ab\"\n- i=9: \"ca\" != \"ab\"\n- 결과: **3**\n\n2. [`fnCalculation(a, \"ca\")` 계산]\n- i=0: \"ab\" != \"ca\"\n- i=1: \"bd\" != \"ca\"\n- i=2: \"dc\" != \"ca\"\n- i=3: \"ca\" == \"ca\" → result = 1\n- i=4: \"ab\" != \"ca\"\n- i=5: \"bc\" != \"ca\"\n- i=6: \"ca\" == \"ca\" → result = 2\n- i=7: \"ab\" != \"ca\"\n- i=8: \"bc\" != \"ca\"\n- i=9: \"ca\" == \"ca\" → result = 3\n- 결과: **3**\n\n3. [최종 출력]\n```python out = f\"ab{3}ca{3}\" = \"ab3ca3\"\n```\n\n[답] \"ab3ca3\"", "table_refs": [], "image_refs": ["images/2024_round2/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [{"language": "python", "code": "def fnCalculation(x,y):\n    result = 0;\n    for i in range(len(x)):\n     temp = x[i:i+len(y)] \n     if temp == y:\n       result += 1;\n    return result\na = \"abdcabcabca\"\np1 = \"ab\";\np2 = \"ca\";\nout = f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\"\nprint(out)", "line_numbers": [1, 12], "file": "data/codes/2024_round2/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 설명하는 내용을 확인하여\n\n알맞는 알고리즘을 작성하시오.\n\n- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.\n\n- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.\n\n- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다.", "choices": [], "answer": {"keys": ["AES"], "raw_text": "AES"}, "explanation": "AES(Advanced Encryption Standard)는 고급 암호화 표준으로 대칭키 암호 알고리즘입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다\"\n- AES는 대칭키 암호 알고리즘입니다 (같은 키로 암호화/복호화).\n- 1997년 NIST가 DES의 취약점을 해결하기 위해 공모를 시작했습니다.\n- 2000년 Rijndael 알고리즘이 선택되어 AES로 지정되었습니다.\n- DES(56비트 키)의 취약점을 해결하기 위해 개발되었습니다.\n\n2. \"128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다\"\n- 키 크기: AES-128, AES-192, AES-256 (세 가지 버전)\n- 블록 크기: 항상 128비트 (고정)\n- 키가 길수록 보안성이 높아지지만 성능은 약간 저하됩니다.\n\n3. \"높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다\"\n- DES보다 훨씬 빠르고 안전합니다.\n- 하드웨어와 소프트웨어 모두에서 효율적으로 구현 가능합니다.\n- 현재 가장 널리 사용되는 대칭키 암호 알고리즘입니다.\n- SSL/TLS, Wi-Fi 보안(WPA2), 하드디스크 암호화 등에 사용됩니다.\n\n[AES의 작동 방식]\n- SubBytes: 바이트 치환\n- ShiftRows: 행 이동\n- MixColumns: 열 혼합\n- AddRoundKey: 라운드 키 적용\n\n[답] \"AES\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "패킷 교환 방식 중에 연결형과 비연결형에 해당하는 방식을 작성하시오.\n\n① 연결형 교환 방식\n② 비연결형 교환 방식", "choices": [], "answer": {"keys": ["① 가상회선", "② 데이터그램"], "raw_text": "① 가상회선\n② 데이터그램"}, "explanation": "패킷 교환 방식은 연결형과 비연결형으로 나뉩니다.\n\n① 연결형 교환 방식: 가상회선(Virtual Circuit)[특징]\n- 통신 시작 전에 경로를 설정합니다 (가상 회선 설정).\n- 모든 패킷이 같은 경로로 전송됩니다.\n- 패킷 순서가 보장됩니다.\n- 연결 설정과 해제 과정이 필요합니다.\n- 전화망과 유사한 방식입니다.\n\n[예시]\n- X.25\n- Frame Relay\n- ATM (Asynchronous Transfer Mode)\n\n② 비연결형 교환 방식: 데이터그램(Datagram)[특징]\n- 경로 설정 없이 각 패킷을 독립적으로 전송합니다.\n- 각 패킷은 목적지 주소를 포함하여 독립적으로 라우팅됩니다.\n- 패킷 순서가 보장되지 않을 수 있습니다.\n- 연결 설정/해제 과정이 없습니다.\n- 우편물과 유사한 방식입니다.\n\n[예시]\n- IP (Internet Protocol)\n- UDP (User Datagram Protocol)\n\n[비교]\n- **가상회선**: 연결 설정 필요, 순서 보장, 오버헤드 큼\n- **데이터그램**: 연결 설정 없음, 순서 보장 안 됨, 오버헤드 작음\n\n[답]\n- ① 가상회선 (Virtual Circuit)\n- ② 데이터그램 (Datagram)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "아래 내용을 확인하고 보기에서 알맞는 답을 고르시오.\n실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다.\n한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다.\n\n[보기]\n\nㄱ.  기능적(functional)\n\nㄴ.  우연적(Coincidental)\n\nㄷ.  통신적(Communication)\n\nㄹ.  절차적(Procedural)\n\nㅁ.  시간적(Temporal)\n\nㅂ.  순차적(sequential)\n\nㅅ.    논리적(Logical)", "choices": [], "answer": {"keys": ["ㅂ"], "raw_text": "ㅂ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도 중 순차적 응집도(Sequential Cohesion)를 구분하는 문제입니다.\n\n[문제에서 설명하는 특징]\n\n1. \"실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다\"\n- 순차적 응집도는 기능들이 시간적 순서대로 실행되는 경우입니다.\n\n2. \"한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다\"\n- 한 기능의 출력이 바로 다음 기능의 입력이 되는 파이프라인 형태입니다.\n- 예: 입력 처리 → 데이터 변환 → 출력 처리\n\n[응집도 종류 비교]\n\n- ㄱ. 기능적: 하나의 명확한 기능 수행 (가장 높음)\n- ㄴ. 우연적: 관련성 없는 요소들의 집합 (가장 낮음)\n- ㄷ. 통신적: 같은 데이터를 조작하는 요소들\n- ㄹ. 절차적: 순차적으로 실행되는 요소들\n- ㅁ. 시간적: 특정 시점에 실행되는 요소들\n- ㅂ. 순차적: 출력→입력 파이프라인 형태 ✓\n- ㅅ. 논리적: 논리적으로 비슷한 기능들\n\n[순차적 응집도의 예시]\n- 데이터 입력 → 검증 → 변환 → 저장\n- 이미지 로드 → 리사이즈 → 필터 적용 → 저장\n\n[답] \"ㅂ\" (순차적 응집도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래는 디자인 패턴에 관한 설명이다.\n아래 설명을 읽고 보기에서 알맞는 용어를 작성하시오.\n\n- 컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다.\n\n- 이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\n\n- 반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다.", "choices": [], "answer": {"keys": ["Iterator"], "raw_text": "Iterator"}, "explanation": "Iterator(반복자) 패턴은 컬렉션의 요소에 접근하는 방법을 표준화하는 디자인 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다\"\n- 클라이언트는 컬렉션의 내부 구현(배열, 리스트, 트리 등)을 알 필요가 없습니다.\n- 일관된 방식으로 요소에 접근할 수 있습니다.\n- 캡슐화 원칙을 따릅니다.\n\n2. \"이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\"\n- 컬렉션이 배열이든 리스트든 상관없이 같은 방식으로 접근 가능합니다.\n- 컬렉션의 구현이 바뀌어도 클라이언트 코드는 변경되지 않습니다.\n\n3. \"반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다\"\n- 반복 로직을 Iterator 객체에 위임합니다.\n- 클라이언트는 `hasNext()`, `next()` 같은 표준 메서드만 사용합니다.\n- 의존성 역전 원칙을 따릅니다.\n\n[Iterator 패턴의 구성요소]\n- **Iterator**: 반복 작업을 담당하는 인터페이스\n- **ConcreteIterator**: 구체적인 반복자 구현\n- **Aggregate**: 컬렉션 인터페이스\n- **ConcreteAggregate**: 구체적인 컬렉션 구현\n\n[사용 예시]\n- Java: `Iterator<String> it = list.iterator();`\n- C++: STL의 iterator\n- Python: `for item in collection:`\n\n[답] \"Iterator\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q010_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2024_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "아래 그림을 바탕으로 RIP을 구성하여 최단 경로 비용을 계산하여 흐름에 맞게 작성하시오.", "choices": [], "answer": {"keys": ["A → D → C → F"], "raw_text": "A → D → C → F"}, "explanation": "RIP(Routing Information Protocol)는 거리 벡터 라우팅 프로토콜입니다.\n\n[RIP의 작동 원리]\n- 각 라우터가 이웃 라우터와 라우팅 정보를 주기적으로 교환합니다.\n- 홉(Hop) 수를 거리로 사용합니다 (최대 15홉).\n- 최단 경로는 가장 적은 홉 수를 가진 경로입니다.\n\n[문제 해결 방법]\n\n1. [초기 상태]\n- 각 라우터는 직접 연결된 네트워크만 알고 있습니다.\n\n2. [라우팅 테이블 갱신]\n- 이웃 라우터로부터 받은 정보를 바탕으로 테이블을 업데이트합니다.\n- 홉 수가 1 증가합니다.\n\n3. [최단 경로 계산]\n- A에서 F로 가는 경로를 찾습니다.\n- 가능한 경로:\n- A → D → C → F\n- A → B → C → F\n- 기타 경로\n- 홉 수가 가장 적은 경로를 선택합니다.\n\n[답] \"A → D → C → F\"\"\"\n\n[참고] 문제의 네트워크 그림을 보면 A에서 F로 가는 최단 경로를 계산해야 합니다. RIP는 홉 수를 기준으로 최단 경로를 선택하므로, 그림상의 경로 비용을 확인하여 답을 결정합니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q011_1.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "아래의 표를 확인하여\n\nSRT 스케줄링의 평균 대기시간을 계산하여 작성하시오.", "choices": [], "answer": {"keys": ["6.5"], "raw_text": "6.5"}, "explanation": "SRT(Shortest Remaining Time) 스케줄링은 남은 실행 시간이 가장 짧은 프로세스를 우선 실행하는 선점형 스케줄링입니다.\n\n[SRT 스케줄링의 특징]\n- SJF(Shortest Job First)의 선점형 버전입니다.\n- 새 프로세스가 도착하면 남은 실행 시간을 비교하여 선점할 수 있습니다.\n- 평균 대기 시간이 짧습니다.\n\n[문제 해결 방법]\n\n주어진 표에서:\n- 프로세스들의 도착 시간과 실행 시간을 확인합니다.\n- Gantt 차트를 그려서 각 프로세스의 실행 순서를 결정합니다.\n- 각 프로세스의 대기 시간을 계산합니다.\n\n[대기 시간 계산]\n- 프로세스 i의 대기 시간 = 시작 시간 - 도착 시간\n- 평균 대기 시간 = (모든 프로세스의 대기 시간 합) / 프로세스 개수\n\n[예시 계산 (표 데이터 기준)]\n표의 실제 데이터를 바탕으로 Gantt 차트를 그려 계산하면:\n- 평균 대기 시간 = **6.5[답] \"6.5\"\"\"\n\n[참고] 문제의 표에 따라 각 프로세스의 도착 시간과 실행 시간이 다르므로, 정확한 답은 표의 데이터를 바탕으로 계산해야 합니다.", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q012_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2024_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["21"], "raw_text": "21"}, "explanation": "이 C언어 코드는 포인터 배열과 포인터 연산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint* parr[2] = {arr[1], arr[2]};\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n```\n\n[메모리 레이아웃]\n\n```\narr[0] → [1, 2, 3]\narr[1] → [4, 5, 6]\narr[2] → [7, 8, 9]\n```\n\n[실행 과정]\n\n1. [`parr` 배열 초기화]\n```c int* parr[2] = {arr[1], arr[2]};\n```\n- `parr[0]` = `arr[1]` (두 번째 행을 가리킴)\n- `parr[1]` = `arr[2]` (세 번째 행을 가리킴)\n\n2. [표현식 계산]\n```c parr[1][1] + *(parr[1]+2) + parr\n```\n\n- [`parr[1][1]`]\n- `parr[1]` = `arr[2]` → `[7, 8, 9]`\n- `parr[1][1]` = `arr[2][1]` = 8**\n\n- **`*(parr[1]+2)`:**\n- `parr[1]` = `arr[2]` (시작 주소)\n- `parr[1] + 2` = `arr[2] + 2` (두 칸 뒤)\n- `*(parr[1]+2)` = `arr[2][2]` = **9**\n\n- **`[parr`]\n- `parr` = `parr[0]`의 주소\n- `*parr` = `parr[0]` = `arr[1]` (주소)\n- `parr` = `arr[1][0]` = 4**\n\n3. [최종 계산]\n- `8 + 9 + 4 = 21`\n\n[답] 21", "table_refs": [], "image_refs": ["images/2024_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int* parr[2] = {arr[1], arr[2]};\n    printf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n    return 0;\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 Java 언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["25, 20"], "raw_text": "25, 20"}, "explanation": "[Java 홀수/짝수 합 계산 - 코드 실행 추적]\n\n**배열:** `a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}`\n\n**실행 과정:**\n\n**1. `OE.sum(a, true)` - 홀수 합**\n\n조건: `odd && a[i]%2 != 0` (홀수만 선택)\n\n| i | a[i] | 홀수? | result |\n|---|------|-------|--------|\n| 0 | 1 | O | 1 |\n| 2 | 3 | O | 4 |\n| 4 | 5 | O | 9 |\n| 6 | 7 | O | 16 |\n| 8 | 9 | O | **25** |\n\n**2. `OE.sum(a, false)` - 짝수 합**\n\n조건: `!odd && a[i]%2 == 0` (짝수만 선택)\n\n| i | a[i] | 짝수? | result |\n|---|------|-------|--------|\n| 1 | 2 | O | 2 |\n| 3 | 4 | O | 6 |\n| 5 | 6 | O | 12 |\n| 7 | 8 | O | **20** |\n\n**출력:** `25 + \", \" + 20` → **25, 20**\n\n**정답: 25, 20**", "table_refs": [], "image_refs": ["images/2024_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-05T16:01:31.955275", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        ODDNumber OE = new ODDNumber();\n        System.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n    }\n}\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }        \n        return result;\n    }    \n}", "line_numbers": [1, 20], "file": "data/codes/2024_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 C언어 코드는 문자열 복사 함수와 인덱스 합 계산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c void sumFn(char* d, const char* s) {\nwhile (*s) {\n*d = *s;\nd++;\ns++;\n}\n*d = '\\0';\n}\n```\n\n[실행 과정]\n\n1. [초기값]\n```c const char* str1 = \"first\"; // 길이: 5 char str2[50] = \"teststring\"; // 길이: 10\n```\n\n2. [`sumFn(str2, str1)` 호출]\n- `str1 = \"first\"`를 `str2`에 복사\n- 복사 후: `str2 = \"first\\0...\"` (길이: 5)\n\n3. [인덱스 합 계산]\n```c for (int i = 0; str2[i] != '\\0'; i++) {\nresult += i;\n}\n```\n- i=0: result += 0 (result = 0)\n- i=1: result += 1 (result = 1)\n- i=2: result += 2 (result = 3)\n- i=3: result += 3 (result = 6)\n- i=4: result += 4 (result = 10)\n- i=5: `str2[5] == '\\0'` → 루프 종료\n\n4. [최종 출력]\n- **출력: 10[답] 10", "table_refs": [], "image_refs": ["images/2024_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid sumFn(char* d, const char* s) {\n    while (*s) {\n        *d = *s;\n        d++;\n        s++;\n    }\n    *d = '\\0'; \n}\nint main() {\n   const char* str1 = \"first\";\n    char str2[50] = \"teststring\";  \n    int result=0;\n    sumFn(str2, str1);\n    for (int i = 0; str2[i] != '\\0'; i++) {\n        result += i;\n    }\n    printf(\"%d\", result);\n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "아래는 소프트웨어 설계에 대한 내용이다.\n내용을 읽고 괄호 안에 알맞는 답을 작성하시오.\n\n- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다.\n\n- 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.\n(              ) Coupling", "choices": [], "answer": {"keys": ["제어"], "raw_text": "제어"}, "explanation": "제어 결합도(Control Coupling)는 한 모듈이 다른 모듈의 제어 흐름을 조작하는 결합도입니다.\n\n[문제에서 설명하는 특징]\n\n1. \"어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다\"\n- 한 모듈이 다른 모듈의 실행 흐름을 제어하는 경우입니다.\n- 플래그(flag)나 제어 변수를 전달하여 분기를 결정합니다.\n- 예: 함수에 `mode` 파라미터를 전달하여 다른 동작을 수행\n\n2. \"한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다\"\n- 모듈 A가 모듈 B의 내부 로직을 알고 있습니다.\n- 모듈 A가 모듈 B에게 \"어떻게 처리할지\" 지시합니다.\n\n[결합도 종류 비교]\n- 내용 결합도: 가장 강함 (내부 직접 접근)\n- 공통 결합도: 전역 변수 공유\n- 외부 결합도: 외부 인터페이스 공유\n- **제어 결합도: 제어 흐름 조작** ✓\n- 스탬프 결합도: 구조체 전달\n- 자료 결합도: 값만 전달 (가장 약함, 이상적)\n\n[예시]\n```c void process(int mode) {\nif (mode == 1) {\n// 처리 A\n} else {\n// 처리 B\n}\n}\n```\n\n[답] \"제어\" (Control Coupling)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["dcba"], "raw_text": "dcba"}, "explanation": "이미지의 Java 코드는 재귀 함수를 사용하여 문자열에서 뒤에서부터 중복을 제거하는 알고리즘입니다.\n\n[코드 분석]\n\n```java\nString str = \"abacabcd\";\nboolean[] seen = new boolean[256];\nSystem.out.print(calculFn(str, str.length()-1, seen));\n\npublic static String calculFn(String str, int index, boolean[] seen) {\n    if(index < 0) return \"\";\n    char c = str.charAt(index);\n    String result = calculFn(str, index-1, seen);\n    if(!seen[c]) {\n        seen[c] = true;\n        return c + result;\n    }\n    return result;\n}\n```\n\n[알고리즘 이해]\n\n1. **재귀 호출 순서**: 문자열을 **뒤에서 앞으로** 처리합니다 (index가 감소).\n2. **중복 제거**: `seen[]` 배열로 이미 본 문자를 체크합니다.\n3. **결과 구성**: 처음 본 문자를 **앞에 추가**합니다.\n\n[실행 과정 (재귀 스택)]\n\n```\ncalculFn(\"abacabcd\", 7, seen) // index=7, c='d'\n  → seen['d']=false → seen['d']=true → \"d\" + result\n  ↓\ncalculFn(\"abacabcd\", 6, seen) // index=6, c='c'\n  → seen['c']=false → seen['c']=true → \"c\" + result\n  ↓\ncalculFn(\"abacabcd\", 5, seen) // index=5, c='b'\n  → seen['b']=false → seen['b']=true → \"b\" + result\n  ↓\ncalculFn(\"abacabcd\", 4, seen) // index=4, c='a'\n  → seen['a']=false → seen['a']=true → \"a\" + result\n  ↓\ncalculFn(\"abacabcd\", 3, seen) // index=3, c='c'\n  → seen['c']=true (이미 본 문자) → result 반환 (\"a\" 추가 안 함)\n  ↓\ncalculFn(\"abacabcd\", 2, seen) // index=2, c='a'\n  → seen['a']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", 1, seen) // index=1, c='b'\n  → seen['b']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", 0, seen) // index=0, c='a'\n  → seen['a']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", -1, seen) // 종료 조건\n  → return \"\"\n```\n\n[결과 구성 (재귀 반환 순서)]\n\n1. `calculFn(-1)` → `\"\"` 반환\n2. `calculFn(0)` → `\"\"` 반환 (a는 이미 봄)\n3. `calculFn(1)` → `\"\"` 반환 (b는 이미 봄)\n4. `calculFn(2)` → `\"\"` 반환 (a는 이미 봄)\n5. `calculFn(3)` → `\"\"` 반환 (c는 이미 봄)\n6. `calculFn(4)` → `\"a\" + \"\"` = `\"a\"` 반환 (처음 본 a)\n7. `calculFn(5)` → `\"b\" + \"a\"` = `\"ba\"` 반환 (처음 본 b)\n8. `calculFn(6)` → `\"c\" + \"ba\"` = `\"cba\"` 반환 (처음 본 c)\n9. `calculFn(7)` → `\"d\" + \"cba\"` = `\"dcba\"` 반환 (처음 본 d)\n\n[핵심 포인트]\n- 문자열을 **뒤에서 앞으로** 처리하므로, 결과는 **역순**으로 구성됩니다.\n- **처음 본 문자만 추가**하므로 중복이 제거됩니다.\n- `seen[c]`는 ASCII 코드를 인덱스로 사용합니다 (char → int 자동 변환).\n\n[답] \"dcba\"", "table_refs": [], "image_refs": ["images/2024_round2/Q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"abacabcd\";\n        boolean[] seen = new boolean[256];\n        System.out.print(calculFn(str, str.length()-1, seen));\n    }\n    public static String calculFn(String str, int index, boolean[] seen) {\n        if(index < 0) return \"\";\n        char c = str.charAt(index);\n        String result = calculFn(str, index-1, seen);\n        if(!seen[c]) {\n            seen[c] = true;\n            return c + result;\n        }\n        return result;\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["-13"], "raw_text": "-13"}, "explanation": "이 C언어 코드는 함수 파라미터의 값 전달과 switch 문의 fall-through를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c void swap(int a, int b) {\nint = a;\na = b;\nb = t;\n}\n```\n\n[실행 과정]\n\n1. [초기값]\n```c int a = 11;\nint b = 19;\n```\n\n2. [`swap(a, b)` 호출]\n- C언어는 값에 의한 전달(Call by Value)을 사용합니다.\n- `swap()` 함수 내부에서 `a`와 `b`의 값을 변경해도 원본 변수에는 영향이 없습니다.\n- 함수 호출 후에도 `a = 11`, `b = 19` (변경 없음)\n\n3. [switch 문 실행]\n```c switch(a) { // a = 11 case 1:\nb += 1;\ncase 11: // 매칭! (하지만 break 없음)\nb += 2; // 실행 default:\nb += 3; // 실행 (fall-through)\nbreak;\n}\n```\n- `a = 11`이므로 `case 11:`로 이동합니다.\n- break가 없으므로 아래로 fall-through합니다.\n- `b += 2` → `b = 19 + 2 = 21`\n- `default:` 실행 → `b += 3` → `b = 21 + 3 = 24`\n\n4. [최종 계산]\n```c printf(\"%d\", a - b); // 11 - 24 = -13\n```\n\n[답] \"-13\"", "table_refs": [], "image_refs": ["images/2024_round2/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int a = 11;\n    int b = 19;\n    swap(a, b);\n    switch(a) {\n        case 1:\n            b += 1;\n        case 11:\n            b += 2;\n        default:\n            b += 3;\n        break;\n    }\n    printf(\"%d\", a-b);\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 C언어의 구조체에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 구조체 포인터와 연결 리스트를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c struct node {\nint n1;\nstruct node *n2;\n};\n\nstruct node a = {10, NULL};\nstruct node b = {20, NULL};\nstruct node c = {30, NULL};\nstruct node *head = &a;\na.n2 = &b;\nb.n2 = &c;\nprintf(\"%d\\n\", head->n2->n1);\n```\n\n[메모리 구조]\n\n```\nhead → a {n1=10, n2=&b}\n↓\nb {n1=20, n2=&c}\n↓\nc {n1=30, n2=NULL}\n```\n\n[표현식 계산]\n\n```c head->n2->n1\n```\n\n1. **`head`**: `&a` (a의 주소)\n\n2. **`head->n2`**: `a.n2` = `&b` (b의 주소)\n\n3. **`head->n2->n1`**: `b.n1` = **20[답] 20", "table_refs": [], "image_refs": ["images/2024_round2/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.028447"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct node {\n    int n1;\n    struct node *n2;\n};\nint main() {\n    struct node a = {10, NULL};\n    struct node b = {20, NULL};\n    struct node c = {30, NULL};\n    struct node *head = &a;\n    a.n2 = &b;\n    b.n2 = &c;\n    printf(\"%d\\n\", head->n2->n1);\n    return 0;\n}", "line_numbers": [1, 15], "file": "data/codes/2024_round2/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["S"], "raw_text": "S"}, "explanation": "이미지의 Java 코드는 String의 split() 메서드를 사용하여 문자열을 분할하는 문제입니다.\n\n[코드 분석]\n\n```java\nString str = \"ITISTESTSTRING\";\nString[] result = str.split(\"T\");\nSystem.out.print(result[3]);\n```\n\n[String.split() 메서드]\n\n- `split(\"구분자\")`: 문자열을 **구분자를 기준으로 분할**하여 배열로 반환합니다.\n- 구분자는 **제거**되고, 나머지 부분들이 배열 요소가 됩니다.\n\n[실행 과정]\n\n1. [`str.split(\"T\")` 실행]\n   - 원본 문자열: `\"ITISTESTSTRING\"`\n   - 구분자: `\"T\"`\n   - 분할 위치 확인:\n     ```\n     I T I S T E S T S T R I N G\n       ↑   ↑   ↑   ↑   ↑\n     ```\n   - `\"T\"`로 분할:\n     - `\"I\"` (첫 번째)\n     - `\"IS\"` (두 번째)\n     - `\"ES\"` (세 번째)\n     - `\"S\"` (네 번째)\n     - `\"RING\"` (다섯 번째)\n\n2. [배열 생성]\n```java\nresult = [\"I\", \"IS\", \"ES\", \"S\", \"RING\"]\n// 인덱스:  0     1      2     3     4\n```\n\n3. [`result[3]` 출력]\n   - 인덱스 3의 값: `\"S\"`\n\n[주의사항]\n- `split()`은 구분자를 **제거**하므로, 결과 배열에는 구분자가 포함되지 않습니다.\n- 구분자 앞뒤의 문자열이 각각 배열 요소가 됩니다.\n- 빈 문자열도 배열 요소로 포함될 수 있습니다.\n\n[답] \"S\"", "table_refs": [], "image_refs": ["images/2024_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.028447"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"ITISTESTSTRING\";\n        String[] result = str.split(\"T\");\n        System.out.print(result[3]);\n    }\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
