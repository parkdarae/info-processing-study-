{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["OOAAA"], "raw_text": "OOAAA"}, "explanation": "이미지의 Java 코드는 String의 equals() 메서드를 사용하여 내용을 비교하는 문제입니다.\n\n[코드 분석]\n\n```java\nstatic String[] s = new String[3];\ns[0] = \"A\";\ns[1] = \"A\";\ns[2] = new String(\"A\");\nfunc(s, 3);\n\nstatic void func(String[] s, int size) {\n    for(int i=1; i<size; i++) {\n        if(s[i-1].equals(s[i])) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"N\");\n        }\n    }\n    for (String m : s) {\n        System.out.print(m);\n    }\n}\n```\n\n[핵심 개념]\n\n1. [String 리터럴 vs `new String()`]\n   - `\"A\"` (리터럴): String 상수 풀에 저장, 같은 리터럴은 같은 참조\n   - `new String(\"A\")`: 새로운 객체 생성, 다른 참조\n\n2. [`equals()` 메서드]\n   - **내용 비교**: 문자열의 실제 값(내용)을 비교합니다.\n   - `==` 연산자와 달리 참조가 아닌 **내용**을 비교합니다.\n\n[실행 과정]\n\n1. [초기화]\n   - `s[0] = \"A\"` (리터럴)\n   - `s[1] = \"A\"` (리터럴, s[0]과 같은 참조 가능)\n   - `s[2] = new String(\"A\")` (새 객체, 다른 참조이지만 내용은 \"A\")\n\n2. [첫 번째 반복문 (`for(int i=1; i<3; i++)`)]\n   - [i=1] `s[0].equals(s[1])` → `\"A\".equals(\"A\")` → `True` → **\"O\" 출력**\n   - [i=2] `s[1].equals(s[2])` → `\"A\".equals(new String(\"A\"))` → `True` (내용이 같음) → **\"O\" 출력**\n\n3. [두 번째 반복문 (`for (String m : s)`)]\n   - `s[0]` = `\"A\"` → **\"A\" 출력**\n   - `s[1]` = `\"A\"` → **\"A\" 출력**\n   - `s[2]` = `new String(\"A\")` → **\"A\" 출력**\n\n[참고]\n- `==`는 참조 비교이므로 `s[1] == s[2]`는 `false`입니다.\n- `equals()`는 내용 비교이므로 `s[1].equals(s[2])`는 `true`입니다.\n\n[답] \"OOAAA\"", "table_refs": [], "image_refs": ["images/2024_round3/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.030449"}, "code_blocks": [{"language": "java", "code": "public class Main{\n  static String[] s = new String[3];\n  static void func(String[]s, int size){\n    for(int i=1; i<size; i++){\n      if(s[i-1].equals(s[i])){\n        System.out.print(\"O\");\n      }else{\n        System.out.print(\"N\");\n      }\n    }\n      for (String m : s){\n        System.out.print(m);\n      }\n    }\n  public static void main(String[] args){\n    s[0] = \"A\";\n    s[1] = \"A\";\n    s[2] = new String(\"A\");\n    func(s, 3);\n  }\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round3/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["3"], "raw_text": "3"}, "explanation": "이 파이썬 코드는 리스트를 역순으로 뒤집고 짝수 인덱스와 홀수 인덱스의 합 차이를 계산하는 문제입니다.\n\n[코드 분석]\n\n```python def func(lst):\nfor i in range(len(lst) // 2):\nlst[i], lst[-i-1] = lst[-i-1], lst[i] # 리스트 역순\n\nlst = [1, 2, 3, 4, 5, 6]\nfunc(lst) # 역순으로 뒤집기 print(sum(lst[::2]) - sum(lst[1::2])) # 짝수 인덱스 합 - 홀수 인덱스 합\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `lst = [1, 2, 3, 4, 5, 6]`\n\n2. [`func(lst)` 실행 (역순으로 뒤집기)]\n- `len(lst) // 2 = 6 // 2 = 3`\n- i=0: lst[0] ↔ lst[-1] → [6, 2, 3, 4, 5, 1]\n- i=1: lst[1] ↔ lst[-2] → [6, 5, 3, 4, 2, 1]\n- i=2: lst[2] ↔ lst[-3] → [6, 5, 4, 3, 2, 1]\n- 결과: `lst = [6, 5, 4, 3, 2, 1]`\n\n3. [합 차이 계산]\n```python sum(lst[::2]) # 짝수 인덱스 (0, 2, 4): 6 + 4 + 2 = 12 sum(lst[1::2]) # 홀수 인덱스 (1, 3, 5): 5 + 3 + 1 = 9\n```\n- `12 - 9 = 3`\n\n[답] 3", "table_refs": [], "image_refs": ["images/2024_round3/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.030449"}, "code_blocks": [{"language": "python", "code": "def func(lst):\n  for i in range(len(lst) //2):\n    lst[i], lst[-i-1] = lst[-i-1], lst[i]\nlst = [1,2,3,4,5,6] \nfunc(lst)\nprint(sum(lst[::2]) - sum(lst[1::2]))", "line_numbers": [1, 6], "file": "data/codes/2024_round3/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "아래의 employee테이블과 project테이블을 참고하여\n\n보기의 SQL명령어에 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 문제는 **중첩 서브쿼리와 JOIN**을 이해하는 SQL 문제입니다.\n\n[SQL 쿼리 분석]\n\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p \n    WHERE p.project_id IN (\n        SELECT project_id FROM employee \n        GROUP BY project_id \n        HAVING count(*) < 2\n    )\n);\n```\n\n[실행 순서 (안쪽부터 바깥쪽으로)]\n\n1. [가장 안쪽 서브쿼리]\n```sql\nSELECT project_id FROM employee \nGROUP BY project_id \nHAVING count(*) < 2\n```\n- **의미**: 직원이 1명 이하인 프로젝트 ID를 찾습니다.\n- 각 프로젝트별 직원 수를 세고, 직원이 1명 이하인 프로젝트만 선택합니다.\n- 예: 프로젝트 ID가 `P001`에 직원이 1명만 있으면 `P001` 반환\n\n2. [중간 서브쿼리]\n```sql\nSELECT name FROM project p \nWHERE p.project_id IN (위의 결과)\n```\n- **의미**: 위에서 찾은 프로젝트 ID에 해당하는 **프로젝트 이름**을 찾습니다.\n- 직원이 1명 이하인 프로젝트의 이름을 반환합니다.\n\n3. [외부 쿼리]\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (위의 결과)\n```\n- **의미**: 직원과 프로젝트를 조인한 후, 직원이 1명 이하인 프로젝트에 **속한 직원 수**를 세습니다.\n- `JOIN`으로 employee와 project를 연결하고, `WHERE` 절로 프로젝트 이름을 필터링합니다.\n- `count(*)`로 해당 조건을 만족하는 직원 레코드 수를 세어 반환합니다.\n\n[요약]\n- **직원이 1명 이하인 프로젝트**를 찾고\n- 그 프로젝트에 **속한 직원의 수**를 세는 쿼리입니다.\n- 직원이 1명 이하인 프로젝트에 속한 직원이 1명이므로 결과는 **1**입니다.\n\n[답] 1", "table_refs": [], "image_refs": ["images/2024_round3/Q003_1.png", "images/2024_round3/Q003_2.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.030449"}, "code_blocks": [{"language": "sql", "code": "SELECT \n    count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p WHERE p.project_id IN (\n        SELECT project_id FROM employee GROUP BY project_id HAVING count(*) < 2\n    )\n);", "line_numbers": [1, 8], "file": "data/codes/2024_round3/Q003_code.txt"}], "primary_category": "데이터베이스", "secondary_categories": ["SQL"], "tags": ["sql"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 운영체제 페이지 순서를 참고하여\n\n할당된 프레임의 수가 3개일 때  LRU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서\n: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1", "choices": [], "answer": {"keys": ["12"], "raw_text": "12"}, "explanation": "LRU(Least Recently Used) 스케줄링은 가장 오래전에 사용된 페이지를 교체하는 알고리즘입니다.\n\n[주어진 정보]\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1\n\n[LRU 실행 과정]초기 상태: [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 7 | [7, 빈, 빈] | ✓ |\n| 0 | [7, 0, 빈] | ✓ |\n| 1 | [7, 0, 1] | ✓ |\n| 2 | [0, 1, 2] | ✓ (7 제거, 가장 오래됨) |\n| 0 | [0, 1, 2] | (히트) |\n| 3 | [1, 2, 3] | ✓ (0 제거) |\n| 0 | [2, 3, 0] | ✓ (1 제거) |\n| 4 | [3, 0, 4] | ✓ (2 제거) |\n| 2 | [0, 4, 2] | ✓ (3 제거) |\n| 3 | [4, 2, 3] | ✓ (0 제거) |\n| 0 | [2, 3, 0] | ✓ (4 제거) |\n| 3 | [2, 3, 0] | (히트) |\n| 2 | [2, 3, 0] | (히트) |\n| 1 | [3, 0, 1] | ✓ (2 제거) |\n| 2 | [0, 1, 2] | ✓ (3 제거) |\n| 0 | [0, 1, 2] | (히트) |\n| 1 | [0, 1, 2] | (히트) |\n| 7 | [1, 2, 7] | ✓ (0 제거) |\n| 0 | [2, 7, 0] | ✓ (1 제거) |\n| 1 | [7, 0, 1] | ✓ (2 제거) |\n\n페이지 부재 횟수: 12[답] 12", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 네트워크 취약점에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다.\n\n- 여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply 를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다.\n\n- 공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다.", "choices": [], "answer": {"keys": ["스머프"], "raw_text": "스머프"}, "explanation": "스머프(Smurf) 공격은 IP와 ICMP의 특성을 악용한 DDoS 공격입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다\"\n- 스머프 공격은 IP 브로드캐스트 주소를 악용합니다.\n- 공격자는 피해자의 IP 주소를 위조(spoofing)하여 브로드캐스트 주소로 ICMP Echo Request를 전송합니다.\n- 브로드캐스트 네트워크의 모든 호스트가 응답하여 트래픽이 증폭됩니다.\n\n2. \"여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다\"\n- 공격자는 피해자의 IP를 소스로 위조한 ICMP Echo Request를 브로드캐스트합니다.\n- 네트워크의 모든 호스트가 피해자에게 ICMP Echo Reply를 전송합니다.\n- 결과적으로 피해자는 엄청난 양의 응답 패킷을 받게 됩니다.\n\n3. \"공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다\"\n- 수신 대역폭이 포화되어 정상적인 통신이 불가능해집니다.\n- DoS(Denial of Service) 상태에 빠집니다.\n\n[스머프 공격의 방어 방법]\n- 라우터에서 브로드캐스트 주소로 향하는 패킷을 차단\n- ICMP 패킷 필터링\n- IP 스푸핑 방지\n\n[답] \"스머프\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 GoF 디자인 패턴과 관련된 문제이다.\n괄호 안에 알맞는 용어를 작성하시오.\n(        ) 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.\n(        ) 패턴은 객체들 간의 통신 방법을 정의하고 알고리즘을 캡슐화하여 객체 간의 결합도를 낮춘다.\n(        ) 패턴은 Chain of Responsibility나 Command 또는 Observer 패턴이 있다.", "choices": [], "answer": {"keys": ["행위"], "raw_text": "행위"}, "explanation": "행위(Behavioral) 패턴은 객체 간의 상호작용과 책임 분배를 정의하는 GoF 디자인 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다\"\n- 행위 패턴은 객체 간의 통신 방식을 정의합니다.\n- 각 객체의 역할과 책임을 명확히 분리합니다.\n- 예: Observer 패턴에서 주제와 관찰자의 상호작용\n\n2. \"객체들 간의 통신 방법을 정의하고 알고리즘을 캡슐화하여 객체 간의 결합도를 낮춘다\"\n- 통신 방법을 표준화하여 결합도를 낮춥니다.\n- 알고리즘을 객체로 캡슐화합니다.\n- 예: Strategy 패턴에서 알고리즘을 독립적인 객체로 분리\n\n3. \"Chain of Responsibility나 Command 또는 Observer 패턴이 있다\"\n- Chain of Responsibility: 요청을 객체 체인으로 전달\n- Command: 요청을 객체로 캡슐화\n- Observer: 객체 간 일대다 의존성 정의\n\n[GoF 패턴 분류]\n- **생성 패턴(Creational)**: 객체 생성 담당 (Singleton, Factory 등)\n- **구조 패턴(Structural)**: 클래스/객체 조합 (Adapter, Decorator 등)\n- **행위 패턴(Behavioral)**: 객체 간 상호작용 (Observer, Command 등) ✓\n\n[답] \"행위\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 static 변수의 특성을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c int func() {\nstatic int x = 0; // static 변수 (초기화는 한 번만!)\nx += 2;\nreturn x;\n}\n\nint main() {\nint x = 1; // 지역 변수 (func의 x와 별개)\nint sum = 0;\nfor(int i=0; i<4; i++) {\nx++; // 지역 변수 x 증가 sum += func(); // func() 호출\n}\nprintf(\"%d\", sum);\n}\n```\n\n[실행 과정]\n\n1. [초기값]\n- `main`의 지역 변수: `x = 1`\n- `func`의 static 변수: `x = 0` (초기화는 프로그램 시작 시 한 번만)\n\n2. [반복문 실행]i=0:\n- `x++` → `x = 2` (main의 지역 변수)\n- `func()` 호출:\n- static `x = 0` (유지됨)\n- `x += 2` → `x = 2`\n- 반환: 2\n- `sum = 0 + 2 = 2`\n\n[i=1]\n- `x++` → `x = 3`\n- `func()` 호출:\n- static `x = 2` (이전 값 유지!)\n- `x += 2` → `x = 4`\n- 반환: 4\n- `sum = 2 + 4 = 6`\n\n[i=2]\n- `x++` → `x = 4`\n- `func()` 호출:\n- static `x = 4`\n- `x += 2` → `x = 6`\n- 반환: 6\n- `sum = 6 + 6 = 12`\n\n[i=3]\n- `x++` → `x = 5`\n- `func()` 호출:\n- static `x = 6`\n- `x += 2` → `x = 8`\n- 반환: 8\n- `sum = 12 + 8 = 20`\n\n3. [최종 출력]\n- 출력: 20[핵심 포인트]\n- static 변수는 함수가 종료되어도 메모리에 유지됩니다.\n- static 변수의 초기화는 프로그램 시작 시 한 번만 실행됩니다.\n- 함수를 여러 번 호출해도 static 변수는 이전 값을 유지합니다.\n\n[답] 20", "table_refs": [], "image_refs": ["images/2024_round3/Q007.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint func(){\n static int x =0; \n  x+=2; \n  return x;\n}\nint main(){\n  int x = 1; \n  int sum=0; \n  for(int i=0;i<4;i++) {\n    x++; \n    sum+=func();\n  } \n  printf(\"%d\", sum);\n  return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2024_round3/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음은 무결성제약조건에 대한 문제이다.\n아래 표에서 어떠한 (       ) 무결성을 위반하였는지 작성하시오.", "choices": [], "answer": {"keys": ["개체"], "raw_text": "개체"}, "explanation": "이 문제는 데이터베이스의 제약조건(무결성 제약조건)에 대한 문제입니다.\n\n[제약조건의 정의와 목적]\n\n제약조건은 데이터베이스에 저장되는 데이터가 정확하고 일관성 있게 유지되도록 하는 규칙입니다. 잘못된 데이터가 입력되는 것을 방지하고 데이터의 무결성을 보장합니다.\n\n[제약조건의 종류]\n\n1. 도메인 제약조건(Domain Constraint): 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 지정합니다.\n- 예: 나이는 0 이상 150 이하의 정수만 허용\n\n2. 개체 제약조건(Entity Constraint, 엔티티 무결성): 기본키(Primary Key)와 관련된 제약조건입니다.\n- 기본키는 NULL 값을 가질 수 없습니다.\n- 기본키는 중복될 수 없으며, 각 튜플(행)을 유일하게 식별해야 합니다.\n\n3. 참조 제약조건(Referential Constraint, 참조 무결성): 외래키(Foreign Key)와 관련된 제약조건입니다.\n- 외래키는 참조하는 테이블의 기본키 값과 일치해야 하거나 NULL 값이어야 합니다.\n\n**문제 해석**: 문제에서 각 설명에 해당하는 제약조건을 보기에서 찾아야 합니다. 제약조건의 정의와 특징을 정확히 이해하면 답은 \"개체\"입니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q008.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 URL 구조에 관한 문제이다.\n아래  보기의 순서대로 URL에 해당하는 번호를 작성하시오.\nquery\n: 서버에 전달할 추가 데이터 path\n: 서버 내의 특정 자원을 가리키는 경로 scheme\n: 리소스에 접근하는 방법이나 프로토콜 authority\n: 사용자 정보, 호스트명, 포트 번호 fragment\n: 특정 문서 내의 위치", "choices": [], "answer": {"keys": ["43125"], "raw_text": "43125"}, "explanation": "URL(Uniform Resource Locator)의 구조를 이해하는 문제입니다.\n\n[URL 구조 예시]\n```\nhttps://user:pass@example.com:8080/path/to/resource?query=value#fragment\n│ │ │ │ │ │ │ │\n│ │ │ │ │ │ │ └─ fragment\n│ │ │ │ │ │ └─ query\n│ │ │ │ │ └─ path\n│ │ │ │ └─ port\n│ │ │ └─ hostname\n│ │ └─ password\n│ └─ username\n└─ scheme\n```\n\n[각 구성 요소]\n\n1. **scheme (3번)**: 리소스에 접근하는 방법이나 프로토콜\n- 예: `http`, `https`, `ftp`, `mailto`\n- URL의 가장 앞에 위치합니다.\n\n2. **authority (4번)**: 사용자 정보, 호스트명, 포트 번호\n- 형식: `[username:password@]hostname[:port]`\n- 예: `user:pass@example.com:8080`\n\n3. **path (1번)**: 서버 내의 특정 자원을 가리키는 경로\n- 예: `/path/to/resource`\n- 서버의 파일 시스템 경로를 나타냅니다.\n\n4. **query (2번)**: 서버에 전달할 추가 데이터\n- 형식: `?key=value&key2=value2`\n- GET 요청의 파라미터를 전달합니다.\n\n5. **fragment (5번)**: 특정 문서 내의 위치\n- 형식: `#section`\n- HTML 문서의 앵커를 가리킵니다.\n\n[순서]\n1. scheme → 2. authority → 3. path → 4. query → 5. fragment\n\n[보기 매칭]\n- query: 1\n- path: 2\n- scheme: 3\n- authority: 4\n- fragment: 5\n\n[답] \"43125\"", "table_refs": [], "image_refs": ["images/2024_round3/Q009.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["45"], "raw_text": "45"}, "explanation": "이 파이썬 코드는 `type()` 함수를 사용한 타입 체크를 이해하는 문제입니다.\n\n[코드 분석]\n\n```python def func(value):\nif type(value) == type(100): # int 타입 체크 return 100 elif type(value) == type(\"\"): # str 타입 체크 return len(value)\nelse:\nreturn 20\n\na = '100.0' # 문자열 b = 100.0 # float (실수)\nc = (100, 200) # tuple\n\nprint(func(a) + func(b) + func(c))\n```\n\n[실행 과정]\n\n1. [`func('100.0')` 호출]\n- `type('100.0') == type(\"\")` → `True` (문자열)\n- 반환: `len('100.0') = 5`\n\n2. [`func(100.0)` 호출]\n- `type(100.0) == type(100)` → `False` (float ≠ int)\n- `type(100.0) == type(\"\")` → `False` (float ≠ str)\n- else 블록 실행 → 반환: **20**\n\n3. [`func((100, 200))` 호출]\n- `type((100, 200)) == type(100)` → `False` (tuple ≠ int)\n- `type((100, 200)) == type(\"\")` → `False` (tuple ≠ str)\n- else 블록 실행 → 반환: **20**\n\n4. [최종 계산]\n- `5 + 20 + 20 = 45`\n\n[핵심 포인트]\n- `type()` 함수는 객체의 타입을 반환합니다.\n- `type(100)`은 `int` 타입 객체를 반환합니다.\n- `100.0`은 `float` 타입이므로 `int`와 다릅니다.\n\n[답] 45", "table_refs": [], "image_refs": ["images/2024_round3/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [{"language": "python", "code": "def func(value):\n    if type(value) == type(100):\n        return 100\n    elif type(value) == type(\"\"):\n        return len(value) \n    else:\n        return 20\na = '100.0'\nb = 100.0\nc = (100, 200)\nprint(func(a) + func(b) + func(c))", "line_numbers": [1, 11], "file": "data/codes/2024_round3/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["52"], "raw_text": "52"}, "explanation": "이미지의 Java 코드는 상속에서 필드 숨김과 메서드 오버라이딩의 차이를 보여주는 문제입니다.\n\n[코드 분석]\n\n```java\nBase a = new Derivate();\nDerivate b = new Derivate();\nSystem.out.print(a.getX() + a.x + b.getX() + b.x);\n\nclass Base {\n    int x = 3;\n    int getX() {\n        return x * 2;  // Base의 x 사용\n    }\n}\n\nclass Derivate extends Base {\n    int x = 7;  // 필드 숨김 (Base의 x를 숨김)\n    int getX() {\n        return x * 3;  // Derivate의 x 사용 (7 * 3 = 21)\n    }\n}\n```\n\n[핵심 개념]\n\n1. [필드 숨김 (Field Hiding)]\n   - 자식 클래스에서 부모 클래스의 필드와 같은 이름의 필드를 선언하면 부모의 필드가 **숨겨집니다**.\n   - `Base.x = 3`, `Derivate.x = 7` (서로 다른 필드)\n\n2. [메서드 오버라이딩 (Method Overriding)]\n   - 자식 클래스에서 부모 클래스의 메서드를 재정의하면 **항상 자식의 메서드가 호출**됩니다.\n   - 객체의 실제 타입(`Derivate`)에 따라 메서드가 결정됩니다.\n\n3. [필드 접근 vs 메서드 호출]\n   - 필드 접근 (`a.x`): 참조 변수의 타입(`Base`)에 따라 결정 → `Base.x = 3`\n   - 메서드 호출 (`a.getX()`): 객체의 실제 타입(`Derivate`)에 따라 결정 → `Derivate.getX()` 호출\n\n[실행 과정]\n\n1. [`a.getX()` 계산]\n   - `a`는 `Base` 타입으로 선언되었지만 실제 객체는 `Derivate`입니다.\n   - 메서드는 **실제 타입**에 따라 결정되므로 `Derivate.getX()` 호출됩니다.\n   - `Derivate.getX()`는 `Derivate.x`를 사용: `7 * 3 = 21`\n   - **결과: 21**\n\n2. [`a.x` 계산]\n   - 필드는 **참조 변수의 타입**에 따라 결정됩니다.\n   - `a`는 `Base` 타입이므로 `Base.x = 3`\n   - **결과: 3**\n\n3. [`b.getX()` 계산]\n   - `b`는 `Derivate` 타입으로 선언되었고 실제 객체도 `Derivate`입니다.\n   - `Derivate.getX()` 호출: `7 * 3 = 21`\n   - **결과: 21**\n\n4. [`b.x` 계산]\n   - `b`는 `Derivate` 타입이므로 `Derivate.x = 7`\n   - **결과: 7**\n\n5. [최종 출력]\n```java\nSystem.out.print(21 + 3 + 21 + 7);\n// 출력: \"52\"\n```\n\n[정리]\n- 필드: 참조 변수 타입에 따라 결정 (`a.x` → `Base.x`, `b.x` → `Derivate.x`)\n- 메서드: 실제 객체 타입에 따라 결정 (`a.getX()`, `b.getX()` → 모두 `Derivate.getX()`)\n\n[답] \"52\"", "table_refs": [], "image_refs": ["images/2024_round3/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [{"language": "java", "code": "public class Main{\n  public static void main(String[] args){\n    Base a =  new Derivate();\n    Derivate b = new Derivate();\n    System.out.print(a.getX() + a.x + b.getX() + b.x);\n  }\n}\nclass Base{\n  int x = 3;\n  int getX(){\n     return x * 2; \n  }\n}\nclass Derivate extends Base{\n  int x = 7;\n  int getX(){\n     return x * 3;\n  }\n}", "line_numbers": [1, 19], "file": "data/codes/2024_round3/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["312"], "raw_text": "312"}, "explanation": "이 C언어 코드는 연결 리스트에서 인접한 노드 쌍의 값을 교환하는 문제입니다.\n\n[코드 분석]\n\n```c void func(struct Node* node) {\nwhile(node != NULL && node->next != NULL) {\nint = node->value;\nnode->value = node->next->value;\nnode->next->value = t; // 인접 노드 값 교환 node = node->next->next; // 두 칸 건너뛰기\n}\n}\n```\n\n[실행 과정]\n\n1. [초기 리스트 구성]\n```c n1 = {1, NULL}\nn2 = {2, NULL}\nn3 = {3, NULL}\nn1.next = &n3;\nn3.next = &n2;\n```\n- 리스트: 1 → 3 → 2 → NULL• \n\n2. [`func(&n1)` 실행]첫 번째 반복 (node = &n1):\n- node != NULL ✓, node->next != NULL ✓\n- 교환: n1.value(1) ↔ n3.value(3)\n- 리스트: 3 → 1 → 2 → NULL\n- `node = node->next->next` = `n3->next` = `&n2`\n\n[두 번째 반복 (node = &n2)]\n- node != NULL ✓, node->next == NULL ✗\n- 루프 종료\n\n3. [출력]\n```c while(current != NULL) {\nprintf(\"%d\", current->value);\ncurrent = current->next;\n}\n```\n- 출력: \"312\"[답] \"312\"", "table_refs": [], "image_refs": ["images/2024_round3/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct Node {\n int value;\n struct Node* next;\n};\nvoid func(struct Node* node){\n  while(node != NULL && node->next != NULL){\n     int t = node->value;\n     node->value = node->next->value;\n     node->next->value = t;\n     node = node->next->next;\n  }\n}\nint main(){\n  struct Node n1 = {1, NULL};\n  struct Node n2 = {2, NULL};\n  struct Node n3 = {3, NULL};\n  n1.next = &n3;\n  n3.next = &n2;\n  func(&n1);  \n  struct Node* current = &n1;\n  while(current != NULL){\n    printf(\"%d\", current->value);\n    current = current->next;\n }\n return 0;\n}", "line_numbers": [1, 27], "file": "data/codes/2024_round3/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 테스트 커버리지에 대한 문제이다.\n아래 내용에 알맞는 답을 보기에서 골라 작성하시오.\n\n1. 테스트를 통해 프로그램의 모든 문장을 최소한 번씩 실행했는지를 측정\n\n2. 프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 번씩 실행했는지를 측정\n\n3. 복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정\n\nㄱ. 조건\n\nㄴ. 경로\n\nㄷ. 결정\n\nㄹ. 분기\n\nㅁ.함수\n\nㅂ. 문장\n\nㅅ. 루프", "choices": [], "answer": {"keys": ["1. 문장", "2. 분기", "3. 조건"], "raw_text": "1. 문장 2. 분기 3. 조건"}, "explanation": "이 문제는 소프트웨어 테스트 커버리지(Test Coverage)의 종류를 구분하는 문제입니다.\n\n[문제에서 설명하는 각 커버리지]\n\n1. \"테스트를 통해 프로그램의 모든 문장을 최소한 번씩 실행했는지를 측정\"\n- 문장 커버리지(Statement Coverage) 또는 **구문 커버리지**\n- 모든 실행 가능한 문장이 한 번 이상 실행되었는지 확인합니다.\n- 가장 기본적인 커버리지입니다.\n- 예: `if-else` 문에서 각 분기가 실행되었는지 확인\n\n2. \"프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 번씩 실행했는지를 측정\"\n- 분기 커버리지(Branch Coverage) 또는 결정 커버리지(Decision Coverage)\n- 모든 조건문의 참/거짓 분기를 실행했는지 확인합니다.\n- 문장 커버리지보다 엄격합니다.\n- 예: `if (a > 0)`의 참과 거짓 경우를 모두 테스트\n\n3. \"복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정\"\n- 조건 커버리지(Condition Coverage)\n- 복합 조건문(`if (a > 0 && b < 0)`)의 각 조건을 개별적으로 테스트합니다.\n- 각 조건이 참과 거짓으로 평가되었는지 확인합니다.\n\n[커버리지 종류]\n- ㄱ. 조건 커버리지 ✓ (3번)\n- ㄴ. 경로 커버리지: 모든 실행 경로를 테스트\n- ㄷ. 결정 커버리지: 분기 커버리지와 유사\n- ㄹ. 분기 커버리지 ✓ (2번)\n- ㅁ. 함수 커버리지: 모든 함수 호출\n- ㅂ. 문장 커버리지 ✓ (1번)\n- ㅅ. 루프 커버리지: 모든 루프 실행\n\n[답]\n- 1. 문장 (ㅂ)\n- 2. 분기 (ㄹ)\n- 3. 조건 (ㄱ)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합\n\nㄱ. 슈퍼키\n\nㄴ. 외래키\n\nㄷ. 대체키\n\nㄹ. 후보키", "choices": [], "answer": {"keys": ["(1) 외래키", "(2) 후보키", "(3) 대체키", "(4) 슈퍼키"], "raw_text": "(1) 외래키\n(2) 후보키\n(3) 대체키\n(4) 슈퍼키"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n[문제에서 설명하는 내용]\n\n다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별...\n\n[핵심 특징]\n- 다음은 데이터베이스에 관한 문제이다.\n\n[답이 \"(1) 외래키, (2) 후보키, (3) 대체키\"인 이유]\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"(1) 외래키, (2) 후보키, (3) 대체키\"입니다.\n\n[구체적 매칭]\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 C언어 코드는 이중 포인터와 배열 연산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c void func(int** arr, int size) {\nfor(int i=0; i<size; i++) {\n*(*arr + i) = (*(*arr+i) + i) % size;\n}\n}\n\nint main() {\nint arr[] = {3, 1, 4, 1, 5};\nint* p = arr;\nint pp = &p;\nfunc(pp, 5);\nnum = arr[2];\nprintf(\"%d\", num);\n}\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `arr = {3, 1, 4, 1, 5}`\n- `p = arr` (arr의 시작 주소)\n- `pp = &p` (p의 주소)\n\n2. [`func(pp, 5)` 호출]\n- `arr` 파라미터는 `pp`이므로 `arr = *p = arr[0]`\n\n[i=0]\n- `*(*arr + 0) = arr[0] = 3`\n- `(3 + 0) % 5 = 3`\n- `arr[0] = 3`\n\n[i=1]\n- `*(*arr + 1) = arr[1] = 1`\n- `(1 + 1) % 5 = 2`\n- `arr[1] = 2`\n\n[i=2]\n- `*(*arr + 2) = arr[2] = 4`\n- `(4 + 2) % 5 = 1`\n- `arr[2] = 1`\n\n[i=3]\n- `*(*arr + 3) = arr[3] = 1`\n- `(1 + 3) % 5 = 4`\n- `arr[3] = 4`\n\n[i=4]\n- `*(*arr + 4) = arr[4] = 5`\n- `(5 + 4) % 5 = 4`\n- `arr[4] = 4`\n\n[최종 배열] `{3, 2, 1, 4, 4}`\n\n3. [출력]\n```c num = arr[2] = 1 printf(\"%d\", 1);\n```\n\n[답] 1", "table_refs": [], "image_refs": ["images/2024_round3/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid func(int** arr, int size){\n  for(int i=0; i<size; i++){\n     *(*arr + i) = (*(*arr+i) + i) % size;\n  }\n}\nint main(){\n  int arr[] = {3,1, 4, 1, 5};\n  int* p = arr;\n  int** pp = &p;\n  int num = 6;\n  func(pp, 5);  \n  num = arr[2];\n  printf(\"%d\", num);  \n  return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2024_round3/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n(3글자로 작성)\n\n- 공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다.\n\n- 사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다.\n\n- 종류로는 IPsec 또는 SSL, L2TP 등이 있다.", "choices": [], "answer": {"keys": ["VPN"], "raw_text": "VPN"}, "explanation": "VPN(Virtual Private Network)은 공용 네트워크를 통해 사설 네트워크를 확장하는 기술입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다\"\n- 인터넷 같은 공용 네트워크 위에 가상의 사설 네트워크를 구축합니다.\n- 물리적으로 멀리 떨어진 네트워크를 하나의 사설망처럼 사용할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등이 있습니다.\n\n2. \"사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다\"\n- VPN 서버를 통해 트래픽을 중계하므로 실제 IP가 숨겨집니다.\n- 위치 추적이 어려워집니다.\n- 프라이버시 보호에 도움이 됩니다.\n\n3. \"종류로는 IPsec 또는 SSL, L2TP 등이 있다\"\n- **IPsec (IP Security)**: 네트워크 계층 암호화\n- **SSL/TLS VPN**: 애플리케이션 계층 암호화\n- L2TP (Layer 2 Tunneling Protocol): 데이터 링크 계층 터널링\n\n[VPN의 주요 용도]\n- 원격 접근: 외부에서 회사 내부 네트워크 접속\n- 사이트 간 연결: 지사 간 안전한 통신\n- 프라이버시 보호: IP 주소 숨김\n\n[답] \"VPN\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["101"], "raw_text": "101"}, "explanation": "이 Java 코드는 예외 처리 메커니즘과 finally 블록의 실행 순서를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java public static void main(String[] args) {\nint sum = 0;\ntry {\nfunc(); // NullPointerException 발생\n} catch (NullPointerException e) {\nsum = sum + 1; // sum = 1\n} catch (Exception e) {\nsum = sum + 10;\n} finally {\nsum = sum + 100; // 항상 실행\n}\nSystem.out.print(sum);\n}\n\nstatic void func() throws Exception {\nthrow new NullPointerException();\n}\n```\n\n[실행 과정]\n\n1. [try 블록 실행]\n- `func()` 호출\n- `NullPointerException` 발생\n\n2. [예외 처리]\n- Java는 첫 번째로 일치하는 catch 블록을 찾습니다.\n- `catch (NullPointerException e)` → **일치!**\n- `sum = 0 + 1 = 1`\n\n3. [finally 블록 실행]\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- `sum = 1 + 100 = 101`\n\n4. [최종 출력]\n- **출력: 101[핵심 포인트]\n- 예외 처리 순서: try → catch(일치하는 예외) → finally\n- finally 블록은 반드시 실행됩니다.\n- `NullPointerException`은 `Exception`의 자식 클래스이므로, 더 구체적인 catch 블록이 먼저 매칭됩니다.\n\n[답] 101", "table_refs": [], "image_refs": ["images/2024_round3/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "java", "code": "public class ExceptionHandling {\n  public static void main(String[] args) {\n      int sum = 0;\n      try {\n          func();\n      } catch (NullPointerException e) {\n          sum = sum + 1;\n      } catch (Exception e) {\n          sum = sum + 10;\n      } finally {\n          sum = sum + 100;\n      }\n      System.out.print(sum);\n  }\n  static void func() throws Exception {\n      throw new NullPointerException(); \n  }\n}", "line_numbers": [1, 18], "file": "data/codes/2024_round3/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["B0"], "raw_text": "B0"}, "explanation": "[Java 제네릭 타입 소거와 메서드 오버로딩 - 코드 실행 추적]\n\n**실행 과정:**\n\n1. `new Collection<>(0)` → Collection<Integer> 객체 생성\n   - value = 0 (Integer)\n\n2. `.print()` 호출 → `new Printer().print(value)` 실행\n\n3. **메서드 오버로딩 해석:**\n   - 컴파일 타임에 제네릭 타입 소거 발생\n   - `T value`는 `Object` 타입으로 처리됨\n   - 사용 가능한 메서드:\n     - `print(Integer a)` - Integer 타입\n     - `print(Number a)` - Number 타입\n     - `print(Object a)` - Object 타입 ✅\n   \n4. **타입 매칭:**\n   - value는 컴파일 타임에 `Object` 타입\n   - `print(Object a)` 메서드 호출\n\n5. **출력:**\n   - `System.out.print(\"B\" + 0)` → **B0**\n\n**정답: B0**\n\n**핵심:**\n- 제네릭 타입 소거: 런타임에 타입 정보 삭제\n- 컴파일 타임에 `T`는 `Object`로 취급", "table_refs": [], "image_refs": ["images/2024_round3/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-05T16:01:31.959340", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "java", "code": "class Main {\n  public static class Collection<T>{\n    T value;\n    public Collection(T t){\n        value = t;\n    }\n    public void print(){\n       new Printer().print(value);\n    }\n   class Printer{\n      void print(Integer a){\n        System.out.print(\"A\" + a);\n      }\n      void print(Object a){\n        System.out.print(\"B\" + a);\n      } \n      void print(Number a){\n        System.out.print(\"C\" + a);\n      }\n   }\n }\n  public static void main(String[] args) {\n      new Collection<>(0).print();\n  }\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round3/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 네트워크에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다.\n\n- 일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다.\n\n- 긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다.\n\n[보기]\n\nㄱ.Infrastructure Network\n\nㄴ. Firmware Network\n\nㄷ. Peer-to-Peer Network\n\nㄹ. Ad-hoc Network\n\nㅁ. Mesh Network\n\nㅂ.Sensor Network\n\nㅅ.Virtual Private Network", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "Ad-hoc Network(애드혹 네트워크)는 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다\"\n- 중앙 서버나 라우터 없이 노드들이 직접 통신합니다.\n- 인프라가 필요 없어 빠르게 구성 가능합니다.\n- 동적으로 네트워크를 형성합니다.\n\n2. \"일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다\"\n- 무선 기술(Wi-Fi, Bluetooth 등)을 사용합니다.\n- P2P(Peer-to-Peer) 방식으로 직접 통신합니다.\n- 각 노드가 라우터 역할을 할 수 있습니다.\n\n3. \"긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다\"\n- 인프라가 없는 상황에서도 통신 가능\n- 재난 상황, 야전 환경 등에서 활용\n- 임시 네트워크 구축에 적합\n\n[보기 분석]\n- ㄱ. Infrastructure Network: 인프라 기반 네트워크 (Wi-Fi AP 필요)\n- ㄴ. Firmware Network: 펌웨어 네트워크 (일반적 용어 아님)\n- ㄷ. Peer-to-Peer Network: P2P (일부 특징 유사하지만 Ad-hoc과 다름)\n- ㄹ. Ad-hoc Network: 중앙 인프라 없이 임시 구성 ✓\n- ㅁ. Mesh Network: 메시 네트워크 (Ad-hoc의 확장 형태)\n- ㅂ. Sensor Network: 센서 네트워크 (IoT)\n- ㅅ. Virtual Private Network: VPN (가상 사설망)\n\n[답] \"ㄹ\" (Ad-hoc Network)", "table_refs": [{"id": "table1", "json": "data/tables/2024_round3/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.033447"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
