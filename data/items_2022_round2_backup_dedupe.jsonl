{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 관계 데이터 모델에 대한 설명이다.\n괄호 안에 들어가는 용어를 작성하시오.\n( )은 /는 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용한다.\n수학의 predicate calculus에 기반을 두고 있으며\n,\n관계 데이터 모델의 제안자인 codd가 수학에 가까운 기반을 두고 특별히 관계 데이터베이스를 위해 제안하여 탄생하였다.\n( ) /은/는 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 튜블 ( )와/과 도메인 ( ) 이/가 있다.", "choices": [], "answer": {"keys": ["관계해석", "Relational Calculus"], "raw_text": "관계해석"}, "explanation": "이 문제는 관계해석(Relational Calculus)에 대한 문제입니다.\n\n[관계해석(Relational Calculus)이란?]\n- **관계 데이터의 연산을 표현하는 방법**으로, 원하는 정보를 정의할 때 **계산 수식을 사용**\n- 수학의 predicate calculus(술어 해석학)에 기반\n- 관계 데이터 모델의 제안자인 E.F. Codd가 수학에 가까운 기반을 두고 관계 데이터베이스를 위해 제안\n\n[관계해석의 특징]\n\n1. [비절차적(Non-procedural) 특성]\n   - **\"원하는 정보가 무엇인지만 정의\"**\n   - 어떻게(How) 얻을지는 명시하지 않음\n   - 무엇(What)을 원하는지만 명시\n   - SQL과 유사한 특성\n\n2. [튜블 관계해석(Tuple Relational Calculus)과 도메인 관계해석(Domain Relational Calculus)]\n   - **튜블 관계해석**: 튜플(행) 단위로 표현\n   - **도메인 관계해석**: 속성(컬럼)의 값 도메인 단위로 표현\n\n[관계해석 vs 관계대수]\n\n| 구분 | 관계대수 (Relational Algebra) | 관계해석 (Relational Calculus) |\n|------|-------------------------------|--------------------------------|\n| **특성** | 절차적 (Procedural) | 비절차적 (Non-procedural) |\n| **표현** | 연산자(σ, π, ⋈) 사용 | 수식(식) 사용 |\n| **기반** | 집합 이론 (Set Theory) | 술어 해석학 (Predicate Calculus) |\n| **방법** | 어떻게(How) 얻을지 명시 | 무엇(What)을 원하는지만 명시 |\n| **등가성** | 관계대수로 표현 가능한 것은 관계해석으로도 표현 가능 (등가) | |\n\n[관계해석의 예시]\n```\n{t | EMPLOYEE(t) AND t.SALARY > 50000}\n→ 급여가 50000보다 큰 직원 튜플의 집합\n```\n\n[Codd의 기여]\n- 1970년 \"A Relational Model of Data for Large Shared Data Banks\" 논문 발표\n- 관계 데이터베이스의 이론적 기초 마련\n- 관계대수와 관계해석의 등가성 증명\n\n[답] **관계해석** (또는 **Relational Calculus**)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.996449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 대칭 키 알고리즘에 대한 설명이다.\n해당 설명에 맞는 용어를 보기에 골라 작성하시오.", "choices": [], "answer": {"keys": ["1. IDEA", "2. SKIPJACK"], "raw_text": "1. IDEA 2. SKIPJACK"}, "explanation": "이 문제는 **대칭 키 암호 알고리즘**에 관한 문제입니다.\n\n[1. IDEA (International Data Encryption Algorithm, 국제 데이터 암호화 알고리즘)]\n\n[영어 약자 풀이]\n- **I**nternational: 국제\n- **D**ata: 데이터\n- **E**ncryption: 암호화\n- **A**lgorithm: 알고리즘\n- IDEA = International Data Encryption Algorithm\n\n[IDEA의 개발 역사]\n- **개발자**: Xuejia Lai와 James Massey\n- **개발 과정**:\n  - PES (Proposed Encryption Standard): 초기 제안된 암호화 표준\n  - **IPES (Improved PES)**: 개선된 PES\n  - **IDEA**: 1991년에 최종적으로 제작된 블록 암호 알고리즘\n\n[IDEA의 특징]\n- **블록 크기**: 64비트 블록\n- **키 크기**: 128비트 키\n- **라운드 수**: 8개 라운드로 구성\n- **용도**: 현재 **국제 데이터 암호화 알고리즘**으로 사용\n\n[IDEA의 특징 요약]\n| 특징 | 값 |\n|------|-----|\n| **블록 크기** | 64비트 |\n| **키 크기** | 128비트 |\n| **라운드 수** | 8개 |\n| **개발자** | Xuejia Lai, James Massey |\n| **개발 연도** | 1991년 |\n\n[2. SKIPJACK]\n\n[SKIPJACK의 특징]\n- **개발자**: 미국 NSA (National Security Agency)\n- **용도**: **Clipper 칩**에 내장되는 블록 알고리즘\n- **주요 사용**: 전화기와 같은 **음성을 암호화**하는데 주로 사용\n- **블록 크기**: 64비트 입출력\n- **키 크기**: 80비트 키\n- **라운드 수**: 총 32라운드\n\n[SKIPJACK의 특징 요약]\n| 특징 | 값 |\n|------|-----|\n| **개발자** | 미국 NSA |\n| **용도** | Clipper 칩 내장, 음성 암호화 |\n| **블록 크기** | 64비트 |\n| **키 크기** | 80비트 |\n| **라운드 수** | 32라운드 |\n\n[대칭 키 암호 알고리즘 비교]\n| 알고리즘 | 블록 크기 | 키 크기 | 라운드 | 특징 |\n|----------|-----------|---------|--------|------|\n| **IDEA** | 64비트 | 128비트 | 8 | 국제 표준, Lai와 Massey 개발 |\n| **SKIPJACK** | 64비트 | 80비트 | 32 | NSA 개발, Clipper 칩, 음성 암호화 |\n| **AES** | 128비트 | 128/192/256비트 | 10/12/14 | 현재 가장 널리 사용 |\n| **DES** | 64비트 | 56비트 | 16 | 구형 표준 (현재는 취약) |\n\n[답]\n- (1) IDEA (International Data Encryption Algorithm)\n- (2) **SKIPJACK**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.996449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "Xuejia Lai와 James Messey 가 만든 알고리즘으로 PES(Proposed Encryption Standard)에서 IPES(Improved PES)로 변경되었다가, 1991년에 제작된 블록 암호 알고리즘으로 현재 국제 데이터 암호화 알고리즘으로 사용되고 있다. 64비트 블록을 128비트의 key를 이용하여 8개의 라운드로 구성되어 있다.", "choices": [], "answer": {"keys": ["IDEA"], "raw_text": "IDEA"}, "explanation": "이 문제는 IDEA (International Data Encryption Algorithm, 국제 데이터 암호화 알고리즘)에 대한 문제입니다.\n\n[IDEA (International Data Encryption Algorithm, 국제 데이터 암호화 알고리즘)]\n\n[영어 약자 풀이]\n- **I**nternational: 국제\n- **D**ata: 데이터\n- **E**ncryption: 암호화\n- **A**lgorithm: 알고리즘\n- IDEA = International Data Encryption Algorithm\n\n[IDEA의 개발 역사]\n- **개발자**: **Xuejia Lai**와 **James Massey** (문제에서 \"Messey\"는 오타로 보이며, 정확한 이름은 Massey)\n- **개발 과정**:\n  1. PES (Proposed Encryption Standard): 초기 제안된 암호화 표준\n  2. **IPES (Improved PES)**: 개선된 PES\n  3. **IDEA**: 1991년에 최종적으로 제작된 블록 암호 알고리즘\n\n[문제에서 설명한 IDEA의 특징]\n\n1. \"Xuejia Lai와 James Massey가 만든 알고리즘\":\n   - 스위스 연방공과대학(ETH Zurich)의 연구자들이 개발\n   - 1990년대 초반 개발\n\n2. \"PES → IPES → IDEA로 변경\":\n   - PES (Proposed Encryption Standard): 초기 제안 표준\n   - **IPES (Improved PES)**: 개선된 버전\n   - **IDEA**: 최종 버전 (1991년 완성)\n\n3. \"현재 국제 데이터 암호화 알고리즘으로 사용\":\n   - 현재까지 널리 사용되는 블록 암호 알고리즘\n   - PGP(Pretty Good Privacy) 등에서 사용\n\n4. \"64비트 블록을 128비트의 key를 이용하여 8개의 라운드로 구성\":\n   - **블록 크기**: 64비트\n   - **키 크기**: 128비트\n   - **라운드 수**: 8개 라운드\n\n[IDEA의 특징]\n| 특징 | 값 |\n|------|-----|\n| **블록 크기** | 64비트 |\n| **키 크기** | 128비트 |\n| **라운드 수** | 8개 |\n| **개발자** | Xuejia Lai, James Massey |\n| **개발 연도** | 1991년 |\n| **주요 용도** | PGP, 국제 데이터 암호화 |\n\n[IDEA의 암호화 과정]\n1. **64비트 평문 블록**을 입력\n2. **128비트 키**를 사용하여 8개의 라운드로 암호화\n3. 각 라운드에서 XOR, 덧셈, 곱셈 연산 수행\n4. 최종적으로 **64비트 암호문** 생성\n\n[IDEA vs 다른 암호 알고리즘]\n| 알고리즘 | 블록 크기 | 키 크기 | 라운드 | 특징 |\n|----------|-----------|---------|--------|------|\n| **IDEA** | 64비트 | 128비트 | 8 | 국제 표준, Lai와 Massey 개발 |\n| **AES** | 128비트 | 128/192/256비트 | 10/12/14 | 현재 가장 널리 사용 |\n| **DES** | 64비트 | 56비트 | 16 | 구형 표준 (현재는 취약) |\n| **3DES** | 64비트 | 168비트 | 48 | DES의 3회 반복 |\n\n[답] IDEA (International Data Encryption Algorithm)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["네트워크"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "미국의 NSA에서 개발한 Clipper 칩에 내장되는 블록 알고리즘이다. 전화기와 같은 음성을 암호화 하는데 주로 사용되며 64비트 입출력에 80비트의 키 총 32라운드를 가진다.", "choices": [], "answer": {"keys": ["SKIPJACK"], "raw_text": "SKIPJACK"}, "explanation": "이 문제는 **SKIPJACK** 블록 암호 알고리즘에 대한 문제입니다.\n\n[SKIPJACK이란?]\n\n[SKIPJACK의 특징]\n\n1. **\"미국의 NSA에서 개발\"**:\n   - NSA (National Security Agency): 미국 국가안보국\n   - 미국 정부 기관에서 개발한 블록 암호 알고리즘\n\n2. \"Clipper 칩에 내장되는 블록 알고리즘\":\n   - **Clipper 칩**: 1990년대 미국 정부가 개발한 암호화 칩\n   - SKIPJACK 알고리즘이 Clipper 칩에 내장되어 사용\n   - Clipper 칩은 전화 통신 암호화를 위한 하드웨어 칩\n\n3. \"전화기와 같은 음성을 암호화하는데 주로 사용\":\n   - **주요 용도**: 음성 통신 암호화\n   - 전화 통신에서 음성 데이터를 안전하게 암호화\n   - 실시간 음성 암호화에 적합\n\n4. \"64비트 입출력에 80비트의 키 총 32라운드를 가진다\":\n   - **블록 크기**: 64비트 입출력\n   - **키 크기**: 80비트 키\n   - **라운드 수**: 총 32라운드\n\n[SKIPJACK의 특징 요약]\n| 특징 | 값 |\n|------|-----|\n| **개발자** | 미국 NSA (National Security Agency) |\n| **용도** | Clipper 칩 내장, 음성 암호화 |\n| **블록 크기** | 64비트 |\n| **키 크기** | 80비트 |\n| **라운드 수** | 32라운드 |\n| **주요 사용** | 전화기 음성 암호화 |\n\n[Clipper 칩과 SKIPJACK]\n- **Clipper 칩**: 1990년대 미국 정부가 개발한 암호화 하드웨어 칩\n- **목적**: 전화 통신의 암호화 및 키 복구 기능 제공\n- **내장 알고리즘**: SKIPJACK\n- **특징**: 키 복구 기능 포함 (법 집행 기관을 위한 백도어)\n\n[SKIPJACK vs 다른 암호 알고리즘]\n| 알고리즘 | 개발자 | 블록 크기 | 키 크기 | 라운드 | 주요 용도 |\n|----------|--------|-----------|---------|--------|----------|\n| **SKIPJACK** | NSA | 64비트 | 80비트 | 32 | Clipper 칩, 음성 암호화 |\n| **IDEA** | Lai, Massey | 64비트 | 128비트 | 8 | 국제 표준, PGP |\n| **AES** | NIST | 128비트 | 128/192/256비트 | 10/12/14 | 현재 가장 널리 사용 |\n| **DES** | IBM | 64비트 | 56비트 | 16 | 구형 표준 (현재는 취약) |\n\n[SKIPJACK의 암호화 과정]\n1. **64비트 평문 블록**을 입력\n2. **80비트 키**를 사용하여 32개의 라운드로 암호화\n3. 각 라운드에서 복잡한 연산 수행\n4. 최종적으로 **64비트 암호문** 생성\n\n[답] **SKIPJACK**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["네트워크"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "H회사의 전체 제품 단가 보다 큰 제품 출력을 하고자 한다. 괄호 안에 들어갈 알맞는 용어를 작성하시오.\nSELECT 제조사, 제품명, 단가 FROM 제품 WHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사='H')", "choices": [], "answer": {"keys": ["ALL"], "raw_text": "ALL"}, "explanation": "이 문제는 SQL 서브쿼리에서 비교 연산자와 함께 사용하는 수량자에 관한 문제입니다.\n\n[주어진 SQL 쿼리]\n```sql\nSELECT 제조사, 제품명, 단가 \nFROM 제품 \nWHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사='H')\n```\n\n[문제의 요구사항]\n- \"H회사의 **전체** 제품 단가보다 큰 제품\"\n- 즉, H회사의 **모든** 제품 단가보다 큰 제품만 선택\n\n[서브쿼리와 비교 연산자]\n- 서브쿼리 결과가 여러 행일 경우, 비교 연산자(>, <, >=, <=, =, !=)와 직접 사용 불가\n- 수량자 **ALL** 또는 **ANY(SOME)** 사용 필요\n\n[ALL의 의미]\n- **ALL**: 서브쿼리의 **모든 값**과 비교\n- `단가 > ALL (서브쿼리)` = 서브쿼리의 **모든 값보다 크다**\n- 예: `단가 > ALL (100, 200, 300)` = 단가가 **100보다 크고**, **200보다 크고**, **300보다 큰** (즉, 300보다 큰)\n\n[ANY(SOME)의 의미]\n- **ANY(SOME)**: 서브쿼리의 **임의의 값**과 비교 (하나라도 만족하면 됨)\n- `단가 > ANY (서브쿼리)` = 서브쿼리의 **어떤 값보다 크다** (하나라도 크면 됨)\n- 예: `단가 > ANY (100, 200, 300)` = 단가가 **100보다 크거나**, **200보다 크거나**, **300보다 큰** (즉, 100보다 크면 됨)\n\n[문제 해석]\n- \"H회사의 **전체** 제품 단가보다 큰\"\n- = H회사의 **모든** 제품 단가보다 큰\n- = **ALL** 사용\n\n[최대값 비교 방법]\n- `단가 > ALL (SELECT 단가 FROM 제품 WHERE 제조사='H')`\n- = `단가 > (SELECT MAX(단가) FROM 제품 WHERE 제조사='H')`\n- 두 쿼리는 동일한 결과 (ALL과 MAX 사용)\n\n[ALL vs ANY 비교]\n\n| 수량자 | 의미 | 예시 |\n|--------|------|------|\n| **ALL** | 모든 값과 비교 (모두 만족) | `단가 > ALL (100, 200, 300)` = 단가 > 300 |\n| **ANY(SOME)** | 임의의 값과 비교 (하나라도 만족) | `단가 > ANY (100, 200, 300)` = 단가 > 100 |\n\n[실행 과정 예시]\n1. 서브쿼리 실행: `SELECT 단가 FROM 제품 WHERE 제조사='H'`\n   - 결과: (100, 200, 300) - H회사의 모든 제품 단가\n\n2. ALL 적용: `단가 > ALL (100, 200, 300)`\n   - 의미: 단가가 **100보다 크고**, **200보다 크고**, **300보다 큰**\n   - 실제 조건: **단가 > 300** (최대값보다 큰 값만 선택)\n\n3. 최종 결과: 단가가 300보다 큰 제품만 출력\n\n[답] **ALL**", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 SQL 결과에 알맞는 답을 작성하시오.\nSELECT count(col2)\nFROM TABLE WHERE col1 in(2,3) or col2 in(3,5);", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 문제는 SQL COUNT 함수와 WHERE 절의 OR 조건에 관한 문제입니다.\n\n[주어진 SQL 쿼리]\n```sql\nSELECT count(col2)\nFROM TABLE\nWHERE col1 in(2,3) or col2 in(3,5);\n```\n\n[COUNT 함수의 특징]\n- **COUNT(컬럼명)**: 해당 컬럼의 **NULL이 아닌 값의 개수**를 반환\n- **COUNT(*): 모든 행의 개수를 반환 (NULL 포함)\n- COUNT(DISTINCT 컬럼명): 중복을 제거한 고유 값의 개수 반환\n\n[WHERE 절의 OR 조건]\n- OR 연산자**: 조건 중 **하나라도 만족하면 선택\n- `col1 in(2,3) or col2 in(3,5)`:\n  - `col1`이 2 또는 3인 행 또는\n  - `col2`가 3 또는 5인 행\n\n[쿼리 실행 과정]\n1. WHERE 절 조건 확인:\n   - `col1 in(2,3) or col2 in(3,5)` 조건을 만족하는 행 선택\n   - OR 조건이므로 둘 중 하나만 만족해도 선택됨\n\n2. COUNT(col2) 계산:\n   - 선택된 행들 중에서 `col2`가 NULL이 아닌 값의 개수를 세어서 반환\n   - COUNT는 NULL 값을 제외하고 계산\n\n[주의사항]\n- OR 조건: `col1 in(2,3)` 또는 `col2 in(3,5)` 조건을 만족하는 모든 행** 선택\n- **중복 제거 없음: OR 조건이므로 같은 행이 여러 조건에 해당될 수 있지만, COUNT는 행 단위로 계산\n- NULL 처리: COUNT(col2)는 col2가 NULL인 행은 제외하고 계산\n\n[답] 문제에서 주어진 테이블의 데이터를 기준으로 조건을 만족하는 행들 중 col2가 NULL이 아닌 행의 개수를 세면 4가 됩니다.\n\n[답] 4**", "table_refs": [], "image_refs": ["images/2022_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 네트워크에 관련한 내용이다.\n괄호 안에 들어갈 알맞는 답을 작성하시오.\n( )은/는 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하며, 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.\n또한 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.", "choices": [], "answer": {"keys": ["VPN"], "raw_text": "VPN"}, "explanation": "문제에서 설명하는 특징들이 모두 VPN (Virtual Private Network, 가상 사설망)을 가리킵니다.\n\n[VPN (Virtual Private Network, 가상 사설망)]\n\n[영어 약자 풀이]\n- **V**irtual: 가상의\n- **P**rivate: 사설의\n- **N**etwork: 네트워크\n- VPN = Virtual Private Network\n\n[VPN의 정의]\n- 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하는 기술\n- **퍼블릭 네트워크(공중망)**를 이용하여 **사설 네트워크처럼 안전하게** 통신하는 기술\n\n[문제에서 언급한 VPN의 특징]\n\n1. \"인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성\":\n   - 실제 물리적 네트워크가 아닌 **가상의 터널(Tunnel)**을 통해 연결\n   - 여러 지점을 마치 하나의 사설망처럼 연결\n\n2. \"퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송\":\n   - 공중망을 통해 전송하지만 **암호화**하여 안전하게 전송\n   - 실제 IP 주소를 숨겨 **익명성** 보장\n\n3. **\"사용자 IP 주소를 마스킹\"**:\n   - 실제 IP 주소를 **가상 IP 주소로 대체** (IP 마스킹)\n   - 위치 추적 및 식별을 어렵게 만듦\n\n4. \"데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록\":\n   - 전송되는 모든 데이터를 **암호화** (Encryption)\n   - 중간에 가로채도 암호화되어 있어 내용 확인 불가\n\n[VPN의 동작 원리]\n\n1. **터널링(Tunneling)**:\n   - 공중망 위에 가상의 **암호화된 터널** 생성\n   - 터널을 통해 데이터가 안전하게 전송\n\n2. **암호화(Encryption)**:\n   - 전송 전 데이터를 암호화 (AES, RSA 등 사용)\n   - 수신 측에서 복호화하여 원본 데이터 복원\n\n3. **인증(Authentication)**:\n   - 사용자 인증 및 접근 권한 확인\n   - 승인된 사용자만 VPN 접속 가능\n\n[VPN의 주요 용도]\n- **원격 접근**: 재택근무자나 외부 직원이 회사 네트워크에 안전하게 접속\n- **사이트 간 연결**: 여러 지사나 데이터센터를 하나의 네트워크처럼 연결\n- **개인 프라이버시 보호**: IP 주소 마스킹, 위치 정보 숨김\n- **지역 제한 우회**: 특정 국가/지역에서만 접근 가능한 서비스 이용\n\n[VPN의 종류]\n- PPTP (Point-to-Point Tunneling Protocol): 초기 VPN 프로토콜\n- L2TP/IPSec (Layer 2 Tunneling Protocol with IPSec): 더 안전한 프로토콜\n- **OpenVPN**: 오픈소스 기반 VPN 프로토콜\n- **SSL/TLS VPN**: 웹 기반 VPN (HTTPS 사용)\n\n[VPN의 보안 기능]\n| 기능 | 설명 |\n|------|------|\n| **암호화** | 데이터를 암호화하여 전송 |\n| **IP 마스킹** | 실제 IP 주소를 가상 IP로 대체 |\n| **인증** | 사용자 및 기기 인증 |\n| **터널링** | 가상의 암호화된 통로 생성 |\n\n[답] **VPN**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 SOLID 원칙에 관한 내용이다.\n괄호 안에 알맞는 단어를 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nSRP\n,\nLSP 등..))\n( ) 은/는 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.\n( ) 은/는 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.\n예를 들어 하나의 복합기에 프린터와 복사기, 팩스 메서드가 있는데 이 세가지 메서드는 같은 파일에 존재하므로 프린터 로직만 바뀌어도 복사기와 팩스도 재컴파일을 해야한다.\n그러므로 ( ) 을/를 적용하여 로직이 바뀌어도 다른 메서드는 영향을 받지 않도록 해야한다.", "choices": [], "answer": {"keys": ["ISP"], "raw_text": "ISP"}, "explanation": "이 문제는 **SOLID 원칙** 중 ISP (Interface Segregation Principle, 인터페이스 분리 원칙)에 대한 문제입니다.\n\n[ISP (Interface Segregation Principle, 인터페이스 분리 원칙)이란?]\n\n[영어 약자 풀이]\n- **I**nterface: 인터페이스\n- **S**egregation: 분리, 격리\n- **P**rinciple: 원칙\n- ISP = Interface Segregation Principle\n\n[ISP의 핵심 원칙]\n1. \"클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다\":\n   - 클라이언트는 **자신이 실제로 사용하는 메서드만** 의존해야 함\n   - 사용하지 않는 메서드까지 구현하도록 강제하면 안 됨\n\n2. \"큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리\":\n   - 하나의 큰 인터페이스를 **여러 개의 작은 인터페이스로 분리**\n   - 각 인터페이스는 **특정 역할**에만 집중\n   - 클라이언트는 **필요한 인터페이스만** 구현/사용\n\n[문제에서 제시한 예시]\n\n[문제 상황]\n- 하나의 복합기 인터페이스에 프린터, 복사기, 팩스 메서드가 모두 있음\n- 프린터 로직만 변경해도 복사기와 팩스도 재컴파일 필요\n- **강한 결합도**, 불필요한 의존성 발생\n\n[ISP 적용 전 (나쁜 예)]\n```java\ninterface 복합기 {\n    void 프린트();\n    void 복사();\n    void 팩스();\n}\n\nclass 프린터 implements 복합기 {\n    void 프린트() { ... }\n    void 복사() { ... } // 사용 안 함\n    void 팩스() { ... } // 사용 안 함\n}\n```\n- 프린터 클래스가 복사(), 팩스() 메서드까지 구현해야 함 (불필요한 의존)\n- 하나의 메서드 변경 시 전체 재컴파일 필요\n\n[ISP 적용 후 (좋은 예)]\n```java\ninterface 프린터인터페이스 {\n    void 프린트();\n}\n\ninterface 복사기인터페이스 {\n    void 복사();\n}\n\ninterface 팩스인터페이스 {\n    void 팩스();\n}\n\nclass 프린터 implements 프린터인터페이스 {\n    void 프린트() { ... }\n}\n```\n- 각 클래스는 **자신이 필요한 인터페이스만** 구현\n- 프린터 로직 변경 시 프린터만 재컴파일 (독립적 수정 가능)\n\n[ISP의 장점]\n1. **낮은 결합도**: 클라이언트가 필요한 메서드만 의존\n2. **높은 응집도**: 관련된 메서드만 하나의 인터페이스에 포함\n3. **독립적 수정**: 한 기능 변경이 다른 기능에 영향 없음\n4. **재사용성 향상**: 작은 인터페이스 단위로 재사용 용이\n\n[SOLID 원칙 전체]\n| 원칙 | 약자 | 핵심 내용 |\n|------|------|----------|\n| **단일 책임 원칙** | SRP | 하나의 클래스는 하나의 책임만 가져야 함 |\n| **개방-폐쇄 원칙** | OCP | 확장에는 열려 있고 수정에는 닫혀 있어야 함 |\n| **리스코프 치환 원칙** | LSP | 하위 클래스는 상위 클래스를 대체 가능해야 함 |\n| **인터페이스 분리 원칙** | **ISP** | 큰 인터페이스를 작은 인터페이스로 분리 |\n| **의존성 역전 원칙** | DIP | 고수준 모듈은 저수준 모듈에 의존하면 안 됨 |\n\n[답] ISP (Interface Segregation Principle)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 자바 코드에 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["-8"], "raw_text": "-8"}, "explanation": "✅ 정답: -8\n\n📌 코드 실행 과정 추적\n\n초기값:\n- i = 3\n- k = 1\n\nswitch(3) 실행 (fall-through):\n\n| case | 조건 | 실행 | k 값 |\n|------|------|------|------|\n| 1 | i==1 | ❌ 실행 안 됨 | 1 |\n| 2 | i==2 | ❌ 실행 안 됨 | 1 |\n| 3 | i==3 | ✅ k = 0 | 0 |\n| 4 | break 없음 | ✅ k += 3 | 3 |\n| 5 | break 없음 | ✅ k -= 10 | -7 |\n| default | break 없음 | ✅ k-- | -8 ✅ |\n\n⚠️ Fall-through:\n```\ncase 3: k = 0;        // break 없음 → 계속 실행\ncase 4: k += 3;       // 3\ncase 5: k -= 10;      // -7\ndefault: k--;         // -8\n```\n\n출력: -8\n\n💡 핵심:\n- switch-case에서 break가 없으면 다음 case도 계속 실행됨 (fall-through)\n- case 3부터 default까지 모두 실행\n\n", "table_refs": [], "image_refs": ["images/2022_round2/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 소스코드에 대한 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["22"], "raw_text": "22"}, "explanation": "[C언어 포인터와 배열 - 코드 실행 추적]\n\n**코드:**\n```c\nint a[4] = {0, 2, 4, 8};\nint b[3] = {};\nint i = 1;\nint sum = 0;\nint *p1;\n\nfor (i; i < 4; i++) {\n    p1 = a + i;\n    b[i-1] = *p1 - a[i-1];\n    sum = sum + b[i-1] + a[i];\n}\n```\n\n**초기 상태:**\n```\na[] = {0, 2, 4, 8}\nb[] = {0, 0, 0}\ni = 1, sum = 0\n```\n\n**실행 과정:**\n\n| 반복 | p1 | b[i-1] 계산 | b[i-1] | sum 계산 | sum |\n|------|-----|-------------|--------|----------|-----|\n| i=1 | a+1 (a[1]의 주소) | *p1 - a[0] = 2 - 0 | 2 | 0 + 2 + a[1] = 0 + 2 + 2 | 4 |\n| i=2 | a+2 (a[2]의 주소) | *p1 - a[1] = 4 - 2 | 2 | 4 + 2 + a[2] = 4 + 2 + 4 | 10 |\n| i=3 | a+3 (a[3]의 주소) | *p1 - a[2] = 8 - 4 | 4 | 10 + 4 + a[3] = 10 + 4 + 8 | **22** |\n\n**단계별 설명:**\n\n**i=1:**\n- `p1 = a + 1` → a[1]의 주소\n- `b[0] = *p1 - a[0] = 2 - 0 = 2`\n- `sum = 0 + 2 + 2 = 4`\n\n**i=2:**\n- `p1 = a + 2` → a[2]의 주소\n- `b[1] = *p1 - a[1] = 4 - 2 = 2`\n- `sum = 4 + 2 + 4 = 10`\n\n**i=3:**\n- `p1 = a + 3` → a[3]의 주소\n- `b[2] = *p1 - a[2] = 8 - 4 = 4`\n- `sum = 10 + 4 + 8 = 22`\n\n**최종 결과:**\n```\nsum = 22\nb[] = {2, 2, 4}\n```\n\n**정답: 22**\n\n**핵심 개념:**\n- 포인터 연산: `a + i`는 `&a[i]`와 동일\n- 포인터 역참조: `*p1`은 포인터가 가리키는 값\n- 배열 인덱스: `b[i-1]`로 이전 위치에 저장", "table_refs": [], "image_refs": ["images/2022_round2/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-05T16:09:26.135423", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "IP 주소가 139.127.19.132이고 서브넷마스크 255.255.255.192일 때 아래의 답을 작성하시오.\n(10진수로 표기)\n\n(1) 괄호 안에 들어갈 네트워크 주소 : 139.127.19.( )\n(2) 해당 네트워크 주소와 브로드캐스트 주소를 제외한 호스트 개수", "choices": [], "answer": {"keys": ["1) 128", "2) 62"], "raw_text": "1) 128 2) 62"}, "explanation": "이 문제는 서브넷마스크를 이용한 네트워크 주소와 호스트 개수 계산 문제입니다.\n\n[주어진 정보]\n- **IP 주소**: 139.127.19.132\n- **서브넷마스크**: 255.255.255.192\n\n[① 네트워크 주소 계산]\n\n[서브넷마스크 분석]\n- 서브넷마스크 255.255.255.192를 이진수로 변환:\n  - 255.255.255.192 = `11111111.11111111.11111111.11000000`\n  - 마지막 옥텟(8비트)에서: `192` = `11000000` (2진수)\n  - 서브넷 비트: 앞의 2개 비트 (11)\n  - 호스트 비트: 뒤의 6개 비트 (000000)\n\n[네트워크 주소 계산 (AND 연산)]\n- **IP 주소 (이진수)**: 139.127.19.132 = `10001011.01111111.00010011.10000100`\n- **서브넷마스크 (이진수)**: 255.255.255.192 = `11111111.11111111.11111111.11000000`\n- **AND 연산**:\n  ```\n  10000100  (132 in binary)\n  AND\n  11000000  (192 in binary)\n  ---------\n  10000000  = 128 (decimal)\n  ```\n- **네트워크 주소**: 139.127.19.**128**\n\n[② 사용 가능한 호스트 개수 계산]\n\n[호스트 비트 수]\n- 서브넷마스크 `255.255.255.192`에서 호스트 비트 = 6개\n- 총 사용 가능한 주소 수 = 2^6 = **64개**\n\n[사용 불가능한 주소 제외]\n- **네트워크 주소**: 139.127.19.128 (시작 주소, 호스트에 할당 불가)\n- **브로드캐스트 주소**: 139.127.19.191 (끝 주소, 호스트에 할당 불가)\n  - 계산: 128 + 64 - 1 = 191\n\n[실제 사용 가능한 호스트 수]\n- 64 - 2 = **62개**\n\n[상세 계산 과정]\n\n| 항목 | 값 | 계산 |\n|------|-----|------|\n| **서브넷마스크** | 255.255.255.192 | `11111111.11111111.11111111.11000000` |\n| **호스트 비트 수** | 6개 | 마지막 옥텟에서 0의 개수 |\n| **총 주소 수** | 64개 | 2^6 = 64 |\n| **네트워크 주소** | 139.127.19.128 | IP AND 서브넷마스크 |\n| **브로드캐스트 주소** | 139.127.19.191 | 네트워크 주소 + 64 - 1 |\n| **사용 가능한 호스트** | **62개** | 64 - 2 = 62 |\n\n[호스트 주소 범위]\n- 시작: 139.127.19.129 (네트워크 주소 + 1)\n- 끝: 139.127.19.190 (브로드캐스트 주소 - 1)\n- 총 62개 호스트 주소 사용 가능\n\n[답]\n- (1) **128**\n- (2) **62**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 설명에 대한 괄호 안에 알맞는 단어를 작성하시오.", "choices": [], "answer": {"keys": ["1) 베타", "2) 알파"], "raw_text": "1) 베타 2) 알파"}, "explanation": "이 문제는 **소프트웨어 테스트의 단계**에 관한 문제입니다.\n\n[1. 베타 테스트 (Beta Test)]\n\n[베타 테스트의 정의]\n- **선정된 최종 사용자**가 여러 명의 사용자 앞에서 행하는 테스트 기법\n- **실제 업무**를 가지고 사용자가 직접 테스트\n- **사용자 환경**에서 실시되는 테스트\n\n[베타 테스트의 특징]\n- **실행 주체**: 선정된 최종 사용자\n- **실행 장소**: 사용자 장소 (실제 운영 환경)\n- **테스트 방법**: 실제 업무를 가지고 사용자가 직접 테스트\n- **목적**: 실제 사용 환경에서의 문제점 발견\n- **시기**: 알파 테스트 이후, 상용화 직전\n\n[베타 테스트의 과정]\n1. **선정된 사용자**에게 시제품 제공\n2. **실제 업무 환경**에서 사용자가 직접 테스트\n3. **여러 명의 사용자** 앞에서 테스트 수행 (공개 테스트)\n4. 발견된 오류를 개발사에 보고\n5. 개발사가 오류를 수정하고 최종 제품 발매\n\n[2. 알파 테스트 (Alpha Test)]\n\n[알파 테스트의 정의]\n- **개발 회사 내부**에서 이루어지는 테스트\n- **개발자의 장소**에서 사용자가 개발자 앞에서 행하는 테스트\n- **통제된 환경**에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록\n\n[알파 테스트의 특징]\n- **실행 주체**: 개발 회사 내부 (개발자와 사용자 함께)\n- **실행 장소**: 개발자의 장소 (개발 환경)\n- **테스트 환경**: 통제된 환경\n- **테스트 방법**: 사용자와 개발자가 함께 확인하며 기록\n- **목적**: 초기 작동의 결과 평가, 내부 문제점 발견\n- **시기**: 개발 과정 초기 단계 (베타 테스트 이전)\n\n[알파 테스트 포함 테스트]\n- **단위 테스트**: 개별 모듈 테스트\n- **구성 테스트**: 모듈 간 통합 테스트\n- **시스템 테스트**: 전체 시스템 테스트\n\n[알파 vs 베타 테스트 비교]\n| 구분 | **알파 테스트 (Alpha Test)** | **베타 테스트 (Beta Test)** |\n|------|-------------------------------|-----------------------------|\n| **실행 장소** | 개발자의 장소 (개발 환경) | 사용자 장소 (실제 운영 환경) |\n| **실행 주체** | 개발 회사 내부 (개발자 + 사용자) | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **방법** | 개발자와 사용자가 함께 확인하며 기록 | 사용자가 직접 테스트 |\n| **시기** | 개발 과정 초기 단계 | 상용화 직전 |\n| **목적** | 초기 작동 결과 평가, 내부 문제점 발견 | 실제 사용 환경에서의 문제점 발견 |\n\n[테스트 단계 순서]\n1. **단위 테스트** → 2. **통합 테스트** → 3. **시스템 테스트** → 4. **알파 테스트** → 5. **베타 테스트** → 6. **상용화**\n\n[답]\n- (1) **베타 테스트 (Beta Test)**\n- (2) **알파 테스트 (Alpha Test)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "( ) 테스트는 하드웨어나 소프트웨어의 개발 단계에서 상용화하기 전에 실시하는 제품 검사 작업. 제품의 결함 여부, 제품으로서의 가치 등을 평가하기 위해 실시한다. 선발된 잠재 고객으로 하여금 일정 기간 무료로 사용하게 한 후에 나타난 여러 가지 오류를 수정, 보완한다. 공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업이다.", "choices": [], "answer": {"keys": ["베타"], "raw_text": "베타"}, "explanation": "이 문제는 **베타 테스트 (Beta Test)**에 대한 문제입니다.\n\n[베타 테스트 (Beta Test)란?]\n\n[베타 테스트의 정의]\n- 하드웨어나 소프트웨어의 개발 단계에서 **상용화하기 전에 실시**하는 제품 검사 작업\n- 공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업\n\n[문제에서 설명한 베타 테스트의 특징]\n\n1. \"상용화하기 전에 실시하는 제품 검사 작업\":\n   - 제품이 상용화되기 직전 단계에서 실시\n   - 최종 검증 단계\n\n2. \"제품의 결함 여부, 제품으로서의 가치 등을 평가\":\n   - 제품의 **기능적 결함** 발견\n   - 제품의 **가치** 평가 (사용자 경험, 만족도 등)\n   - 시장 반응 예측\n\n3. \"선발된 잠재 고객으로 하여금 일정 기간 무료로 사용하게 한 후에 나타난 여러 가지 오류를 수정, 보완\":\n   - **선정된 최종 사용자**에게 시제품 제공\n   - **무료로 일정 기간** 사용하도록 허용\n   - 실제 사용 환경에서 **오류 발견**\n   - 발견된 오류를 **수정, 보완**하여 최종 제품 완성\n\n4. \"공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업\":\n   - 알파 테스트 이후 단계\n   - 상용화 직전 **최종 검증**\n\n[베타 테스트의 특징]\n| 특징 | 설명 |\n|------|------|\n| **실행 주체** | 선정된 최종 사용자 |\n| **실행 장소** | 사용자 장소 (실제 운영 환경) |\n| **테스트 방법** | 실제 업무를 가지고 사용자가 직접 테스트 |\n| **시기** | 상용화 직전, 알파 테스트 이후 |\n| **목적** | 실제 사용 환경에서의 문제점 발견, 제품 가치 평가 |\n\n[베타 테스트의 과정]\n1. **사용자 선정**: 잠재 고객 중 베타 테스터 선발\n2. **시제품 제공**: 무료로 일정 기간 사용 허용\n3. **실제 사용**: 실제 업무 환경에서 사용자가 직접 테스트\n4. **피드백 수집**: 발견된 오류와 사용자 의견 수집\n5. **오류 수정**: 개발사가 수정, 보완\n6. **최종 제품 발매**: 공식 제품으로 발매\n\n[베타 테스트 vs 알파 테스트]\n| 구분 | **알파 테스트** | **베타 테스트** |\n|------|----------------|----------------|\n| **실행 장소** | 개발자의 장소 | 사용자 장소 |\n| **실행 주체** | 개발 회사 내부 | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **시기** | 개발 과정 초기 | 상용화 직전 |\n\n[답] **베타 테스트 (Beta Test)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "( ) 테스트는 새로운 제품 개발 과정에서 이루어지는 첫 번째 테스트. 즉, 시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 초기 작동의 결과를 평가하는 수단이며 개발 회사 내부에서 이루어지는 테스트로서 단위 테스트, 구성 테스트, 시스템 테스트 등을 포함한다.", "choices": [], "answer": {"keys": ["알파"], "raw_text": "알파"}, "explanation": "이 문제는 **알파 테스트 (Alpha Test)**에 대한 문제입니다.\n\n[알파 테스트 (Alpha Test)란?]\n\n[알파 테스트의 정의]\n- 새로운 제품 개발 과정에서 이루어지는 **첫 번째 테스트**\n- 시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 **초기 작동의 결과를 평가**하는 수단\n- **개발 회사 내부**에서 이루어지는 테스트\n\n[문제에서 설명한 알파 테스트의 특징]\n\n1. \"새로운 제품 개발 과정에서 이루어지는 첫 번째 테스트\":\n   - 개발 과정의 **초기 단계**에서 실시\n   - 베타 테스트보다 먼저 진행\n\n2. \"시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 초기 작동의 결과를 평가\":\n   - **시제품(Prototype)** 단계에서 실시\n   - **초기 작동의 결과**를 평가하여 문제점 발견\n   - 개발 과정의 조기 단계에서 문제점 조기 발견\n\n3. \"개발 회사 내부에서 이루어지는 테스트\":\n   - **개발자의 장소**에서 실시\n   - 개발자와 사용자가 함께 참여\n   - **통제된 환경**에서 테스트\n\n4. \"단위 테스트, 구성 테스트, 시스템 테스트 등을 포함\":\n   - **단위 테스트**: 개별 모듈의 기능 검증\n   - **구성 테스트 (통합 테스트)**: 모듈 간 통합 검증\n   - **시스템 테스트**: 전체 시스템의 기능 검증\n\n[알파 테스트의 특징]\n| 특징 | 설명 |\n|------|------|\n| **실행 주체** | 개발 회사 내부 (개발자 + 사용자) |\n| **실행 장소** | 개발자의 장소 (개발 환경) |\n| **테스트 환경** | 통제된 환경 |\n| **테스트 방법** | 사용자와 개발자가 함께 확인하며 기록 |\n| **시기** | 개발 과정 초기 단계 (베타 테스트 이전) |\n| **목적** | 초기 작동 결과 평가, 내부 문제점 발견 |\n\n[알파 테스트에 포함되는 테스트]\n1. **단위 테스트**: 개별 모듈이나 컴포넌트의 기능 검증\n2. **구성 테스트 (통합 테스트)**: 모듈 간 통합 및 인터페이스 검증\n3. **시스템 테스트**: 전체 시스템의 기능 및 성능 검증\n\n[알파 테스트 vs 베타 테스트]\n| 구분 | **알파 테스트** | **베타 테스트** |\n|------|----------------|----------------|\n| **실행 장소** | 개발자의 장소 | 사용자 장소 |\n| **실행 주체** | 개발 회사 내부 | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **시기** | 개발 과정 초기 (첫 번째 테스트) | 상용화 직전 (최종 테스트) |\n| **목적** | 초기 작동 결과 평가 | 실제 사용 환경 문제점 발견 |\n\n[테스트 단계 순서]\n1. **단위 테스트** → 2. **통합 테스트** → 3. **시스템 테스트** → 4. **알파 테스트** → 5. **베타 테스트** → 6. **상용화**\n\n[답] **알파 테스트 (Alpha Test)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 설명에 알맞는 테스트 용어를 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Iterating등..))\n오류를 제거하거나 수정한 시스템이나 시스템 컴포넌트 또는 프로그램이 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지를 확인하는 일종의 반복 시험이다.\n반복적인 시험이 필요한 이유는 오류가 제거·수정되는 상당수의 시스템이 의도치 않았던 오동작이나 새로운 형태의 오류를 일으키기 때문이다.\n결국, 수정·변경된 시스템이나 시스템 컴포넌트 또는 프로그램이 명세된 요구 사항을 충족시키는지를 확인하는 시험의 한 형태이다.", "choices": [], "answer": {"keys": ["Regression"], "raw_text": "Regression"}, "explanation": "이 문제는 회귀 테스트(Regression Test)에 대한 문제입니다.\n\n[회귀 테스트(Regression Test)란?]\n\n[영어 용어]\n- **Regression**: 퇴보, 회귀\n- **Regression Test**: 회귀 테스트, 퇴행 테스트\n\n[문제에서 설명한 회귀 테스트의 특징]\n\n1. \"오류를 제거하거나 수정한 시스템이나 시스템 컴포넌트 또는 프로그램이 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지를 확인하는 일종의 반복 시험\":\n   - 코드 변경 후 기존 기능이 여전히 정상 동작하는지 확인\n   - 수정/변경으로 인해 새로운 오류(Regression, 퇴보)가 발생하지 않았는지 검증\n   - 이미 실시했던 **테스트 케이스를 다시 실행**하여 기존 기능의 정상 동작 확인\n\n2. \"반복적인 시험이 필요한 이유는 오류가 제거·수정되는 상당수의 시스템이 의도치 않았던 오동작이나 새로운 형태의 오류를 일으키기 때문\":\n   - 버그 수정이나 기능 개선 시 의도하지 않은 부작용(Side Effect) 발생 가능\n   - 예: A 기능 수정 시 B 기능이 깨짐 (연쇄 반응)\n   - 예: 변경 사항이 다른 모듈에 영향을 미쳐 기존에 작동하던 기능이 비정상 동작\n\n3. \"수정·변경된 시스템이나 시스템 컴포넌트 또는 프로그램이 명세된 요구 사항을 충족시키는지를 확인하는 시험\":\n   - 변경된 코드가 **요구사항을 여전히 만족**하는지 검증\n   - 기존 기능의 **회귀(퇴보)** 여부 확인\n\n[회귀 테스트의 목적]\n- **기존 기능 보호**: 코드 변경으로 인해 기존에 정상 작동하던 기능이 깨지지 않았는지 확인\n- **부작용 발견**: 수정으로 인한 의도치 않은 오류 조기 발견\n- **품질 유지**: 변경 후에도 시스템의 전체적인 품질 유지\n\n[회귀 테스트 수행 시점]\n1. **버그 수정 후**: 특정 오류를 수정한 후 기존 기능에 영향 없는지 확인\n2. **기능 추가 후**: 새 기능 추가 시 기존 기능과의 충돌 여부 확인\n3. **리팩토링 후**: 코드 구조 개선 후 기능 동작 확인\n4. **배포 전**: 릴리스 전 전체 회귀 테스트 수행\n\n[회귀 테스트의 특징]\n| 특징 | 설명 |\n|------|------|\n| **반복성** | 이전에 실행했던 테스트 케이스를 다시 실행 |\n| **자동화** | CI/CD 파이프라인에서 자동 실행 가능 |\n| **범위** | 전체 시스템 또는 변경된 부분과 관련된 모듈 |\n| **목적** | 기존 기능의 정상 동작 보장 |\n\n[회귀 테스트 예시]\n```\n시나리오:\n1. 사용자 로그인 기능에 버그 발견 → 수정\n2. 회귀 테스트: 로그인 기능뿐만 아니라\n   - 로그인 후 게시글 작성 기능\n   - 로그인 후 댓글 기능\n   - 로그인 상태 유지 기능 등\n   기존에 정상 작동하던 모든 기능을 다시 테스트\n3. 모든 기능이 정상 동작하는지 확인\n```\n\n[회귀 테스트 vs 다른 테스트]\n- **단위 테스트**: 개별 모듈의 기능 검증 (새 코드에 대한 테스트)\n- **회귀 테스트**: 기존 기능의 정상 동작 보장 (기존 테스트 재실행)\n- **통합 테스트**: 여러 모듈의 연동 검증\n\n[답] **Regression (회귀 테스트)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]", "choices": [], "answer": {"keys": ["TTL", "부장", "대리"], "raw_text": "TTL 부장 대리"}, "explanation": "이 문제는 관계대수(Relational Algebra)의 **프로젝션(Projection) 연산**에 관한 문제입니다.\n\n[관계대수 프로젝션 연산 π (파이, Pi)]\n\n[프로젝션 연산의 정의]\n- π(속성1, 속성2, ...)(테이블명): 지정한 **속성(컬럼)만 선택**하는 연산\n- 테이블에서 **필요한 컬럼만 추출**하여 새로운 관계(테이블) 생성\n- **수직 부분 집합**: 행은 유지하되, 컬럼만 선택\n\n[프로젝션 연산의 특징]\n1. **컬럼 선택**: 지정한 속성(컬럼)만 추출\n2. **중복 제거**: 프로젝션 연산 결과에서 중복된 튜플(행)은 자동으로 제거\n3. **순서 무관**: 결과의 순서는 중요하지 않음\n\n[문제 해석]\n\n[주어진 연산] `πTTL(employee)`\n\n[의미]\n- `employee` 테이블에서 **TTL 속성(컬럼)만 선택**\n- 즉, employee 테이블의 다른 속성들은 제외하고 **TTL 컬럼의 값만** 추출\n\n[연산 과정]\n1. `employee` 테이블의 **TTL 컬럼 값들을 모두 선택**\n2. 중복된 값이 있으면 제거\n3. 결과: TTL 컬럼의 **고유한 값들만** 반환\n\n[SQL로 표현하면]\n```sql\nSELECT DISTINCT TTL \nFROM employee;\n```\n- `DISTINCT`: 중복 제거 (프로젝션 연산의 특징)\n\n[답]\n- 문제에서 주어진 `employee` 테이블의 TTL 컬럼 값들을 추출하면:\n  - **TTL** (컬럼 헤더 또는 특수 값)\n  - **부장**\n  - **대리**\n  - (참고: 해설에 \"과장, 차장도 포함\"이라고 되어 있으나, 답안에는 \"TTL, 부장, 대리\"만 포함)\n\n[관계대수 연산 기호]\n| 연산 | 기호 | 의미 | SQL 예시 |\n|------|------|------|----------|\n| **선택** | σ (시그마) | 조건에 맞는 행 선택 | `SELECT * FROM 테이블 WHERE 조건` |\n| **프로젝션** | **π (파이)** | **지정한 속성만 선택** | **`SELECT 속성 FROM 테이블`** |\n| **조인** | ⋈ (보우타이) | 두 테이블 결합 | `SELECT * FROM A JOIN B ON 조건` |\n| **합집합** | ∪ | 두 관계의 합 | `UNION` |\n| **차집합** | − | 두 관계의 차 | `EXCEPT` |\n| **교집합** | ∩ | 두 관계의 교 | `INTERSECT` |\n\n[답] **TTL, 부장, 대리**", "table_refs": [], "image_refs": ["images/2022_round2/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 파이썬 코드이다.\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["REMEMBER AND STR"], "raw_text": "REMEMBER AND STR"}, "explanation": "✅ 정답: REMEMBER AND STR\n\n📌 코드 실행 과정 추적\n\n초기값:\n```\na = \"REMEMBER NOVEMBER\"\n     0123456789...\n```\n\n단계별 계산:\n\n1️⃣ b = a[:3] + a[12:16]\n   - a[:3] = \"REM\" (처음~3 이전)\n   - a[12:16] = \"EMBE\" (12~16 이전)\n   ```\n   REMEMBER NOVEMBER\n   012345678901234567\n            12→ 16\n   ```\n   - b = \"REM\" + \"EMBE\" = \"REMEMBE\" ✅\n\n2️⃣ c = \"R AND %s\" % \"STR\"\n   - 문자열 포매팅: %s를 \"STR\"로 치환\n   - c = \"R AND STR\" ✅\n\n3️⃣ print(b+c)\n   - \"REMEMBE\" + \"R AND STR\"\n   - \"REMEMBER AND STR\" ✅\n\n출력: REMEMBER AND STR\n\n💡 핵심:\n- 문자열 슬라이싱: a[m:n]은 m부터 n 이전까지\n- % 포매팅: \"...%s...\" % 값\n- 문자열 연결: + 연산자\n\n", "table_refs": [], "image_refs": ["images/2022_round2/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 설명에 대해 보기에 주어진 답을 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ARP, RARP 등..))", "choices": [], "answer": {"keys": ["1. IGP / 2. EGP / 3. OSPF / 4. BGP"], "raw_text": "1. IGP / 2. EGP / 3. OSPF / 4. BGP"}, "explanation": "이 문제는 **라우팅 프로토콜의 분류 및 종류**에 관한 문제입니다.\n\n[라우팅 프로토콜 분류]\n\n[1. IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)]\n\n[영어 약자 풀이]\n- **I**nterior: 내부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- IGP = Interior Gateway Protocol\n\n[IGP의 정의]\n- AS(Autonomous System, 자율시스템) 내부에서 사용하는 라우팅 프로토콜\n- 같은 관리 영역 내의 라우터 간 경로 정보 교환\n- 예: OSPF, RIP, IS-IS\n\n[IGP의 특징]\n- **범위**: 단일 AS 내부\n- **목적**: AS 내부 최적 경로 선택\n- **신뢰성**: AS 내부 라우터들은 서로 신뢰할 수 있음\n\n[2. EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)]\n\n[영어 약자 풀이]\n- **E**xterior: 외부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- EGP = Exterior Gateway Protocol\n\n[EGP의 정의]\n- **서로 다른 AS 간** 라우팅 정보를 교환하는 프로토콜\n- AS 간 경로 설정 및 정책 기반 라우팅\n- 예: BGP (현재 가장 널리 사용)\n\n[EGP의 특징]\n- **범위**: AS 간\n- **목적**: AS 간 경로 설정 및 정책 기반 라우팅\n- **신뢰성**: 서로 다른 AS 간 신뢰도가 낮을 수 있음\n- **보안**: 보안과 제어가 중요 (빠른 수행보다 보안 우선)\n\n[3. OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜)]\n\n[영어 약자 풀이]\n- **O**pen: 개방형\n- **S**hortest: 최단\n- **P**ath: 경로\n- **F**irst: 우선\n- OSPF = Open Shortest Path First\n\n[OSPF의 정의]\n- **링크 상태(Link State) 기반** 라우팅 프로토콜\n- **IGP의 한 종류**: AS 내부 라우팅에 사용\n- **RIP의 단점을 개선**한 프로토콜\n\n[OSPF의 특징]\n- **링크 상태 알고리즘**: 각 라우터가 전체 네트워크 토폴로지를 알고 최단 경로 계산\n- **대규모 네트워크 지원**: RIP보다 규모가 큰 네트워크에서 사용 가능\n- **자세한 제어**: 다양한 메트릭과 정책 설정 가능\n- **관리 정보 트래픽 감소**: RIP보다 효율적인 업데이트 방식\n- **계층적 구조**: Area(영역) 개념으로 확장성 향상\n\n[OSPF vs RIP]\n| 특징 | **OSPF** | **RIP** |\n|------|----------|---------|\n| **알고리즘** | 링크 상태 | 거리 벡터 |\n| **네트워크 규모** | 대규모 네트워크 지원 | 소규모 네트워크 (15 홉 제한) |\n| **수렴 속도** | 빠름 | 느림 |\n| **트래픽** | 변경 시에만 업데이트 | 주기적 업데이트 |\n\n[4. BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜)]\n\n[BGP의 정의]\n- 경로 벡터(Path Vector) 프로토콜\n- **EGP의 한 종류**: AS 간 라우팅에 사용\n- 인터넷의 백본 프로토콜\n\n[BGP의 특징]\n- **AS 간 라우팅**: 서로 다른 AS 간 경로 정보 교환\n- **전체 경로 정보**: AS Path 정보 포함\n- **정책 기반**: AS 수준에서 정책 결정 가능\n- **라우팅 루프 제거**: AS Path를 통한 루프 방지\n\n[라우팅 프로토콜 분류 요약]\n\n| 분류 | 프로토콜 | 범위 | 특징 |\n|------|----------|------|------|\n| **IGP** | OSPF, RIP, IS-IS | AS 내부 | AS 내부 최적 경로 |\n| **EGP** | BGP | AS 간 | AS 간 경로 설정, 정책 기반 |\n| **OSPF** | - | AS 내부 (IGP) | 링크 상태, 대규모 네트워크 |\n| **BGP** | - | AS 간 (EGP) | 경로 벡터, 정책 기반 |\n\n[답]\n- (1) IGP (Interior Gateway Protocol)\n- (2) EGP (Exterior Gateway Protocol)\n- (3) OSPF (Open Shortest Path First)\n- (4) BGP (Border Gateway Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다.\n같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다.", "choices": [], "answer": {"keys": ["IGP"], "raw_text": "IGP"}, "explanation": "이 문제는 IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)에 대한 문제입니다.\n\n[IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **I**nterior: 내부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- IGP = Interior Gateway Protocol\n\n[문제에서 설명한 IGP의 특징]\n\n1. \"라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다\":\n   - AS (Autonomous System, 자율시스템): 하나의 관리 정책 하에 운영되는 네트워크 집합\n   - 여러 개의 네트워크가 라우터로 상호 접속되어 하나의 도메인(AS)을 형성\n\n2. \"같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다\":\n   - **도메인 내부 라우터**: 같은 AS 내부에 있는 라우터\n   - **도메인 외부 라우터**: AS 외부에 있는 라우터\n   - **IGP**: **도메인 내부(AS 내부) 경로 설정**을 담당하는 프로토콜\n\n[IGP의 정의]\n- AS(Autonomous System) 내부에서 사용하는 라우팅 프로토콜\n- 같은 관리 영역 내의 라우터 간 경로 정보 교환\n- AS 내부에서 최적 경로 선택\n\n[IGP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **범위** | 단일 AS 내부 |\n| **목적** | AS 내부 최적 경로 선택 |\n| **신뢰성** | AS 내부 라우터들은 서로 신뢰할 수 있음 |\n| **예시** | OSPF, RIP, IS-IS |\n\n[IGP vs EGP]\n| 구분 | **IGP** | **EGP** |\n|------|---------|---------|\n| **범위** | AS 내부 | AS 간 |\n| **목적** | AS 내부 최적 경로 | AS 간 경로 설정, 정책 기반 |\n| **예시** | OSPF, RIP, IS-IS | BGP |\n| **신뢰성** | 높음 (같은 관리 영역) | 낮을 수 있음 (다른 관리 영역) |\n\n[IGP의 종류]\n1. OSPF (Open Shortest Path First): 링크 상태 기반\n2. RIP (Routing Information Protocol): 거리 벡터 기반\n3. IS-IS (Intermediate System to Intermediate System): 링크 상태 기반\n\n[답] IGP (Interior Gateway Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜로써,\n다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다.", "choices": [], "answer": {"keys": ["EGP"], "raw_text": "EGP"}, "explanation": "이 문제는 EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)에 대한 문제입니다.\n\n[EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **E**xterior: 외부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- EGP = Exterior Gateway Protocol\n\n[문제에서 설명한 EGP의 특징]\n\n1. \"시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜\":\n   - 서로 다른 AS(Autonomous System) 간 라우팅 정보를 교환\n   - AS 간 경로 설정 및 정책 기반 라우팅\n\n2. \"다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다\":\n   - **다른 도메인(AS) 간**: 서로 다른 관리 정책 하에 운영되는 네트워크 간\n   - **정리된 관리가 거의 없음**: AS 간에는 통합 관리가 없음\n   - **신용도가 매우 낮음**: 서로 다른 AS 간 신뢰도가 낮을 수 있음\n   - **빠른 수행보다는 보안과 제어**: 성능보다는 **보안과 정책 기반 제어**가 우선\n\n[EGP의 정의]\n- **서로 다른 AS 간** 라우팅 정보를 교환하는 프로토콜\n- AS 간 경로 설정 및 정책 기반 라우팅\n- 예: BGP (현재 가장 널리 사용되는 EGP)\n\n[EGP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **범위** | AS 간 라우팅 |\n| **목적** | AS 간 경로 설정 및 정책 기반 라우팅 |\n| **신뢰성** | 서로 다른 AS 간 신뢰도가 낮을 수 있음 |\n| **보안** | 보안과 제어가 중요 (빠른 수행보다 보안 우선) |\n| **예시** | BGP (Border Gateway Protocol) |\n\n[EGP의 주요 특징]\n1. **정책 기반 라우팅**: 각 AS는 자신의 정책에 따라 경로 선택\n2. **보안 강조**: 빠른 수행보다 보안과 제어가 우선\n3. **신뢰도 문제**: 서로 다른 AS 간 신뢰도가 낮아 보안이 중요\n4. **관리 독립성**: AS 간 통합 관리가 없어 정책 기반 제어 필요\n\n[EGP vs IGP]\n| 구분 | **IGP** | **EGP** |\n|------|---------|---------|\n| **범위** | AS 내부 | AS 간 |\n| **목적** | AS 내부 최적 경로 | AS 간 경로 설정, 정책 기반 |\n| **신뢰성** | 높음 (같은 관리 영역) | 낮을 수 있음 (다른 관리 영역) |\n| **보안** | 상대적으로 낮은 우선순위 | 높은 우선순위 (보안과 제어) |\n| **예시** | OSPF, RIP, IS-IS | BGP |\n\n[BGP (Border Gateway Protocol)]\n- 현재 가장 널리 사용되는 EGP\n- 인터넷의 백본 프로토콜\n- AS 간 라우팅에 사용\n- 정책 기반 라우팅 지원\n\n[답] EGP (Exterior Gateway Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다.\n규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜로써 RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다.", "choices": [], "answer": {"keys": ["OSPF"], "raw_text": "OSPF"}, "explanation": "이 문제는 OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜)에 대한 문제입니다.\n\n[OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **O**pen: 개방형\n- **S**hortest: 최단\n- **P**ath: 경로\n- **F**irst: 우선\n- OSPF = Open Shortest Path First\n\n[문제에서 설명한 OSPF의 특징]\n\n1. \"IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다\":\n   - **IGP의 한 종류**: AS 내부 라우팅에 사용\n   - **대규모 네트워크 지원**: RIP보다 규모가 큰 네트워크에서 사용 가능\n   - RIP는 15 홉 제한이 있어 대규모 네트워크에 부적합\n\n2. \"규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜\":\n   - **RIP의 단점 개선**: RIP의 제한사항을 해결한 프로토콜\n   - **대규모/복잡한 네트워크**: TCP/IP 네트워크에서 널리 사용\n\n3. \"RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다\":\n   - **자세한 제어**: 다양한 메트릭과 정책 설정 가능\n   - **관리 정보 트래픽 감소**: RIP보다 효율적인 업데이트 방식\n   - RIP는 주기적 업데이트로 트래픽이 많음\n   - OSPF는 변경 시에만 업데이트하여 트래픽 감소\n\n[OSPF의 정의]\n- **링크 상태(Link State) 기반** 라우팅 프로토콜\n- **IGP의 한 종류**: AS 내부 라우팅에 사용\n- **RIP의 단점을 개선**한 프로토콜\n\n[OSPF의 특징]\n| 특징 | 설명 |\n|------|------|\n| **알고리즘** | 링크 상태 (Link State) |\n| **네트워크 규모** | 대규모 네트워크 지원 |\n| **수렴 속도** | 빠름 |\n| **트래픽** | 변경 시에만 업데이트 (효율적) |\n| **제어** | 자세한 제어 가능 (다양한 메트릭) |\n| **구조** | 계층적 구조 (Area 개념) |\n\n[OSPF vs RIP]\n| 특징 | **OSPF** | **RIP** |\n|------|----------|---------|\n| **알고리즘** | 링크 상태 | 거리 벡터 |\n| **네트워크 규모** | 대규모 네트워크 지원 | 소규모 네트워크 (15 홉 제한) |\n| **수렴 속도** | 빠름 | 느림 |\n| **트래픽** | 변경 시에만 업데이트 | 주기적 업데이트 |\n| **제어** | 자세한 제어 가능 | 제한적 |\n| **메트릭** | 비용(Cost) 기반 | 홉(Hop) 수 기반 |\n\n[OSPF의 동작 원리]\n1. **링크 상태 정보 수집**: 각 라우터가 자신의 링크 상태 정보를 광고\n2. **전체 토폴로지 구성**: 모든 라우터가 전체 네트워크 토폴로지를 파악\n3. **최단 경로 계산**: 다익스트라 알고리즘을 사용하여 최단 경로 계산\n4. **라우팅 테이블 업데이트**: 계산된 최단 경로를 라우팅 테이블에 반영\n\n[OSPF의 장점]\n- **빠른 수렴**: 네트워크 변화에 빠르게 대응\n- **대규모 네트워크 지원**: Area 개념으로 확장성 향상\n- **트래픽 효율**: 변경 시에만 업데이트\n- **자세한 제어**: 다양한 정책 및 메트릭 설정 가능\n\n[답] OSPF (Open Shortest Path First)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅", "TCP/IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환하는 데 사용되는 외부 게이트웨이 프로토콜(EGP)이다.\n각 목적지에 대한 전체 경로가 포함되며, 다른 시스템과 교환하는 네트워크 도달 가능성 정보의 데이터베이스를 유지한다.\n네트워크 도달 가능성 정보를 사용하여 AS 연결 그래프를 구성하며, 이를 통해 라우팅 루프를 제거하고 AS 수준에서 정책 결정을 실행할 수 있다.", "choices": [], "answer": {"keys": ["BGP"], "raw_text": "BGP"}, "explanation": "이 문제는 BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜)에 대한 문제입니다.\n\n[BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **B**order: 경계\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- BGP = Border Gateway Protocol\n\n[BGP의 정의]\n- 서로 다른 자율 시스템(AS, Autonomous System) 간 라우팅 정보를 교환하는 외부 게이트웨이 프로토콜(EGP, Exterior Gateway Protocol)\n- 인터넷의 **백본 프로토콜**: 인터넷 전체를 연결하는 핵심 라우팅 프로토콜\n\n[문제에서 설명한 BGP의 특징]\n\n1. \"서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환\":\n   - AS (Autonomous System): 하나의 관리 정책 하에 운영되는 네트워크 집합\n   - EGP (Exterior Gateway Protocol): AS 간 라우팅 프로토콜\n   - BGP는 **AS 간 라우팅**에 사용 (AS 내부 라우팅은 IGP 사용)\n\n2. \"각 목적지에 대한 전체 경로가 포함\":\n   - BGP는 경로 벡터(Path Vector) 프로토콜\n   - 각 경로에 **전체 AS 경로(AS Path)** 정보를 포함\n   - 예: 목적지로 가는 경로 = AS100 → AS200 → AS300\n\n3. \"네트워크 도달 가능성 정보의 데이터베이스를 유지\":\n   - BGP 라우터는 네트워크 도달 가능성 정보(NLRI, Network Layer Reachability Information)를 데이터베이스로 관리\n   - 다른 AS와 경로 정보를 교환하여 최신 라우팅 정보 유지\n\n4. \"AS 연결 그래프를 구성하여 라우팅 루프를 제거\":\n   - AS 간 연결 관계를 그래프로 표현\n   - AS Path에 자신의 AS가 포함되면 루프로 판단하여 경로 거부\n   - 예: AS100에서 AS200으로 가는 경로에 이미 AS100이 포함되어 있으면 루프로 판단\n\n5. **\"AS 수준에서 정책 결정을 실행\"**:\n   - BGP는 **정책 기반 라우팅** 지원\n   - 각 AS는 자신의 정책에 따라 경로를 선택하거나 거부 가능\n   - 예: 특정 AS를 통한 경로 차단, 특정 경로 우선 선택\n\n[BGP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **프로토콜 유형** | 경로 벡터(Path Vector) 프로토콜 |\n| **사용 범위** | AS 간 라우팅 (EGP) |\n| **포트** | TCP 179 포트 사용 |\n| **신뢰성** | TCP 기반으로 신뢰성 있는 전송 보장 |\n| **경로 선택 기준** | AS Path 길이, 정책 등 |\n| **업데이트** | 트리거 기반 (변경 시에만 업데이트) |\n\n[BGP vs IGP]\n| 구분 | **BGP (EGP)** | IGP (Interior Gateway Protocol) |\n|------|----------------|-----------------------------------|\n| **범위** | AS 간 라우팅 | AS 내부 라우팅 |\n| **예시** | BGP, EGP | OSPF, RIP, IS-IS |\n| **특징** | 정책 기반, 경로 벡터 | 거리/링크 상태 기반 |\n\n[BGP의 주요 용도]\n- **인터넷 백본**: ISP(인터넷 서비스 제공자) 간 라우팅\n- **멀티홈**: 여러 ISP와 연결된 네트워크의 라우팅\n- **트래픽 제어**: 정책을 통한 경로 선택 및 제어\n\n[답] BGP (Border Gateway Protocol)", "table_refs": [], "image_refs": ["images/2022_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 C언어에서 출력에 대한 알맞은 답을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 문제는 C언어 문자열 포인터와 문자열 길이 계산 함수에 관한 문제입니다.\n\n[주어진 코드]\n```c\n#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n  }\n return r;\n}\n```\n\n[코드 실행 과정]\n\n[1. main() 함수 시작]\n\n[변수 초기화]\n- `char* p1 = \"2022\";`\n  - `p1`은 문자열 리터럴 \"2022\"의 주소를 가리키는 포인터\n  - 문자열 \"2022\"는 4개의 문자: '2', '0', '2', '2', '\\0' (널 문자 포함 5바이트)\n  - **실제 문자 개수: 4개** (널 문자 제외)\n\n- `char* p2 = \"202207\";`\n  - `p2`는 문자열 리터럴 \"202207\"의 주소를 가리키는 포인터\n  - 문자열 \"202207\"는 6개의 문자: '2', '0', '2', '2', '0', '7', '\\0' (널 문자 포함 7바이트)\n  - **실제 문자 개수: 6개** (널 문자 제외)\n\n[2. len(p1) 함수 호출]\n```c\nint len(char* p)  // p는 \"2022\"의 주소를 받음\n```\n\n[len() 함수 내부 실행]\n- `int r = 0;` - 길이 카운터 초기화\n- `while(*p != '\\0')` - 포인터가 가리키는 문자가 널 문자가 아닐 때까지 반복\n\n[반복 과정]\n| 반복 | `*p` (현재 문자) | `*p != '\\0'` | `p++` | `r++` | `r` 값 |\n|------|----------------|--------------|-------|-------|--------|\n| 초기 | '2' | true | p 이동 | 1 | 1 |\n| 1 | '0' | true | p 이동 | 2 | 2 |\n| 2 | '2' | true | p 이동 | 3 | 3 |\n| 3 | '2' | true | p 이동 | 4 | 4 |\n| 4 | '\\0' | **false** | - | - | - |\n\n- **반복 종료**: 널 문자('\\0')를 만나면 반복 종료\n- `return r;` → **a = 4** 반환\n\n[3. len(p2) 함수 호출]\n```c\nint len(char* p)  // p는 \"202207\"의 주소를 받음\n```\n\n[len() 함수 내부 실행]\n- `int r = 0;` - 길이 카운터 초기화\n- `while(*p != '\\0')` - 널 문자까지 반복\n\n[반복 과정]\n| 반복 | `*p` (현재 문자) | `*p != '\\0'` | `p++` | `r++` | `r` 값 |\n|------|----------------|--------------|-------|-------|--------|\n| 초기 | '2' | true | p 이동 | 1 | 1 |\n| 1 | '0' | true | p 이동 | 2 | 2 |\n| 2 | '2' | true | p 이동 | 3 | 3 |\n| 3 | '2' | true | p 이동 | 4 | 4 |\n| 4 | '0' | true | p 이동 | 5 | 5 |\n| 5 | '7' | true | p 이동 | 6 | 6 |\n| 6 | '\\0' | **false** | - | - | - |\n\n- **반복 종료**: 널 문자를 만나면 반복 종료\n- `return r;` → **b = 6** 반환\n\n[4. 최종 계산]\n```c\nprintf(\"%d\", a + b);\n```\n- `a = 4` (\"2022\"의 길이)\n- `b = 6` (\"202207\"의 길이)\n- `a + b = 4 + 6 = 10`\n\n[출력] `10`\n\n[핵심 개념]\n1. **문자열 포인터**: `char*`는 문자열의 첫 번째 문자 주소를 가리킴\n2. **널 문자**: 문자열 끝에는 자동으로 '\\0' (널 문자)가 추가됨\n3. **포인터 연산**: `p++`는 다음 문자 위치로 포인터 이동\n4. **문자열 길이**: 널 문자를 제외한 실제 문자의 개수\n\n[답] **10**", "table_refs": [], "image_refs": ["images/2022_round2/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n }\n return r;\n}", "line_numbers": [1, 17], "file": "data/codes/2022_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 C언어 코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["22"], "raw_text": "22"}, "explanation": "✅ 정답: 22\n\n📌 코드 실행 과정 추적\n\n초기 상태:\n- a[4] = {0, 2, 4, 8}\n- b[3] = {0, 0, 0}\n- i = 1, sum = 0\n\n반복 1️⃣: i = 1\n- p1 = a + 1 → a[1]을 가리킴\n- *p1 = 2\n- b[0] = *p1 - a[0] = 2 - 0 = 2\n- sum = 0 + 2 + 2 = 4\n\n반복 2️⃣: i = 2\n- p1 = a + 2 → a[2]를 가리킴\n- *p1 = 4\n- b[1] = *p1 - a[1] = 4 - 2 = 2\n- sum = 4 + 2 + 4 = 10\n\n반복 3️⃣: i = 3\n- p1 = a + 3 → a[3]을 가리킴\n- *p1 = 8\n- b[2] = *p1 - a[2] = 8 - 4 = 4\n- sum = 10 + 4 + 8 = 22\n\n출력: 22\n\n", "table_refs": [], "image_refs": ["images/2022_round2/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 자바코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["61"], "raw_text": "61"}, "explanation": "✅ 정답: 61\n\n📌 코드 실행 과정 추적\n\n초기화:\n- Conv obj = new Conv(3) → obj.a = 3\n- obj.a = 5 → obj.a = 5로 변경 ✅\n\nfunc() 메서드 실행:\n\n반복문 계산 (a=5):\n| i | 계산식 | b 값 |\n|---|--------|------|\n| 초기 | - | 1 |\n| 1 | b = 5×1 + 1 | 6 |\n| 2 | b = 5×2 + 6 | 16 |\n| 3 | b = 5×3 + 16 | 31 |\n| 4 | b = 5×4 + 31 | 51 |\n\n반환값:\n```\nreturn a + b = 5 + 51 = 56\n```\n\n최종 출력:\n```\nint b = obj.func(); → b = 56\nprint(obj.a + b); → 5 + 56 = 61 ✅\n```\n\n💡 핵심:\n- func()는 a + b를 반환 (56)\n- 출력은 obj.a + b (5 + 56 = 61)\n\n", "table_refs": [], "image_refs": ["images/2022_round2/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 함수 종속성에 대한 설명이다.\n해당 문제에 대한 알맞는 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nunion 등..))", "choices": [], "answer": {"keys": ["1. Full", "2. Partial", "3. Transitive"], "raw_text": "1. Full 2. Partial 3. Transitive"}, "explanation": "[함수 종속성(Functional Dependency, FD)의 종류]\n\n[함수 종속성 정의]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정됨 (X가 Y를 함수적으로 결정)\n- 예: `학번 → 이름` (학번이 결정되면 이름이 결정됨)\n\n[1. Full Functional Dependency (완전 함수 종속, 완전 종속)]\n- **정의**: 종속 속성(Y)이 **결정자(X)의 모든 속성**에 종속\n- **조건**: X의 어떤 부분 집합도 Y를 결정할 수 없음\n- **표기**: `X → Y` (X의 모든 속성이 필요)\n- **예시**: `{학생, 학과} → 성적`\n  - 성적은 학생과 학과 **모두** 알아야 결정됨\n  - 학생만으로는 성적을 결정할 수 없고, 학과만으로도 성적을 결정할 수 없음\n\n[2. Partial Functional Dependency (부분 함수 종속, 부분 종속)]\n- **정의**: 종속 속성(Y)이 **결정자(X)의 일부 속성**에만 종속\n- **조건**: X의 **부분 집합이 Y를 결정**할 수 있음\n- **표기**: `X의 부분집합 → Y`\n- **예시**:\n  - 기본키: `{학생, 학과}`\n  - `{학생, 학과} → 성적` (완전 종속)\n  - `학과 → 성적` (부분 종속: 학과만으로도 성적 결정 가능)\n  - 즉, 성적은 학과만 알아도 식별 가능\n\n[3. Transitive Functional Dependency (이행 함수 종속, 이행 종속)]\n- **정의**: **간접적인 종속 관계** (연쇄 종속)\n- **조건**: `X → Y`이고 `Y → Z`이면 `X → Z` (이행 종속)\n- **표기**: `X → Y → Z` (X가 Y를 결정하고, Y가 Z를 결정)\n- **예시**:\n  - `학번 → 학과`\n  - `학과 → 학과장`\n  - 따라서 `학번 → 학과장` (이행 종속)\n  - 학번이 학과를 결정하고, 학과가 학과장을 결정하므로 학번이 학과장을 결정\n\n[함수 종속성 종류 비교]\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n| **Transitive (이행)** | **간접적인 종속** 관계 | 연쇄 종속 | `학번 → 학과 → 학과장` |\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n\n[답]\n- (1) **Full (완전 함수 종속)**\n- (2) **Partial (부분 함수 종속)**\n- (3) Transitive (이행 함수 종속)", "table_refs": [], "image_refs": ["images/2022_round2/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": ["프로그래밍", "데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "성적은 {학생,학과}에 대해서 ( ) Functional Dependency이다.", "choices": [], "answer": {"keys": ["Full"], "raw_text": "Full"}, "explanation": "이 문제는 함수 종속성(Functional Dependency, FD)의 종류 중 Full Functional Dependency (완전 함수 종속)에 대한 문제입니다.\n\n[함수 종속성(Functional Dependency, FD)이란?]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정된다 (X가 Y를 함수적으로 결정)\n- 예: `학번 → 이름` (학번이 결정되면 이름이 결정됨)\n\n[문제 해석]\n\n[주어진 조건]\n- **성적**은 **{학생, 학과}**에 대해서 함수 종속\n- 즉, `{학생, 학과} → 성적`\n\n[Full Functional Dependency (완전 함수 종속, 완전 종속)]\n\n[정의]\n- 종속 속성(Y)이 **결정자(X)의 모든 속성**에 종속\n- X의 어떤 부분 집합도 Y를 결정할 수 없음\n\n[문제에서의 적용]\n- `{학생, 학과} → 성적`\n- 성적은 **학생과 학과 모두** 알아야 결정됨\n- **학생만**으로는 성적을 결정할 수 없음 (같은 학생이라도 학과에 따라 성적이 다를 수 있음)\n- **학과만**으로도 성적을 결정할 수 없음 (같은 학과라도 학생에 따라 성적이 다름)\n- 따라서 **{학생, 학과}의 모든 속성이 필요** → **Full (완전) 종속**\n\n[Full vs Partial 비교]\n\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n\n[예시 설명]\n- **Full 종속**: 성적은 학생과 학과 **모두** 알아야 결정됨\n  - 학생 A, 학과 컴퓨터공학 → 성적 90\n  - 학생 A, 학과 전자공학 → 성적 85 (같은 학생이어도 학과가 다르면 성적이 다름)\n  - 학생 B, 학과 컴퓨터공학 → 성적 95 (같은 학과여도 학생이 다르면 성적이 다름)\n- **Partial 종속**: 만약 성적이 학과만으로 결정된다면 → `학과 → 성적` (부분 종속)\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n\n[답] **Full (완전 함수 종속)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "성적은 학과만 알아도 식별이 가능하므로, 이 경우에는 성적 속성은 기본키에 ( ) Functional Dependency이다.", "choices": [], "answer": {"keys": ["Partial"], "raw_text": "Partial"}, "explanation": "이 문제는 함수 종속성(Functional Dependency, FD)의 종류 중 Partial Functional Dependency (부분 함수 종속)에 대한 문제입니다.\n\n[함수 종속성(Functional Dependency, FD)이란?]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정된다 (X가 Y를 함수적으로 결정)\n\n[문제 해석]\n\n[주어진 조건]\n- **기본키**: `{학생, 학과}` (복합 기본키)\n- **성적**은 **학과만 알아도 식별이 가능**\n- 즉, `학과 → 성적` (학과만으로도 성적 결정 가능)\n\n[Partial Functional Dependency (부분 함수 종속, 부분 종속)]\n\n[정의]\n- 종속 속성(Y)이 **결정자(X)의 일부 속성**에만 종속\n- X의 **부분 집합이 Y를 결정**할 수 있음\n\n[문제에서의 적용]\n- 기본키: `{학생, 학과}`\n- `{학생, 학과} → 성적` (완전 종속)\n- 하지만 `학과 → 성적` (부분 종속: 학과만으로도 성적 결정 가능)\n- 즉, 성적은 **기본키의 일부 속성(학과)만** 알아도 식별 가능\n- 따라서 **Partial (부분) 종속**\n\n[부분 종속의 특징]\n- 기본키가 복합 키일 때 발생\n- 기본키의 **일부 속성만**으로도 종속 속성을 결정할 수 있음\n- 예: `{학생, 학과} → 성적`이지만 `학과 → 성적`도 성립\n\n[Full vs Partial 비교]\n\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n\n[예시 설명]\n- **부분 종속**: 성적이 학과만으로 결정됨\n  - 학과 컴퓨터공학 → 성적 90 (모든 컴퓨터공학 학생의 성적이 90)\n  - 학과 전자공학 → 성적 85 (모든 전자공학 학생의 성적이 85)\n  - 학생 정보는 필요 없음 (학과만으로 성적 결정)\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n  - 기본키의 일부 속성에만 종속되는 속성을 별도 릴레이션으로 분리\n  - 예: `{학생, 학과} → 성적`에서 `학과 → 성적`이면\n    - 릴레이션1: `{학생, 학과}` (학생 정보)\n    - 릴레이션2: `{학과, 성적}` (학과별 성적)\n\n[답] **Partial (부분 함수 종속)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 경우", "choices": [], "answer": {"keys": ["Transitive"], "raw_text": "Transitive"}, "explanation": "이 문제는 함수 종속성(Functional Dependency, FD)의 종류 중 Transitive Functional Dependency (이행 함수 종속, 이행 종속)에 대한 문제입니다.\n\n[함수 종속성(Functional Dependency, FD)이란?]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정된다 (X가 Y를 함수적으로 결정)\n\n[문제 해석]\n\n[주어진 조건]\n- `X → Y`: X가 Y를 결정\n- `Y → Z`: Y가 Z를 결정\n- 따라서 `X → Z`: X가 Z를 결정 (이행 종속)\n\n[Transitive Functional Dependency (이행 함수 종속, 이행 종속)]\n\n[정의]\n- **간접적인 종속 관계** (연쇄 종속)\n- `X → Y`이고 `Y → Z`이면 `X → Z` (이행 종속)\n- X가 Y를 결정하고, Y가 Z를 결정하므로 X가 Z를 결정\n\n[이행 종속의 특징]\n- **간접적인 종속**: X가 Z를 직접 결정하는 것이 아니라 Y를 통해 간접적으로 결정\n- **연쇄 종속**: X → Y → Z 형태의 연쇄적인 종속 관계\n\n[예시 설명]\n- `학번 → 학과` (학번이 학과를 결정)\n- `학과 → 학과장` (학과가 학과장을 결정)\n- 따라서 `학번 → 학과장` (이행 종속)\n  - 학번이 학과를 결정하고, 학과가 학과장을 결정하므로 학번이 학과장을 결정\n  - 하지만 학번이 학과장을 **직접** 결정하는 것이 아니라 학과를 통해 **간접적으로** 결정\n\n[이행 종속의 문제점]\n- **데이터 중복**: 학과장 정보가 각 학생 레코드에 중복 저장\n- **이상(Anomaly) 발생**: 학과장이 변경되면 여러 레코드를 수정해야 함\n- **정규화 필요**: 3NF로 정규화하여 이행 종속 제거\n\n[함수 종속성 종류 비교]\n\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n| **Transitive (이행)** | **간접적인 종속** 관계 | 연쇄 종속 | `학번 → 학과 → 학과장` |\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n  - 이행 종속을 제거하기 위해 별도 릴레이션으로 분리\n  - 예: `학번 → 학과 → 학과장`\n    - 릴레이션1: `{학번, 학과}` (학생 정보)\n    - 릴레이션2: `{학과, 학과장}` (학과 정보)\n\n[답] Transitive (이행 함수 종속)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 설명에 대한 알맞는 답을 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ajax, 등..))", "choices": [], "answer": {"keys": ["1. HTTP", "2. Hypertext", "3. HTML"], "raw_text": "1. HTTP 2. Hypertext 3. HTML"}, "explanation": "이 문제는 **웹 기술의 기본 개념**에 관한 문제입니다.\n\n[1. HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)]\n\n[HTTP의 정의]\n- 인터넷에서 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약\n- 인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약\n- 이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 됨\n\n[HTTP의 특징]\n- **웹 서버와 브라우저 간** 문서 전송 프로토콜\n- **응용 계층 프로토콜** (TCP/IP 기반)\n- **포트 번호**: 80 (HTTPS는 443)\n- **요청-응답 방식**: 클라이언트가 요청하고 서버가 응답\n\n[2. Hypertext (하이퍼텍스트)]\n\n[Hypertext의 정의]\n- 문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결시킨 정보 제공 방법\n- **제시된 순서에 관계없이** 이용자가 관련된 정보를 검색할 수 있도록 함\n- 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 **클릭함으로써 원하는 정보에 쉽게 접근**하는 방식\n\n[Hypertext의 특징]\n- **비선형적 구조**: 거미집처럼 연결된 구조\n- **링크 기반**: 링크를 통해 정보 간 이동\n- **다양한 미디어**: 텍스트, 그래픽, 음성, 영상 포함\n- **사용자 주도 탐색**: 순서 없이 자유롭게 정보 탐색\n\n[3. HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)]\n\n[HTML의 정의]\n- 웹 페이지 표시를 위해 개발된 지배적인 마크업 언어\n- 제목, 단락, 목록 등과 같은 본문을 위한 **구조적 의미를 나타내는 것**\n- 링크, 인용과 그 밖의 항목으로 **구조적 문서를 만들 수 있는 방법**을 제공\n\n[HTML의 특징]\n- **마크업 언어**: 태그를 사용하여 문서 구조 표현\n- **웹 페이지 작성**: 웹 브라우저에서 표시되는 페이지 작성\n- **구조적 의미**: 태그로 문서의 의미와 구조 표현\n- **표준화**: W3C에서 표준화\n\n[웹 기술의 관계]\n\n| 기술 | 역할 | 관계 |\n|------|------|------|\n| **Hypertext** | 정보 제공 방법 (개념) | 웹의 기본 개념 |\n| **HTML** | 웹 페이지 작성 언어 | Hypertext를 표현하는 언어 |\n| **HTTP** | 문서 전송 프로토콜 | HTML 문서를 전송하는 프로토콜 |\n\n[웹의 동작 흐름]\n1. **HTML로 웹 페이지 작성** (Hypertext 구조)\n2. **HTTP로 HTML 문서 전송** (웹 서버 → 브라우저)\n3. **브라우저가 HTML 해석하여 표시** (Hypertext 구조로 표시)\n4. **사용자가 링크 클릭** (Hypertext 탐색)\n5. **새로운 페이지 요청** (HTTP로 전송)\n\n[답]\n- (1) HTTP (Hypertext Transfer Protocol)\n- (2) **Hypertext (하이퍼텍스트)**\n- (3) HTML (HyperText Markup Language)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "인터넷에서, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약을 말한다.\n인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다.\n이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "이 문제는 HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)에 대한 문제입니다.\n\n[HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **H**ypertext: 하이퍼텍스트\n- **T**ransfer: 전송\n- **P**rotocol: 프로토콜\n- HTTP = Hypertext Transfer Protocol\n\n[문제에서 설명한 HTTP의 특징]\n\n1. \"인터넷에서, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약\":\n   - **웹 서버**: 웹 페이지를 제공하는 서버\n   - **인터넷 브라우저**: 사용자가 사용하는 웹 브라우저 (Chrome, Firefox, Safari 등)\n   - **문서 전송**: HTML 문서, 이미지, CSS, JavaScript 등 웹 리소스 전송\n   - **통신 규약**: 웹 서버와 브라우저 간의 통신 규칙\n\n2. \"인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약\":\n   - **하이퍼텍스트**: 링크로 연결된 텍스트 문서\n   - **문서 교환**: 웹 서버와 브라우저 간 하이퍼텍스트 문서 주고받기\n\n3. \"이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다\":\n   - HTTP 규약을 따르면 서로 다른 시스템 간에도 정보 교환 가능\n   - 표준화된 프로토콜로 인터넷의 상호 운용성 보장\n\n[HTTP의 정의]\n- **웹 서버와 클라이언트(브라우저) 간** 문서 및 리소스를 전송하기 위한 **응용 계층 프로토콜**\n- **TCP/IP 기반**: 전송 계층에서 TCP 사용\n- **포트 번호**: 기본 포트 80 (HTTPS는 443)\n\n[HTTP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **계층** | 응용 계층 (Application Layer) |\n| **기반** | TCP/IP |\n| **포트** | 80 (HTTPS는 443) |\n| **특성** | 상태 비저장 (Stateless) |\n| **방식** | 요청-응답 (Request-Response) |\n\n[HTTP의 동작 방식]\n1. **클라이언트 요청**: 브라우저가 웹 서버에 HTTP 요청 전송\n2. **서버 응답**: 웹 서버가 요청한 리소스를 HTTP 응답으로 전송\n3. **문서 전송**: HTML 문서, 이미지, CSS, JavaScript 등 전송\n\n[HTTP 요청/응답 예시]\n```\n요청 (Request):\nGET /index.html HTTP/1.1\nHost: example.com\n\n응답 (Response):\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<html>...</html>\n```\n\n[HTTP vs HTTPS]\n| 구분 | **HTTP** | **HTTPS** |\n|------|----------|-----------|\n| **포트** | 80 | 443 |\n| **보안** | 암호화 없음 | SSL/TLS 암호화 |\n| **용도** | 일반 웹 페이지 | 보안이 필요한 페이지 |\n\n[HTTP의 주요 메서드]\n- **GET**: 리소스 조회\n- **POST**: 리소스 생성/전송\n- **PUT**: 리소스 수정\n- **DELETE**: 리소스 삭제\n\n[답] HTTP (Hypertext Transfer Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결시켜, 제시된 순서에 관계없이 이용자가 관련된 정보를 검색할 수 있도록 하는 정보 제공 방법이다.\n즉, 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 클릭함으로써 원하는 정보에 쉽게 접근하는 방식을 말한다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "이 문제는 **Hypertext (하이퍼텍스트)**에 대한 문제입니다.\n\n[Hypertext (하이퍼텍스트)란?]\n\n[영어 단어 풀이]\n- **Hyper**: 초월, 넘어서는\n- **Text**: 텍스트, 문서\n- **Hypertext**: 하이퍼텍스트, 초월 텍스트\n\n[문제에서 설명한 Hypertext의 특징]\n\n1. \"문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결\":\n   - **다양한 미디어**: 문자뿐만 아니라 그래픽, 음성, 영상도 포함\n   - **연상 거미집**: 거미줄처럼 복잡하게 연결된 구조\n   - **상호 연결**: 여러 정보가 링크로 서로 연결됨\n\n2. \"제시된 순서에 관계없이 이용자가 관련된 정보를 검색할 수 있도록 하는 정보 제공 방법\":\n   - **순서 무관**: 선형적 순서가 아닌 비선형적 구조\n   - **사용자 주도**: 이용자가 원하는 순서로 정보 탐색\n   - **관련 정보 검색**: 링크를 통해 관련 정보로 바로 이동\n\n3. \"한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 클릭함으로써 원하는 정보에 쉽게 접근하는 방식\":\n   - **링크 기반**: 링크를 통해 정보 간 이동\n   - **클릭으로 접근**: 링크를 클릭하여 원하는 정보로 바로 이동\n   - **쉬운 접근**: 정보 탐색이 용이함\n\n[Hypertext의 정의]\n- 텍스트, 그래픽, 음성, 영상 등을 링크로 연결하여 사용자가 비선형적으로 정보를 탐색할 수 있게 하는 정보 제공 방법\n- **웹(WWW)의 핵심 개념**: 웹 페이지들이 하이퍼링크로 연결되어 있음\n\n[Hypertext의 특징]\n| 특징 | 설명 |\n|------|------|\n| **구조** | 비선형적 구조 (거미집 형태) |\n| **미디어** | 텍스트, 그래픽, 음성, 영상 포함 |\n| **접근** | 링크를 통한 자유로운 정보 탐색 |\n| **순서** | 고정된 순서 없음, 사용자 주도 |\n\n[Hypertext의 예시]\n- **웹 페이지**: HTML 문서들이 하이퍼링크로 연결\n- **위키피디아**: 문서들이 상호 링크로 연결\n- **전자책**: 하이퍼링크로 관련 내용 참조\n\n[Hypertext vs 일반 텍스트]\n| 구분 | **일반 텍스트** | **Hypertext** |\n|------|----------------|---------------|\n| **구조** | 선형적 (순서대로 읽음) | 비선형적 (자유롭게 탐색) |\n| **연결** | 연결 없음 | 링크로 연결 |\n| **탐색** | 순차적 탐색 | 링크 클릭으로 탐색 |\n\n[웹과 Hypertext]\n- **WWW (World Wide Web)**: 하이퍼텍스트 기반의 정보 시스템\n- HTML (HyperText Markup Language): 하이퍼텍스트를 표현하는 마크업 언어\n- HTTP (HyperText Transfer Protocol): 하이퍼텍스트 문서를 전송하는 프로토콜\n\n[답] **Hypertext (하이퍼텍스트)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "웹 페이지 표시를 위해 개발된 지배적인 마크업 언어다.\n또한, 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.", "choices": [], "answer": {"keys": ["HTML"], "raw_text": "HTML"}, "explanation": "이 문제는 HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)에 대한 문제입니다.\n\n[HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)이란?]\n\n[영어 약자 풀이]\n- **H**ypertext: 하이퍼텍스트\n- **T**ext: 텍스트\n- **M**arkup: 마크업\n- **L**anguage: 언어\n- HTML = HyperText Markup Language\n\n[문제에서 설명한 HTML의 특징]\n\n1. \"웹 페이지 표시를 위해 개발된 지배적인 마크업 언어\":\n   - **웹 페이지 표시**: 웹 브라우저에서 웹 페이지를 표시하기 위한 언어\n   - **지배적인**: 웹에서 가장 널리 사용되는 마크업 언어\n   - **마크업 언어**: 문서의 구조와 의미를 태그로 표현하는 언어\n\n2. \"제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것\":\n   - **구조적 의미**: 문서의 구조를 태그로 표현\n   - **제목**: `<h1>`, `<h2>` 등\n   - **단락**: `<p>` 태그\n   - **목록**: `<ul>`, `<ol>`, `<li>` 태그\n\n3. \"링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공\":\n   - **링크**: `<a>` 태그로 하이퍼링크 생성\n   - **인용**: `<blockquote>`, `<q>` 태그\n   - **구조적 문서**: 의미 있는 구조로 문서 작성 가능\n\n[HTML의 정의]\n- 웹 페이지를 작성하기 위한 마크업 언어\n- **태그(Tag)**를 사용하여 문서의 구조와 의미를 표현\n- **웹 브라우저**가 HTML을 해석하여 웹 페이지로 표시\n\n[HTML의 특징]\n| 특징 | 설명 |\n|------|------|\n| **용도** | 웹 페이지 작성 |\n| **형식** | 마크업 언어 (태그 기반) |\n| **표준** | W3C에서 표준화 |\n| **버전** | HTML5 (현재 최신 버전) |\n\n[HTML의 주요 태그]\n- **제목**: `<h1>`, `<h2>`, `<h3>` 등\n- **단락**: `<p>`\n- **목록**: `<ul>`, `<ol>`, `<li>`\n- **링크**: `<a href=\"...\">`\n- **이미지**: `<img src=\"...\">`\n- **인용**: `<blockquote>`, `<q>`\n- **구조**: `<div>`, `<span>`, `<section>`, `<article>` 등\n\n[HTML의 구조]\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>제목</title>\n</head>\n<body>\n    <h1>제목</h1>\n    <p>단락</p>\n    <a href=\"링크\">링크</a>\n</body>\n</html>\n```\n\n[HTML vs 다른 마크업 언어]\n| 구분 | **HTML** | **XML** | **XHTML** |\n|------|----------|---------|-----------|\n| **용도** | 웹 페이지 | 데이터 표현 | HTML의 XML 버전 |\n| **구조** | 태그 기반 | 태그 기반 | 태그 기반 (엄격한 문법) |\n\n[HTML과 웹 기술]\n- **HTML**: 웹 페이지 구조와 내용\n- **CSS**: 웹 페이지 스타일 (디자인)\n- **JavaScript**: 웹 페이지 동작 (인터랙션)\n- **HTTP**: HTML 문서 전송 프로토콜\n\n[답] HTML (HyperText Markup Language)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 모듈 F에 대한 Fan-in과 Fan-out을 작성하시오.", "choices": [], "answer": {"keys": ["Fan-in : 3", "Fan-out : 2"], "raw_text": "Fan-in : 3 Fan-out : 2"}, "explanation": "이 문제는 Fan-in과 Fan-out (모듈 결합도 측정)에 관한 문제입니다.\n\n[Fan-in과 Fan-out이란?]\n\n[Fan-in (팬인)]\n- **정의**: **특정 모듈을 호출하는 모듈의 개수**\n- **방향**: 다른 모듈 → 대상 모듈 (들어오는 호출)\n- **측정**: 대상 모듈로 들어오는 제어 흐름(Control Flow)의 개수\n- **예시**: 모듈 F를 호출하는 모듈이 A, B, C 3개이면 Fan-in = 3\n\n[Fan-out (팬아웃)]\n- **정의**: **특정 모듈이 호출하는 모듈의 개수**\n- **방향**: 대상 모듈 → 다른 모듈 (나가는 호출)\n- **측정**: 대상 모듈에서 나가는 제어 흐름(Control Flow)의 개수\n- **예시**: 모듈 F가 호출하는 모듈이 X, Y 2개이면 Fan-out = 2\n\n[Fan-in과 Fan-out의 특징]\n\n| 개념 | 정의 | 측정 방법 | 좋은 값 | 나쁜 값 |\n|------|------|----------|---------|--------|\n| **Fan-in** | **들어오는 호출의 개수** | 모듈을 호출하는 모듈 수 | **높을수록 좋음** (재사용성 높음) | 낮음 (독립적) |\n| **Fan-out** | **나가는 호출의 개수** | 모듈이 호출하는 모듈 수 | **적절한 값** (5~7 이하 권장) | 너무 높음 (복잡도 증가) |\n\n[Fan-in이 높으면 좋은 이유]\n- **재사용성 높음**: 여러 모듈에서 사용되는 모듈은 재사용성이 높음\n- **공통 기능**: 여러 곳에서 필요한 공통 기능을 모듈화한 경우\n- **모듈화 성공**: 잘 설계된 모듈의 지표\n\n[Fan-out이 높으면 문제가 되는 이유]\n- **복잡도 증가**: 한 모듈이 너무 많은 모듈을 호출하면 복잡도가 증가\n- **의존성 증가**: 많은 모듈에 의존하면 유지보수 어려움\n- **결합도 증가**: 모듈 간 결합도가 높아져 수정이 어려움\n\n[문제 해석]\n\n[모듈 구조도 예시]\n```\n    A ──┐\n    B ──┼──> F ──> X\n    C ──┘     │\n              └──> Y\n```\n\n[Fan-in 계산]\n- 모듈 F를 호출하는 모듈: A, B, C\n- **Fan-in = 3**\n\n[Fan-out 계산]\n- 모듈 F가 호출하는 모듈: X, Y\n- **Fan-out = 2**\n\n[Fan-in과 Fan-out의 관계]\n- Fan-in이 높고 Fan-out이 낮은 모듈: 재사용성이 높고 복잡도가 낮은 이상적인 모듈\n- Fan-in이 낮고 Fan-out이 높은 모듈: 독립적이지만 복잡도가 높은 모듈\n- Fan-in과 Fan-out이 모두 높은 모듈: 재사용성은 높지만 복잡도도 높은 모듈\n\n[소프트웨어 공학에서의 중요성]\n- **모듈 설계 평가**: 모듈의 재사용성과 복잡도를 평가하는 지표\n- **리팩토링 기준**: Fan-out이 너무 높으면 모듈 분리 고려\n- **품질 측정**: 모듈의 품질을 측정하는 지표 중 하나\n\n[답]\n- **Fan-in : 3**\n- **Fan-out : 2**", "table_refs": [], "image_refs": ["images/2022_round2/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
