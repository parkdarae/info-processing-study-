{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 C언어 코드의 문제이다.\n보기의 조건에 맞도록 괄호 안에 알맞은 코드를 작성하시오.\n입력값이 54321일 경우 출력값이 43215로 출력되어야 한다.", "choices": [], "answer": {"keys": ["n[(i+1) % 5]"], "raw_text": "n[(i+1) % 5]"}, "explanation": "이 C언어 코드는 배열을 한 칸씩 왼쪽으로 시프트하는 문제입니다.\n\n[문제 요구사항]\n- 입력값: 54321\n- 출력값: 43215\n- 첫 번째 요소가 마지막으로 이동\n\n[해결 방법]\n- 배열을 한 칸씩 왼쪽으로 이동\n- 첫 번째 요소를 마지막으로 이동\n\n[빈칸 분석]\n- 각 요소를 한 칸 앞으로 이동시키는 인덱스 계산 필요\n- 원형 이동: `(i+1) % 5`로 인덱스 계산\n\n[답] \"n[(i+1) % 5]\"", "table_refs": [], "image_refs": ["images/2023_round2/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 JAVA 코드 문제이다.\n가지고 있는 돈이 총 4620원일 경우 1000원, 500원, 100원, 10원의 지폐 및 동전을 이용하여 보기의 조건에 맞춰 최소한의 코드를 통해 괄호안을 작성하시오.\n아래 주어진 항목들을 갖고 괄호안의 코드를 작성 변수 : m 연산자 : / , %\n괄호 : [ , ] , ( , )\n정수 : 1000, 500, 100, 10", "choices": [], "answer": {"keys": ["a = m / 1000", "b = (m % 1000) / 500", "c = (m % 500) / 100"], "raw_text": "a = m / 1000 b = (m % 1000) / 500 c = (m % 500) / 100"}, "explanation": "이 문제는 Java 코드에서 금액을 지폐/동전 단위로 분해하는 문제입니다.\n\n[문제 분석]\n- 총 금액: `m = 4620원`\n- 지폐/동전 단위: 1000원, 500원, 100원, 10원\n- 각 단위의 개수를 구하는 코드 작성\n\n[각 단위 개수 계산 방법]\n\n1. **1000원 개수 (`a`)**:\n   - `a = m / 1000`\n   - `4620 / 1000 = 4` (정수 나눗셈)\n   - 1000원 지폐 4개\n\n2. **500원 개수 (`b`)**:\n   - 먼저 1000원을 제외한 나머지 계산: `m % 1000`\n   - 그 나머지를 500으로 나눔: `(m % 1000) / 500`\n   - `(4620 % 1000) / 500 = 620 / 500 = 1`\n   - 500원 동전 1개\n\n3. **100원 개수 (`c`)**:\n   - 먼저 1000원과 500원을 제외한 나머지 계산: `m % 500`\n   - 그 나머지를 100으로 나눔: `(m % 500) / 100`\n   - `(4620 % 500) / 100 = 120 / 100 = 1`\n   - 100원 동전 1개\n\n4. **10원 개수 (`d`)**:\n   - 먼저 100원을 제외한 나머지 계산: `m % 100`\n   - 그 나머지를 10으로 나눔: `(m % 100) / 10`\n   - `(4620 % 100) / 10 = 20 / 10 = 2`\n   - 10원 동전 2개\n\n[검증]\n- `4 × 1000 + 1 × 500 + 1 × 100 + 2 × 10 = 4000 + 500 + 100 + 20 = 4620원` ✓\n\n[핵심 개념]\n- **나눗셈(`/`)**: 몫을 구하여 개수 계산\n- **나머지(`%`)**: 상위 단위를 제외한 나머지 금액 계산\n- **계산 순서**: 큰 단위부터 순차적으로 계산\n\n[답]\n- `a = m / 1000`\n- `b = (m % 1000) / 500`\n- `c = (m % 500) / 100`\n- `d = (m % 100) / 10`", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q002_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2023_round2/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 c언어의 코드이다.\n보기의 조건에 맞추어 알맞은 출력값을 작성하시오.\n입력값은 홍길동, 김철수, 박영희 순서로 주어진다.", "choices": [], "answer": {"keys": ["박영희", "박영희", "박영희"], "raw_text": "박영희"}, "explanation": "이 문제는 **C언어의 문자열 배열과 포인터**를 활용하는 문제입니다.\n\n[문제 분석]\n- 입력값: \"홍길동\", \"김철수\", \"박영희\"\n- 출력값: \"박영희\"가 3번 출력\n\n[코드 실행 과정]\n\n1. [문자열 배열 선언]\n   - 문자열 배열에 3개의 이름이 저장됨\n   - 배열의 각 요소는 문자열 포인터를 가리킴\n\n2. [포인터 연산]\n   - 포인터가 배열의 마지막 요소(박영희)를 가리키도록 설정\n   - 반복문에서 포인터를 통해 배열 요소에 접근\n\n3. [출력 과정]\n   - 반복문이 3번 실행되며, 매번 포인터가 가리키는 값(박영희) 출력\n   - 또는 포인터가 마지막 요소를 가리키고 있어서 항상 \"박영희\" 출력\n\n[일반적인 C언어 문자열 배열 코드 패턴]\n```c\nchar *names[3] = {\"홍길동\", \"김철수\", \"박영희\"};\nchar **p = names + 2;  // 마지막 요소(박영희)를 가리킴\nfor(int i = 0; i < 3; i++) {\n    printf(\"%s\\n\", *p);  // 항상 \"박영희\" 출력\n}\n```\n\n[핵심 개념]\n- **문자열 배열**: `char *names[]` - 각 요소가 문자열 포인터\n- **포인터 연산**: 배열 이름 + 오프셋으로 특정 요소 접근\n- **포인터 참조**: `*p`로 포인터가 가리키는 값(문자열) 접근\n\n[답] **\"박영희\"** (3번 출력)", "table_refs": [], "image_refs": ["images/2023_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 테이블에 데이터를 삽입하기 위한 과정이다.\n보기의 조건식에 맞게 데이터 삽입을 위한 SQL문을 작성하시오.\nCREATE TABLE 학생 (\n학번 int,\n이름 varchar(20),\n학년 int,\n전공 varchar(30),\n전화번호varchar(20)\n);\n문자열일 경우 작은따음표\n(작은따음표가 아니라 다른 단어로 명시되었습니다.)", "choices": [], "answer": {"keys": ["INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')"], "raw_text": "INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')"}, "explanation": "이 문제는 **SQL INSERT 문**을 작성하는 문제입니다.\n\n[INSERT 문의 기본 구조]\n\n```sql\nINSERT INTO 테이블명 (컬럼1, 컬럼2, ...)\nVALUES (값1, 값2, ...);\n```\n\n[문제 분석]\n\n- **테이블명**: `학생`\n- **컬럼**: 학번(int), 이름(varchar(20)), 학년(int), 전공(varchar(30)), 전화번호(varchar(20))\n- **삽입할 데이터**: 테이블의 보기를 확인하여 정확한 값 입력\n\n[SQL INSERT 문 작성]\n\n```sql\nINSERT INTO 학생(학번, 이름, 학년, 전공, 전화번호)\nVALUES(9830287, '뉴진스', 3, '경영학개론', '010-1234-1234');\n```\n\n[각 값의 데이터 타입]\n\n1. **학번**: `9830287` (정수, 작은따옴표 불필요)\n2. **이름**: `'뉴진스'` (문자열, 작은따옴표 필수)\n3. **학년**: `3` (정수, 작은따옴표 불필요)\n4. **전공**: `'경영학개론'` (문자열, 작은따옴표 필수)\n5. **전화번호**: `'010-1234-1234'` (문자열, 작은따옴표 필수)\n\n[주의사항]\n\n- **문자열 값**: 작은따옴표(`'`)로 감싸야 함\n- **정수 값**: 작은따옴표 없이 숫자만 입력\n- **컬럼 순서**: INSERT INTO 절의 컬럼 순서와 VALUES 절의 값 순서가 일치해야 함\n- **컬럼명 생략 가능**: 모든 컬럼에 값을 입력할 경우 컬럼명 생략 가능\n\n[INSERT vs 다른 SQL 문]\n\n| 문장 | 목적 | 예시 |\n|------|------|------|\n| **SELECT** | 조회 | `SELECT * FROM 학생` |\n| **INSERT** | 삽입 | `INSERT INTO 학생 VALUES(...)` |\n| **UPDATE** | 수정 | `UPDATE 학생 SET 이름 = '철수'` |\n| **DELETE** | 삭제 | `DELETE FROM 학생 WHERE 학번 = 1` |\n\n[답] INSERT INTO 학생(학번, 이름, 학년, 전공, 전화번호) VALUES(9830287, '뉴진스', 3, '경영학개론', '010-1234-1234')", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q004_table1.json", "rows": 1, "cols": 5}], "image_refs": ["images/2023_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 C언어의 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["BCD"], "raw_text": "BCD"}, "explanation": "[주어진 코드]\n```c\n#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0; i<3; i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}\n```\n\n[실행 과정]\n\n1. [배열 합 계산]\n   - `sum = 73 + 95 + 82 = 250`\n\n2. [switch 조건]\n   - `sum / 30 = 250 / 30 = 8` (정수 나눗셈)\n\n3. [switch 실행]\n   - `case 8:`로 이동\n   - break가 없으므로 아래로 fall-through\n   - `printf(\"B\")` 실행 → \"B\" 출력\n   - `case 7:` (빈 case, 계속 진행)\n   - `case 6:` → `printf(\"C\")` 실행 → \"C\" 출력\n   - `default:` → `printf(\"D\")` 실행 → \"D\" 출력\n\n[최종 출력] **\"BCD\"**\n\n[핵심 포인트]\n- **switch fall-through**: `break` 문이 없으면 다음 case로 계속 실행됨\n- **정수 나눗셈**: `250 / 30 = 8` (소수점 버림)\n\n[답] **\"BCD\"**", "table_refs": [], "image_refs": ["images/2023_round2/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0;i<3;i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round2/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 테스트 커버리지에 대한 내용이다.\n내용을 보고\n\n보기에 알맞는 기호를 고르시오.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 경로 커버리지\n\nㄷ. 조건/결정 커버리지\n\nㄹ. 변형 조건/결정 커버리지\n\nㅂ. 다중 조건 커버리지\n\nㅅ. 결정 커버리지\n\nㅇ. 조건 커버리지", "choices": [], "answer": {"keys": ["ㅇ"], "raw_text": "ㅇ"}, "explanation": "이 문제는 테스트 커버리지(Test Coverage) 중 조건 커버리지(Condition Coverage)에 대한 문제입니다.\n\n[조건 커버리지(Condition Coverage)란?]\n\n[정의]\n- 각 **조건문(condition)**의 참(true)과 거짓(false) 값을 최소 한 번씩 실행하는 테스트 커버리지\n- **Predicate Coverage**라고도 함\n- 조건식의 각 부분 조건을 개별적으로 테스트\n\n[조건 커버리지의 특징]\n\n1. [조건문 단위 테스트]\n   - `if (A && B)` 같은 복합 조건에서\n   - `A = true`, `A = false`, `B = true`, `B = false`를 각각 테스트\n\n2. [결정 커버리지와의 차이]\n   - **결정 커버리지**: 전체 조건식의 참/거짓만 테스트\n   - **조건 커버리지**: 각 부분 조건의 참/거짓을 개별적으로 테스트\n\n[예시]\n\n```c\nif (A && B) {  // A와 B가 모두 참이어야 실행\n    // 코드\n}\n```\n\n[조건 커버리지 테스트 케이스]\n- 케이스 1: `A = true, B = false` (A는 참, B는 거짓)\n- 케이스 2: `A = false, B = true` (A는 거짓, B는 참)\n- 케이스 3: `A = true, B = true` (A는 참, B는 참)\n- 케이스 4: `A = false, B = false` (A는 거짓, B는 거짓)\n\n[테스트 커버리지 종류 비교]\n\n| 커버리지 | 정의 | 예시 |\n|---------|------|------|\n| **구문 커버리지** | 모든 문장 실행 | 코드의 모든 줄 실행 |\n| **분기 커버리지** | 모든 분기의 참/거짓 경로 실행 | if문의 true/false 경로 |\n| **조건 커버리지** | 각 조건문의 참/거짓 값 실행 | `A && B`에서 A와 B 각각 테스트 |\n| **결정 커버리지** | 전체 조건식의 참/거짓 실행 | `A && B` 전체 결과만 테스트 |\n| **경로 커버리지** | 모든 실행 경로 실행 | 모든 가능한 경로 조합 |\n\n[답] **ㅇ (조건 커버리지)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 소스코드의 알맞은 출력을 작성하시오.", "choices": [], "answer": {"keys": ["505"], "raw_text": "505"}, "explanation": "이 문제는 **프로그래밍 코드의 실행 결과**를 구하는 문제입니다. 문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.\n\n[문제 해결 방법]\n\n이 문제는 코드의 실행 흐름을 추적하여 출력값을 구하는 문제입니다. 코드의 실제 내용(변수, 메서드, 반복문, 조건문 등)을 확인하고, 각 단계별로 변수 값의 변화를 추적하여 최종 출력값을 도출해야 합니다.\n\n[코드 분석 시 확인사항]\n\n1. **변수 선언 및 초기화**:\n   - 변수의 타입과 초기값 확인\n   - 전역 변수 vs 지역 변수 구분\n\n2. **연산 및 계산**:\n   - 산술 연산: `+`, `-`, `*`, `/`, `%`\n   - 논리 연산: `&&`, `||`, `!`\n   - 비교 연산: `==`, `!=`, `<`, `>`, `<=`, `>=`\n\n3. **제어 구조**:\n   - 조건문: `if`, `else`, `switch`\n   - 반복문: `for`, `while`, `do-while`\n   - 반복 횟수와 종료 조건 확인\n\n4. **출력문**:\n   - 출력문의 위치와 순서 확인\n   - 출력 형식 확인 (`printf`, `System.out.println` 등)\n\n[일반적인 코드 실행 순서]\n1. 변수 선언 및 초기화\n2. 조건문 확인 및 실행\n3. 반복문 실행 (조건 확인 → 실행 → 증가/감소)\n4. 연산 및 계산 수행\n5. 출력문 실행\n\n[답] 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 변수의 초기값부터 시작하여 각 문장의 실행 결과를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round2/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 내용에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["템퍼프루핑"], "raw_text": "템퍼프루핑"}, "explanation": "템퍼프루핑(Tamper Proofing)은 소프트웨어나 시스템이 변조되지 않도록 보호하는 기술입니다.\n\n[템퍼프루핑의 특징]\n- 소프트웨어 코드나 데이터가 무단으로 수정되는 것을 방지\n- 변조 시도를 감지하고 대응\n- 무결성 검증 기능 제공\n\n[답] \"템퍼프루핑\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 C언어 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["213465"], "raw_text": "213465"}, "explanation": "이 C언어 코드는 스택(Stack) 자료구조를 구현하고 사용하는 문제입니다.\n\n[코드 분석]\n\n```c void into(int num) {\nif (point >= 10) printf(\"Full\");\nelse isWhat[++point] = num; // push (전위 증가)\n}\n\nint take() {\nif (isEmpty() == 1) printf(\"Empty\");\nelse return isWhat[point--]; // pop (후위 감소)\nreturn 0;\n}\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `point = -1` (빈 스택)\n\n2. `into(5); into(2);`• \n- 스택: `[5, 2]`, `point = 1`\n\n3. [while 루프]첫 번째 반복:\n- `take()` → `isWhat[1] = 2` 반환, `point = 0` → \"2\" 출력\n- `into(4);` → 스택: `[5, 4]`, `point = 1`\n- `into(1);` → 스택: `[5, 4, 1]`, `point = 2`\n- `take()` → `isWhat[2] = 1` 반환, `point = 1` → \"1\" 출력\n- `into(3);` → 스택: `[5, 4, 3]`, `point = 2`\n- `take()` → `isWhat[2] = 3` 반환, `point = 1` → \"3\" 출력\n- `take()` → `isWhat[1] = 4` 반환, `point = 0` → \"4\" 출력\n- `into(6);` → 스택: `[5, 6]`, `point = 1`\n- `take()` → `isWhat[1] = 6` 반환, `point = 0` → \"6\" 출력\n- `take()` → `isWhat[0] = 5` 반환, `point = -1` → \"5\"** 출력\n\n[두 번째 반복]\n- `isEmpty() == 1` → 루프 종료\n\n[최종 출력] \"213465\"\n\n[답] \"213465\"", "table_refs": [], "image_refs": ["images/2023_round2/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#define MAX_SIZE 10\nint isWhat[MAX_SIZE];\nint point= -1;\nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    else isWhat[++point] = num;\n}\nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    else return isWhat[point--];\n    return 0;\n}\nint main(int argc, char const *argv[]){\n    int e;\n    into(5); into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take());\n        into(3); printf(\"%d\", take()); printf(\"%d\", take());\n        into(6); printf(\"%d\", take()); printf(\"%d\", take());\n    }\n    return 0;\n}", "line_numbers": [1, 32], "file": "data/codes/2023_round2/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 디자인 패턴에 관한 문제이다.\n보기에서 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. Singleton", "2. Visitor"], "raw_text": "1. Singleton 2. Visitor"}, "explanation": "GoF 디자인 패턴 분류 문제입니다.\n\n[문제의 보기 (이미지 참조)]\n\n| **생성패턴** | **구조패턴** | **행위패턴** |\n|-------------|-------------|-------------|\n| Singleton | Adapter | Observer |\n| Factory Method | Bridge | Strategy |\n| Builder | Decorator | Visitor |\n\n[GoF 디자인 패턴은 3가지 범주로 분류됩니다]\n\n[1. 생성 패턴 (Creational Patterns)]\n- 객체의 생성과 관련된 패턴\n- 객체 생성 방식을 구조화하여 시스템의 유연성과 재사용성을 높임\n\n[보기의 생성 패턴]\n- **Singleton**: 클래스의 인스턴스가 **하나만** 존재하도록 보장\n  - 전역 접근 지점 제공\n  - 예: Database 연결, Logger\n  \n- **Factory Method**: 객체 생성 인터페이스를 정의하고 서브클래스에서 구체적인 객체 생성\n  - 객체 생성 로직을 서브클래스에 위임\n  \n- **Builder**: 복잡한 객체를 단계별로 생성\n  - 생성 과정과 표현 분리\n\n[2. 구조 패턴 (Structural Patterns)]\n- 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴\n- 서로 다른 인터페이스를 가진 객체들을 묶어 새로운 기능 제공\n\n[보기의 구조 패턴]\n- **Adapter**: 서로 다른 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 변환\n  - 호환성 없는 인터페이스를 연결\n  \n- **Bridge**: 구현부와 추상부를 분리하여 독립적으로 변형 가능\n  - 기능 계층과 구현 계층 분리\n  \n- **Decorator**: 객체에 동적으로 새로운 책임/기능 추가\n  - 상속 대신 조합으로 기능 확장\n\n[3. 행위 패턴 (Behavioral Patterns)]\n- 객체나 클래스 간의 알고리즘, 책임 분배에 관한 패턴\n- 객체들 간의 상호작용과 책임 분배 정의\n\n[보기의 행위 패턴]\n- **Observer**: 한 객체의 상태 변화를 다른 객체들에게 자동으로 통지\n  - 발행-구독(Publish-Subscribe) 모델\n  - 예: Event Listener, MVC 패턴\n  \n- **Strategy**: 알고리즘 군을 정의하고 각각을 캡슐화하여 교환 가능하게 만듦\n  - 알고리즘을 동적으로 교체\n  \n- **Visitor**: 객체 구조와 연산을 분리\n  - 구조 변경 없이 새로운 연산 추가\n  - Double Dispatch 기법 사용\n\n[문제 해결]\n\n문제에서 요구하는 것은 보기 표에서 특정 패턴을 찾는 것입니다.\n\n- **1번 답**: 생성 패턴 중 하나 → **Singleton**\n- **2번 답**: 행위 패턴 중 하나 → **Visitor**\n\n[답] 1. Singleton, 2. Visitor", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q011_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2023_round2/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 내용에서 설명하는 문제에 대해 보기에 알맞는 답을 골라 작성하시오.\n\n(1) Code는 데이터 전송시 1 비트의 에러를 정정할 수 있는, 오류정정부호의 일종으로 미국의 Bell 연구소의 Hamming에 의해 고안되었다. 선형블록부호 및 순회부호에 속에 속한다.\n( 2 ) 은/는 송신측이 전송할 문자나 프레임에 부가적 정보(Redundancy)를 첨가하여 전송하고 수신측이 부가적 정보를 이용하여 에러검출 및 에러정정을 하는 방식이다.\n( 3 ) 은/는 데이터 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 방식이다. 오류를 검출하는 방법은 Parity검사와 CRC, 블록 합 검사 등이 있다.\n( 4 ) 은/는 데이터가 저장장치 내의 한 장소에서 다른 장소로 이동되거나, 컴퓨터들간에 전송될 때, 데이터가 유실 또는 손상되었는지 여부를 점검하는 기술과 관련된 용어이다.\n( 5 ) 은/는 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.\nEAC, FEC, hamming, CRC, PDS, parity, BEC", "choices": [], "answer": {"keys": ["1. hamming", "2. FEC", "3. BEC"], "raw_text": "1. hamming 2. FEC 3. BEC"}, "explanation": "이 문제는 **오류 검출 및 정정 기법**에 대한 문제입니다.\n\n[각 용어의 정의]\n\n1. **Hamming (해밍 코드)**:\n   - **정의**: 데이터 전송 시 **1비트의 에러를 정정**할 수 있는 오류 정정 부호\n   - **고안자**: 미국 Bell 연구소의 Hamming\n   - **특징**: 선형 블록 부호 및 순회 부호에 속함\n   - **용도**: 단일 비트 오류 정정\n\n2. FEC (Forward Error Correction, 순방향 오류 정정):\n   - **정의**: 송신측이 전송할 문자나 프레임에 **부가적 정보(Redundancy)**를 첨가하여 전송하고, 수신측이 부가적 정보를 이용하여 **에러 검출 및 에러 정정**을 하는 방식\n   - **특징**: 재전송 없이 오류 정정 가능\n   - **예시**: Hamming 코드, Reed-Solomon 코드\n\n3. BEC (Backward Error Correction, 역방향 오류 정정):\n   - **정의**: 데이터 전송 과정에서 오류가 발생하면 **송신 측에 재전송을 요구**하는 방식\n   - **특징**: 오류 검출 후 재전송 요청\n   - **오류 검출 방법**: Parity 검사, CRC, 블록 합 검사 등\n\n4. **Parity (패리티)**:\n   - **정의**: 데이터가 저장장치 내의 한 장소에서 다른 장소로 이동되거나, 컴퓨터들 간에 전송될 때, 데이터가 **유실 또는 손상되었는지 여부를 점검**하는 기술\n   - **특징**: 단순한 오류 검출 방법\n   - **종류**: 짝수 패리티(Even Parity), 홀수 패리티(Odd Parity)\n\n5. CRC (Cyclic Redundancy Check, 순환 중복 검사):\n   - **정의**: 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식\n   - **특징**: 다항식 기반의 오류 검출 코드\n   - **용도**: 네트워크 통신, 파일 전송 등\n\n[오류 처리 방식 비교]\n\n| 방식 | 특징 | 예시 |\n|------|------|------|\n| **FEC** | 순방향 오류 정정, 재전송 불필요 | Hamming 코드 |\n| **BEC** | 역방향 오류 정정, 재전송 필요 | ARQ (Automatic Repeat Request) |\n| **Parity** | 단순 오류 검출 | 짝수/홀수 패리티 |\n| **CRC** | 고급 오류 검출 | 네트워크 프로토콜 |\n\n[답]\n- 1. hamming\n- 2. FEC\n- 3. BEC\n- 4. parity\n- 5. CRC", "table_refs": [], "image_refs": ["images/2023_round2/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["운영체제", "네트워크"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 HDLC 프로토콜에 대한 설명이다.\n보기 안에 알맞는 답을 골라 작성하시오.\n\n(1) 프레임은 Seq, Next, P/F의 필드를 가진다. 또한 맨 처음 비트를 0으로 가진다. Seq는 송신용 순서번호를 가지고 있다. Next는 응답용 순서번호를 가진다. P/F는 P가 1로 설정된 경우 주국에서 종국에 데이터 전송을 허용하는 것을 의미하고 F가 1로 설정된 경우 종국에서 주국으로 데이터 전송을 하는 것을 의미한다.\n( 2 ) 프레임은 맨 앞의 필드가 1로 되어 있어 정보 프레임이 아니라는 것을 나타내고 다음 비트가 0이 나와있다. Type의 경우에는 2비트를 가지고 있어 4가지의 종류로 나누어진다.  데이터를 보내는 역할이 아니라 응답의 기능을 수행하므로 Seq에 대한 값은 필요가 없고 다음 프레임을 요구하는 Next만 존재한다.\n( 3 ) 프레임은 순서 번호가 없는 프레임을 의미한다. 첫 번째 비트와 두 번째 비트가 모두 1로 설정되어 있다. 여러 종류를 가지고 있는데 Type의 2비트와 Modifier의 3비트를 합쳐 5비트를 통해 종류를 나눈다.\n( 4 ) 은/는 두 호스트 모두 혼합국으로 동작한다. 양쪽에서 명령과 응답을 전송할 수 있다.\n( 5 ) 은/는 불균형 모드로 주국의 허락 없이 종국에서 데이터를 전송할 수 있다.\n\n[보기]\n\nㄱ. 연결제어\n\nㄴ. 감독\n\nㄷ. 정보\n\nㄹ. 양방향 응답\n\nㅁ. 익명\n\nㅂ. 비번호\n\nㅅ. 릴레이\n\nㅇ. 동기균형     ㅈ. 동기응답    ㅊ. 비동기균형     ㅋ. 비동기응답", "choices": [], "answer": {"keys": ["1. ㄷ", "2. ㄴ", "3. ㅂ"], "raw_text": "1. ㄷ\n2. ㄴ\n3. ㅂ"}, "explanation": "이 문제는 HDLC (High-Level Data Link Control) 프로토콜의 프레임 타입과 모드에 대한 문제입니다.\n\n[HDLC 프레임 타입]\n\n1. 정보 프레임 (Information Frame, ㄷ):\n   - **첫 번째 비트**: `0`\n   - **필드**: Seq (송신용 순서번호), Next (응답용 순서번호), P/F (Poll/Final)\n   - **P/F 필드**:\n     - P = 1: 주국에서 종국에 데이터 전송 허용\n     - F = 1: 종국에서 주국으로 데이터 전송\n   - **용도**: 실제 데이터 전송\n\n2. 감독 프레임 (Supervisory Frame, ㄴ):\n   - **첫 번째 비트**: `1`\n   - **두 번째 비트**: `0`\n   - **필드**: Type (2비트, 4가지 종류), Next (응답용 순서번호)\n   - **특징**: Seq 없음 (데이터 전송 역할이 아니므로)\n   - **용도**: 응답 기능 수행, 다음 프레임 요구\n\n3. 비번호 프레임 (Unnumbered Frame, ㅂ):\n   - **첫 번째 비트**: `1`\n   - **두 번째 비트**: `1`\n   - **필드**: Type (2비트), Modifier (3비트)\n   - **특징**: 순서 번호 없음 (Seq, Next 없음)\n   - **용도**: 연결 설정/해제, 오류 제어 등\n\n[HDLC 모드]\n\n4. 비동기 균형 모드 (Asynchronous Balanced Mode, ㅊ):\n   - **특징**: 두 호스트 모두 혼합국(Combined Station)으로 동작\n   - **통신**: 양쪽에서 명령과 응답을 전송 가능\n   - **용도**: 점대점 연결\n\n5. 비동기 응답 모드 (Asynchronous Response Mode, ㅋ):\n   - **특징**: **불균형 모드**\n   - **통신**: 주국의 허락 없이 종국에서 데이터 전송 가능\n   - **용도**: 주국-종국 구조\n\n[HDLC 프레임 타입 비교]\n\n| 프레임 타입 | 첫 비트 | 두 번째 비트 | Seq | Next | 용도 |\n|-----------|--------|------------|-----|------|------|\n| **정보** | 0 | - | 있음 | 있음 | 데이터 전송 |\n| **감독** | 1 | 0 | 없음 | 있음 | 응답, 제어 |\n| **비번호** | 1 | 1 | 없음 | 없음 | 연결 제어 |\n\n[HDLC 모드 비교]\n\n| 모드 | 특징 | 용도 |\n|------|------|------|\n| **동기 균형** | 양쪽 모두 주국 | - |\n| **동기 응답** | 주국-종국 구조, 주국 허락 필요 | - |\n| **비동기 균형 (ㅊ)** | 양쪽 모두 혼합국, 양방향 전송 | 점대점 |\n| **비동기 응답 (ㅋ)** | 주국-종국, 종국 자율 전송 | 불균형 |\n\n[답]\n- 1. ㄷ (정보)\n- 2. ㄴ (감독)\n- 3. ㅂ (비번호)\n- 4. ㅊ (비동기 균형)\n- 5. ㅋ (비동기 응답)", "table_refs": [], "image_refs": ["images/2023_round2/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 자바에 대한 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["true", "false", "true"], "raw_text": "true false true"}, "explanation": "Java 코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"true false true\"**입니다.", "table_refs": [], "image_refs": ["images/2023_round2/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 보기는 암호화 알고리즘에 대한 내용이다.\n대칭키와 비대칭키에 해당하는 보기의 내용을 작성하시오 대칭키 : (              )\n비대칭키 : (                    )\nDES, RSA, AES, ECC,  ARIA, SEED", "choices": [], "answer": {"keys": ["대칭키: DES AES ARIA SEED", "비대칭키: RSA ECC"], "raw_text": "대칭키: DES AES ARIA SEED 비대칭키: RSA ECC"}, "explanation": "암호화 알고리즘은 키 사용 방식에 따라 대칭키와 비대칭키로 분류됩니다.\n\n[대칭키 암호화 (Symmetric Key Cryptography)]\n- 암호화와 복호화에 **같은 키** 사용\n- 빠른 속도, 대용량 데이터 처리 적합\n- 키 배포 문제 존재\n\n[대칭키 알고리즘]\n- DES (Data Encryption Standard): 56비트 키, 구형 표준\n- AES (Advanced Encryption Standard): 128/192/256비트 키, 현재 표준\n- ARIA (Academy Research Institute in America): 한국 표준 암호화 알고리즘\n- **SEED**: 한국 표준 블록 암호 알고리즘\n\n[비대칭키 암호화 (Asymmetric Key Cryptography)]\n- 암호화와 복호화에 **다른 키** 사용 (공개키/개인키 쌍)\n- 공개키는 공개, 개인키는 비공개\n- 키 배포 문제 해결\n- 상대적으로 느림\n\n[비대칭키 알고리즘]\n- RSA (Rivest-Shamir-Adleman): 가장 널리 사용되는 공개키 암호화\n- ECC (Elliptic Curve Cryptography): 타원 곡선 기반, 작은 키로 높은 보안\n\n[답]\n- 대칭키: DES, AES, ARIA, SEED\n- 비대칭키: RSA, ECC", "table_refs": [], "image_refs": ["images/2023_round2/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["해시"], "raw_text": "해시"}, "explanation": "이 문제는 **해시(Hash)** 또는 **해싱(Hashing)**에 대한 문제입니다. 문제의 설명을 확인하여 정확한 답을 작성해야 합니다.\n\n[해시(Hash)란?]\n\n[정의]\n- 데이터를 **고정된 길이의 값(해시 값)**으로 변환하는 함수\n- **해시 함수(Hash Function)**: 입력 데이터를 해시 값으로 변환하는 함수\n- **해싱(Hashing)**: 해시 함수를 사용하여 데이터를 변환하는 과정\n\n[해시의 특징]\n\n1. **고정된 길이**:\n   - 입력 데이터 크기에 관계없이 항상 같은 길이의 해시 값 생성\n   - 예: SHA-256은 항상 256비트 (32바이트) 출력\n\n2. **단방향 함수**:\n   - 해시 값에서 원본 데이터를 복원하기 어려움\n   - 암호화와 달리 복호화 불가\n\n3. **결정적 함수**:\n   - 같은 입력에 대해 항상 같은 해시 값 출력\n\n4. **충돌 가능성**:\n   - 서로 다른 입력이 같은 해시 값을 가질 수 있음 (해시 충돌)\n\n[해시의 용도]\n\n1. **해시 테이블 (Hash Table)**:\n   - 빠른 데이터 검색, 삽입, 삭제\n   - O(1) 시간 복잡도 (평균)\n\n2. **데이터 무결성 검증**:\n   - 파일의 해시 값을 비교하여 변경 여부 확인\n   - 예: MD5, SHA-256 체크섬\n\n3. **암호화**:\n   - 비밀번호 해시 저장\n   - 디지털 서명\n\n4. **데이터베이스 인덱싱**:\n   - 해시 인덱스로 빠른 검색\n\n[해시 함수 예시]\n\n- **MD5**: 128비트 해시 값\n- **SHA-1**: 160비트 해시 값\n- **SHA-256**: 256비트 해시 값\n- **CRC**: 순환 중복 검사\n\n[해시 테이블 구조]\n\n```\n키(key) → 해시 함수 → 해시 값 → 인덱스 → 저장 위치\n```\n\n[답] **\"해시\"** 또는 **\"해싱\"**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 보기의 SQL문에서 괄호 안에 알맞는 단어를 작성하시오.\nDROP VIEW 학생 (         )", "choices": [], "answer": {"keys": ["cascade"], "raw_text": "cascade"}, "explanation": "이 문제는 **SQL DROP VIEW 문**에서 **CASCADE 옵션**을 사용하는 문제입니다.\n\n[DROP VIEW 문의 기본 구조]\n\n```sql\nDROP VIEW 뷰명 [CASCADE | RESTRICT];\n```\n\n[CASCADE 옵션]\n\n- **CASCADE**: 뷰를 삭제할 때, 해당 뷰에 의존하는 다른 객체들도 함께 삭제\n- **RESTRICT**: 뷰에 의존하는 객체가 있으면 삭제 실패 (기본값)\n\n[문제 분석]\n\n- `DROP VIEW 학생 (        )`\n- 괄호 안에 들어갈 옵션: **CASCADE**\n\n[CASCADE의 동작]\n\n1. **뷰 삭제**: `학생` 뷰 삭제\n2. **의존 객체 삭제**: `학생` 뷰를 참조하는 다른 뷰나 객체도 함께 삭제\n3. **연쇄 삭제**: 의존 관계를 따라 모든 관련 객체 삭제\n\n[예시]\n\n```sql\n-- 학생 뷰 생성\nCREATE VIEW 학생 AS SELECT * FROM 학생테이블;\n\n-- 학생 뷰를 참조하는 다른 뷰 생성\nCREATE VIEW 학생정보 AS SELECT * FROM 학생;\n\n-- CASCADE로 삭제 시\nDROP VIEW 학생 CASCADE;  -- 학생 뷰와 학생정보 뷰 모두 삭제\n\n-- RESTRICT로 삭제 시\nDROP VIEW 학생 RESTRICT;  -- 학생정보 뷰가 있으면 삭제 실패\n```\n\n[CASCADE vs RESTRICT]\n\n| 옵션 | 동작 | 특징 |\n|------|------|------|\n| **CASCADE** | 의존 객체도 함께 삭제 | 연쇄 삭제, 위험할 수 있음 |\n| **RESTRICT** | 의존 객체가 있으면 삭제 실패 | 안전한 삭제, 기본값 |\n\n[주의사항]\n\n- **CASCADE 사용 시 주의**: 의도치 않은 객체까지 삭제될 수 있음\n- **의존 관계 확인**: 삭제 전에 의존 관계를 확인하는 것이 좋음\n\n[답] **\"CASCADE\"**", "table_refs": [], "image_refs": ["images/2023_round2/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음 코드는 선택정렬 구현에 관한 문제이다.\n오름차순으로 정렬할 경우 빈칸에 알맞는 연산자를 보기에서 골라 작성하시오.\n\n<, <=, =>, >, ==, /, %", "choices": [], "answer": {"keys": [">"], "raw_text": ">"}, "explanation": "선택 정렬(Selection Sort)은 오름차순 정렬 시 최소값을 찾아 앞으로 이동시키는 알고리즘입니다.\n\n[선택 정렬 알고리즘]\n1. 배열에서 최소값 찾기 2. 최소값을 첫 번째 위치와 교환 3. 남은 부분에서 최소값 찾기 4. 두 번째 위치와 교환 5. 반복...\n\n[오름차순 정렬]\n- 작은 값부터 앞으로 이동\n- 비교 연산자: **\">\"** 사용 (큰 값이면 교환)\n- 또는 **\"<\"** 사용 (작은 값이면 교환)\n\n[코드 예시]\n```c for(int i=0; i<n-1; i++){\nint min_idx = i;\nfor(int j=i+1; j<n; j++){\nif(arr[j] < arr[min_idx]) // 오름차순: <\nmin_idx = j;\n}\nswap(arr[i], arr[min_idx]);\n}\n```\n\n[답] \">\" (또는 \"<\", 코드 구조에 따라)", "table_refs": [], "image_refs": ["images/2023_round2/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "알고리즘", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 파이썬 코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["engneing"], "raw_text": "engneing"}, "explanation": "이 문제는 **Python 코드의 실행 결과**를 구하는 문제입니다. 문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.\n\n[문제 해결 방법]\n\n이 문제는 Python 코드의 실행 흐름을 추적하여 출력값을 구하는 문제입니다. 코드의 실제 내용(변수, 문자열 조작, 리스트 메서드, 반복문 등)을 확인하고, 각 단계별로 변수 값의 변화를 추적하여 최종 출력값을 도출해야 합니다.\n\n[Python 코드 분석 시 확인사항]\n\n1. **문자열 조작**:\n   - 문자열 슬라이싱: `str[start:end]`\n   - 문자열 메서드: `replace()`, `split()`, `join()`, `strip()` 등\n   - 문자열 인덱싱: `str[index]`\n\n2. **리스트 조작**:\n   - 리스트 인덱싱: `list[index]`\n   - 리스트 메서드: `append()`, `pop()`, `remove()`, `insert()` 등\n   - 리스트 슬라이싱: `list[start:end]`\n\n3. **반복문**:\n   - `for` 루프: `for item in iterable`\n   - `while` 루프: 조건에 따른 반복\n   - 반복 횟수와 종료 조건 확인\n\n4. **출력문**:\n   - `print()` 함수\n   - 출력 형식 및 구분자 확인\n\n[일반적인 Python 문자열/리스트 조작 패턴]\n\n```python\n# 예시 1: 문자열 슬라이싱\ns = \"engineering\"\nprint(s[1:5])  # \"ngin\"\nprint(s[::2])  # \"enieig\"\n\n# 예시 2: 리스트 조작\narr = ['e', 'n', 'g', 'i', 'n', 'e', 'e', 'r', 'i', 'n', 'g']\narr.pop(0)  # 첫 번째 요소 제거\nprint(''.join(arr))  # \"ngineering\"\n```\n\n[답] 문제의 이미지에서 코드를 확인하고, 문자열이나 리스트의 조작 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 문자열 슬라이싱, 인덱싱, 또는 리스트 조작을 통해 특정 문자들을 제거하거나 재배열하는 과정을 거칩니다.", "table_refs": [], "image_refs": ["images/2023_round2/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 설명에 대한 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. 스텁", "2. 드라이버"], "raw_text": "1. 스텁 2. 드라이버"}, "explanation": "스텁(Stub)과 드라이버(Driver)는 소프트웨어 테스트에서 사용하는 더미 모듈입니다.\n\n[스텁(Stub)]\n- 하향식 통합 테스트에서 사용\n- 상위 모듈이 호출하는 하위 모듈을 대체\n- 하위 모듈이 아직 구현되지 않았을 때 사용\n- 상위 모듈 테스트를 위해 간단한 결과만 반환\n\n[드라이버(Driver)]\n- 상향식 통합 테스트에서 사용\n- 하위 모듈을 호출하는 상위 모듈을 대체\n- 상위 모듈이 아직 구현되지 않았을 때 사용\n- 하위 모듈을 호출하고 결과를 확인\n\n[비교]\n- **스텁**: 하위 모듈 대체 (상위 모듈 테스트)\n- **드라이버**: 상위 모듈 대체 (하위 모듈 테스트)\n\n[답] \"1. 스텁, 2. 드라이버\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
