{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "아래 설명에 맞는 RAID 단계를 숫자로 작성하시오.\n\n- Striping(스트라이핑) 구현 방식\n\n- I/O 로드의 분산으로 매우 빠른 속도\n\n- 데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장", "choices": [], "answer": {"keys": ["RAID 0"], "raw_text": "RAID 0"}, "explanation": "문제에서 설명하는 특징들이 모두 **RAID 0**을 가리킵니다.\n\n[RAID 0 (스트라이핑, Striping)]\n\n[1. Striping(스트라이핑) 구현 방식]\n- 데이터를 여러 디스크에 **균등하게 분산 저장**하는 방식\n- **데이터를 블록 단위로 분할**하여 각 디스크에 저장\n- 예: 100MB 파일을 4개 디스크에 25MB씩 분산 저장\n\n[2. I/O 로드의 분산으로 매우 빠른 속도]\n- 여러 디스크에 **동시에 접근**할 수 있어 병렬 처리 가능\n- 읽기/쓰기 속도가 **디스크 개수에 비례하여 증가**\n- 예: 4개 디스크 사용 시 이론적으로 최대 4배 속도 향상\n- I/O 작업이 각 디스크에 분산되어 전체 처리량 증가\n\n[3. 데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장]\n- 연속된 데이터를 **블록 단위로 분할**\n- 첫 번째 블록 → 디스크1, 두 번째 블록 → 디스크2, 세 번째 블록 → 디스크3... 순서로 저장\n- 데이터가 여러 디스크에 **교차(interleave) 저장**됨\n\n[RAID 0의 동작 원리]\n```\n예시: \"ABCD\" 데이터를 2개 디스크에 저장\n\n디스크1: A | C\n디스크2: B | D\n\n읽기 시: 디스크1과 디스크2에서 동시에 읽어서 병렬 처리\n```\n\n[문제 설명과의 매칭]\n- ✓ \"스트라이핑 구현 방식\" → RAID 0만 스트라이핑 사용\n- ✓ \"I/O 로드의 분산으로 매우 빠른 속도\" → RAID 0의 핵심 특징\n- ✓ \"데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장\" → RAID 0의 저장 방식\n\n[RAID 0의 특징 요약]\n| 특징 | 설명 |\n|------|------|\n| **구현 방식** | 스트라이핑 (Striping) |\n| **성능** | 매우 빠름 (I/O 분산, 병렬 처리) |\n| **저장 방식** | 블록 단위 분할, 여러 디스크에 분산 |\n| **장점** | 성능 향상, 용량 효율 (100% 사용 가능) |\n| **단점** | 안정성 낮음 (디스크 하나 고장 시 전체 데이터 손실) |\n\n[답] **RAID 0**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["데이터베이스"], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 설명을 확인하여\n\n해당하는 항목을 보기에서 찾아 적으시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, rollback 등..))\n\n1. 오류가 발생하기 전까지의 사항을 로그(log)로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상\n\n2. 작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것", "choices": [], "answer": {"keys": ["watering hole (워터링홀)"], "raw_text": "watering hole (워터링홀)"}, "explanation": "이 문제는 데이터베이스 **트랜잭션의 복구 기법**에 대한 문제입니다.\n\n[문제에서 설명하는 내용]\n\n1. 오류가 발생하기 전까지의 사항을 로그로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상\n- 이것은 **REDO (재실행)**입니다.\n- 트랜잭션이 커밋된 후 갱신 사항이 데이터베이스에 반영되지 못한 경우\n- 로그 파일의 기록을 이용하여 다시 실행하는 복구 방법\n\n2. 작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것\n- 이것은 **UNDO (취소)**입니다.\n- 트랜잭션이 롤백될 때 변경 사항을 취소하는 복구 방법\n- 변경 전 값으로 복원\n\n[REDO와 UNDO의 차이]\n\n| 구분 | UNDO | REDO |\n|------|------|------|\n| 목적 | 트랜잭션 취소 | 트랜잭션 재실행 |\n| 시점 | 롤백 시 | 커밋 후 미반영 시 |\n| 방향 | 과거로 되돌림 | 앞으로 진행 |\n| 로그 | Before Image 사용 | After Image 사용 |\n\n[답]\n- 1) **redo** (재실행)\n- 2) **undo** (취소)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음 자바 문법에 알맞는 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["2000"], "raw_text": "2000"}, "explanation": "[주어진 코드]\n```java\nclass A {\n    int a;\n    int b;\n}\n\npublic class Main {\n    static void func1(A m) {\n        m.a *= 10;\n    }\n    \n    static void func2(A m) {\n        m.a += m.b;\n    }\n    \n    public static void main(String args[]) {\n        A m = new A();\n        m.a = 100;\n        func1(m);\n        m.b = m.a;\n        func2(m);\n        System.out.printf(\"%d\", m.a);\n    }\n}\n```\n\n[Java 객체 참조 전달]\n- Java에서 객체는 **참조(reference)로 전달**됩니다\n- 메서드에 객체를 전달하면 **원본 객체의 참조**가 전달됩니다\n- 메서드 내에서 객체의 필드를 변경하면 **원본 객체도 함께 변경**됩니다\n\n[단계별 실행 과정]\n\n[1. 객체 생성 및 초기화]\n- `A m = new A();` → `m.a = 0`, `m.b = 0` (기본값)\n- `m.a = 100;` → `m.a = 100`, `m.b = 0`\n\n[2. func1(m) 호출]\n- `m.a *= 10;` → `m.a = m.a * 10 = 100 * 10 = 1000`\n- 참조로 전달되었으므로 원본 객체의 `m.a`가 1000으로 변경됨\n- 상태: `m.a = 1000`, `m.b = 0`\n\n[3. m.b 값 설정]\n- `m.b = m.a;` → `m.b = 1000`\n- 상태: `m.a = 1000`, `m.b = 1000`\n\n[4. func2(m) 호출]\n- `m.a += m.b;` → `m.a = m.a + m.b = 1000 + 1000 = 2000`\n- 참조로 전달되었으므로 원본 객체의 `m.a`가 2000으로 변경됨\n- 상태: `m.a = 2000`, `m.b = 1000`\n\n[5. 출력]\n- `System.out.printf(\"%d\", m.a);` → **2000 출력**\n\n[실행 순서 요약]\n| 단계 | 코드 | m.a | m.b |\n|------|------|-----|-----|\n| 초기화 | `A m = new A()` | 0 | 0 |\n| 1 | `m.a = 100` | 100 | 0 |\n| 2 | `func1(m)` → `m.a *= 10` | 1000 | 0 |\n| 3 | `m.b = m.a` | 1000 | 1000 |\n| 4 | `func2(m)` → `m.a += m.b` | 2000 | 1000 |\n| 5 | `printf(\"%d\", m.a)` | **2000 출력** | 1000 |\n\n[핵심 포인트]\n- `*=`: 곱셈 후 할당 (`m.a *= 10` = `m.a = m.a * 10`)\n- `+=`: 덧셈 후 할당 (`m.a += m.b` = `m.a = m.a + m.b`)\n- Java에서 **기본 타입은 값 전달**, **객체는 참조 전달**\n- 객체의 필드를 메서드에서 변경하면 원본 객체도 변경됨\n\n[답] **2000**", "table_refs": [], "image_refs": ["images/2022_round1/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [{"language": "java", "code": "class A {\n  int a;\n  int b;\n}\n  public class Main {\n  static void func1(A m){\n   m.a *= 10;\n  }\n  static void func2(A m){\n    m.a += m.b;\n  }\n  public static void main(String args[]){\n  A m = new A();\n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  System.out.printf(\"%d\", m.a);\n  }\n}", "line_numbers": [1, 20], "file": "data/codes/2022_round1/Q003_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 SQL 결과에 알맞는 쿼리을 작성하시오.\nSELECT name, score FROM 성적\n\n(1) BY ( 2 ) ( 3 )", "choices": [], "answer": {"keys": ["1) ORDER", "2) score", "3) DESC"], "raw_text": "1) ORDER 2) score 3) DESC"}, "explanation": "문제에서 제시된 SQL 결과를 보면 점수(score) 기준으로 내림차순 정렬이 필요합니다.\n\n[주어진 쿼리 패턴]\n```sql\nSELECT name, score FROM 성적\n(1) BY (2) (3)\n```\n\n[패턴 분석]\n- `(1) BY (2) (3)` 형태는 **ORDER BY 절**을 나타냅니다\n- `BY` 앞에는 `ORDER`가 오고\n- `BY` 뒤에는 정렬 기준 컬럼명과 정렬 방향이 옵니다\n\n[ORDER BY 절 구조]\n```sql\nORDER BY 컬럼명 [ASC | DESC]\n```\n- `ORDER BY`: 결과를 정렬하기 위한 SQL 절\n- `컬럼명`: 정렬 기준이 되는 컬럼\n- `ASC`: 오름차순 (Ascending, 기본값, 생략 가능)\n- `DESC`: 내림차순 (Descending, 높은 값부터 낮은 값 순서)\n\n[문제의 요구사항]\n- 주어진 결과를 보면 점수가 **높은 순서부터 낮은 순서**로 정렬되어 있음\n- 따라서 **내림차순(DESC)** 정렬 필요\n- 정렬 기준 컬럼은 **score**\n\n[빈칸 채우기]\n1. **(1)**: `ORDER` - ORDER BY 절의 시작 키워드\n2. **(2)**: `score` - 정렬 기준 컬럼명 (점수 컬럼)\n3. **(3)**: `DESC` - 내림차순 정렬 지정\n\n[완성된 쿼리]\n```sql\nSELECT name, score FROM 성적\nORDER BY score DESC\n```\n\n[실행 결과]\n- 성적 테이블에서 학생 이름과 점수를 조회\n- 점수가 높은 학생부터 낮은 학생 순서로 정렬되어 출력\n\n[ORDER BY 사용 예시]\n- `ORDER BY score ASC` 또는 `ORDER BY score`: 점수 오름차순 (낮은 점수 → 높은 점수)\n- `ORDER BY score DESC`: 점수 내림차순 (높은 점수 → 낮은 점수)\n- `ORDER BY name`: 이름 오름차순 (가나다순)\n\n[답]\n- (1) **ORDER**\n- (2) **score**\n- (3) **DESC**", "table_refs": [{"id": "table1", "json": "data/tables/2022_round1/Q004_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2022_round1/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "데이터베이스의 이상현상 중, 삭제 이상에 대해 서술하시오.", "choices": [], "answer": {"keys": ["삭제 이상"], "raw_text": "삭제 이상"}, "explanation": "이 문제는 데이터베이스의 삭제 이상(Deletion Anomaly)에 대한 문제입니다.\n\n[삭제 이상이란?]\n- 데이터를 삭제할 때 **의도치 않은 다른 데이터도 함께 삭제**되는 이상 현상\n- 정규화되지 않은 테이블에서 발생하는 문제점 중 하나\n\n[삭제 이상의 예시]\n\n예를 들어, 학생-과목 테이블에서:\n| 학번 | 이름 | 과목코드 | 과목명 |\n|------|------|----------|--------|\n| 001 | 김철수 | C101 | 데이터베이스 |\n| 001 | 김철수 | C102 | 운영체제 |\n| 002 | 이영희 | C101 | 데이터베이스 |\n\n만약 이영희가 데이터베이스 과목을 취소(삭제)하면:\n- 이영희의 행이 삭제됨\n- **문제**: C101(데이터베이스) 과목 정보도 함께 사라질 수 있음\n- 만약 C101을 듣는 학생이 이영희뿐이었다면, 과목 정보 자체가 삭제됨\n\n[해결 방법]\n- 정규화를 통해 테이블을 분리\n- 학생 테이블, 과목 테이블, 수강 테이블로 분리\n\n[다른 이상 현상]\n- **삽입 이상**: 데이터 삽입 시 불필요한 데이터도 함께 삽입해야 함\n- **갱신 이상**: 데이터 수정 시 여러 곳을 수정해야 하거나 일관성 문제 발생\n\n[답]삭제 이상**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 파이썬 코드에서 출력되는 a와 b의 값을 작성하시오.", "choices": [], "answer": {"keys": ["a= 20 b= 2"], "raw_text": "a= 20 b= 2"}, "explanation": "✅ 정답: a= 20 b= 2\n\n📌 코드 실행 과정 추적\n\n함수 정의:\n```python\ndef exam(num1, num2=2):\n```\n- num1: 필수 매개변수\n- num2: 기본값 2를 가진 선택적 매개변수\n\n함수 호출:\n```python\nexam(20)\n```\n- num1=20 (전달된 값)\n- num2=2 (기본값 사용, 전달되지 않았으므로)\n\n출력:\n```python\nprint('a=', num1, 'b=', num2)\n```\n→ a= 20 b= 2\n\n💡 핵심:\n- 기본값 매개변수: 호출 시 인자를 생략하면 기본값 사용\n- exam(20, 5) 호출 시: a= 20 b= 5\n- exam(20) 호출 시: a= 20 b= 2 (기본값)\n\n", "table_refs": [], "image_refs": ["images/2022_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [{"language": "python", "code": "def exam(num1, num2=2):\n  print('a=', num1, 'b=', num2)\nexam(20)", "line_numbers": [1, 3], "file": "data/codes/2022_round1/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 설명과 관련된 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, remove, sort 등..))\n\n1. 요소를 확장해준다는 의미를 가지고 있으며, 모든 항목을 하나의 요소로 추가\n\n2. 리스트 내부 요소를 꺼내주는 함수로써, 그 요소는 리스트 안에서 삭제하고 그 값을 반환\n\n3. 리스트 내부의 요소의 순서는 뒤집는 역할", "choices": [], "answer": {"keys": ["1) extend", "2) pop", "3) reverse"], "raw_text": "1) extend 2) pop 3) reverse"}, "explanation": "이 문제는 파이썬 **리스트 메서드**의 기능을 이해하는 문제입니다.\n\n[각 메서드의 기능]\n\n1. [`extend(iterable)`]\n- 요소를 확장해준다는 의미\n- 반복 가능한 객체(리스트, 튜플 등)의 모든 항목을 하나씩 추가\n- 예: `[1, 2].extend([3, 4])` → `[1, 2, 3, 4]`\n- `append()`와 차이: `append([3, 4])`는 `[1, 2, [3, 4]]`가 됨\n\n2. [`pop([index])`]\n- 리스트 내부 요소를 꺼내주는 함수\n- 해당 요소는 리스트에서 삭제하고 그 값을 반환\n- 인덱스를 지정하지 않으면 마지막 요소를 반환\n- 예: `[1, 2, 3].pop()` → `3` 반환, 리스트는 `[1, 2]`가 됨\n\n3. [`reverse()`]\n- 리스트 내부 요소의 순서를 뒤집는 역할\n- 원본 리스트를 직접 수정 (반환값 없음)\n- 예: `[1, 2, 3].reverse()` → 리스트가 `[3, 2, 1]`로 변경\n\n[답]\n- (1) **extend**\n- (2) **pop**\n- (3) **reverse**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["알고리즘"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 아래 단어를 영어 약자로 작성하시오.\n임시 키 무결성 프로토콜", "choices": [], "answer": {"keys": ["TKIP"], "raw_text": "TKIP"}, "explanation": "문제에서 요구하는 것은 **\"임시 키 무결성 프로토콜\"**을 영어 약자로 작성하는 것입니다.\n\n[TKIP (Temporal Key Integrity Protocol)]\n\n[영어 약자 풀이]\n- **T**emporal: 임시의, 시간에 따른\n- **K**ey: 키\n- **I**ntegrity: 무결성\n- **P**rotocol: 프로토콜\n- TKIP = Temporal Key Integrity Protocol\n\n[TKIP의 정의]\n- **임시 키 무결성 프로토콜** 또는 **시간적 키 무결성 프로토콜**\n- 무선 네트워크 보안을 위한 암호화 프로토콜\n- WEP(Wired Equivalent Privacy)의 취약점을 보완하기 위해 개발\n\n[TKIP의 특징]\n1. [임시 키(Temporal Key) 사용]\n   - 정적 키를 사용하는 WEP와 달리 **동적으로 키를 변경**\n   - 일정 시간마다 또는 패킷 단위로 키를 갱신\n   - 보안 강화\n\n2. [무결성(Integrity) 보장]\n   - 데이터가 전송 중 변조되지 않았음을 검증\n   - MIC(Message Integrity Check)를 사용하여 데이터 무결성 확인\n\n3. [WEP 호환성]\n   - 기존 WEP 하드웨어에서도 사용 가능\n   - 소프트웨어 업데이트로 적용 가능\n\n[TKIP의 용도]\n- Wi-Fi 네트워크(WLAN) 보안\n- IEEE 802.11i 표준의 일부\n- WPA(Wi-Fi Protected Access)에서 사용\n- WEP의 보안 취약점을 개선\n\n[답] **TKIP**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["네트워크"], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 중, 설명에 대한 답을 영어 약자로 작성하시오.\n키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경", "choices": [], "answer": {"keys": ["NUI"], "raw_text": "NUI"}, "explanation": "문제에서 설명하는 특징들이 모두 NUI (Natural User Interface)를 가리킵니다.\n\n[NUI (Natural User Interface, 자연적 사용자 인터페이스)]\n\n[영어 약자 풀이]\n- **N**atural: 자연스러운, 자연적인\n- **U**ser: 사용자\n- **I**nterface: 인터페이스\n- NUI = Natural User Interface\n\n[NUI의 정의]\n- 키보드나 마우스와 같은 전통적인 입력 장치 없이 컴퓨터나 장치를 제어할 수 있는 환경\n- **인간의 자연스러운 표현**을 입력 수단으로 사용하는 사용자 인터페이스\n\n[문제에서 언급한 특징]\n1. **\"키보드나 마우스와 같은 장치 없이\"**\n   - 전통적인 GUI(Graphical User Interface)와 달리 물리적 입력 장치 불필요\n   - CUI(Command User Interface), GUI( Graphical User Interface)의 다음 세대\n\n2. \"말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현\"\n   - **말(음성)**: 음성 인식 기술 사용 (예: \"안녕, 시리\")\n   - **행동**: 제스처, 터치, 몸짓 (예: 손짓으로 화면 제어, 눈동자 추적)\n   - **감정**: 표정, 생체 신호 인식 (예: 얼굴 표정 인식)\n\n[NUI의 예시]\n- **음성 인식**: 음성으로 명령 전달 (Siri, Alexa, Google Assistant)\n- **제스처 인식**: 손동작으로 화면 제어 (Kinect, 손짓 인식)\n- **터치 스크린**: 손가락 터치로 직접 조작 (스마트폰, 태블릿)\n- **생체 인식**: 얼굴, 지문, 홍채 인식으로 인증\n- **시선 추적**: 눈동자 움직임으로 화면 제어\n- **뇌파 인식**: 뇌 신호를 이용한 제어 (연구 단계)\n\n[다른 UI 유형과의 비교]\n| 유형 | 약자 | 특징 | 예시 |\n|------|------|------|------|\n| **CUI** | Command User Interface | 명령어 입력 | DOS 프롬프트, 터미널 |\n| **GUI** | Graphical User Interface | 그래픽, 마우스, 키보드 | Windows, macOS |\n| **NUI** | Natural User Interface | 자연스러운 표현 | 음성, 제스처, 터치 |\n\n[NUI의 장점]\n- 직관적이고 사용하기 쉬움\n- 학습 곡선이 낮음 (자연스러운 동작)\n- 물리적 장치 불필요 (접근성 향상)\n- 다양한 입력 방식 지원\n\n[NUI의 응용 분야]\n- 스마트 홈 (음성 제어)\n- VR/AR (손동작 제어)\n- 터치스크린 기기 (스마트폰, 태블릿)\n- 자동차 (음성 인식 내비게이션)\n- 헬스케어 (생체 신호 인식)\n\n[답] **NUI**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 분석도구에 대한 설명으로 보기에 알맞는 답을 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, running analysis 등..))\n\n1. 소스 코드의 실행 없이, 코드의 의미를 분석해 결함을 찾아내는 원시적 코드 분석 기법\n\n2. 소스 코드를 실행하여 프로그램 동작이나 반응을 추적하고 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석", "choices": [], "answer": {"keys": ["1) static", "2) dynamic"], "raw_text": "1) static 2) dynamic"}, "explanation": "이 문제는 소프트웨어 **코드 분석 도구**의 종류를 묻는 문제입니다.\n\n[정적 분석 (Static Analysis)]\n\n1. [특징]\n- 소스 코드의 실행 없이 코드의 의미를 분석\n- 코드 자체를 읽어서 결함을 찾아내는 원시적 코드 분석 기법\n- 컴파일 타임에 수행\n\n2. [장점]\n- 실행 환경이 필요 없음\n- 빠른 분석 가능\n- 모든 코드 경로 분석 가능\n\n3. [예시 도구]\n- SonarQube, ESLint, Pylint 등\n\n[동적 분석 (Dynamic Analysis)]\n\n1. [특징]\n- 소스 코드를 실행하여 프로그램 동작이나 반응을 추적\n- 실행 중에 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석\n- 런타임에 수행\n\n2. [장점]\n- 실제 실행 환경에서 문제 발견 가능\n- 성능 문제, 메모리 누수 등 실제 동작 문제 발견\n\n3. [예시 도구]\n- Valgrind, JProfiler, Chrome DevTools 등\n\n[답]\n- (1) **static**\n- (2) **dynamic**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 Java 코드 중에서 밑줄에 들어갈 알맞는 코드를 작성하시오.", "choices": [], "answer": {"keys": ["Car"], "raw_text": "Car"}, "explanation": "이 Java 코드는 **Thread 클래스의 생성자**와 **Runnable 인터페이스 구현**을 이해하는 문제입니다.\n\n[코드 분석]\n```java class Car implements Runnable{\nint a;\npublic void run(){\nsystem.out.println(\"message\")\n}\n}\npublic class Main{\npublic static void main(String args[]){\nThread t1 = new Thread(new ___());\nt1.start();\n}\n}\n```\n\n[문제 해결]\n\n1. [Thread 생성자]\n- `Thread(Runnable target)`: Runnable 인터페이스를 구현한 객체를 받음\n- `new Thread(new Car())` 형식으로 호출\n\n2. [Runnable 인터페이스]\n- `Car` 클래스가 `implements Runnable`로 구현\n- `run()` 메서드를 구현하여 스레드가 실행할 작업 정의\n\n3. [빈칸에 들어갈 코드]\n- `new Thread(new Car())` → 빈칸은 **Car**\n- `Car` 클래스의 인스턴스를 생성하여 Thread 생성자에 전달\n\n4. [실행 흐름]\n- `t1.start()` 호출 → 새 스레드 시작\n- `Car` 클래스의 `run()` 메서드 실행\n- \"message\" 출력\n\n[핵심 포인트]\n- Thread는 Runnable 인터페이스를 구현한 객체를 받아 실행합니다.\n- `start()` 메서드로 스레드를 시작하면 `run()` 메서드가 자동 실행됩니다.\n\n[답]Car**", "table_refs": [], "image_refs": ["images/2022_round1/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [{"language": "java", "code": "class Car implements Runnable{\n  int a;\n  public void run(){\n     system.out.println(\"message\")\n  }\n}\npublic class Main{\n  public static void main(String args[]){\n    Thread t1 = new Thread(new ___());\n    t1.start();\n  }\n}", "line_numbers": [1, 12], "file": "data/codes/2022_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 설명에 대한 알맞는 단어를 작성하시오.\n자바 프로그래밍 언어를 이용한 xUnit의 테스트 기법으로써 숨겨진 단위 테스트를 끌어내어 정형화시켜 단위 테스트를 쉽게 해주는 테스트용 Framework이다.", "choices": [], "answer": {"keys": ["JUnit"], "raw_text": "JUnit"}, "explanation": "✅ 정답: JUnit\n\n📌 문제 분석\n\n**JUnit (제이유닛)**\n\n정의:\n- Java 프로그래밍 언어를 이용한 xUnit의 테스트 기법\n- 단위 테스트(Unit Test) 프레임워크\n\n주요 특징:\n\n1️⃣ **단위 테스트 자동화**\n- 숨겨진 단위 테스트를 끌어내어 정형화\n- 반복적인 테스트를 자동으로 수행\n\n2️⃣ **테스트 케이스 작성**\n```java\n@Test\npublic void testMethod() {\n    assertEquals(expected, actual);\n}\n```\n\n3️⃣ **Annotation 기반**\n- @Test: 테스트 메서드\n- @Before: 테스트 전 실행\n- @After: 테스트 후 실행\n\n4️⃣ **Assertion 제공**\n- assertEquals(), assertTrue(), assertNull() 등\n\n💡 핵심:\n- Java 단위 테스트의 표준 프레임워크\n- xUnit 계열 (다른 언어: PyUnit, NUnit 등)\n- TDD(테스트 주도 개발)의 핵심 도구\n\n", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["소프트웨어공학"], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 보기 중에서 블랙박스 테스트 기법을 3가지 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄷ", "ㄹ", "ㅂ"], "raw_text": "ㄷ\nㄹ\nㅂ"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 선택하는 문제입니다.\n\n[블랙박스 테스트란?]\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n[블랙박스 테스트 기법 종류]\n\n1. [동치 분할 (Equivalence Partitioning)]\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. [경계값 분석 (Boundary Value Analysis)]\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. [원인-효과 그래프 (Cause-Effect Graphing)]\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. [오류 예측 (Error Guessing)]\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. [비교 검사 (Comparison Testing)]\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n[문제에서 요구하는 기법]\n- 보기에서 블랙박스 테스트 기법 3가지를 선택해야 합니다.\n\n[답]ㄷ, ㄹ, ㅂ** (보기에 나열된 블랙박스 테스트 기법 3개)", "table_refs": [], "image_refs": ["images/2022_round1/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 소스코드에서 입력값이 5가 들어왔을때 출력되는 값을 작성하시오.", "choices": [], "answer": {"keys": ["120"], "raw_text": "120"}, "explanation": "이 코드는 **재귀 함수를 이용한 팩토리얼 계산** 문제입니다.\n\n[주어진 코드]\n```c\n#include <stdio.h>\nint func(int a) {\n    if (a <= 1) return 1;\n    return a * func(a - 1);\n}\nint main() {\n    int a;\n    scanf(\"%d\", &a);\n    printf(\"%d\", func(a));\n}\n```\n\n[팩토리얼(Factorial) 정의]\n- n! = n × (n-1) × (n-2) × ... × 2 × 1\n- 예: 5! = 5 × 4 × 3 × 2 × 1 = 120\n- 0! = 1! = 1 (특수 케이스)\n\n[재귀 함수 동작 원리]\n- **기저 조건(Base Case)**: `if (a <= 1) return 1` - 재귀 종료 조건\n- **재귀 호출**: `return a * func(a - 1)` - 자기 자신을 호출하여 작은 문제로 분해\n\n[입력값이 5일 때 실행 과정]\n\n[호출 스택 (Call Stack)]\n```\nfunc(5)\n  └─ func(4)\n      └─ func(3)\n          └─ func(2)\n              └─ func(1) ← 기저 조건 도달\n```\n\n[단계별 추적]\n\n1. [func(5) 호출]\n   - `5 <= 1`? 아니오\n   - `return 5 * func(4)` 실행 (func(4) 결과 기다림)\n\n2. [func(4) 호출]\n   - `4 <= 1`? 아니오\n   - `return 4 * func(3)` 실행 (func(3) 결과 기다림)\n\n3. [func(3) 호출]\n   - `3 <= 1`? 아니오\n   - `return 3 * func(2)` 실행 (func(2) 결과 기다림)\n\n4. [func(2) 호출]\n   - `2 <= 1`? 아니오\n   - `return 2 * func(1)` 실행 (func(1) 결과 기다림)\n\n5. [func(1) 호출]\n   - `1 <= 1`? **예** → `return 1` (기저 조건, 재귀 종료)\n\n[값 반환 과정 (Unwinding)]\n```\nfunc(1) = 1                                    ← 반환\nfunc(2) = 2 * func(1) = 2 * 1 = 2            ← 반환\nfunc(3) = 3 * func(2) = 3 * 2 = 6            ← 반환\nfunc(4) = 4 * func(3) = 4 * 6 = 24           ← 반환\nfunc(5) = 5 * func(4) = 5 * 24 = 120         ← 최종 반환\n```\n\n[실행 순서 요약 표]\n| 단계 | 호출 | 조건 확인 | 반환값 | 계산식 |\n|------|------|-----------|--------|--------|\n| 5 | func(5) | 5 <= 1? 아니오 | - | 5 * func(4) 대기 |\n| 4 | func(4) | 4 <= 1? 아니오 | - | 4 * func(3) 대기 |\n| 3 | func(3) | 3 <= 1? 아니오 | - | 3 * func(2) 대기 |\n| 2 | func(2) | 2 <= 1? 아니오 | - | 2 * func(1) 대기 |\n| 1 | func(1) | 1 <= 1? **예** | **1** | 기저 조건 |\n| 2 | func(2) | - | **2** | 2 * 1 = 2 |\n| 3 | func(3) | - | **6** | 3 * 2 = 6 |\n| 4 | func(4) | - | **24** | 4 * 6 = 24 |\n| 5 | func(5) | - | **120** | 5 * 24 = 120 |\n\n[최종 출력] `printf(\"%d\", 120)` → **120**\n\n[재귀 함수의 특징]\n- 분할 정복(Divide and Conquer): 큰 문제를 작은 문제로 나눔\n- **기저 조건**: 재귀 종료 조건이 반드시 필요 (없으면 무한 루프)\n- **호출 스택**: 함수 호출이 스택에 쌓임 (후입선출, LIFO)\n- **메모리 사용**: 호출이 깊을수록 스택 메모리 많이 사용\n\n[답] **120**", "table_refs": [], "image_refs": ["images/2022_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint func(int a) {\n  if (a <= 1) return 1;\n  return a * func(a - 1);\n}\nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  printf(\"%d\", func(a));\n}", "line_numbers": [1, 10], "file": "data/codes/2022_round1/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 중, 괄호 ( ) 안에 들어갈 연산자를 써서 정수를 역순으로 출력하는 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1) >", "2) %", "3) /"], "raw_text": "1) >\n2) %\n3) /"}, "explanation": "이 C언어 코드는 **정수를 역순으로 출력**하는 문제입니다.\n\n[코드 분석]\n\n```c int number = 1234;\nint div = 10;\nint result = 0;\nwhile (number (1) 0) {\nresult = result * div;\nresult = result + number (2) div;\nnumber = number (3) div;\n}\n```\n\n[목표]\n- 입력: 1234\n- 출력: 4321\n\n[빈칸 분석]\n\n1. [`while (number (1) 0)`]\n- 반복 조건: `number`가 0보다 큰 동안 반복\n- `(1)` = **>** (크다)\n\n2. [`number (2) div`]\n- 마지막 자릿수를 구하기 위해 나머지 연산 필요\n- `number % div` = 일의 자리 숫자\n- `(2)` = **%** (나머지)\n\n3. [`number = number (3) div`]\n- 마지막 자릿수를 제거하기 위해 나누기 연산 필요\n- `number / div` = 마지막 자릿수 제거\n- `(3)` = **/** (나누기)\n\n[실행 과정 (number = 1234)]\n\n| 반복 | number | result | 설명 |\n|------|--------|--------|------|\n| 초기 | 1234 | 0 | - |\n| 1 | 123 | 4 | result = 0*10 + 1234%10 = 4, number = 1234/10 = 123 |\n| 2 | 12 | 43 | result = 4*10 + 123%10 = 43, number = 123/10 = 12 |\n| 3 | 1 | 432 | result = 43*10 + 12%10 = 432, number = 12/10 = 1 |\n| 4 | 0 | 4321 | result = 432*10 + 1%10 = 4321, number = 1/10 = 0 |\n\n[최종 출력]4321[답]\n- (1) **>**\n- (2) **%**\n- (3) **/**", "table_refs": [], "image_refs": ["images/2022_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n  int number = 1234;\n  int div = 10;\n  int result = 0;\n  while (number ( 1 ) 0) {\n    result = result * div;\n    result = result + number ( 2 ) div;\n    number = number ( 3 ) div;\n  }\n  printf(\"%d\", result);return 0;\n}", "line_numbers": [1, 12], "file": "data/codes/2022_round1/Q015_code.txt"}], "primary_category": "기타", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 설명에 대한 답을 영어 약자로 작성하시오.\n정보보호 관리체계의 영문 약자", "choices": [], "answer": {"keys": ["ISMS (Information Security Management System)"], "raw_text": "ISMS (Information Security Management System)"}, "explanation": "문제에서 요구하는 것은 **\"정보보호 관리체계\"**의 영문 약자입니다.\n\n[ISMS (Information Security Management System)]\n\n[영어 약자 풀이]\n- **I**nformation: 정보\n- **S**ecurity: 보안, 보호\n- **M**anagement: 관리\n- **S**ystem: 체계, 시스템\n- ISMS = Information Security Management System\n\n[ISMS의 정의]\n- **정보보호 관리체계** 또는 **정보보안 관리체계**\n- 조직의 정보자산을 체계적으로 보호하기 위한 관리 시스템\n- 정보보안 위험을 관리하고 통제하기 위한 일련의 정책, 절차, 프로세스\n\n[ISMS의 주요 요소]\n1. **정보자산 관리**: 정보자산 식별, 분류, 보호\n2. **보안 정책**: 조직의 보안 목표와 방침 수립\n3. **위험 관리**: 보안 위협 식별, 평가, 대응\n4. **통제 체계**: 기술적/물리적/관리적 보안 통제\n5. **지속적 개선**: PDCA 사이클을 통한 관리체계 개선\n\n[ISMS 인증]\n- **인증 기관**: 한국인터넷진흥원(KISA, Korea Internet & Security Agency)\n- **인증 기준**: ISO/IEC 27001 국제표준 기반\n- **인증 범위**: 조직 전체 또는 특정 부서/시스템\n- **인증 유효기간**: 3년 (재인증 필요)\n\n[ISMS의 목적]\n- 정보자산의 기밀성, 무결성, 가용성 보장\n- 정보보안 위험을 사전에 예방 및 차단\n- 법규 및 규정 준수\n- 조직의 신뢰성 및 경쟁력 향상\n\n[ISMS와 관련 개념]\n- **ISO/IEC 27001**: ISMS를 위한 국제 표준\n- PIMS (Personal Information Management System): 개인정보보호 관리체계\n- **ISO/IEC 27002**: 정보보안 통제를 위한 실무 지침\n\n[답] ISMS (Information Security Management System)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 설명 중, 괄호 ( ) 안에 들어가는 알맞는 답을 보기에서 선택하여 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, 참조성, 무결성 등..))\n\n1. 슈퍼키는\n\n(1) 의 속성을 갖는다.", "choices": [], "answer": {"keys": ["1) 유일성", "2) 최소성"], "raw_text": "1) 유일성 2) 최소성"}, "explanation": "이 문제는 데이터베이스 **키(Key)**의 속성에 관한 문제입니다.\n\n[슈퍼키(Super Key)의 속성]\n\n[슈퍼키(Super Key)란?]\n- 테이블에서 **튜플을 유일하게 식별**할 수 있는 하나 이상의 속성(컬럼) 조합\n- 테이블의 모든 행을 고유하게 구분할 수 있는 속성 집합\n\n[슈퍼키의 핵심 속성]\n\n1. [유일성(Uniqueness)]\n   - 슈퍼키의 가장 중요한 속성\n   - 슈퍼키 값이 **중복되지 않음**을 보장\n   - 테이블의 각 행을 **유일하게 식별**할 수 있어야 함\n   - 예: 학생 테이블에서 `학번`은 슈퍼키 (각 학생마다 고유한 학번)\n   - 예: `학번 + 이름`도 슈퍼키 (유일성 만족)\n   - 예: `학번 + 이름 + 주소`도 슈퍼키 (유일성 만족)\n\n2. [최소성(Minimality) - 슈퍼키는 갖지 않음]\n   - 슈퍼키는 **최소성을 보장하지 않음**\n   - 더 작은 속성 집합으로도 유일성을 만족할 수 있음\n   - 예: `학번 + 이름`은 슈퍼키지만, `학번`만으로도 유일성을 만족하므로 최소성 없음\n\n[주의사항]\n- 문제에서 \"슈퍼키는 (1) 의 속성을 갖는다\"라고 되어 있으나, 정답이 \"1) 유일성, 2) 최소성\"인 것은 문제가 \"후보키\"를 묻는 문제이거나, 혹은 슈퍼키의 정의에 오류가 있을 수 있습니다.\n\n[슈퍼키 vs 후보키 vs 기본키]\n\n| 키 유형 | 유일성 | 최소성 | 설명 |\n|---------|--------|--------|------|\n| **슈퍼키** | ✓ | ✗ | 튜플을 유일하게 식별 (최소성 불필요) |\n| **후보키** | ✓ | ✓ | 슈퍼키 중 최소성을 만족하는 키 |\n| **기본키** | ✓ | ✓ | 후보키 중 하나를 선택한 키 |\n\n[예시]\n- 학생 테이블: `학번`, `주민등록번호`\n  - 슈퍼키: `{학번}`, `{주민등록번호}`, `{학번, 이름}`, `{학번, 이름, 주소}` 등\n  - 후보키: `{학번}`, `{주민등록번호}` (최소성을 만족하는 슈퍼키)\n  - 기본키: `{학번}` (후보키 중 하나 선택)\n\n[답]\n- 문제의 의도에 따라 \"1) 유일성\" 또는 \"1) 유일성, 2) 최소성\"이 될 수 있습니다.\n- 일반적으로 **슈퍼키는 유일성만** 갖고, **후보키는 유일성과 최소성을 모두** 갖습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "후보키는\n\n(1) 와/과 ( 2 ) 의 속성을 갖는다.", "choices": [], "answer": {"keys": ["1) 유일성", "2) 최소성"], "raw_text": "1) 유일성 2) 최소성"}, "explanation": "이 문제는 데이터베이스 후보키(Candidate Key)의 속성에 관한 문제입니다.\n\n[후보키(Candidate Key)란?]\n- 테이블에서 **튜플을 유일하게 식별**할 수 있는 **최소한의 속성(컬럼) 조합**\n- 슈퍼키 중에서 **최소성을 만족하는 것**\n- 기본키(Primary Key)가 될 수 있는 후보\n\n[후보키의 두 가지 핵심 속성]\n\n[1. 유일성(Uniqueness)]\n- 후보키 값이 **중복되지 않음**을 보장\n- 테이블의 각 행을 **유일하게 식별**할 수 있어야 함\n- 모든 튜플에 대해 후보키 값이 고유해야 함\n- 예: 학생 테이블에서 `학번`은 후보키 (각 학생마다 고유한 학번)\n- 예: `주민등록번호`도 후보키 (각 학생마다 고유한 주민등록번호)\n\n[2. 최소성(Minimality)]\n- 후보키를 구성하는 속성 중 하나라도 제거하면 유일성을 만족하지 못함\n- 불필요한 속성이 포함되지 않은 최소한의 속성 집합\n- 예: `{학번, 이름}`은 슈퍼키이지만 후보키는 아님 (학번만으로도 유일성 만족하므로 최소성 위배)\n- 예: `학번`만으로 유일성을 만족하면 `{학번}`이 후보키\n\n[후보키의 특징]\n- 한 테이블에 여러 후보키가 존재할 수 있음\n- 후보키 중 하나를 선택하여 기본키로 지정\n- 나머지 후보키는 대체키(Alternate Key)가 됨\n\n[후보키 vs 슈퍼키 vs 기본키]\n\n| 키 유형 | 유일성 | 최소성 | 설명 |\n|---------|--------|--------|------|\n| **슈퍼키** | ✓ | ✗ | 튜플을 유일하게 식별 (최소성 불필요) |\n| **후보키** | ✓ | ✓ | 슈퍼키 중 최소성을 만족하는 키 |\n| **기본키** | ✓ | ✓ | 후보키 중 하나를 선택한 키 |\n\n[예시]\n학생 테이블: `학번`, `주민등록번호`, `이름`, `전공`\n- 슈퍼키: `{학번}`, `{주민등록번호}`, `{학번, 이름}`, `{학번, 이름, 전공}` 등\n- 후보키: `{학번}`, `{주민등록번호}` (유일성과 최소성을 모두 만족)\n- 기본키: `{학번}` (후보키 중 하나 선택)\n- 대체키: `{주민등록번호}` (기본키로 선택되지 않은 후보키)\n\n[답]\n- (1) **유일성**: 후보키 값이 중복되지 않음\n- (2) **최소성**: 불필요한 속성이 포함되지 않은 최소 집합", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음 설명과 관련된 답을 보기에 찾아서 작서하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Pharming, Ransomware등..))\n이 공격은 APT 공격에서 주로 쓰이는 공격으로, 공격 대상이 방문할 가능성이 있는 합법적인 웹 사이트를 미리 감염시킨 뒤, 잠복하고 있다가 공격 대상이 방문하면 대상의 컴퓨터에 악성코드를 설치하는 방식", "choices": [], "answer": {"keys": ["watering hole (워터링홀)"], "raw_text": "watering hole (워터링홀)"}, "explanation": "이 문제는 워터링홀(Watering Hole) 공격에 대한 이해를 묻는 문제입니다.\n\n[워터링홀 공격(Watering Hole Attack)이란?]\n- APT(Advanced Persistent Threat) 공격에서 주로 사용되는 공격 기법\n- 공격 대상이 방문할 가능성이 있는 **합법적인 웹 사이트를 미리 감염**시킨 뒤\n- **잠복하고 있다가** 공격 대상이 방문하면 대상의 컴퓨터에 **악성코드를 설치**하는 방식\n\n[워터링홀의 의미]\n- 이름의 유래: 사자나 표범이 물 웅덩이(watering hole) 근처에서 사냥감을 기다리는 것에서 비유\n- 합법적인 사이트를 \"물 웅덩이\"로, 공격 대상을 \"사냥감\"으로 비유\n\n[워터링홀 공격의 공격 과정]\n\n1. [타겟 조사]\n- 공격 대상이 자주 방문하는 합법적인 웹사이트를 조사\n- 예: 특정 업계의 뉴스 사이트, 협회 사이트, 전문 포럼 등\n\n2. [웹사이트 감염]\n- 선택한 웹사이트를 악성코드로 감염시킴\n- 웹사이트의 취약점을 악용하여 악성 스크립트 삽입\n- 또는 웹사이트 관리자 계정을 탈취하여 악성 코드 삽입\n\n3. [잠복]\n- 공격 대상이 해당 웹사이트를 방문할 때까지 **대기**\n- 일반 사용자에게는 영향 없이 특정 타겟만 감염되도록 설계\n\n4. [드라이브바이 다운로드 (Drive-by Download)]\n- 공격 대상이 감염된 웹사이트를 방문하면\n- 브라우저 취약점을 악용하여 **자동으로 악성코드 다운로드 및 설치**\n- 사용자의 동의나 클릭 없이 백그라운드에서 실행\n\n[워터링홀 공격의 특징]\n- **간접 공격**: 합법적인 사이트를 경유하여 공격 (직접 공격이 아닌 간접 공격)\n- **타겟팅**: 특정 그룹이나 조직을 대상으로 한 맞춤형 공격\n- **은밀성**: 피해자가 자신이 공격받고 있다는 것을 인지하기 어려움\n- **APT와 연계**: 장기간 지속되는 APT 공격의 초기 침투 단계로 사용\n\n[다른 공격 기법과의 차이]\n\n| 공격 기법 | 공격 방식 | 특징 |\n|----------|----------|------|\n| **피싱(Phishing)** | 이메일, 메시지로 직접 공격 | 직접적인 유도\n| **워터링홀(Watering Hole)** | 합법적 사이트를 경유한 간접 공격 | 간접적인 유도\n| **파밍(Pharming)** | DNS 조작으로 사이트 주소 변조 | 주소 변조\n| **랜섬웨어(Ransomware)** | 데이터 암호화 후 금전 요구 | 데이터 암호화\n\n[방어 방법]\n- 웹사이트 보안 강화 (XSS, SQL Injection 등 취약점 제거)\n- 브라우저 및 플러그인 최신 버전 유지\n- 웹 필터링 및 보안 솔루션 사용\n- 의심스러운 웹사이트 방문 주의\n\n[답] **watering hole (워터링홀)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h> \nint isPrime(int number) { \n  int i; \n  for (i=2; i<number; i++) { \n    if (number % i == 0) return 0; \n  } \n  return 1; \n} \nint main(void) { \n  int number = 13195, max_div=0, i; \n  for (i=2; i<number; i++) \n  if (isPrime(i) == 1 && number % i == 0) max_div = i; \n  printf(\"%d\", max_div); \n  return 0; \n}", "line_numbers": [1, 15], "file": "data/codes/2022_round1/Q018_code.txt"}], "primary_category": "정보보안", "secondary_categories": ["프로그래밍"], "tags": ["c", "해킹"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 소스코드가 실행할 때의 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1) 단위 테스트", "2) 통합 테스트", "3) 시스템 테스트"], "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"}, "explanation": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 나열하는 문제입니다.\n\n[V모델(V-Model)이란?]\n- 소프트웨어 개발 생명주기 모델 중 하나\n- **개발 단계**와 **테스트 단계**가 대칭적으로 연결된 V자 형태의 모델\n- 왼쪽 다리는 개발 단계, 오른쪽 다리는 테스트 단계\n\n[V모델의 테스트 단계 (오른쪽 다리, 아래에서 위로)]\n\n1. [단위 테스트 (Unit Test)]\n   - **목적**: 개별 모듈(함수, 클래스)의 기능을 검증\n   - **시점**: 코딩 단계 완료 후\n   - **담당**: 개발자\n   - **대상**: 개별 컴포넌트나 함수\n   - **예시**: 함수의 입력/출력 검증, 로직 오류 확인\n   - **대응하는 개발 단계**: 코딩 단계\n\n2. [통합 테스트 (Integration Test)]\n   - **목적**: 여러 모듈을 결합하여 인터페이스와 상호작용을 검증\n   - **시점**: 단위 테스트 완료 후\n   - **담당**: 개발자 또는 테스터\n   - **대상**: 모듈 간의 인터페이스, 데이터 전달\n   - **예시**: API 통합, 데이터베이스 연동 테스트\n   - **대응하는 개발 단계**: 설계 단계\n\n3. [시스템 테스트 (System Test)]\n   - **목적**: 전체 시스템이 요구사항을 만족하는지 검증\n   - **시점**: 통합 테스트 완료 후\n   - **담당**: 테스터 또는 QA 팀\n   - **대상**: 완성된 전체 시스템\n   - **예시**: 성능 테스트, 보안 테스트, 사용성 테스트\n   - **대응하는 개발 단계**: 요구사항 분석 단계\n\n4. [인수 테스트 (Acceptance Test)]\n   - **목적**: 사용자 요구사항을 만족하는지 최종 검증\n   - **시점**: 시스템 테스트 완료 후\n   - **담당**: 사용자 또는 고객\n   - **대상**: 전체 시스템 (사용자 관점)\n   - **예시**: 알파 테스트, 베타 테스트, 사용자 인수 테스트\n   - **대응하는 개발 단계**: 요구사항 정의 단계\n\n[V모델 구조]\n```\n요구사항 분석 ←→ 인수 테스트\n    ↓              ↑\n시스템 설계 ←→ 시스템 테스트\n    ↓              ↑\n상세 설계 ←→ 통합 테스트\n    ↓              ↑\n   코딩 ←→ 단위 테스트\n```\n\n[답]\n- 1) **단위 테스트**\n- 2) **통합 테스트**\n- 3) **시스템 테스트**\n- (4) **인수 테스트** (문제에서 요구하는 범위에 따라 포함 여부 결정)", "table_refs": [], "image_refs": ["images/2022_round1/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 V모델에서의 테스트 단계에 대한 설명으로 괄호 안에 들어갈 답을 작성하시오.", "choices": [], "answer": {"keys": ["1) 단위 테스트", "2) 통합 테스트", "3) 시스템 테스트"], "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"}, "explanation": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 작성하는 문제입니다.\n\n[V모델(V-Model)의 구조]\n- 소프트웨어 개발 생명주기 모델\n- **개발 단계(왼쪽 다리)**와 **테스트 단계(오른쪽 다리)**가 V자 형태로 대칭\n- 각 개발 단계마다 대응하는 테스트 단계가 존재\n\n[V모델의 테스트 단계 (아래에서 위로 순서)]\n\n[1. 단위 테스트 (Unit Testing)]\n- **정의**: 개별 모듈, 함수, 클래스의 기능을 검증하는 테스트\n- **시점**: 코딩 단계가 완료된 후\n- **담당자**: 개발자\n- **목적**: 코드의 논리적 오류, 알고리즘 오류 발견\n- **대응 개발 단계**: 코딩 단계\n- **예시**: 함수의 반환값 검증, 변수 상태 확인\n\n[2. 통합 테스트 (Integration Testing)]\n- **정의**: 여러 모듈을 결합하여 인터페이스와 상호작용을 검증하는 테스트\n- **시점**: 단위 테스트 완료 후\n- **담당자**: 개발자 또는 통합 테스터\n- **목적**: 모듈 간 인터페이스 오류, 데이터 전달 오류 발견\n- **대응 개발 단계**: 설계 단계 (상세 설계, 시스템 설계)\n- **예시**: API 호출 테스트, 데이터베이스 연동 테스트\n\n[3. 시스템 테스트 (System Testing)]\n- **정의**: 완성된 전체 시스템이 요구사항을 만족하는지 검증하는 테스트\n- **시점**: 통합 테스트 완료 후\n- **담당자**: QA 팀 또는 전문 테스터\n- **목적**: 요구사항 충족 여부, 성능, 보안, 사용성 검증\n- **대응 개발 단계**: 요구사항 분석 단계\n- **예시**: 성능 테스트, 보안 테스트, 부하 테스트, 회귀 테스트\n\n[4. 인수 테스트 (Acceptance Testing)]\n- **정의**: 사용자 또는 고객이 시스템을 실제 사용 환경에서 검증하는 테스트\n- **시점**: 시스템 테스트 완료 후\n- **담당자**: 사용자 또는 고객\n- **목적**: 사용자 요구사항 만족 여부 최종 확인\n- **대응 개발 단계**: 요구사항 정의 단계\n- **예시**: 알파 테스트, 베타 테스트, 사용자 인수 테스트(UAT)\n\n[V모델 전체 구조]\n```\n        요구사항 정의 ←→ 인수 테스트\n              ↓              ↑\n        요구사항 분석 ←→ 시스템 테스트\n              ↓              ↑\n          시스템 설계 ←→ 통합 테스트\n              ↓              ↑\n          상세 설계 ←→ 단위 테스트\n              ↓              ↑\n            코딩\n```\n\n[테스트 단계의 특징]\n- **점진적 확대**: 단위(작은 범위) → 통합(중간 범위) → 시스템(큰 범위) → 인수(최종 검증)\n- **오류 발견 단계**: 단위 테스트에서는 코드 오류, 시스템 테스트에서는 요구사항 오류 발견\n- **비용**: 발견 시점이 늦을수록 수정 비용 증가 (V모델의 위로 올라갈수록 비용 증가)\n\n[답]\n- (1) **단위 테스트**\n- (2) **통합 테스트**\n- (3) **시스템 테스트**", "table_refs": [], "image_refs": ["images/2022_round1/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
