{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["RARP (Reverse Address Resolution Protocol)"], "raw_text": "RARP (Reverse Address Resolution Protocol)"}, "explanation": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n[RARP의 특징]\n\n1. [역방향 변환]\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. [사용 목적]\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. [동작 방식]\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n[답] RARP (Reverse Address Resolution Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 DB 설계 절차에 관한 설명이다.\n다음 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- (1)은/는 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.\n\n- (2)은/는 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다.\n\n- (3)은/는 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.\n\n[보기]\n\n: 구현 / 개념적 설계 / 논리적 설계 / 요구사항 분석 / 물리적 설계", "choices": [], "answer": {"keys": ["1. 물리적 설계", "2. 개념적 설계", "3. 논리적 설계"], "raw_text": "1. 물리적 설계 2. 개념적 설계 3. 논리적 설계"}, "explanation": "이 문제는 **데이터베이스 설계 절차**를 이해하는 문제입니다.\n\n[데이터베이스 설계 절차]\n\n1. [요구사항 분석]\n- 사용자 요구사항을 파악하고 분석\n- 시스템이 처리해야 할 데이터와 기능 정의\n\n2. [개념적 설계]\n- 현실 세계에 대한 인식을 추상적, 개념적으로 표현\n- 개념적 구조를 도출하는 과정\n- 주요 산출물: E-R 다이어그램\n- 엔티티와 속성, 관계를 정의\n\n3. [논리적 설계]\n- 목표 DBMS에 맞는 스키마 설계\n- 트랜잭션 인터페이스 설계\n- 정규화 과정 수행\n- 관계형 데이터 모델로 변환\n\n4. [물리적 설계]\n- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환\n- 인덱스 설계, 저장 공간 할당\n- 결과 산출물: 테이블 정의서 등\n\n5. [구현]\n- 실제 데이터베이스 생성 및 응용 프로그램 개발\n\n[문제에서 요구하는 답]\n- (1) 물리적 설계: 테이블 정의서 등 명세서 생성\n- (2) 개념적 설계: E-R 다이어그램 등 개념적 구조 도출\n- (3) 논리적 설계: 정규화 과정 수행\n\n[답] 1. 물리적 설계, 2. 개념적 설계, 3. 논리적 설계", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 요구사항의 분류에 대한 설명이다.\n괄호 (   ) 안에 들어갈 요구사항의 유형에 대해서 쓰시오.\n\n- (1) 요구사항은 시스템이 제공하는 기능, 서비스에 대한 요구사항이다.\n\n- (2) 요구사항은 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항이다.", "choices": [], "answer": {"keys": ["1. 기능적", "2. 비기능적"], "raw_text": "1. 기능적 2. 비기능적"}, "explanation": "이 문제는 **요구사항의 분류**에 대한 이해를 묻는 문제입니다.\n\n[요구사항이란?]\n시스템 개발 분야에서 어떤 과제를 수행하기 위해 필요한 조건이나 능력을 말합니다. 요구사항은 시스템이 무엇을 해야 하는지를 정의합니다.\n\n[요구사항의 두 가지 주요 유형]\n\n[1. 기능적 요구사항 (Functional Requirements)]\n- **정의**: 시스템이 **제공해야 하는 기능, 서비스**에 대한 요구사항\n- **특징**:\n  - 시스템이 \"무엇을\" 해야 하는지 명시\n  - 시스템의 입력, 처리, 출력에 대한 명세\n  - 사용자가 시스템을 통해 수행할 수 있는 기능들\n- **예시**:\n  - \"사용자는 로그인할 수 있어야 한다\"\n  - \"시스템은 주문을 처리할 수 있어야 한다\"\n  - \"게시판에 글을 작성, 수정, 삭제할 수 있어야 한다\"\n- **분류**: 사용자 요구사항, 시스템 요구사항\n\n[2. 비기능적 요구사항 (Non-Functional Requirements)]\n- **정의**: 시스템이 수행하는 **기능 이외의 사항**, 즉 **시스템 구축에 대한 제약사항**에 관한 요구사항\n- **특징**:\n  - 시스템이 \"어떻게\" 작동해야 하는지에 대한 품질 특성\n  - 성능, 보안, 신뢰성, 사용성 등의 측면\n  - 기능적 요구사항의 제약 조건\n- **예시**:\n  - 성능: \"응답 시간은 3초 이내여야 한다\"\n  - 보안: \"데이터는 암호화되어 저장되어야 한다\"\n  - 신뢰성: \"시스템 가동률은 99.9% 이상이어야 한다\"\n  - 사용성: \"초보자도 쉽게 사용할 수 있어야 한다\"\n- **분류**: 제품 요구사항, 조직 요구사항, 외부 요구사항\n\n[비교 요약]\n| 구분 | 기능적 요구사항 | 비기능적 요구사항 |\n|------|----------------|------------------|\n| **관점** | 무엇을 (What) | 어떻게 (How) |\n| **내용** | 기능, 서비스 | 제약사항, 품질 |\n| **예시** | 로그인 기능 | 응답 시간, 보안 |\n\n[문제에서 요구하는 답]\n- (1) **기능적**: 시스템이 제공하는 기능, 서비스에 대한 요구사항\n- (2) **비기능적**: 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항\n\n[답] 1. 기능적, 2. 비기능적", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구성된 언어를 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["WSDL"], "raw_text": "WSDL"}, "explanation": "WSDL(Web Services Description Language의 약자)은 웹 서비스 기술언어 또는 기술된 정의 파일의 총칭으로 XML로 기술됩니다. 웹 서비스의 구체적 내용이 기술되어 있으며 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술됩니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 파이썬 코드이다.\n출력 결과를 쓰시오.", "choices": [], "answer": {"keys": ["skiddp"], "raw_text": "skiddp"}, "explanation": "이 파이썬 코드는 문자열 리스트의 각 요소에서 첫 번째 문자를 추출하는 문제입니다.\n\n[코드 분석]\n```python class good :\nli = [\"seoul\", \"kyeonggi\", \"inchon\", \"daejeon\", \"daegu\", \"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\nstr01 = str01 + i[0]\nprint(str01)\n```\n\n[실행 과정]\n\n1. [클래스 정의 및 인스턴스 생성]\n- `good` 클래스의 클래스 변수 `li`에 도시명 리스트 저장\n- `g = good()`로 인스턴스 생성\n\n2. [반복문 실행]\n- `for i in g.li`: 리스트의 각 요소를 순회\n- 각 도시명 문자열에서 첫 번째 문자(`i[0]`) 추출\n\n3. [문자 추출 과정]\n- `i = \"seoul\"` → `i[0] = 's'` → `str01 = 's'`\n- `i = \"kyeonggi\"` → `i[0] = 'k'` → `str01 = 'sk'`\n- `i = \"inchon\"` → `i[0] = 'i'` → `str01 = 'ski'`\n- `i = \"daejeon\"` → `i[0] = 'd'` → `str01 = 'skid'`\n- `i = \"daegu\"` → `i[0] = 'd'` → `str01 = 'skidd'`\n- `i = \"pusan\"` → `i[0] = 'p'` → `str01 = 'skiddp'`\n\n[최종 출력] `skiddp`\n\n[핵심 포인트]\n- 문자열 인덱싱: `문자열[0]`은 첫 번째 문자를 반환합니다.\n- 문자열 연결: `str01 = str01 + i[0]`는 기존 문자열에 새 문자를 추가합니다.\n\n[답]skiddp**", "table_refs": [], "image_refs": ["images/2021_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [{"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}, {"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 SQL 실행 결과를 숫자만 쓰시오.\nSELECT COUNT(*) FROM 급여 WHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "[SQL 쿼리 실행 결과 분석]\n\n[주어진 쿼리]\n```sql\nSELECT COUNT(*) FROM 급여 \nWHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;\n```\n\n[연산자 우선순위 적용]\n- `AND`가 `OR`보다 우선순위가 높음\n- 실제 조건: `(EMPNO > 100 AND SAL >= 3000) OR EMPNO = 200`\n\n[급여 테이블 데이터 (문제 이미지 참고)]\n| EMPNO | SAL |\n|-------|-----|\n| 100   | 1000|\n| 200   | 3000|\n| 300   | 1500|\n\n[각 행별 조건 평가]\n\n[행1 (EMPNO=100, SAL=1000)]\n- 조건: `(100 > 100 AND 1000 >= 3000) OR 100 = 200`\n- 계산: `(FALSE AND FALSE) OR FALSE` = `FALSE OR FALSE` = **FALSE**\n- 결과: 카운트 제외\n\n[행2 (EMPNO=200, SAL=3000)]\n- 조건: `(200 > 100 AND 3000 >= 3000) OR 200 = 200`\n- 계산: `(TRUE AND TRUE) OR TRUE` = `TRUE OR TRUE` = **TRUE**\n- 결과: 카운트 포함 ✓\n\n[행3 (EMPNO=300, SAL=1500)]\n- 조건: `(300 > 100 AND 1500 >= 3000) OR 300 = 200`\n- 계산: `(TRUE AND FALSE) OR FALSE` = `FALSE OR FALSE` = **FALSE**\n- 결과: 카운트 제외\n\n[최종 결과]\n- 조건을 만족하는 행은 **EMPNO=200인 행 1개**\n- **답: 1**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q006_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2021_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 Java 프로그램 결과를 쓰시오.", "choices": [], "answer": {"keys": ["3 1 45 50 89"], "raw_text": "3 1 45 50 89"}, "explanation": "이 Java 코드는 **2차원 배열의 구조와 접근 방법**을 이해하는 문제입니다.\n\n[코드 분석]\n```java int[][]arr = new int[][]{{45,50,75},{89}};\nSystem.out.println(arr[0].length); // 첫 번째 행의 길이 System.out.println(arr[1].length); // 두 번째 행의 길이 System.out.println(arr[0][0]); // 첫 번째 행, 첫 번째 요소 System.out.println(arr[0][1]); // 첫 번째 행, 두 번째 요소 System.out.println(arr[1][0]); // 두 번째 행, 첫 번째 요소\n```\n\n[2차원 배열 구조]\n- `arr[0] = {45, 50, 75}` → 길이 3\n- `arr[1] = {89}` → 길이 1\n\n[실행 순서]\n\n1. `arr[0].length`: 첫 번째 행의 길이 → **3**\n2. `arr[1].length`: 두 번째 행의 길이 → **1**\n3. `arr[0][0]`: 첫 번째 행의 첫 번째 요소 → **45**\n4. `arr[0][1]`: 첫 번째 행의 두 번째 요소 → **50**\n5. `arr[1][0]`: 두 번째 행의 첫 번째 요소 → 89[출력] `3 1 45 50 89`\n\n[핵심 포인트]\n- Java에서 2차원 배열은 행마다 길이가 다를 수 있습니다(가변 배열).\n- `arr[i].length`는 i번째 행의 길이를 반환합니다.\n- `arr[i][j]`는 i번째 행의 j번째 요소에 접근합니다.\n\n[답]3 1 45 50 89", "table_refs": [], "image_refs": ["images/2021_round1/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [{"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}, {"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["비정규화 (반정규화/역정규화)"], "raw_text": "비정규화 (반정규화/역정규화)"}, "explanation": "이 문제는 **비정규화(반정규화/역정규화)**에 대한 문제입니다.\n\n[비정규화란?]\n- 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법\n- 정규화의 반대 개념으로, 성능을 위해 의도적으로 정규화 원칙을 완화\n\n[비정규화 방법]\n\n1. [테이블 통합]\n- 관련된 여러 테이블을 하나로 통합\n- 조인 연산 감소로 성능 향상\n\n2. [테이블 분할]\n- 하나의 테이블을 여러 테이블로 분할\n- 수직 분할: 컬럼 단위 분할\n- 수평 분할: 행 단위 분할\n\n3. [중복 테이블 추가]\n- 조회 성능 향상을 위해 중복 테이블 생성\n- 집계 테이블, 통계 테이블 등\n\n4. [중복 속성 추가]\n- 조인 없이 접근하기 위해 중복 컬럼 추가\n- 계산된 값 저장\n\n[비정규화의 목적]\n- 조회 성능 향상\n- 개발 및 운영 단순화\n- 응답 시간 단축\n\n[주의사항]\n- 데이터 일관성 관리 필요\n- 저장 공간 증가\n- 데이터 중복으로 인한 업데이트 비용 증가\n\n[답]비정규화 (반정규화/역정규화)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["ERD", "정규화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 블랙박스 기법에 대한 예제이다.\n블랙박스 기법 두 가지를 쓰시오.", "choices": [], "answer": {"keys": ["1. 경곗값 분석", "2. 동등분할 테스트"], "raw_text": "1. 경곗값 분석 2. 동등분할 테스트"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 이해하는 문제입니다.\n\n[블랙박스 테스트란?]\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n[블랙박스 테스트 종류]\n\n1. [동치 분할 검사(동등분할 테스트, Equivalence Partitioning)]\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 동일한 결과를 낼 것으로 예상되는 입력값들을 하나의 그룹으로 묶음\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. [경계값 분석(Boundary Value Analysis)]\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 경계와 그 근처 값을 테스트\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. [원인-효과 그래프 검사(Cause-Effect Graphing)]\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. [오류 예측 검사(Error Guessing)]\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. [비교 검사(Comparison Testing)]\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n[문제에서 요구하는 기법]\n- 블랙박스 기법 두 가지: **경계값 분석**, **동등분할 테스트[답] 1. 경계값 분석, 2. 동등분할 테스트", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "0 <= x <= 10이면 -1 0 10 11 검사", "choices": [], "answer": {"keys": ["경계값 분석"], "raw_text": "경계값 분석"}, "explanation": "이 문제는 경계값 분석(Boundary Value Analysis) 테스트 기법을 설명하는 문제입니다.\n\n[경계값 분석이란?]\n- 블랙박스 테스트 기법 중 하나\n- 입력 조건의 **경계값과 그 근처 값**을 테스트 케이스로 선정하는 기법\n- 경계에서 오류가 발생할 가능성이 높기 때문에 경계값을 집중적으로 테스트\n\n[문제 분석]\n- 입력 조건: `0 <= x <= 10`\n- 경계값: 0 (하한 경계), 10 (상한 경계)\n- 경계 근처 값: -1 (하한 경계 바로 아래), 11 (상한 경계 바로 위)\n\n[테스트 케이스]\n- **-1**: 경계값(0) 바로 아래, 무효값 (경계 오류 검사)\n- **0**: 하한 경계값, 유효값 (경계 검사)\n- **10**: 상한 경계값, 유효값 (경계 검사)\n- **11**: 경계값(10) 바로 위, 무효값 (경계 오류 검사)\n\n[경계값 분석의 원리]\n- 경계값: 유효 범위의 최소값과 최대값 (0, 10)\n- 경계 바로 밖: 무효 범위의 값 (-1, 11)\n- 경계에서 오류가 발생할 가능성이 높으므로 이러한 값들을 반드시 테스트\n\n[일반적인 경계값 분석 규칙]\n- 입력 범위가 `a <= x <= b`일 때:\n  - 경계값: `a`, `b` (유효 경계)\n  - 경계 바로 밖: `a-1`, `b+1` (무효 경계)\n  - 경계 바로 안: `a+1`, `b-1` (유효 내부)\n\n[답] **경계값 분석**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "입력 데이터의 영역을 유사한 도메인별로 유횻값 / 무횻값을 그룹핑하여 나누어서 검사", "choices": [], "answer": {"keys": ["동등분할 테스트"], "raw_text": "동등분할 테스트"}, "explanation": "이 문제는 동등분할 테스트(Equivalence Partitioning) 블랙박스 테스트 기법을 설명하는 문제입니다.\n\n[동등분할 테스트란?]\n- 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 나누어서 검사하는 테스트 기법\n- 블랙박스 테스트 기법 중 하나\n- 동일한 결과를 낼 것으로 예상되는 입력값들을 하나의 그룹(동등 분할)으로 묶어서 대표값으로 테스트\n\n[동등분할의 원리]\n1. [입력 도메인 분할]\n   - 입력 데이터를 유사한 도메인별로 그룹핑\n   - 각 그룹은 동일한 동작을 할 것으로 예상\n\n2. [유효값/무효값 구분]\n   - **유효값**: 정상적인 입력 범위에 속하는 값들\n   - **무효값**: 정상적인 입력 범위를 벗어난 값들\n\n3. [대표값 테스트]\n   - 각 동등 분할에서 대표값 하나만 선택하여 테스트\n   - 동일한 그룹 내의 다른 값들은 같은 결과를 낼 것으로 가정\n\n[예시]\n- 입력 조건: `0 <= 나이 <= 100`\n- **유효 분할**: 0~100 사이의 값 (예: 25, 50, 75)\n- **무효 분할**: 0 미만 (예: -5), 100 초과 (예: 150)\n- 각 분할에서 대표값 하나씩만 테스트 (예: 50, -5, 150)\n\n[동등분할 테스트의 장점]\n- 테스트 케이스 수를 크게 줄일 수 있음\n- 효율적인 테스트 수행 가능\n- 입력 공간을 체계적으로 분할하여 커버리지 향상\n\n[경계값 분석과의 차이]\n| 구분 | 동등분할 테스트 | 경계값 분석 |\n|------|----------------|-----------|\n| **초점** | 입력 도메인 분할 | 경계값 집중 |\n| **방법** | 그룹별 대표값 | 경계값과 근처값 |\n| **예시** | 0~100 범위면 25, 50, 75 테스트 | 0~100 범위면 -1, 0, 100, 101 테스트 |\n\n[답] **동등분할 테스트**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 테스트 종류에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n\n- (2) 은/는 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n\n[보기]\n\n: 시스템 테스트 / 인수 테스트 / 알파 테스트 / 단위 테스트 / 통합 테스트 / 회귀 테스트", "choices": [], "answer": {"keys": ["1. 단위 테스트", "2. 통합 테스트"], "raw_text": "1. 단위 테스트 2. 통합 테스트"}, "explanation": "이 문제는 **테스트 종류**를 이해하는 문제입니다.\n\n[각 테스트 레벨의 정의]\n\n1. [단위 테스트(Unit Test)]\n- 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n- 가장 작은 단위(함수, 메서드)를 독립적으로 테스트\n- 화이트박스 테스트 기법 사용\n- 개발자가 수행\n\n2. [통합 테스트(Integration Test)]\n- 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n- 여러 모듈을 결합하여 테스트\n- 모듈 간 인터페이스와 상호작용 검증\n\n[다른 테스트 레벨]\n\n3. [시스템 테스트(System Test)]\n- 구현된 시스템이 정해진 요건에 적합한지 여부를 평가\n- 실제 운용과 같은 환경에서 시스템 전체에 대해 수행\n- 기능적 요구사항과 비기능적 요구사항 검증\n\n4. [인수 테스트(Acceptance Test)]\n- 사용자나 고객이 수행하는 최종 테스트\n- 시스템이 사용자의 요구사항을 만족하는지 확인\n\n[테스트 순서]\n단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트\n\n[답]\n- (1) **단위 테스트**: 개별 모듈 확인\n- (2) **통합 테스트**: 인터페이스 간 시스템 확인", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- IPv6는 (1.)  비트 길이를 가진다.\n\n- IPv4는 길이 32bit이며, (2.) 비트씩 네 부분으로 나눈다.", "choices": [], "answer": {"keys": ["1. 128", "2. 8"], "raw_text": "1. 128 2. 8"}, "explanation": "이 문제는 **IPv6와 IPv4의 주소 체계**를 이해하는 문제입니다.\n\n[IPv6 주소]\n- **128비트 길이**를 가집니다.\n- IPv4의 주소 고갈 문제를 해결하기 위해 개발\n- 16진수로 표현하며 8그룹으로 나눔 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)\n\n[IPv4 주소]\n- **32비트 길이**를 가집니다.\n- **8비트씩 네 부분**으로 나누어 표현\n- 각 부분을 10진수로 표현 (예: 192.168.0.1)\n- 총 32비트 = 8비트 × 4개 부분\n\n[비교]\n| 항목 | IPv4 | IPv6 |\n|------|------|------|\n| 주소 길이 | 32비트 | 128비트 |\n| 표현 방식 | 10진수, 4개 부분 | 16진수, 8개 부분 |\n| 예시 | 192.168.0.1 | 2001:0db8::1 |\n\n[답]\n- (1) **128** (IPv6는 128비트)\n- (2) **8** (IPv4는 8비트씩 네 부분)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "공유메모리, 소켓, 세마포어, 메세지 큐 등 프로세스 간 통신하는 기술을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["IPC (Inter Process Communication)"], "raw_text": "IPC (Inter Process Communication)"}, "explanation": "이 문제는 IPC (Inter Process Communication, 프로세스 간 통신)에 대한 이해를 묻는 문제입니다.\n\n[IPC란?]\n- Inter Process Communication의 약자\n- **프로세스 간 통신**을 위한 기술들의 총칭\n- 운영체제에서 서로 다른 프로세스가 데이터를 주고받을 수 있도록 하는 메커니즘\n\n[IPC가 필요한 이유]\n- 각 프로세스는 **독립적인 메모리 공간**을 가짐\n- 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없음\n- 따라서 프로세스 간 데이터 교환을 위한 특별한 메커니즘이 필요\n\n[문제에서 언급한 IPC의 종류]\n\n[1. 공유 메모리 (Shared Memory)]\n- 여러 프로세스가 **같은 물리적 메모리 영역을 공유**하는 방식\n- 특징:\n  - 가장 빠른 IPC 방식 (메모리 직접 접근)\n  - 데이터 복사 없이 직접 읽기/쓰기 가능\n  - 동기화 메커니즘 필요 (세마포어, 뮤텍스 등으로 동시 접근 제어)\n- 예시: 두 프로세스가 공유 메모리 영역에 데이터를 읽고 쓰기\n\n[2. 소켓 (Socket)]\n- **네트워크를 통한 프로세스 간 통신** 방식\n- 특징:\n  - 로컬 프로세스 간 통신과 원격 프로세스 간 통신 모두 가능\n  - TCP/UDP 프로토콜 사용\n  - 클라이언트-서버 모델에서 주로 사용\n- 예시: 웹 브라우저와 웹 서버 간 통신\n\n[3. 세마포어 (Semaphore)]\n- 공유 자원에 대한 접근을 제어하는 동기화 메커니즘\n- 특징:\n  - 정수값(카운터)을 사용하여 사용 가능한 자원의 개수 표현\n  - P 연산 (wait, 대기): 자원을 사용하려고 시도\n  - V 연산 (signal, 신호): 자원 사용 후 해제\n  - 상호 배제(Mutual Exclusion) 제공\n- 예시: 여러 프로세스가 프린터를 공유할 때 순서 제어\n\n[4. 메시지 큐 (Message Queue)]\n- 프로세스 간 **메시지를 큐(대기열) 형태로 전송**하는 방식\n- 특징:\n  - 비동기 통신 지원 (송신자와 수신자가 동시에 실행 중이지 않아도 됨)\n  - 시스템 커널이 관리하는 큐를 통해 메시지 전달\n  - 메시지에 우선순위 부여 가능\n- 예시: 프로세스 A가 메시지를 큐에 보내고, 프로세스 B가 나중에 읽기\n\n[IPC 방법 비교]\n| 방법 | 통신 방식 | 속도 | 동기화 |\n|------|----------|------|--------|\n| 공유 메모리 | 메모리 직접 접근 | 매우 빠름 | 필요 (별도 메커니즘) |\n| 소켓 | 네트워크/파이프 | 느림 | 자동 (연결 기반) |\n| 세마포어 | 동기화 메커니즘 | - | 제공 |\n| 메시지 큐 | 큐를 통한 전달 | 중간 | 자동 (큐 기반) |\n\n[답] IPC (Inter Process Communication)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "시스템 통합에 사용되는 솔루션으로 구축 유형에는 Point to Point, Hub & Spoke, Message Bus가 있다. 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 , 통합이 가능하도록 해주는 솔루션을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["EAI (Enterprise Application Integration)"], "raw_text": "EAI (Enterprise Application Integration)"}, "explanation": "이 문제는 EAI (Enterprise Application Integration, 기업 애플리케이션 통합)에 대한 이해를 묻는 문제입니다.\n\n[EAI란?]\n- Enterprise Application Integration의 약자\n- 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션\n- 기업 내 다양한 시스템(ERP, CRM, DBMS 등)을 연결하여 데이터와 프로세스를 통합하는 기술\n\n[EAI의 목적]\n- 이기종 시스템 간의 정보 교환 및 연계\n- 데이터 일관성 유지\n- 비즈니스 프로세스 통합\n- 시스템 간 상호 운용성 향상\n\n[문제에서 언급한 EAI 구축 유형]\n\n1. [Point to Point (포인트 투 포인트)]\n- 가장 기초적인 애플리케이션 통합 방법\n- 애플리케이션 간 **1:1 직접 연결** 방식\n- 단순하고 직접적이지만, 시스템이 많아질수록 연결 복잡도가 증가\n- 예: 애플리케이션 A ↔ 애플리케이션 B 직접 연결\n\n2. [Hub & Spoke (허브 앤 스포크)]\n- **단일한 접점의 허브 시스템**을 통하여 데이터를 전송하는 중앙 집중적 방식\n- 모든 애플리케이션이 중앙 허브를 통해 통신\n- 허브가 모든 연결을 관리하므로 중앙 집중적 관리 가능\n- 단점: 허브에 장애가 발생하면 전체 시스템 영향\n- 예: 허브 ← 애플리케이션 A, B, C, D (스포크들)\n\n3. [Message Bus (메시지 버스)]\n- **애플리케이션 사이 미들웨어를 두어** 연계하는 통합 방식\n- 공통 버스(버스 아키텍처)를 통해 메시지 기반 통신\n- 느슨한 결합(Loosely Coupled) 방식\n- 애플리케이션이 독립적으로 운영 가능\n- 예: 애플리케이션 A, B, C, D ↔ 메시지 버스 ↔ 서로 통신\n\n4. [하이브리드 (Hybrid)]\n- 여러 방식을 조합한 형태\n- 그룹 내에서는 허브 앤 스포크 방식, 그룹 간에는 메시지 버스 방식 사용\n- 유연성과 확장성 제공\n\n[비교 요약]\n| 구축 유형 | 특징 | 장점 | 단점 |\n|----------|------|------|------|\n| Point to Point | 1:1 직접 연결 | 단순, 빠름 | 복잡도 증가 |\n| Hub & Spoke | 중앙 허브 관리 | 중앙 집중 관리 | 허브 장애 시 전체 영향 |\n| Message Bus | 미들웨어 기반 | 느슨한 결합, 확장성 | 초기 구축 복잡 |\n\n[답] EAI (Enterprise Application Integration)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "주어진 테이블의 Cardinality / Degree를 구하시오.", "choices": [], "answer": {"keys": ["Cardinality : 5", "Degree : 4"], "raw_text": "Cardinality : 5 Degree : 4"}, "explanation": "이 문제는 데이터베이스의 **Cardinality와 Degree**를 구하는 문제입니다.\n\n[Cardinality (카디널리티)]\n- 릴레이션(테이블)에서 **튜플(행)의 개수**\n- 데이터의 행 수\n- 예: 테이블에 5개의 행이 있으면 Cardinality = 5\n\n[Degree (차수)]\n- 릴레이션(테이블)에서 **속성(컬럼)의 개수**\n- 테이블의 컬럼 수\n- 예: 테이블에 4개의 컬럼이 있으면 Degree = 4\n\n[문제에서 요구하는 답]\n주어진 테이블을 확인하면:\n- 행(Row)의 개수: 5개 → **Cardinality = 5**\n- 컬럼(Column)의 개수: 4개 → Degree = 4[기억하기]\n- Cardinality = 데이터 행 수 (카운트)\n- Degree = 속성 컬럼 수 (도메인)\n\n[답]\n- Cardinality : 5**\n- **Degree : 4**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q014_table1.json", "rows": 5, "cols": 4}], "image_refs": ["images/2021_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["Lee 38"], "raw_text": "Lee 38"}, "explanation": "이 C언어 코드는 **구조체 배열과 포인터**를 이해하는 문제입니다.\n\n[코드 분석]\n```c struct good {\nchar name[10];\nint age;\n};\nvoid main(){\nstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\nstruct good *p;\np = s;\np++;\nprintf(\"%s\\n\", p->name);\nprintf(\"%d\\n\", p->age);\n}\n```\n\n[실행 과정]\n\n1. [구조체 배열 초기화]\n- `s[0] = {\"Kim\", 28}`\n- `s[1] = {\"Lee\", 38}`\n- `s[2] = {\"Seo\", 50}`\n- `s[3] = {\"Park\", 35}`\n\n2. [포인터 설정]\n- `p = s` → `p`는 배열의 첫 번째 요소(`s[0]`)를 가리킴\n\n3. [포인터 증가]\n- `p++` → 포인터가 다음 구조체를 가리킴 (`s[1]`)\n- 구조체 포인터는 구조체 크기만큼 이동\n\n4. [출력]\n- `p->name`: `s[1].name` = **\"Lee\"**\n- `p->age`: `s[1].age` = 38[핵심 포인트]\n- 구조체 포인터의 `++` 연산은 구조체 크기만큼 증가합니다.\n- `p->` 연산자는 포인터가 가리키는 구조체의 멤버에 접근합니다.\n\n[답]Lee 38", "table_refs": [], "image_refs": ["images/2021_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}, {"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "데이터 모델 구성요소 3가지를 쓰시오.\n\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.\n\n- 개체 데이터 모델에서는 (1.) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 (2.) 을/를 어떻게 나타낼 것인지 표현한다.\n\n- (3) 은/는 데이터 무결성 유지를 위한 db의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.", "choices": [], "answer": {"keys": ["1. 연산", "2. 구조", "3. 제약조건"], "raw_text": "1. 연산 2. 구조 3. 제약조건"}, "explanation": "데이터 모델은 데이터베이스 설계의 기초가 되는 개념적 틀입니다. 데이터 모델의 구성요소는 다음과 같습니다.\n\n[데이터 모델 구성요소 3가지]\n\n1. [연산(Operation)]\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세\n- 데이터베이스를 조작하는 기본 도구\n- 예: SELECT, INSERT, UPDATE, DELETE 등의 연산\n\n2. [구조(Structure)]\n- 개체 데이터 모델에서는 연산을 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타냄\n- 논리 데이터 모델에서는 구조를 어떻게 나타낼 것인지 표현\n- 데이터의 논리적 구조와 물리적 구조를 정의\n- 예: 릴레이션 구조, 스키마 구조 등\n\n3. [제약조건(Constraint)]\n- 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법\n- 릴레이션의 특정 칼럼에 설정하는 제약\n- 개체 무결성: 기본 키가 NULL이 될 수 없고 중복될 수 없음\n- 참조 무결성: 외래 키가 참조하는 기본 키 값이 반드시 존재해야 함\n\n[데이터 모델의 역할]\n- 현실 세계의 정보를 데이터베이스에 표현하기 위한 구조와 규칙 제공\n- 데이터의 일관성과 무결성 보장\n\n[답]\n- (1) **연산**\n- (2) **구조**\n- (3) **제약조건**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["15"], "raw_text": "15"}, "explanation": "이 Java 코드는 **반복문을 이용한 누적 합계**를 계산하는 문제입니다.\n\n[코드 분석]\n```java int i, j;\nfor(j=0, i=0; i<=5; i++){\nj += i;\nSystem.out.print(i);\nif(i==5){\nSystem.out.print(\"=\");\nSystem.out.print(j);\n}else{\nSystem.out.print(\"+\");\n}\n}\n```\n\n[실행 과정]\n\n1. [초기화]\n- `i = 0`, `j = 0`\n\n2. [반복문 실행 (i=0부터 i=5까지)]\n\n| 반복 | i 값 | j 값 | j += i 후 | 출력 |\n|------|------|------|----------|------|\n| 초기 | 0 | 0 | - | - |\n| 1회 | 0 | 0 | j = 0 + 0 = 0 | `0+` |\n| 2회 | 1 | 0 | j = 0 + 1 = 1 | `1+` |\n| 3회 | 2 | 1 | j = 1 + 2 = 3 | `2+` |\n| 4회 | 3 | 3 | j = 3 + 3 = 6 | `3+` |\n| 5회 | 4 | 6 | j = 6 + 4 = 10 | `4+` |\n| 6회 | 5 | 10 | j = 10 + 5 = 15 | `5=15` |\n\n3. [최종 출력]\n- `0+1+2+3+4+5=15`\n- 하지만 문제에서 요구하는 것은 숫자만이므로: 15[핵심 포인트]\n- `j += i`는 `j = j + i`와 같습니다 (누적 합계).\n- 반복문이 끝날 때 `j`는 0부터 5까지의 합인 15가 됩니다.\n\n[답]15", "table_refs": [], "image_refs": ["images/2021_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [{"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}, {"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법, 어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식은 ?", "choices": [], "answer": {"keys": ["임의적 접근 통제 (DAC)"], "raw_text": "임의적 접근 통제 (DAC)"}, "explanation": "이 문제는 **임의적 접근 통제 (DAC)**에 대한 이해를 묻는 문제입니다.\n\n[접근 통제란?]\n사람이나 프로세스가 시스템이나 파일에 접근 여부를 허가하거나 거부하는 기능을 말합니다. 시스템 보안의 핵심 요소로, 무단 접근을 방지하고 자원을 보호합니다.\n\n[임의적 접근 통제 (DAC - Discretionary Access Control)]\n\n[정의]\n- 시스템 객체에 대한 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법\n- 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식\n- 객체의 소유자(Owner)가 자신의 판단으로 접근 권한을 결정\n\n[특징]\n1. **소유자 중심**: 객체의 소유자가 접근 권한을 결정\n2. **임의적**: 소유자의 재량에 따라 권한 부여/제거 가능\n3. **신분 기반**: 사용자나 그룹의 신분(식별자)을 기준으로 접근 제어\n4. **유연성**: 필요에 따라 권한을 변경할 수 있음\n\n[예시]\n- Windows 파일 시스템: 파일 소유자가 \"읽기\", \"쓰기\", \"실행\" 권한을 다른 사용자에게 부여\n- Linux 파일 권한: chmod 명령어로 소유자가 파일 권한 설정\n- 문서 공유 시스템: 문서 작성자가 특정 사용자에게만 접근 권한 부여\n\n[다른 접근 통제 방식과의 비교]\n\n1. [MAC (Mandatory Access Control) - 강제적 접근 통제]\n- 시스템 정책에 따라 접근 권한이 강제적으로 결정됨\n- 소유자가 임의로 변경 불가\n- 보안 등급 기반 (예: 군사 시스템)\n\n2. [RBAC (Role-Based Access Control) - 역할 기반 접근 통제]\n- 역할(직책, 부서 등)에 따라 권한 부여\n- 개인 신분이 아닌 역할 기반\n\n[DAC의 장단점]\n- **장점**: 유연성, 사용자 편의성, 세밀한 권한 제어\n- **단점**: 소유자의 실수로 인한 보안 취약점 가능, 권한 관리 복잡도 증가\n\n[답] **임의적 접근 통제 (DAC)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 결합도에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n\n- (2) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도\n\n- (3) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\n: 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도", "choices": [], "answer": {"keys": ["1. 내용 결합도", "2. 스탬프 결합도", "3. 공통 결합도"], "raw_text": "1. 내용 결합도 2. 스탬프 결합도 3. 공통 결합도"}, "explanation": "이 문제는 **결합도(Coupling)**의 종류를 이해하는 문제입니다.\n\n[결합도란?]\n모듈 간의 상호 의존 정도를 나타내는 개념입니다. 결합도가 낮을수록 모듈 간 독립성이 높아지고, 유지보수성과 재사용성이 향상됩니다.\n\n[문제에서 요구하는 결합도 유형]\n\n[1. 내용 결합도 (Content Coupling)]\n- **정의**: 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 직접 사용하는 경우의 결합도\n- **특징**:\n  - 한 모듈이 다른 모듈의 내부 구현을 직접 참조\n  - 모듈의 캡슐화를 완전히 위반\n  - 가장 높은 결합도 (가장 나쁜 결합도)\n- **예시**:\n  - 모듈 A가 모듈 B의 전역 변수를 직접 읽기/쓰기\n  - 모듈 A가 모듈 B의 내부 함수를 직접 호출\n- **문제점**: 한 모듈의 변경이 다른 모듈에 직접적인 영향을 미침\n\n[2. 스탬프 결합도 (Stamp Coupling)]\n- **정의**: 모듈 간의 인터페이스로 **배열이나 객체, 구조** 등이 전달되는 경우의 결합도\n- **특징**:\n  - 복합 자료구조(구조체, 배열, 객체)를 파라미터로 전달\n  - 필요한 데이터만 전달하는 것이 아니라 전체 구조를 전달\n  - 자료 결합도보다는 높지만 내용 결합도보다는 낮음\n- **예시**:\n  - 함수 호출 시 전체 구조체를 파라미터로 전달\n  - 배열 전체를 전달 (일부만 필요해도)\n- **개선 방법**: 필요한 필드만 전달하여 자료 결합도로 개선\n\n[3. 공통 결합도 (Common Coupling)]\n- **정의**: 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n- **특징**:\n  - 여러 모듈이 공통 전역 변수나 공유 데이터를 사용\n  - 한 모듈이 전역 변수를 변경하면 다른 모듈에 영향\n  - 데이터 흐름 추적이 어려움\n- **예시**:\n  - 여러 모듈이 공통 전역 변수 `global_data`를 읽고 쓰기\n  - 공유 메모리를 여러 모듈이 접근\n- **문제점**: 어떤 모듈이 전역 변수를 변경했는지 추적 어려움, 버그 발생 시 원인 파악 곤란\n\n[전체 결합도 순위 (낮은 품질 → 좋은 품질 순)]\n1. **내용 결합도** (Content Coupling) - 가장 나쁨\n2. **공통 결합도** (Common Coupling)\n3. **외부 결합도** (External Coupling)\n4. **제어 결합도** (Control Coupling)\n5. **스탬프 결합도** (Stamp Coupling)\n6. **자료 결합도** (Data Coupling) - 가장 좋음\n\n[결합도 개선 원칙]\n- 가능한 한 자료 결합도를 목표로 설계\n- 모듈 간 데이터 교환은 파라미터를 통해 필요한 최소한의 데이터만 전달\n- 전역 변수 사용 최소화\n- 모듈의 내부 구현을 숨기고 인터페이스를 통해 상호작용\n\n[답]\n- (1) **내용 결합도**: 다른 모듈 내부 변수/기능 직접 사용\n- (2) **스탬프 결합도**: 배열, 객체, 구조 전달\n- (3) **공통 결합도**: 전역 변수 공유 및 갱신", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "괄호 안에 공통으로 들어갈 공격 기법을 적으시오.\n\n- (      ) 은/는 '세션을 가로채다' 라는 의미로 정상적 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결한다.\n\n- (      ) 은/는 세션 관리 취약점을 이용한 공격 기법이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n[세션 하이재킹의 정의]\n\n1. [기본 의미]\n- '세션을 가로채다(Hijack)'라는 의미\n- 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법\n\n2. [공격 방식]\n- 정상적인 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결\n- 세션 관리 취약점을 이용한 공격 기법\n\n[세션 하이재킹의 과정]\n\n1. [세션 정보 획득]\n- 네트워크 스니핑을 통해 세션 ID, 쿠키 등의 세션 정보 탈취\n- 또는 XSS 공격을 통해 세션 정보 유출\n\n2. [세션 가로채기]\n- 획득한 세션 정보를 사용하여 정상 사용자인 것처럼 위장\n- 서버가 공격자를 정상 사용자로 인식\n\n3. [권한 획득]\n- 정상 사용자의 권한으로 시스템 접근 및 조작\n\n[방어 방법]\n- HTTPS 사용 (암호화 통신)\n- 세션 ID 암호화\n- 세션 타임아웃 설정\n- IP 주소 검증\n\n[답]세션 하이재킹**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "아래 설명에 맞는 RAID 단계를 숫자로 작성하시오.\n\n- Striping(스트라이핑) 구현 방식\n\n- I/O 로드의 분산으로 매우 빠른 속도\n\n- 데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장", "choices": [], "answer": {"keys": ["RAID 0"], "raw_text": "RAID 0"}, "explanation": "문제에서 설명하는 특징들이 모두 **RAID 0**을 가리킵니다.\n\n[RAID 0 (스트라이핑, Striping)]\n\n[1. Striping(스트라이핑) 구현 방식]\n- 데이터를 여러 디스크에 **균등하게 분산 저장**하는 방식\n- **데이터를 블록 단위로 분할**하여 각 디스크에 저장\n- 예: 100MB 파일을 4개 디스크에 25MB씩 분산 저장\n\n[2. I/O 로드의 분산으로 매우 빠른 속도]\n- 여러 디스크에 **동시에 접근**할 수 있어 병렬 처리 가능\n- 읽기/쓰기 속도가 **디스크 개수에 비례하여 증가**\n- 예: 4개 디스크 사용 시 이론적으로 최대 4배 속도 향상\n- I/O 작업이 각 디스크에 분산되어 전체 처리량 증가\n\n[3. 데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장]\n- 연속된 데이터를 **블록 단위로 분할**\n- 첫 번째 블록 → 디스크1, 두 번째 블록 → 디스크2, 세 번째 블록 → 디스크3... 순서로 저장\n- 데이터가 여러 디스크에 **교차(interleave) 저장**됨\n\n[RAID 0의 동작 원리]\n```\n예시: \"ABCD\" 데이터를 2개 디스크에 저장\n\n디스크1: A | C\n디스크2: B | D\n\n읽기 시: 디스크1과 디스크2에서 동시에 읽어서 병렬 처리\n```\n\n[문제 설명과의 매칭]\n- ✓ \"스트라이핑 구현 방식\" → RAID 0만 스트라이핑 사용\n- ✓ \"I/O 로드의 분산으로 매우 빠른 속도\" → RAID 0의 핵심 특징\n- ✓ \"데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장\" → RAID 0의 저장 방식\n\n[RAID 0의 특징 요약]\n| 특징 | 설명 |\n|------|------|\n| **구현 방식** | 스트라이핑 (Striping) |\n| **성능** | 매우 빠름 (I/O 분산, 병렬 처리) |\n| **저장 방식** | 블록 단위 분할, 여러 디스크에 분산 |\n| **장점** | 성능 향상, 용량 효율 (100% 사용 가능) |\n| **단점** | 안정성 낮음 (디스크 하나 고장 시 전체 데이터 손실) |\n\n[답] **RAID 0**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["데이터베이스"], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 설명을 확인하여\n\n해당하는 항목을 보기에서 찾아 적으시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, rollback 등..))\n\n1. 오류가 발생하기 전까지의 사항을 로그(log)로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상\n\n2. 작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것", "choices": [], "answer": {"keys": ["watering hole (워터링홀)"], "raw_text": "watering hole (워터링홀)"}, "explanation": "이 문제는 데이터베이스 **트랜잭션의 복구 기법**에 대한 문제입니다.\n\n[문제에서 설명하는 내용]\n\n1. 오류가 발생하기 전까지의 사항을 로그로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상\n- 이것은 **REDO (재실행)**입니다.\n- 트랜잭션이 커밋된 후 갱신 사항이 데이터베이스에 반영되지 못한 경우\n- 로그 파일의 기록을 이용하여 다시 실행하는 복구 방법\n\n2. 작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것\n- 이것은 **UNDO (취소)**입니다.\n- 트랜잭션이 롤백될 때 변경 사항을 취소하는 복구 방법\n- 변경 전 값으로 복원\n\n[REDO와 UNDO의 차이]\n\n| 구분 | UNDO | REDO |\n|------|------|------|\n| 목적 | 트랜잭션 취소 | 트랜잭션 재실행 |\n| 시점 | 롤백 시 | 커밋 후 미반영 시 |\n| 방향 | 과거로 되돌림 | 앞으로 진행 |\n| 로그 | Before Image 사용 | After Image 사용 |\n\n[답]\n- 1) **redo** (재실행)\n- 2) **undo** (취소)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음 자바 문법에 알맞는 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["2000"], "raw_text": "2000"}, "explanation": "[주어진 코드]\n```java\nclass A {\n    int a;\n    int b;\n}\n\npublic class Main {\n    static void func1(A m) {\n        m.a *= 10;\n    }\n    \n    static void func2(A m) {\n        m.a += m.b;\n    }\n    \n    public static void main(String args[]) {\n        A m = new A();\n        m.a = 100;\n        func1(m);\n        m.b = m.a;\n        func2(m);\n        System.out.printf(\"%d\", m.a);\n    }\n}\n```\n\n[Java 객체 참조 전달]\n- Java에서 객체는 **참조(reference)로 전달**됩니다\n- 메서드에 객체를 전달하면 **원본 객체의 참조**가 전달됩니다\n- 메서드 내에서 객체의 필드를 변경하면 **원본 객체도 함께 변경**됩니다\n\n[단계별 실행 과정]\n\n[1. 객체 생성 및 초기화]\n- `A m = new A();` → `m.a = 0`, `m.b = 0` (기본값)\n- `m.a = 100;` → `m.a = 100`, `m.b = 0`\n\n[2. func1(m) 호출]\n- `m.a *= 10;` → `m.a = m.a * 10 = 100 * 10 = 1000`\n- 참조로 전달되었으므로 원본 객체의 `m.a`가 1000으로 변경됨\n- 상태: `m.a = 1000`, `m.b = 0`\n\n[3. m.b 값 설정]\n- `m.b = m.a;` → `m.b = 1000`\n- 상태: `m.a = 1000`, `m.b = 1000`\n\n[4. func2(m) 호출]\n- `m.a += m.b;` → `m.a = m.a + m.b = 1000 + 1000 = 2000`\n- 참조로 전달되었으므로 원본 객체의 `m.a`가 2000으로 변경됨\n- 상태: `m.a = 2000`, `m.b = 1000`\n\n[5. 출력]\n- `System.out.printf(\"%d\", m.a);` → **2000 출력**\n\n[실행 순서 요약]\n| 단계 | 코드 | m.a | m.b |\n|------|------|-----|-----|\n| 초기화 | `A m = new A()` | 0 | 0 |\n| 1 | `m.a = 100` | 100 | 0 |\n| 2 | `func1(m)` → `m.a *= 10` | 1000 | 0 |\n| 3 | `m.b = m.a` | 1000 | 1000 |\n| 4 | `func2(m)` → `m.a += m.b` | 2000 | 1000 |\n| 5 | `printf(\"%d\", m.a)` | **2000 출력** | 1000 |\n\n[핵심 포인트]\n- `*=`: 곱셈 후 할당 (`m.a *= 10` = `m.a = m.a * 10`)\n- `+=`: 덧셈 후 할당 (`m.a += m.b` = `m.a = m.a + m.b`)\n- Java에서 **기본 타입은 값 전달**, **객체는 참조 전달**\n- 객체의 필드를 메서드에서 변경하면 원본 객체도 변경됨\n\n[답] **2000**", "table_refs": [], "image_refs": ["images/2022_round1/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [{"language": "java", "code": "class A {\n  int a;\n  int b;\n}\n  public class Main {\n  static void func1(A m){\n   m.a *= 10;\n  }\n  static void func2(A m){\n    m.a += m.b;\n  }\n  public static void main(String args[]){\n  A m = new A();\n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  System.out.printf(\"%d\", m.a);\n  }\n}", "line_numbers": [1, 20], "file": "data/codes/2022_round1/Q003_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 SQL 결과에 알맞는 쿼리을 작성하시오.\nSELECT name, score FROM 성적\n\n(1) BY ( 2 ) ( 3 )", "choices": [], "answer": {"keys": ["1) ORDER", "2) score", "3) DESC"], "raw_text": "1) ORDER 2) score 3) DESC"}, "explanation": "문제에서 제시된 SQL 결과를 보면 점수(score) 기준으로 내림차순 정렬이 필요합니다.\n\n[주어진 쿼리 패턴]\n```sql\nSELECT name, score FROM 성적\n(1) BY (2) (3)\n```\n\n[패턴 분석]\n- `(1) BY (2) (3)` 형태는 **ORDER BY 절**을 나타냅니다\n- `BY` 앞에는 `ORDER`가 오고\n- `BY` 뒤에는 정렬 기준 컬럼명과 정렬 방향이 옵니다\n\n[ORDER BY 절 구조]\n```sql\nORDER BY 컬럼명 [ASC | DESC]\n```\n- `ORDER BY`: 결과를 정렬하기 위한 SQL 절\n- `컬럼명`: 정렬 기준이 되는 컬럼\n- `ASC`: 오름차순 (Ascending, 기본값, 생략 가능)\n- `DESC`: 내림차순 (Descending, 높은 값부터 낮은 값 순서)\n\n[문제의 요구사항]\n- 주어진 결과를 보면 점수가 **높은 순서부터 낮은 순서**로 정렬되어 있음\n- 따라서 **내림차순(DESC)** 정렬 필요\n- 정렬 기준 컬럼은 **score**\n\n[빈칸 채우기]\n1. **(1)**: `ORDER` - ORDER BY 절의 시작 키워드\n2. **(2)**: `score` - 정렬 기준 컬럼명 (점수 컬럼)\n3. **(3)**: `DESC` - 내림차순 정렬 지정\n\n[완성된 쿼리]\n```sql\nSELECT name, score FROM 성적\nORDER BY score DESC\n```\n\n[실행 결과]\n- 성적 테이블에서 학생 이름과 점수를 조회\n- 점수가 높은 학생부터 낮은 학생 순서로 정렬되어 출력\n\n[ORDER BY 사용 예시]\n- `ORDER BY score ASC` 또는 `ORDER BY score`: 점수 오름차순 (낮은 점수 → 높은 점수)\n- `ORDER BY score DESC`: 점수 내림차순 (높은 점수 → 낮은 점수)\n- `ORDER BY name`: 이름 오름차순 (가나다순)\n\n[답]\n- (1) **ORDER**\n- (2) **score**\n- (3) **DESC**", "table_refs": [{"id": "table1", "json": "data/tables/2022_round1/Q004_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2022_round1/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "데이터베이스의 이상현상 중, 삭제 이상에 대해 서술하시오.", "choices": [], "answer": {"keys": ["삭제 이상"], "raw_text": "삭제 이상"}, "explanation": "이 문제는 데이터베이스의 삭제 이상(Deletion Anomaly)에 대한 문제입니다.\n\n[삭제 이상이란?]\n- 데이터를 삭제할 때 **의도치 않은 다른 데이터도 함께 삭제**되는 이상 현상\n- 정규화되지 않은 테이블에서 발생하는 문제점 중 하나\n\n[삭제 이상의 예시]\n\n예를 들어, 학생-과목 테이블에서:\n| 학번 | 이름 | 과목코드 | 과목명 |\n|------|------|----------|--------|\n| 001 | 김철수 | C101 | 데이터베이스 |\n| 001 | 김철수 | C102 | 운영체제 |\n| 002 | 이영희 | C101 | 데이터베이스 |\n\n만약 이영희가 데이터베이스 과목을 취소(삭제)하면:\n- 이영희의 행이 삭제됨\n- **문제**: C101(데이터베이스) 과목 정보도 함께 사라질 수 있음\n- 만약 C101을 듣는 학생이 이영희뿐이었다면, 과목 정보 자체가 삭제됨\n\n[해결 방법]\n- 정규화를 통해 테이블을 분리\n- 학생 테이블, 과목 테이블, 수강 테이블로 분리\n\n[다른 이상 현상]\n- **삽입 이상**: 데이터 삽입 시 불필요한 데이터도 함께 삽입해야 함\n- **갱신 이상**: 데이터 수정 시 여러 곳을 수정해야 하거나 일관성 문제 발생\n\n[답]삭제 이상**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 파이썬 코드에서 출력되는 a와 b의 값을 작성하시오.", "choices": [], "answer": {"keys": ["a= 20 b= 2"], "raw_text": "a= 20 b= 2"}, "explanation": "이 파이썬 코드는 함수의 기본값 매개변수(Default Parameter)를 이해하는 문제입니다.\n\n[코드 분석]\n\n```python def exam(num1, num2=2):\nprint('a=', num1, 'b=', num2)\n\nexam(20)\n```\n\n[실행 과정]\n\n1. [함수 정의]\n- `exam(num1, num2=2)`: `num1`은 필수 매개변수, `num2`는 기본값이 2로 설정된 선택적 매개변수입니다.\n\n2. [함수 호출]\n- `exam(20)`: 첫 번째 인자 20만 전달\n- `num1 = 20` (전달된 값)\n- `num2 = 2` (기본값 사용, 인자 미전달)\n\n3. [출력]\n- `print('a=', 20, 'b=', 2)`\n- 출력: \"a= 20 b= 2\"[핵심 포인트]\n- 기본값이 설정된 매개변수는 함수 호출 시 인자를 생략하면 기본값이 사용됩니다.\n- 여기서는 `num2`에 값을 전달하지 않았으므로 기본값 2가 사용되었습니다.\n\n[답]a= 20 b= 2", "table_refs": [], "image_refs": ["images/2022_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.992448"}, "code_blocks": [{"language": "python", "code": "def exam(num1, num2=2):\n  print('a=', num1, 'b=', num2)\nexam(20)", "line_numbers": [1, 3], "file": "data/codes/2022_round1/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 설명과 관련된 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, remove, sort 등..))\n\n1. 요소를 확장해준다는 의미를 가지고 있으며, 모든 항목을 하나의 요소로 추가\n\n2. 리스트 내부 요소를 꺼내주는 함수로써, 그 요소는 리스트 안에서 삭제하고 그 값을 반환\n\n3. 리스트 내부의 요소의 순서는 뒤집는 역할", "choices": [], "answer": {"keys": ["1) extend", "2) pop", "3) reverse"], "raw_text": "1) extend 2) pop 3) reverse"}, "explanation": "이 문제는 파이썬 **리스트 메서드**의 기능을 이해하는 문제입니다.\n\n[각 메서드의 기능]\n\n1. [`extend(iterable)`]\n- 요소를 확장해준다는 의미\n- 반복 가능한 객체(리스트, 튜플 등)의 모든 항목을 하나씩 추가\n- 예: `[1, 2].extend([3, 4])` → `[1, 2, 3, 4]`\n- `append()`와 차이: `append([3, 4])`는 `[1, 2, [3, 4]]`가 됨\n\n2. [`pop([index])`]\n- 리스트 내부 요소를 꺼내주는 함수\n- 해당 요소는 리스트에서 삭제하고 그 값을 반환\n- 인덱스를 지정하지 않으면 마지막 요소를 반환\n- 예: `[1, 2, 3].pop()` → `3` 반환, 리스트는 `[1, 2]`가 됨\n\n3. [`reverse()`]\n- 리스트 내부 요소의 순서를 뒤집는 역할\n- 원본 리스트를 직접 수정 (반환값 없음)\n- 예: `[1, 2, 3].reverse()` → 리스트가 `[3, 2, 1]`로 변경\n\n[답]\n- (1) **extend**\n- (2) **pop**\n- (3) **reverse**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["알고리즘"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 아래 단어를 영어 약자로 작성하시오.\n임시 키 무결성 프로토콜", "choices": [], "answer": {"keys": ["TKIP"], "raw_text": "TKIP"}, "explanation": "문제에서 요구하는 것은 **\"임시 키 무결성 프로토콜\"**을 영어 약자로 작성하는 것입니다.\n\n[TKIP (Temporal Key Integrity Protocol)]\n\n[영어 약자 풀이]\n- **T**emporal: 임시의, 시간에 따른\n- **K**ey: 키\n- **I**ntegrity: 무결성\n- **P**rotocol: 프로토콜\n- TKIP = Temporal Key Integrity Protocol\n\n[TKIP의 정의]\n- **임시 키 무결성 프로토콜** 또는 **시간적 키 무결성 프로토콜**\n- 무선 네트워크 보안을 위한 암호화 프로토콜\n- WEP(Wired Equivalent Privacy)의 취약점을 보완하기 위해 개발\n\n[TKIP의 특징]\n1. [임시 키(Temporal Key) 사용]\n   - 정적 키를 사용하는 WEP와 달리 **동적으로 키를 변경**\n   - 일정 시간마다 또는 패킷 단위로 키를 갱신\n   - 보안 강화\n\n2. [무결성(Integrity) 보장]\n   - 데이터가 전송 중 변조되지 않았음을 검증\n   - MIC(Message Integrity Check)를 사용하여 데이터 무결성 확인\n\n3. [WEP 호환성]\n   - 기존 WEP 하드웨어에서도 사용 가능\n   - 소프트웨어 업데이트로 적용 가능\n\n[TKIP의 용도]\n- Wi-Fi 네트워크(WLAN) 보안\n- IEEE 802.11i 표준의 일부\n- WPA(Wi-Fi Protected Access)에서 사용\n- WEP의 보안 취약점을 개선\n\n[답] **TKIP**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["네트워크"], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 중, 설명에 대한 답을 영어 약자로 작성하시오.\n키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경", "choices": [], "answer": {"keys": ["NUI"], "raw_text": "NUI"}, "explanation": "문제에서 설명하는 특징들이 모두 NUI (Natural User Interface)를 가리킵니다.\n\n[NUI (Natural User Interface, 자연적 사용자 인터페이스)]\n\n[영어 약자 풀이]\n- **N**atural: 자연스러운, 자연적인\n- **U**ser: 사용자\n- **I**nterface: 인터페이스\n- NUI = Natural User Interface\n\n[NUI의 정의]\n- 키보드나 마우스와 같은 전통적인 입력 장치 없이 컴퓨터나 장치를 제어할 수 있는 환경\n- **인간의 자연스러운 표현**을 입력 수단으로 사용하는 사용자 인터페이스\n\n[문제에서 언급한 특징]\n1. **\"키보드나 마우스와 같은 장치 없이\"**\n   - 전통적인 GUI(Graphical User Interface)와 달리 물리적 입력 장치 불필요\n   - CUI(Command User Interface), GUI( Graphical User Interface)의 다음 세대\n\n2. \"말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현\"\n   - **말(음성)**: 음성 인식 기술 사용 (예: \"안녕, 시리\")\n   - **행동**: 제스처, 터치, 몸짓 (예: 손짓으로 화면 제어, 눈동자 추적)\n   - **감정**: 표정, 생체 신호 인식 (예: 얼굴 표정 인식)\n\n[NUI의 예시]\n- **음성 인식**: 음성으로 명령 전달 (Siri, Alexa, Google Assistant)\n- **제스처 인식**: 손동작으로 화면 제어 (Kinect, 손짓 인식)\n- **터치 스크린**: 손가락 터치로 직접 조작 (스마트폰, 태블릿)\n- **생체 인식**: 얼굴, 지문, 홍채 인식으로 인증\n- **시선 추적**: 눈동자 움직임으로 화면 제어\n- **뇌파 인식**: 뇌 신호를 이용한 제어 (연구 단계)\n\n[다른 UI 유형과의 비교]\n| 유형 | 약자 | 특징 | 예시 |\n|------|------|------|------|\n| **CUI** | Command User Interface | 명령어 입력 | DOS 프롬프트, 터미널 |\n| **GUI** | Graphical User Interface | 그래픽, 마우스, 키보드 | Windows, macOS |\n| **NUI** | Natural User Interface | 자연스러운 표현 | 음성, 제스처, 터치 |\n\n[NUI의 장점]\n- 직관적이고 사용하기 쉬움\n- 학습 곡선이 낮음 (자연스러운 동작)\n- 물리적 장치 불필요 (접근성 향상)\n- 다양한 입력 방식 지원\n\n[NUI의 응용 분야]\n- 스마트 홈 (음성 제어)\n- VR/AR (손동작 제어)\n- 터치스크린 기기 (스마트폰, 태블릿)\n- 자동차 (음성 인식 내비게이션)\n- 헬스케어 (생체 신호 인식)\n\n[답] **NUI**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 분석도구에 대한 설명으로 보기에 알맞는 답을 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, running analysis 등..))\n\n1. 소스 코드의 실행 없이, 코드의 의미를 분석해 결함을 찾아내는 원시적 코드 분석 기법\n\n2. 소스 코드를 실행하여 프로그램 동작이나 반응을 추적하고 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석", "choices": [], "answer": {"keys": ["1) static", "2) dynamic"], "raw_text": "1) static 2) dynamic"}, "explanation": "이 문제는 소프트웨어 **코드 분석 도구**의 종류를 묻는 문제입니다.\n\n[정적 분석 (Static Analysis)]\n\n1. [특징]\n- 소스 코드의 실행 없이 코드의 의미를 분석\n- 코드 자체를 읽어서 결함을 찾아내는 원시적 코드 분석 기법\n- 컴파일 타임에 수행\n\n2. [장점]\n- 실행 환경이 필요 없음\n- 빠른 분석 가능\n- 모든 코드 경로 분석 가능\n\n3. [예시 도구]\n- SonarQube, ESLint, Pylint 등\n\n[동적 분석 (Dynamic Analysis)]\n\n1. [특징]\n- 소스 코드를 실행하여 프로그램 동작이나 반응을 추적\n- 실행 중에 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석\n- 런타임에 수행\n\n2. [장점]\n- 실제 실행 환경에서 문제 발견 가능\n- 성능 문제, 메모리 누수 등 실제 동작 문제 발견\n\n3. [예시 도구]\n- Valgrind, JProfiler, Chrome DevTools 등\n\n[답]\n- (1) **static**\n- (2) **dynamic**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 Java 코드 중에서 밑줄에 들어갈 알맞는 코드를 작성하시오.", "choices": [], "answer": {"keys": ["Car"], "raw_text": "Car"}, "explanation": "이 Java 코드는 **Thread 클래스의 생성자**와 **Runnable 인터페이스 구현**을 이해하는 문제입니다.\n\n[코드 분석]\n```java class Car implements Runnable{\nint a;\npublic void run(){\nsystem.out.println(\"message\")\n}\n}\npublic class Main{\npublic static void main(String args[]){\nThread t1 = new Thread(new ___());\nt1.start();\n}\n}\n```\n\n[문제 해결]\n\n1. [Thread 생성자]\n- `Thread(Runnable target)`: Runnable 인터페이스를 구현한 객체를 받음\n- `new Thread(new Car())` 형식으로 호출\n\n2. [Runnable 인터페이스]\n- `Car` 클래스가 `implements Runnable`로 구현\n- `run()` 메서드를 구현하여 스레드가 실행할 작업 정의\n\n3. [빈칸에 들어갈 코드]\n- `new Thread(new Car())` → 빈칸은 **Car**\n- `Car` 클래스의 인스턴스를 생성하여 Thread 생성자에 전달\n\n4. [실행 흐름]\n- `t1.start()` 호출 → 새 스레드 시작\n- `Car` 클래스의 `run()` 메서드 실행\n- \"message\" 출력\n\n[핵심 포인트]\n- Thread는 Runnable 인터페이스를 구현한 객체를 받아 실행합니다.\n- `start()` 메서드로 스레드를 시작하면 `run()` 메서드가 자동 실행됩니다.\n\n[답]Car**", "table_refs": [], "image_refs": ["images/2022_round1/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [{"language": "java", "code": "class Car implements Runnable{\n  int a;\n  public void run(){\n     system.out.println(\"message\")\n  }\n}\npublic class Main{\n  public static void main(String args[]){\n    Thread t1 = new Thread(new ___());\n    t1.start();\n  }\n}", "line_numbers": [1, 12], "file": "data/codes/2022_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 설명에 대한 알맞는 단어를 작성하시오.\n자바 프로그래밍 언어를 이용한 xUnit의 테스트 기법으로써 숨겨진 단위 테스트를 끌어내어 정형화시켜 단위 테스트를 쉽게 해주는 테스트용 Framework이다.", "choices": [], "answer": {"keys": ["JUnit"], "raw_text": "JUnit"}, "explanation": "이 문제는 Java 테스트 프레임워크인 **JUnit**에 대한 문제입니다.\n\n[JUnit이란?]\n- Java 프로그래밍 언어를 이용한 xUnit 테스트 기법\n- 숨겨진 단위 테스트를 끌어내어 정형화시켜 단위 테스트를 쉽게 해주는 테스트용 Framework\n\n[JUnit의 특징]\n1. [단위 테스트 자동화]\n- 각 메서드나 클래스의 기능을 개별적으로 테스트\n- 테스트 케이스를 자동으로 실행하고 결과를 확인\n\n2. [정형화된 테스트]\n- `@Test` 어노테이션으로 테스트 메서드 표시\n- `assertEquals()`, `assertTrue()` 등으로 검증\n\n3. [xUnit 패턴]\n- 여러 언어로 포팅된 테스트 프레임워크 패턴\n- Java용은 JUnit, Python용은 PyUnit, C#용은 NUnit 등\n\n[예시]\n```java\n@Test public void testAddition() {\nassertEquals(5, calculator.add(2, 3));\n}\n```\n\n[답]JUnit**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["소프트웨어공학"], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 보기 중에서 블랙박스 테스트 기법을 3가지 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄷ", "ㄹ", "ㅂ"], "raw_text": "ㄷ\nㄹ\nㅂ"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 선택하는 문제입니다.\n\n[블랙박스 테스트란?]\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n[블랙박스 테스트 기법 종류]\n\n1. [동치 분할 (Equivalence Partitioning)]\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. [경계값 분석 (Boundary Value Analysis)]\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. [원인-효과 그래프 (Cause-Effect Graphing)]\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. [오류 예측 (Error Guessing)]\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. [비교 검사 (Comparison Testing)]\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n[문제에서 요구하는 기법]\n- 보기에서 블랙박스 테스트 기법 3가지를 선택해야 합니다.\n\n[답]ㄷ, ㄹ, ㅂ** (보기에 나열된 블랙박스 테스트 기법 3개)", "table_refs": [], "image_refs": ["images/2022_round1/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 소스코드에서 입력값이 5가 들어왔을때 출력되는 값을 작성하시오.", "choices": [], "answer": {"keys": ["120"], "raw_text": "120"}, "explanation": "이 코드는 **재귀 함수를 이용한 팩토리얼 계산** 문제입니다.\n\n[주어진 코드]\n```c\n#include <stdio.h>\nint func(int a) {\n    if (a <= 1) return 1;\n    return a * func(a - 1);\n}\nint main() {\n    int a;\n    scanf(\"%d\", &a);\n    printf(\"%d\", func(a));\n}\n```\n\n[팩토리얼(Factorial) 정의]\n- n! = n × (n-1) × (n-2) × ... × 2 × 1\n- 예: 5! = 5 × 4 × 3 × 2 × 1 = 120\n- 0! = 1! = 1 (특수 케이스)\n\n[재귀 함수 동작 원리]\n- **기저 조건(Base Case)**: `if (a <= 1) return 1` - 재귀 종료 조건\n- **재귀 호출**: `return a * func(a - 1)` - 자기 자신을 호출하여 작은 문제로 분해\n\n[입력값이 5일 때 실행 과정]\n\n[호출 스택 (Call Stack)]\n```\nfunc(5)\n  └─ func(4)\n      └─ func(3)\n          └─ func(2)\n              └─ func(1) ← 기저 조건 도달\n```\n\n[단계별 추적]\n\n1. [func(5) 호출]\n   - `5 <= 1`? 아니오\n   - `return 5 * func(4)` 실행 (func(4) 결과 기다림)\n\n2. [func(4) 호출]\n   - `4 <= 1`? 아니오\n   - `return 4 * func(3)` 실행 (func(3) 결과 기다림)\n\n3. [func(3) 호출]\n   - `3 <= 1`? 아니오\n   - `return 3 * func(2)` 실행 (func(2) 결과 기다림)\n\n4. [func(2) 호출]\n   - `2 <= 1`? 아니오\n   - `return 2 * func(1)` 실행 (func(1) 결과 기다림)\n\n5. [func(1) 호출]\n   - `1 <= 1`? **예** → `return 1` (기저 조건, 재귀 종료)\n\n[값 반환 과정 (Unwinding)]\n```\nfunc(1) = 1                                    ← 반환\nfunc(2) = 2 * func(1) = 2 * 1 = 2            ← 반환\nfunc(3) = 3 * func(2) = 3 * 2 = 6            ← 반환\nfunc(4) = 4 * func(3) = 4 * 6 = 24           ← 반환\nfunc(5) = 5 * func(4) = 5 * 24 = 120         ← 최종 반환\n```\n\n[실행 순서 요약 표]\n| 단계 | 호출 | 조건 확인 | 반환값 | 계산식 |\n|------|------|-----------|--------|--------|\n| 5 | func(5) | 5 <= 1? 아니오 | - | 5 * func(4) 대기 |\n| 4 | func(4) | 4 <= 1? 아니오 | - | 4 * func(3) 대기 |\n| 3 | func(3) | 3 <= 1? 아니오 | - | 3 * func(2) 대기 |\n| 2 | func(2) | 2 <= 1? 아니오 | - | 2 * func(1) 대기 |\n| 1 | func(1) | 1 <= 1? **예** | **1** | 기저 조건 |\n| 2 | func(2) | - | **2** | 2 * 1 = 2 |\n| 3 | func(3) | - | **6** | 3 * 2 = 6 |\n| 4 | func(4) | - | **24** | 4 * 6 = 24 |\n| 5 | func(5) | - | **120** | 5 * 24 = 120 |\n\n[최종 출력] `printf(\"%d\", 120)` → **120**\n\n[재귀 함수의 특징]\n- 분할 정복(Divide and Conquer): 큰 문제를 작은 문제로 나눔\n- **기저 조건**: 재귀 종료 조건이 반드시 필요 (없으면 무한 루프)\n- **호출 스택**: 함수 호출이 스택에 쌓임 (후입선출, LIFO)\n- **메모리 사용**: 호출이 깊을수록 스택 메모리 많이 사용\n\n[답] **120**", "table_refs": [], "image_refs": ["images/2022_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint func(int a) {\n  if (a <= 1) return 1;\n  return a * func(a - 1);\n}\nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  printf(\"%d\", func(a));\n}", "line_numbers": [1, 10], "file": "data/codes/2022_round1/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 중, 괄호 ( ) 안에 들어갈 연산자를 써서 정수를 역순으로 출력하는 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1) >", "2) %", "3) /"], "raw_text": "1) >\n2) %\n3) /"}, "explanation": "이 C언어 코드는 **정수를 역순으로 출력**하는 문제입니다.\n\n[코드 분석]\n\n```c int number = 1234;\nint div = 10;\nint result = 0;\nwhile (number (1) 0) {\nresult = result * div;\nresult = result + number (2) div;\nnumber = number (3) div;\n}\n```\n\n[목표]\n- 입력: 1234\n- 출력: 4321\n\n[빈칸 분석]\n\n1. [`while (number (1) 0)`]\n- 반복 조건: `number`가 0보다 큰 동안 반복\n- `(1)` = **>** (크다)\n\n2. [`number (2) div`]\n- 마지막 자릿수를 구하기 위해 나머지 연산 필요\n- `number % div` = 일의 자리 숫자\n- `(2)` = **%** (나머지)\n\n3. [`number = number (3) div`]\n- 마지막 자릿수를 제거하기 위해 나누기 연산 필요\n- `number / div` = 마지막 자릿수 제거\n- `(3)` = **/** (나누기)\n\n[실행 과정 (number = 1234)]\n\n| 반복 | number | result | 설명 |\n|------|--------|--------|------|\n| 초기 | 1234 | 0 | - |\n| 1 | 123 | 4 | result = 0*10 + 1234%10 = 4, number = 1234/10 = 123 |\n| 2 | 12 | 43 | result = 4*10 + 123%10 = 43, number = 123/10 = 12 |\n| 3 | 1 | 432 | result = 43*10 + 12%10 = 432, number = 12/10 = 1 |\n| 4 | 0 | 4321 | result = 432*10 + 1%10 = 4321, number = 1/10 = 0 |\n\n[최종 출력]4321[답]\n- (1) **>**\n- (2) **%**\n- (3) **/**", "table_refs": [], "image_refs": ["images/2022_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.993440"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n  int number = 1234;\n  int div = 10;\n  int result = 0;\n  while (number ( 1 ) 0) {\n    result = result * div;\n    result = result + number ( 2 ) div;\n    number = number ( 3 ) div;\n  }\n  printf(\"%d\", result);return 0;\n}", "line_numbers": [1, 12], "file": "data/codes/2022_round1/Q015_code.txt"}], "primary_category": "기타", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 설명에 대한 답을 영어 약자로 작성하시오.\n정보보호 관리체계의 영문 약자", "choices": [], "answer": {"keys": ["ISMS (Information Security Management System)"], "raw_text": "ISMS (Information Security Management System)"}, "explanation": "문제에서 요구하는 것은 **\"정보보호 관리체계\"**의 영문 약자입니다.\n\n[ISMS (Information Security Management System)]\n\n[영어 약자 풀이]\n- **I**nformation: 정보\n- **S**ecurity: 보안, 보호\n- **M**anagement: 관리\n- **S**ystem: 체계, 시스템\n- ISMS = Information Security Management System\n\n[ISMS의 정의]\n- **정보보호 관리체계** 또는 **정보보안 관리체계**\n- 조직의 정보자산을 체계적으로 보호하기 위한 관리 시스템\n- 정보보안 위험을 관리하고 통제하기 위한 일련의 정책, 절차, 프로세스\n\n[ISMS의 주요 요소]\n1. **정보자산 관리**: 정보자산 식별, 분류, 보호\n2. **보안 정책**: 조직의 보안 목표와 방침 수립\n3. **위험 관리**: 보안 위협 식별, 평가, 대응\n4. **통제 체계**: 기술적/물리적/관리적 보안 통제\n5. **지속적 개선**: PDCA 사이클을 통한 관리체계 개선\n\n[ISMS 인증]\n- **인증 기관**: 한국인터넷진흥원(KISA, Korea Internet & Security Agency)\n- **인증 기준**: ISO/IEC 27001 국제표준 기반\n- **인증 범위**: 조직 전체 또는 특정 부서/시스템\n- **인증 유효기간**: 3년 (재인증 필요)\n\n[ISMS의 목적]\n- 정보자산의 기밀성, 무결성, 가용성 보장\n- 정보보안 위험을 사전에 예방 및 차단\n- 법규 및 규정 준수\n- 조직의 신뢰성 및 경쟁력 향상\n\n[ISMS와 관련 개념]\n- **ISO/IEC 27001**: ISMS를 위한 국제 표준\n- PIMS (Personal Information Management System): 개인정보보호 관리체계\n- **ISO/IEC 27002**: 정보보안 통제를 위한 실무 지침\n\n[답] ISMS (Information Security Management System)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 설명 중, 괄호 ( ) 안에 들어가는 알맞는 답을 보기에서 선택하여 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, 참조성, 무결성 등..))\n\n1. 슈퍼키는\n\n(1) 의 속성을 갖는다.", "choices": [], "answer": {"keys": ["1) 유일성", "2) 최소성"], "raw_text": "1) 유일성 2) 최소성"}, "explanation": "이 문제는 데이터베이스 **키(Key)**의 속성에 관한 문제입니다.\n\n[슈퍼키(Super Key)의 속성]\n\n[슈퍼키(Super Key)란?]\n- 테이블에서 **튜플을 유일하게 식별**할 수 있는 하나 이상의 속성(컬럼) 조합\n- 테이블의 모든 행을 고유하게 구분할 수 있는 속성 집합\n\n[슈퍼키의 핵심 속성]\n\n1. [유일성(Uniqueness)]\n   - 슈퍼키의 가장 중요한 속성\n   - 슈퍼키 값이 **중복되지 않음**을 보장\n   - 테이블의 각 행을 **유일하게 식별**할 수 있어야 함\n   - 예: 학생 테이블에서 `학번`은 슈퍼키 (각 학생마다 고유한 학번)\n   - 예: `학번 + 이름`도 슈퍼키 (유일성 만족)\n   - 예: `학번 + 이름 + 주소`도 슈퍼키 (유일성 만족)\n\n2. [최소성(Minimality) - 슈퍼키는 갖지 않음]\n   - 슈퍼키는 **최소성을 보장하지 않음**\n   - 더 작은 속성 집합으로도 유일성을 만족할 수 있음\n   - 예: `학번 + 이름`은 슈퍼키지만, `학번`만으로도 유일성을 만족하므로 최소성 없음\n\n[주의사항]\n- 문제에서 \"슈퍼키는 (1) 의 속성을 갖는다\"라고 되어 있으나, 정답이 \"1) 유일성, 2) 최소성\"인 것은 문제가 \"후보키\"를 묻는 문제이거나, 혹은 슈퍼키의 정의에 오류가 있을 수 있습니다.\n\n[슈퍼키 vs 후보키 vs 기본키]\n\n| 키 유형 | 유일성 | 최소성 | 설명 |\n|---------|--------|--------|------|\n| **슈퍼키** | ✓ | ✗ | 튜플을 유일하게 식별 (최소성 불필요) |\n| **후보키** | ✓ | ✓ | 슈퍼키 중 최소성을 만족하는 키 |\n| **기본키** | ✓ | ✓ | 후보키 중 하나를 선택한 키 |\n\n[예시]\n- 학생 테이블: `학번`, `주민등록번호`\n  - 슈퍼키: `{학번}`, `{주민등록번호}`, `{학번, 이름}`, `{학번, 이름, 주소}` 등\n  - 후보키: `{학번}`, `{주민등록번호}` (최소성을 만족하는 슈퍼키)\n  - 기본키: `{학번}` (후보키 중 하나 선택)\n\n[답]\n- 문제의 의도에 따라 \"1) 유일성\" 또는 \"1) 유일성, 2) 최소성\"이 될 수 있습니다.\n- 일반적으로 **슈퍼키는 유일성만** 갖고, **후보키는 유일성과 최소성을 모두** 갖습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "후보키는\n\n(1) 와/과 ( 2 ) 의 속성을 갖는다.", "choices": [], "answer": {"keys": ["1) 유일성", "2) 최소성"], "raw_text": "1) 유일성 2) 최소성"}, "explanation": "이 문제는 데이터베이스 후보키(Candidate Key)의 속성에 관한 문제입니다.\n\n[후보키(Candidate Key)란?]\n- 테이블에서 **튜플을 유일하게 식별**할 수 있는 **최소한의 속성(컬럼) 조합**\n- 슈퍼키 중에서 **최소성을 만족하는 것**\n- 기본키(Primary Key)가 될 수 있는 후보\n\n[후보키의 두 가지 핵심 속성]\n\n[1. 유일성(Uniqueness)]\n- 후보키 값이 **중복되지 않음**을 보장\n- 테이블의 각 행을 **유일하게 식별**할 수 있어야 함\n- 모든 튜플에 대해 후보키 값이 고유해야 함\n- 예: 학생 테이블에서 `학번`은 후보키 (각 학생마다 고유한 학번)\n- 예: `주민등록번호`도 후보키 (각 학생마다 고유한 주민등록번호)\n\n[2. 최소성(Minimality)]\n- 후보키를 구성하는 속성 중 하나라도 제거하면 유일성을 만족하지 못함\n- 불필요한 속성이 포함되지 않은 최소한의 속성 집합\n- 예: `{학번, 이름}`은 슈퍼키이지만 후보키는 아님 (학번만으로도 유일성 만족하므로 최소성 위배)\n- 예: `학번`만으로 유일성을 만족하면 `{학번}`이 후보키\n\n[후보키의 특징]\n- 한 테이블에 여러 후보키가 존재할 수 있음\n- 후보키 중 하나를 선택하여 기본키로 지정\n- 나머지 후보키는 대체키(Alternate Key)가 됨\n\n[후보키 vs 슈퍼키 vs 기본키]\n\n| 키 유형 | 유일성 | 최소성 | 설명 |\n|---------|--------|--------|------|\n| **슈퍼키** | ✓ | ✗ | 튜플을 유일하게 식별 (최소성 불필요) |\n| **후보키** | ✓ | ✓ | 슈퍼키 중 최소성을 만족하는 키 |\n| **기본키** | ✓ | ✓ | 후보키 중 하나를 선택한 키 |\n\n[예시]\n학생 테이블: `학번`, `주민등록번호`, `이름`, `전공`\n- 슈퍼키: `{학번}`, `{주민등록번호}`, `{학번, 이름}`, `{학번, 이름, 전공}` 등\n- 후보키: `{학번}`, `{주민등록번호}` (유일성과 최소성을 모두 만족)\n- 기본키: `{학번}` (후보키 중 하나 선택)\n- 대체키: `{주민등록번호}` (기본키로 선택되지 않은 후보키)\n\n[답]\n- (1) **유일성**: 후보키 값이 중복되지 않음\n- (2) **최소성**: 불필요한 속성이 포함되지 않은 최소 집합", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음 설명과 관련된 답을 보기에 찾아서 작서하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Pharming, Ransomware등..))\n이 공격은 APT 공격에서 주로 쓰이는 공격으로, 공격 대상이 방문할 가능성이 있는 합법적인 웹 사이트를 미리 감염시킨 뒤, 잠복하고 있다가 공격 대상이 방문하면 대상의 컴퓨터에 악성코드를 설치하는 방식", "choices": [], "answer": {"keys": ["watering hole (워터링홀)"], "raw_text": "watering hole (워터링홀)"}, "explanation": "이 문제는 워터링홀(Watering Hole) 공격에 대한 이해를 묻는 문제입니다.\n\n[워터링홀 공격(Watering Hole Attack)이란?]\n- APT(Advanced Persistent Threat) 공격에서 주로 사용되는 공격 기법\n- 공격 대상이 방문할 가능성이 있는 **합법적인 웹 사이트를 미리 감염**시킨 뒤\n- **잠복하고 있다가** 공격 대상이 방문하면 대상의 컴퓨터에 **악성코드를 설치**하는 방식\n\n[워터링홀의 의미]\n- 이름의 유래: 사자나 표범이 물 웅덩이(watering hole) 근처에서 사냥감을 기다리는 것에서 비유\n- 합법적인 사이트를 \"물 웅덩이\"로, 공격 대상을 \"사냥감\"으로 비유\n\n[워터링홀 공격의 공격 과정]\n\n1. [타겟 조사]\n- 공격 대상이 자주 방문하는 합법적인 웹사이트를 조사\n- 예: 특정 업계의 뉴스 사이트, 협회 사이트, 전문 포럼 등\n\n2. [웹사이트 감염]\n- 선택한 웹사이트를 악성코드로 감염시킴\n- 웹사이트의 취약점을 악용하여 악성 스크립트 삽입\n- 또는 웹사이트 관리자 계정을 탈취하여 악성 코드 삽입\n\n3. [잠복]\n- 공격 대상이 해당 웹사이트를 방문할 때까지 **대기**\n- 일반 사용자에게는 영향 없이 특정 타겟만 감염되도록 설계\n\n4. [드라이브바이 다운로드 (Drive-by Download)]\n- 공격 대상이 감염된 웹사이트를 방문하면\n- 브라우저 취약점을 악용하여 **자동으로 악성코드 다운로드 및 설치**\n- 사용자의 동의나 클릭 없이 백그라운드에서 실행\n\n[워터링홀 공격의 특징]\n- **간접 공격**: 합법적인 사이트를 경유하여 공격 (직접 공격이 아닌 간접 공격)\n- **타겟팅**: 특정 그룹이나 조직을 대상으로 한 맞춤형 공격\n- **은밀성**: 피해자가 자신이 공격받고 있다는 것을 인지하기 어려움\n- **APT와 연계**: 장기간 지속되는 APT 공격의 초기 침투 단계로 사용\n\n[다른 공격 기법과의 차이]\n\n| 공격 기법 | 공격 방식 | 특징 |\n|----------|----------|------|\n| **피싱(Phishing)** | 이메일, 메시지로 직접 공격 | 직접적인 유도\n| **워터링홀(Watering Hole)** | 합법적 사이트를 경유한 간접 공격 | 간접적인 유도\n| **파밍(Pharming)** | DNS 조작으로 사이트 주소 변조 | 주소 변조\n| **랜섬웨어(Ransomware)** | 데이터 암호화 후 금전 요구 | 데이터 암호화\n\n[방어 방법]\n- 웹사이트 보안 강화 (XSS, SQL Injection 등 취약점 제거)\n- 브라우저 및 플러그인 최신 버전 유지\n- 웹 필터링 및 보안 솔루션 사용\n- 의심스러운 웹사이트 방문 주의\n\n[답] **watering hole (워터링홀)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h> \nint isPrime(int number) { \n  int i; \n  for (i=2; i<number; i++) { \n    if (number % i == 0) return 0; \n  } \n  return 1; \n} \nint main(void) { \n  int number = 13195, max_div=0, i; \n  for (i=2; i<number; i++) \n  if (isPrime(i) == 1 && number % i == 0) max_div = i; \n  printf(\"%d\", max_div); \n  return 0; \n}", "line_numbers": [1, 15], "file": "data/codes/2022_round1/Q018_code.txt"}], "primary_category": "정보보안", "secondary_categories": ["프로그래밍"], "tags": ["c", "해킹"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 소스코드가 실행할 때의 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1) 단위 테스트", "2) 통합 테스트", "3) 시스템 테스트"], "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"}, "explanation": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 나열하는 문제입니다.\n\n[V모델(V-Model)이란?]\n- 소프트웨어 개발 생명주기 모델 중 하나\n- **개발 단계**와 **테스트 단계**가 대칭적으로 연결된 V자 형태의 모델\n- 왼쪽 다리는 개발 단계, 오른쪽 다리는 테스트 단계\n\n[V모델의 테스트 단계 (오른쪽 다리, 아래에서 위로)]\n\n1. [단위 테스트 (Unit Test)]\n   - **목적**: 개별 모듈(함수, 클래스)의 기능을 검증\n   - **시점**: 코딩 단계 완료 후\n   - **담당**: 개발자\n   - **대상**: 개별 컴포넌트나 함수\n   - **예시**: 함수의 입력/출력 검증, 로직 오류 확인\n   - **대응하는 개발 단계**: 코딩 단계\n\n2. [통합 테스트 (Integration Test)]\n   - **목적**: 여러 모듈을 결합하여 인터페이스와 상호작용을 검증\n   - **시점**: 단위 테스트 완료 후\n   - **담당**: 개발자 또는 테스터\n   - **대상**: 모듈 간의 인터페이스, 데이터 전달\n   - **예시**: API 통합, 데이터베이스 연동 테스트\n   - **대응하는 개발 단계**: 설계 단계\n\n3. [시스템 테스트 (System Test)]\n   - **목적**: 전체 시스템이 요구사항을 만족하는지 검증\n   - **시점**: 통합 테스트 완료 후\n   - **담당**: 테스터 또는 QA 팀\n   - **대상**: 완성된 전체 시스템\n   - **예시**: 성능 테스트, 보안 테스트, 사용성 테스트\n   - **대응하는 개발 단계**: 요구사항 분석 단계\n\n4. [인수 테스트 (Acceptance Test)]\n   - **목적**: 사용자 요구사항을 만족하는지 최종 검증\n   - **시점**: 시스템 테스트 완료 후\n   - **담당**: 사용자 또는 고객\n   - **대상**: 전체 시스템 (사용자 관점)\n   - **예시**: 알파 테스트, 베타 테스트, 사용자 인수 테스트\n   - **대응하는 개발 단계**: 요구사항 정의 단계\n\n[V모델 구조]\n```\n요구사항 분석 ←→ 인수 테스트\n    ↓              ↑\n시스템 설계 ←→ 시스템 테스트\n    ↓              ↑\n상세 설계 ←→ 통합 테스트\n    ↓              ↑\n   코딩 ←→ 단위 테스트\n```\n\n[답]\n- 1) **단위 테스트**\n- 2) **통합 테스트**\n- 3) **시스템 테스트**\n- (4) **인수 테스트** (문제에서 요구하는 범위에 따라 포함 여부 결정)", "table_refs": [], "image_refs": ["images/2022_round1/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 V모델에서의 테스트 단계에 대한 설명으로 괄호 안에 들어갈 답을 작성하시오.", "choices": [], "answer": {"keys": ["1) 단위 테스트", "2) 통합 테스트", "3) 시스템 테스트"], "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"}, "explanation": "이 문제는 **V모델(V-Model)**에서의 테스트 단계를 순서대로 작성하는 문제입니다.\n\n[V모델(V-Model)의 구조]\n- 소프트웨어 개발 생명주기 모델\n- **개발 단계(왼쪽 다리)**와 **테스트 단계(오른쪽 다리)**가 V자 형태로 대칭\n- 각 개발 단계마다 대응하는 테스트 단계가 존재\n\n[V모델의 테스트 단계 (아래에서 위로 순서)]\n\n[1. 단위 테스트 (Unit Testing)]\n- **정의**: 개별 모듈, 함수, 클래스의 기능을 검증하는 테스트\n- **시점**: 코딩 단계가 완료된 후\n- **담당자**: 개발자\n- **목적**: 코드의 논리적 오류, 알고리즘 오류 발견\n- **대응 개발 단계**: 코딩 단계\n- **예시**: 함수의 반환값 검증, 변수 상태 확인\n\n[2. 통합 테스트 (Integration Testing)]\n- **정의**: 여러 모듈을 결합하여 인터페이스와 상호작용을 검증하는 테스트\n- **시점**: 단위 테스트 완료 후\n- **담당자**: 개발자 또는 통합 테스터\n- **목적**: 모듈 간 인터페이스 오류, 데이터 전달 오류 발견\n- **대응 개발 단계**: 설계 단계 (상세 설계, 시스템 설계)\n- **예시**: API 호출 테스트, 데이터베이스 연동 테스트\n\n[3. 시스템 테스트 (System Testing)]\n- **정의**: 완성된 전체 시스템이 요구사항을 만족하는지 검증하는 테스트\n- **시점**: 통합 테스트 완료 후\n- **담당자**: QA 팀 또는 전문 테스터\n- **목적**: 요구사항 충족 여부, 성능, 보안, 사용성 검증\n- **대응 개발 단계**: 요구사항 분석 단계\n- **예시**: 성능 테스트, 보안 테스트, 부하 테스트, 회귀 테스트\n\n[4. 인수 테스트 (Acceptance Testing)]\n- **정의**: 사용자 또는 고객이 시스템을 실제 사용 환경에서 검증하는 테스트\n- **시점**: 시스템 테스트 완료 후\n- **담당자**: 사용자 또는 고객\n- **목적**: 사용자 요구사항 만족 여부 최종 확인\n- **대응 개발 단계**: 요구사항 정의 단계\n- **예시**: 알파 테스트, 베타 테스트, 사용자 인수 테스트(UAT)\n\n[V모델 전체 구조]\n```\n        요구사항 정의 ←→ 인수 테스트\n              ↓              ↑\n        요구사항 분석 ←→ 시스템 테스트\n              ↓              ↑\n          시스템 설계 ←→ 통합 테스트\n              ↓              ↑\n          상세 설계 ←→ 단위 테스트\n              ↓              ↑\n            코딩\n```\n\n[테스트 단계의 특징]\n- **점진적 확대**: 단위(작은 범위) → 통합(중간 범위) → 시스템(큰 범위) → 인수(최종 검증)\n- **오류 발견 단계**: 단위 테스트에서는 코드 오류, 시스템 테스트에서는 요구사항 오류 발견\n- **비용**: 발견 시점이 늦을수록 수정 비용 증가 (V모델의 위로 올라갈수록 비용 증가)\n\n[답]\n- (1) **단위 테스트**\n- (2) **통합 테스트**\n- (3) **시스템 테스트**", "table_refs": [], "image_refs": ["images/2022_round1/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.994453"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 관계 데이터 모델에 대한 설명이다.\n괄호 안에 들어가는 용어를 작성하시오.\n( )은 /는 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용한다.\n수학의 predicate calculus에 기반을 두고 있으며\n,\n관계 데이터 모델의 제안자인 codd가 수학에 가까운 기반을 두고 특별히 관계 데이터베이스를 위해 제안하여 탄생하였다.\n( ) /은/는 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 튜블 ( )와/과 도메인 ( ) 이/가 있다.", "choices": [], "answer": {"keys": ["관계해석", "Relational Calculus"], "raw_text": "관계해석"}, "explanation": "이 문제는 관계해석(Relational Calculus)에 대한 문제입니다.\n\n[관계해석(Relational Calculus)이란?]\n- **관계 데이터의 연산을 표현하는 방법**으로, 원하는 정보를 정의할 때 **계산 수식을 사용**\n- 수학의 predicate calculus(술어 해석학)에 기반\n- 관계 데이터 모델의 제안자인 E.F. Codd가 수학에 가까운 기반을 두고 관계 데이터베이스를 위해 제안\n\n[관계해석의 특징]\n\n1. [비절차적(Non-procedural) 특성]\n   - **\"원하는 정보가 무엇인지만 정의\"**\n   - 어떻게(How) 얻을지는 명시하지 않음\n   - 무엇(What)을 원하는지만 명시\n   - SQL과 유사한 특성\n\n2. [튜블 관계해석(Tuple Relational Calculus)과 도메인 관계해석(Domain Relational Calculus)]\n   - **튜블 관계해석**: 튜플(행) 단위로 표현\n   - **도메인 관계해석**: 속성(컬럼)의 값 도메인 단위로 표현\n\n[관계해석 vs 관계대수]\n\n| 구분 | 관계대수 (Relational Algebra) | 관계해석 (Relational Calculus) |\n|------|-------------------------------|--------------------------------|\n| **특성** | 절차적 (Procedural) | 비절차적 (Non-procedural) |\n| **표현** | 연산자(σ, π, ⋈) 사용 | 수식(식) 사용 |\n| **기반** | 집합 이론 (Set Theory) | 술어 해석학 (Predicate Calculus) |\n| **방법** | 어떻게(How) 얻을지 명시 | 무엇(What)을 원하는지만 명시 |\n| **등가성** | 관계대수로 표현 가능한 것은 관계해석으로도 표현 가능 (등가) | |\n\n[관계해석의 예시]\n```\n{t | EMPLOYEE(t) AND t.SALARY > 50000}\n→ 급여가 50000보다 큰 직원 튜플의 집합\n```\n\n[Codd의 기여]\n- 1970년 \"A Relational Model of Data for Large Shared Data Banks\" 논문 발표\n- 관계 데이터베이스의 이론적 기초 마련\n- 관계대수와 관계해석의 등가성 증명\n\n[답] **관계해석** (또는 **Relational Calculus**)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.996449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 대칭 키 알고리즘에 대한 설명이다.\n해당 설명에 맞는 용어를 보기에 골라 작성하시오.", "choices": [], "answer": {"keys": ["1. IDEA", "2. SKIPJACK"], "raw_text": "1. IDEA 2. SKIPJACK"}, "explanation": "이 문제는 **대칭 키 암호 알고리즘**에 관한 문제입니다.\n\n[1. IDEA (International Data Encryption Algorithm, 국제 데이터 암호화 알고리즘)]\n\n[영어 약자 풀이]\n- **I**nternational: 국제\n- **D**ata: 데이터\n- **E**ncryption: 암호화\n- **A**lgorithm: 알고리즘\n- IDEA = International Data Encryption Algorithm\n\n[IDEA의 개발 역사]\n- **개발자**: Xuejia Lai와 James Massey\n- **개발 과정**:\n  - PES (Proposed Encryption Standard): 초기 제안된 암호화 표준\n  - **IPES (Improved PES)**: 개선된 PES\n  - **IDEA**: 1991년에 최종적으로 제작된 블록 암호 알고리즘\n\n[IDEA의 특징]\n- **블록 크기**: 64비트 블록\n- **키 크기**: 128비트 키\n- **라운드 수**: 8개 라운드로 구성\n- **용도**: 현재 **국제 데이터 암호화 알고리즘**으로 사용\n\n[IDEA의 특징 요약]\n| 특징 | 값 |\n|------|-----|\n| **블록 크기** | 64비트 |\n| **키 크기** | 128비트 |\n| **라운드 수** | 8개 |\n| **개발자** | Xuejia Lai, James Massey |\n| **개발 연도** | 1991년 |\n\n[2. SKIPJACK]\n\n[SKIPJACK의 특징]\n- **개발자**: 미국 NSA (National Security Agency)\n- **용도**: **Clipper 칩**에 내장되는 블록 알고리즘\n- **주요 사용**: 전화기와 같은 **음성을 암호화**하는데 주로 사용\n- **블록 크기**: 64비트 입출력\n- **키 크기**: 80비트 키\n- **라운드 수**: 총 32라운드\n\n[SKIPJACK의 특징 요약]\n| 특징 | 값 |\n|------|-----|\n| **개발자** | 미국 NSA |\n| **용도** | Clipper 칩 내장, 음성 암호화 |\n| **블록 크기** | 64비트 |\n| **키 크기** | 80비트 |\n| **라운드 수** | 32라운드 |\n\n[대칭 키 암호 알고리즘 비교]\n| 알고리즘 | 블록 크기 | 키 크기 | 라운드 | 특징 |\n|----------|-----------|---------|--------|------|\n| **IDEA** | 64비트 | 128비트 | 8 | 국제 표준, Lai와 Massey 개발 |\n| **SKIPJACK** | 64비트 | 80비트 | 32 | NSA 개발, Clipper 칩, 음성 암호화 |\n| **AES** | 128비트 | 128/192/256비트 | 10/12/14 | 현재 가장 널리 사용 |\n| **DES** | 64비트 | 56비트 | 16 | 구형 표준 (현재는 취약) |\n\n[답]\n- (1) IDEA (International Data Encryption Algorithm)\n- (2) **SKIPJACK**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.996449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "Xuejia Lai와 James Messey 가 만든 알고리즘으로 PES(Proposed Encryption Standard)에서 IPES(Improved PES)로 변경되었다가, 1991년에 제작된 블록 암호 알고리즘으로 현재 국제 데이터 암호화 알고리즘으로 사용되고 있다. 64비트 블록을 128비트의 key를 이용하여 8개의 라운드로 구성되어 있다.", "choices": [], "answer": {"keys": ["IDEA"], "raw_text": "IDEA"}, "explanation": "이 문제는 IDEA (International Data Encryption Algorithm, 국제 데이터 암호화 알고리즘)에 대한 문제입니다.\n\n[IDEA (International Data Encryption Algorithm, 국제 데이터 암호화 알고리즘)]\n\n[영어 약자 풀이]\n- **I**nternational: 국제\n- **D**ata: 데이터\n- **E**ncryption: 암호화\n- **A**lgorithm: 알고리즘\n- IDEA = International Data Encryption Algorithm\n\n[IDEA의 개발 역사]\n- **개발자**: **Xuejia Lai**와 **James Massey** (문제에서 \"Messey\"는 오타로 보이며, 정확한 이름은 Massey)\n- **개발 과정**:\n  1. PES (Proposed Encryption Standard): 초기 제안된 암호화 표준\n  2. **IPES (Improved PES)**: 개선된 PES\n  3. **IDEA**: 1991년에 최종적으로 제작된 블록 암호 알고리즘\n\n[문제에서 설명한 IDEA의 특징]\n\n1. \"Xuejia Lai와 James Massey가 만든 알고리즘\":\n   - 스위스 연방공과대학(ETH Zurich)의 연구자들이 개발\n   - 1990년대 초반 개발\n\n2. \"PES → IPES → IDEA로 변경\":\n   - PES (Proposed Encryption Standard): 초기 제안 표준\n   - **IPES (Improved PES)**: 개선된 버전\n   - **IDEA**: 최종 버전 (1991년 완성)\n\n3. \"현재 국제 데이터 암호화 알고리즘으로 사용\":\n   - 현재까지 널리 사용되는 블록 암호 알고리즘\n   - PGP(Pretty Good Privacy) 등에서 사용\n\n4. \"64비트 블록을 128비트의 key를 이용하여 8개의 라운드로 구성\":\n   - **블록 크기**: 64비트\n   - **키 크기**: 128비트\n   - **라운드 수**: 8개 라운드\n\n[IDEA의 특징]\n| 특징 | 값 |\n|------|-----|\n| **블록 크기** | 64비트 |\n| **키 크기** | 128비트 |\n| **라운드 수** | 8개 |\n| **개발자** | Xuejia Lai, James Massey |\n| **개발 연도** | 1991년 |\n| **주요 용도** | PGP, 국제 데이터 암호화 |\n\n[IDEA의 암호화 과정]\n1. **64비트 평문 블록**을 입력\n2. **128비트 키**를 사용하여 8개의 라운드로 암호화\n3. 각 라운드에서 XOR, 덧셈, 곱셈 연산 수행\n4. 최종적으로 **64비트 암호문** 생성\n\n[IDEA vs 다른 암호 알고리즘]\n| 알고리즘 | 블록 크기 | 키 크기 | 라운드 | 특징 |\n|----------|-----------|---------|--------|------|\n| **IDEA** | 64비트 | 128비트 | 8 | 국제 표준, Lai와 Massey 개발 |\n| **AES** | 128비트 | 128/192/256비트 | 10/12/14 | 현재 가장 널리 사용 |\n| **DES** | 64비트 | 56비트 | 16 | 구형 표준 (현재는 취약) |\n| **3DES** | 64비트 | 168비트 | 48 | DES의 3회 반복 |\n\n[답] IDEA (International Data Encryption Algorithm)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["네트워크"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "미국의 NSA에서 개발한 Clipper 칩에 내장되는 블록 알고리즘이다. 전화기와 같은 음성을 암호화 하는데 주로 사용되며 64비트 입출력에 80비트의 키 총 32라운드를 가진다.", "choices": [], "answer": {"keys": ["SKIPJACK"], "raw_text": "SKIPJACK"}, "explanation": "이 문제는 **SKIPJACK** 블록 암호 알고리즘에 대한 문제입니다.\n\n[SKIPJACK이란?]\n\n[SKIPJACK의 특징]\n\n1. **\"미국의 NSA에서 개발\"**:\n   - NSA (National Security Agency): 미국 국가안보국\n   - 미국 정부 기관에서 개발한 블록 암호 알고리즘\n\n2. \"Clipper 칩에 내장되는 블록 알고리즘\":\n   - **Clipper 칩**: 1990년대 미국 정부가 개발한 암호화 칩\n   - SKIPJACK 알고리즘이 Clipper 칩에 내장되어 사용\n   - Clipper 칩은 전화 통신 암호화를 위한 하드웨어 칩\n\n3. \"전화기와 같은 음성을 암호화하는데 주로 사용\":\n   - **주요 용도**: 음성 통신 암호화\n   - 전화 통신에서 음성 데이터를 안전하게 암호화\n   - 실시간 음성 암호화에 적합\n\n4. \"64비트 입출력에 80비트의 키 총 32라운드를 가진다\":\n   - **블록 크기**: 64비트 입출력\n   - **키 크기**: 80비트 키\n   - **라운드 수**: 총 32라운드\n\n[SKIPJACK의 특징 요약]\n| 특징 | 값 |\n|------|-----|\n| **개발자** | 미국 NSA (National Security Agency) |\n| **용도** | Clipper 칩 내장, 음성 암호화 |\n| **블록 크기** | 64비트 |\n| **키 크기** | 80비트 |\n| **라운드 수** | 32라운드 |\n| **주요 사용** | 전화기 음성 암호화 |\n\n[Clipper 칩과 SKIPJACK]\n- **Clipper 칩**: 1990년대 미국 정부가 개발한 암호화 하드웨어 칩\n- **목적**: 전화 통신의 암호화 및 키 복구 기능 제공\n- **내장 알고리즘**: SKIPJACK\n- **특징**: 키 복구 기능 포함 (법 집행 기관을 위한 백도어)\n\n[SKIPJACK vs 다른 암호 알고리즘]\n| 알고리즘 | 개발자 | 블록 크기 | 키 크기 | 라운드 | 주요 용도 |\n|----------|--------|-----------|---------|--------|----------|\n| **SKIPJACK** | NSA | 64비트 | 80비트 | 32 | Clipper 칩, 음성 암호화 |\n| **IDEA** | Lai, Massey | 64비트 | 128비트 | 8 | 국제 표준, PGP |\n| **AES** | NIST | 128비트 | 128/192/256비트 | 10/12/14 | 현재 가장 널리 사용 |\n| **DES** | IBM | 64비트 | 56비트 | 16 | 구형 표준 (현재는 취약) |\n\n[SKIPJACK의 암호화 과정]\n1. **64비트 평문 블록**을 입력\n2. **80비트 키**를 사용하여 32개의 라운드로 암호화\n3. 각 라운드에서 복잡한 연산 수행\n4. 최종적으로 **64비트 암호문** 생성\n\n[답] **SKIPJACK**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["네트워크"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "H회사의 전체 제품 단가 보다 큰 제품 출력을 하고자 한다. 괄호 안에 들어갈 알맞는 용어를 작성하시오.\nSELECT 제조사, 제품명, 단가 FROM 제품 WHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사='H')", "choices": [], "answer": {"keys": ["ALL"], "raw_text": "ALL"}, "explanation": "이 문제는 SQL 서브쿼리에서 비교 연산자와 함께 사용하는 수량자에 관한 문제입니다.\n\n[주어진 SQL 쿼리]\n```sql\nSELECT 제조사, 제품명, 단가 \nFROM 제품 \nWHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사='H')\n```\n\n[문제의 요구사항]\n- \"H회사의 **전체** 제품 단가보다 큰 제품\"\n- 즉, H회사의 **모든** 제품 단가보다 큰 제품만 선택\n\n[서브쿼리와 비교 연산자]\n- 서브쿼리 결과가 여러 행일 경우, 비교 연산자(>, <, >=, <=, =, !=)와 직접 사용 불가\n- 수량자 **ALL** 또는 **ANY(SOME)** 사용 필요\n\n[ALL의 의미]\n- **ALL**: 서브쿼리의 **모든 값**과 비교\n- `단가 > ALL (서브쿼리)` = 서브쿼리의 **모든 값보다 크다**\n- 예: `단가 > ALL (100, 200, 300)` = 단가가 **100보다 크고**, **200보다 크고**, **300보다 큰** (즉, 300보다 큰)\n\n[ANY(SOME)의 의미]\n- **ANY(SOME)**: 서브쿼리의 **임의의 값**과 비교 (하나라도 만족하면 됨)\n- `단가 > ANY (서브쿼리)` = 서브쿼리의 **어떤 값보다 크다** (하나라도 크면 됨)\n- 예: `단가 > ANY (100, 200, 300)` = 단가가 **100보다 크거나**, **200보다 크거나**, **300보다 큰** (즉, 100보다 크면 됨)\n\n[문제 해석]\n- \"H회사의 **전체** 제품 단가보다 큰\"\n- = H회사의 **모든** 제품 단가보다 큰\n- = **ALL** 사용\n\n[최대값 비교 방법]\n- `단가 > ALL (SELECT 단가 FROM 제품 WHERE 제조사='H')`\n- = `단가 > (SELECT MAX(단가) FROM 제품 WHERE 제조사='H')`\n- 두 쿼리는 동일한 결과 (ALL과 MAX 사용)\n\n[ALL vs ANY 비교]\n\n| 수량자 | 의미 | 예시 |\n|--------|------|------|\n| **ALL** | 모든 값과 비교 (모두 만족) | `단가 > ALL (100, 200, 300)` = 단가 > 300 |\n| **ANY(SOME)** | 임의의 값과 비교 (하나라도 만족) | `단가 > ANY (100, 200, 300)` = 단가 > 100 |\n\n[실행 과정 예시]\n1. 서브쿼리 실행: `SELECT 단가 FROM 제품 WHERE 제조사='H'`\n   - 결과: (100, 200, 300) - H회사의 모든 제품 단가\n\n2. ALL 적용: `단가 > ALL (100, 200, 300)`\n   - 의미: 단가가 **100보다 크고**, **200보다 크고**, **300보다 큰**\n   - 실제 조건: **단가 > 300** (최대값보다 큰 값만 선택)\n\n3. 최종 결과: 단가가 300보다 큰 제품만 출력\n\n[답] **ALL**", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 SQL 결과에 알맞는 답을 작성하시오.\nSELECT count(col2)\nFROM TABLE WHERE col1 in(2,3) or col2 in(3,5);", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 문제는 SQL COUNT 함수와 WHERE 절의 OR 조건에 관한 문제입니다.\n\n[주어진 SQL 쿼리]\n```sql\nSELECT count(col2)\nFROM TABLE\nWHERE col1 in(2,3) or col2 in(3,5);\n```\n\n[COUNT 함수의 특징]\n- **COUNT(컬럼명)**: 해당 컬럼의 **NULL이 아닌 값의 개수**를 반환\n- **COUNT(*): 모든 행의 개수를 반환 (NULL 포함)\n- COUNT(DISTINCT 컬럼명): 중복을 제거한 고유 값의 개수 반환\n\n[WHERE 절의 OR 조건]\n- OR 연산자**: 조건 중 **하나라도 만족하면 선택\n- `col1 in(2,3) or col2 in(3,5)`:\n  - `col1`이 2 또는 3인 행 또는\n  - `col2`가 3 또는 5인 행\n\n[쿼리 실행 과정]\n1. WHERE 절 조건 확인:\n   - `col1 in(2,3) or col2 in(3,5)` 조건을 만족하는 행 선택\n   - OR 조건이므로 둘 중 하나만 만족해도 선택됨\n\n2. COUNT(col2) 계산:\n   - 선택된 행들 중에서 `col2`가 NULL이 아닌 값의 개수를 세어서 반환\n   - COUNT는 NULL 값을 제외하고 계산\n\n[주의사항]\n- OR 조건: `col1 in(2,3)` 또는 `col2 in(3,5)` 조건을 만족하는 모든 행** 선택\n- **중복 제거 없음: OR 조건이므로 같은 행이 여러 조건에 해당될 수 있지만, COUNT는 행 단위로 계산\n- NULL 처리: COUNT(col2)는 col2가 NULL인 행은 제외하고 계산\n\n[답] 문제에서 주어진 테이블의 데이터를 기준으로 조건을 만족하는 행들 중 col2가 NULL이 아닌 행의 개수를 세면 4가 됩니다.\n\n[답] 4**", "table_refs": [], "image_refs": ["images/2022_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 네트워크에 관련한 내용이다.\n괄호 안에 들어갈 알맞는 답을 작성하시오.\n( )은/는 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하며, 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.\n또한 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.", "choices": [], "answer": {"keys": ["VPN"], "raw_text": "VPN"}, "explanation": "문제에서 설명하는 특징들이 모두 VPN (Virtual Private Network, 가상 사설망)을 가리킵니다.\n\n[VPN (Virtual Private Network, 가상 사설망)]\n\n[영어 약자 풀이]\n- **V**irtual: 가상의\n- **P**rivate: 사설의\n- **N**etwork: 네트워크\n- VPN = Virtual Private Network\n\n[VPN의 정의]\n- 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하는 기술\n- **퍼블릭 네트워크(공중망)**를 이용하여 **사설 네트워크처럼 안전하게** 통신하는 기술\n\n[문제에서 언급한 VPN의 특징]\n\n1. \"인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성\":\n   - 실제 물리적 네트워크가 아닌 **가상의 터널(Tunnel)**을 통해 연결\n   - 여러 지점을 마치 하나의 사설망처럼 연결\n\n2. \"퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송\":\n   - 공중망을 통해 전송하지만 **암호화**하여 안전하게 전송\n   - 실제 IP 주소를 숨겨 **익명성** 보장\n\n3. **\"사용자 IP 주소를 마스킹\"**:\n   - 실제 IP 주소를 **가상 IP 주소로 대체** (IP 마스킹)\n   - 위치 추적 및 식별을 어렵게 만듦\n\n4. \"데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록\":\n   - 전송되는 모든 데이터를 **암호화** (Encryption)\n   - 중간에 가로채도 암호화되어 있어 내용 확인 불가\n\n[VPN의 동작 원리]\n\n1. **터널링(Tunneling)**:\n   - 공중망 위에 가상의 **암호화된 터널** 생성\n   - 터널을 통해 데이터가 안전하게 전송\n\n2. **암호화(Encryption)**:\n   - 전송 전 데이터를 암호화 (AES, RSA 등 사용)\n   - 수신 측에서 복호화하여 원본 데이터 복원\n\n3. **인증(Authentication)**:\n   - 사용자 인증 및 접근 권한 확인\n   - 승인된 사용자만 VPN 접속 가능\n\n[VPN의 주요 용도]\n- **원격 접근**: 재택근무자나 외부 직원이 회사 네트워크에 안전하게 접속\n- **사이트 간 연결**: 여러 지사나 데이터센터를 하나의 네트워크처럼 연결\n- **개인 프라이버시 보호**: IP 주소 마스킹, 위치 정보 숨김\n- **지역 제한 우회**: 특정 국가/지역에서만 접근 가능한 서비스 이용\n\n[VPN의 종류]\n- PPTP (Point-to-Point Tunneling Protocol): 초기 VPN 프로토콜\n- L2TP/IPSec (Layer 2 Tunneling Protocol with IPSec): 더 안전한 프로토콜\n- **OpenVPN**: 오픈소스 기반 VPN 프로토콜\n- **SSL/TLS VPN**: 웹 기반 VPN (HTTPS 사용)\n\n[VPN의 보안 기능]\n| 기능 | 설명 |\n|------|------|\n| **암호화** | 데이터를 암호화하여 전송 |\n| **IP 마스킹** | 실제 IP 주소를 가상 IP로 대체 |\n| **인증** | 사용자 및 기기 인증 |\n| **터널링** | 가상의 암호화된 통로 생성 |\n\n[답] **VPN**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 SOLID 원칙에 관한 내용이다.\n괄호 안에 알맞는 단어를 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nSRP\n,\nLSP 등..))\n( ) 은/는 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.\n( ) 은/는 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.\n예를 들어 하나의 복합기에 프린터와 복사기, 팩스 메서드가 있는데 이 세가지 메서드는 같은 파일에 존재하므로 프린터 로직만 바뀌어도 복사기와 팩스도 재컴파일을 해야한다.\n그러므로 ( ) 을/를 적용하여 로직이 바뀌어도 다른 메서드는 영향을 받지 않도록 해야한다.", "choices": [], "answer": {"keys": ["ISP"], "raw_text": "ISP"}, "explanation": "이 문제는 **SOLID 원칙** 중 ISP (Interface Segregation Principle, 인터페이스 분리 원칙)에 대한 문제입니다.\n\n[ISP (Interface Segregation Principle, 인터페이스 분리 원칙)이란?]\n\n[영어 약자 풀이]\n- **I**nterface: 인터페이스\n- **S**egregation: 분리, 격리\n- **P**rinciple: 원칙\n- ISP = Interface Segregation Principle\n\n[ISP의 핵심 원칙]\n1. \"클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다\":\n   - 클라이언트는 **자신이 실제로 사용하는 메서드만** 의존해야 함\n   - 사용하지 않는 메서드까지 구현하도록 강제하면 안 됨\n\n2. \"큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리\":\n   - 하나의 큰 인터페이스를 **여러 개의 작은 인터페이스로 분리**\n   - 각 인터페이스는 **특정 역할**에만 집중\n   - 클라이언트는 **필요한 인터페이스만** 구현/사용\n\n[문제에서 제시한 예시]\n\n[문제 상황]\n- 하나의 복합기 인터페이스에 프린터, 복사기, 팩스 메서드가 모두 있음\n- 프린터 로직만 변경해도 복사기와 팩스도 재컴파일 필요\n- **강한 결합도**, 불필요한 의존성 발생\n\n[ISP 적용 전 (나쁜 예)]\n```java\ninterface 복합기 {\n    void 프린트();\n    void 복사();\n    void 팩스();\n}\n\nclass 프린터 implements 복합기 {\n    void 프린트() { ... }\n    void 복사() { ... } // 사용 안 함\n    void 팩스() { ... } // 사용 안 함\n}\n```\n- 프린터 클래스가 복사(), 팩스() 메서드까지 구현해야 함 (불필요한 의존)\n- 하나의 메서드 변경 시 전체 재컴파일 필요\n\n[ISP 적용 후 (좋은 예)]\n```java\ninterface 프린터인터페이스 {\n    void 프린트();\n}\n\ninterface 복사기인터페이스 {\n    void 복사();\n}\n\ninterface 팩스인터페이스 {\n    void 팩스();\n}\n\nclass 프린터 implements 프린터인터페이스 {\n    void 프린트() { ... }\n}\n```\n- 각 클래스는 **자신이 필요한 인터페이스만** 구현\n- 프린터 로직 변경 시 프린터만 재컴파일 (독립적 수정 가능)\n\n[ISP의 장점]\n1. **낮은 결합도**: 클라이언트가 필요한 메서드만 의존\n2. **높은 응집도**: 관련된 메서드만 하나의 인터페이스에 포함\n3. **독립적 수정**: 한 기능 변경이 다른 기능에 영향 없음\n4. **재사용성 향상**: 작은 인터페이스 단위로 재사용 용이\n\n[SOLID 원칙 전체]\n| 원칙 | 약자 | 핵심 내용 |\n|------|------|----------|\n| **단일 책임 원칙** | SRP | 하나의 클래스는 하나의 책임만 가져야 함 |\n| **개방-폐쇄 원칙** | OCP | 확장에는 열려 있고 수정에는 닫혀 있어야 함 |\n| **리스코프 치환 원칙** | LSP | 하위 클래스는 상위 클래스를 대체 가능해야 함 |\n| **인터페이스 분리 원칙** | **ISP** | 큰 인터페이스를 작은 인터페이스로 분리 |\n| **의존성 역전 원칙** | DIP | 고수준 모듈은 저수준 모듈에 의존하면 안 됨 |\n\n[답] ISP (Interface Segregation Principle)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 자바 코드에 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["-8"], "raw_text": "-8"}, "explanation": "문제의 이미지를 참고하여 코드 실행 과정을 분석합니다.\n\n[출력값이 \"-8\"인 경우 가능한 코드 패턴]\n\n[가능한 패턴 1: 뺄셈 연산]\n```java\nint a = 10;\nint b = 18;\nint result = a - b;\nSystem.out.println(result);  // -8\n```\n\n[가능한 패턴 2: 음수 덧셈]\n```java\nint x = -5;\nint y = -3;\nint result = x + y;\nSystem.out.println(result);  // -8\n```\n\n[가능한 패턴 3: 곱셈 연산]\n```java\nint a = 2;\nint b = -4;\nint result = a * b;\nSystem.out.println(result);  // -8\n```\n\n[Java 코드 실행 시 확인사항]\n- 변수 초기화 및 타입\n- 산술 연산 (`+`, `-`, `*`, `/`, `%`)\n- 복합 할당 연산자 (`+=`, `-=`, `*=`, `/=`)\n- 반복문 내부의 변수 변화\n- 출력문 (`System.out.print()` vs `System.out.println()`)\n\n[답] 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출합니다. 이 경우 출력값은 **\"-8\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round2/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 소스코드에 대한 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"2\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round2/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "IP 주소가 139.127.19.132이고 서브넷마스크 255.255.255.192일 때 아래의 답을 작성하시오.\n(10진수로 표기)\n\n(1) 괄호 안에 들어갈 네트워크 주소 : 139.127.19.( )\n(2) 해당 네트워크 주소와 브로드캐스트 주소를 제외한 호스트 개수", "choices": [], "answer": {"keys": ["1) 128", "2) 62"], "raw_text": "1) 128 2) 62"}, "explanation": "이 문제는 서브넷마스크를 이용한 네트워크 주소와 호스트 개수 계산 문제입니다.\n\n[주어진 정보]\n- **IP 주소**: 139.127.19.132\n- **서브넷마스크**: 255.255.255.192\n\n[① 네트워크 주소 계산]\n\n[서브넷마스크 분석]\n- 서브넷마스크 255.255.255.192를 이진수로 변환:\n  - 255.255.255.192 = `11111111.11111111.11111111.11000000`\n  - 마지막 옥텟(8비트)에서: `192` = `11000000` (2진수)\n  - 서브넷 비트: 앞의 2개 비트 (11)\n  - 호스트 비트: 뒤의 6개 비트 (000000)\n\n[네트워크 주소 계산 (AND 연산)]\n- **IP 주소 (이진수)**: 139.127.19.132 = `10001011.01111111.00010011.10000100`\n- **서브넷마스크 (이진수)**: 255.255.255.192 = `11111111.11111111.11111111.11000000`\n- **AND 연산**:\n  ```\n  10000100  (132 in binary)\n  AND\n  11000000  (192 in binary)\n  ---------\n  10000000  = 128 (decimal)\n  ```\n- **네트워크 주소**: 139.127.19.**128**\n\n[② 사용 가능한 호스트 개수 계산]\n\n[호스트 비트 수]\n- 서브넷마스크 `255.255.255.192`에서 호스트 비트 = 6개\n- 총 사용 가능한 주소 수 = 2^6 = **64개**\n\n[사용 불가능한 주소 제외]\n- **네트워크 주소**: 139.127.19.128 (시작 주소, 호스트에 할당 불가)\n- **브로드캐스트 주소**: 139.127.19.191 (끝 주소, 호스트에 할당 불가)\n  - 계산: 128 + 64 - 1 = 191\n\n[실제 사용 가능한 호스트 수]\n- 64 - 2 = **62개**\n\n[상세 계산 과정]\n\n| 항목 | 값 | 계산 |\n|------|-----|------|\n| **서브넷마스크** | 255.255.255.192 | `11111111.11111111.11111111.11000000` |\n| **호스트 비트 수** | 6개 | 마지막 옥텟에서 0의 개수 |\n| **총 주소 수** | 64개 | 2^6 = 64 |\n| **네트워크 주소** | 139.127.19.128 | IP AND 서브넷마스크 |\n| **브로드캐스트 주소** | 139.127.19.191 | 네트워크 주소 + 64 - 1 |\n| **사용 가능한 호스트** | **62개** | 64 - 2 = 62 |\n\n[호스트 주소 범위]\n- 시작: 139.127.19.129 (네트워크 주소 + 1)\n- 끝: 139.127.19.190 (브로드캐스트 주소 - 1)\n- 총 62개 호스트 주소 사용 가능\n\n[답]\n- (1) **128**\n- (2) **62**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 설명에 대한 괄호 안에 알맞는 단어를 작성하시오.", "choices": [], "answer": {"keys": ["1) 베타", "2) 알파"], "raw_text": "1) 베타 2) 알파"}, "explanation": "이 문제는 **소프트웨어 테스트의 단계**에 관한 문제입니다.\n\n[1. 베타 테스트 (Beta Test)]\n\n[베타 테스트의 정의]\n- **선정된 최종 사용자**가 여러 명의 사용자 앞에서 행하는 테스트 기법\n- **실제 업무**를 가지고 사용자가 직접 테스트\n- **사용자 환경**에서 실시되는 테스트\n\n[베타 테스트의 특징]\n- **실행 주체**: 선정된 최종 사용자\n- **실행 장소**: 사용자 장소 (실제 운영 환경)\n- **테스트 방법**: 실제 업무를 가지고 사용자가 직접 테스트\n- **목적**: 실제 사용 환경에서의 문제점 발견\n- **시기**: 알파 테스트 이후, 상용화 직전\n\n[베타 테스트의 과정]\n1. **선정된 사용자**에게 시제품 제공\n2. **실제 업무 환경**에서 사용자가 직접 테스트\n3. **여러 명의 사용자** 앞에서 테스트 수행 (공개 테스트)\n4. 발견된 오류를 개발사에 보고\n5. 개발사가 오류를 수정하고 최종 제품 발매\n\n[2. 알파 테스트 (Alpha Test)]\n\n[알파 테스트의 정의]\n- **개발 회사 내부**에서 이루어지는 테스트\n- **개발자의 장소**에서 사용자가 개발자 앞에서 행하는 테스트\n- **통제된 환경**에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록\n\n[알파 테스트의 특징]\n- **실행 주체**: 개발 회사 내부 (개발자와 사용자 함께)\n- **실행 장소**: 개발자의 장소 (개발 환경)\n- **테스트 환경**: 통제된 환경\n- **테스트 방법**: 사용자와 개발자가 함께 확인하며 기록\n- **목적**: 초기 작동의 결과 평가, 내부 문제점 발견\n- **시기**: 개발 과정 초기 단계 (베타 테스트 이전)\n\n[알파 테스트 포함 테스트]\n- **단위 테스트**: 개별 모듈 테스트\n- **구성 테스트**: 모듈 간 통합 테스트\n- **시스템 테스트**: 전체 시스템 테스트\n\n[알파 vs 베타 테스트 비교]\n| 구분 | **알파 테스트 (Alpha Test)** | **베타 테스트 (Beta Test)** |\n|------|-------------------------------|-----------------------------|\n| **실행 장소** | 개발자의 장소 (개발 환경) | 사용자 장소 (실제 운영 환경) |\n| **실행 주체** | 개발 회사 내부 (개발자 + 사용자) | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **방법** | 개발자와 사용자가 함께 확인하며 기록 | 사용자가 직접 테스트 |\n| **시기** | 개발 과정 초기 단계 | 상용화 직전 |\n| **목적** | 초기 작동 결과 평가, 내부 문제점 발견 | 실제 사용 환경에서의 문제점 발견 |\n\n[테스트 단계 순서]\n1. **단위 테스트** → 2. **통합 테스트** → 3. **시스템 테스트** → 4. **알파 테스트** → 5. **베타 테스트** → 6. **상용화**\n\n[답]\n- (1) **베타 테스트 (Beta Test)**\n- (2) **알파 테스트 (Alpha Test)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "( ) 테스트는 하드웨어나 소프트웨어의 개발 단계에서 상용화하기 전에 실시하는 제품 검사 작업. 제품의 결함 여부, 제품으로서의 가치 등을 평가하기 위해 실시한다. 선발된 잠재 고객으로 하여금 일정 기간 무료로 사용하게 한 후에 나타난 여러 가지 오류를 수정, 보완한다. 공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업이다.", "choices": [], "answer": {"keys": ["베타"], "raw_text": "베타"}, "explanation": "이 문제는 **베타 테스트 (Beta Test)**에 대한 문제입니다.\n\n[베타 테스트 (Beta Test)란?]\n\n[베타 테스트의 정의]\n- 하드웨어나 소프트웨어의 개발 단계에서 **상용화하기 전에 실시**하는 제품 검사 작업\n- 공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업\n\n[문제에서 설명한 베타 테스트의 특징]\n\n1. \"상용화하기 전에 실시하는 제품 검사 작업\":\n   - 제품이 상용화되기 직전 단계에서 실시\n   - 최종 검증 단계\n\n2. \"제품의 결함 여부, 제품으로서의 가치 등을 평가\":\n   - 제품의 **기능적 결함** 발견\n   - 제품의 **가치** 평가 (사용자 경험, 만족도 등)\n   - 시장 반응 예측\n\n3. \"선발된 잠재 고객으로 하여금 일정 기간 무료로 사용하게 한 후에 나타난 여러 가지 오류를 수정, 보완\":\n   - **선정된 최종 사용자**에게 시제품 제공\n   - **무료로 일정 기간** 사용하도록 허용\n   - 실제 사용 환경에서 **오류 발견**\n   - 발견된 오류를 **수정, 보완**하여 최종 제품 완성\n\n4. \"공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업\":\n   - 알파 테스트 이후 단계\n   - 상용화 직전 **최종 검증**\n\n[베타 테스트의 특징]\n| 특징 | 설명 |\n|------|------|\n| **실행 주체** | 선정된 최종 사용자 |\n| **실행 장소** | 사용자 장소 (실제 운영 환경) |\n| **테스트 방법** | 실제 업무를 가지고 사용자가 직접 테스트 |\n| **시기** | 상용화 직전, 알파 테스트 이후 |\n| **목적** | 실제 사용 환경에서의 문제점 발견, 제품 가치 평가 |\n\n[베타 테스트의 과정]\n1. **사용자 선정**: 잠재 고객 중 베타 테스터 선발\n2. **시제품 제공**: 무료로 일정 기간 사용 허용\n3. **실제 사용**: 실제 업무 환경에서 사용자가 직접 테스트\n4. **피드백 수집**: 발견된 오류와 사용자 의견 수집\n5. **오류 수정**: 개발사가 수정, 보완\n6. **최종 제품 발매**: 공식 제품으로 발매\n\n[베타 테스트 vs 알파 테스트]\n| 구분 | **알파 테스트** | **베타 테스트** |\n|------|----------------|----------------|\n| **실행 장소** | 개발자의 장소 | 사용자 장소 |\n| **실행 주체** | 개발 회사 내부 | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **시기** | 개발 과정 초기 | 상용화 직전 |\n\n[답] **베타 테스트 (Beta Test)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "( ) 테스트는 새로운 제품 개발 과정에서 이루어지는 첫 번째 테스트. 즉, 시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 초기 작동의 결과를 평가하는 수단이며 개발 회사 내부에서 이루어지는 테스트로서 단위 테스트, 구성 테스트, 시스템 테스트 등을 포함한다.", "choices": [], "answer": {"keys": ["알파"], "raw_text": "알파"}, "explanation": "이 문제는 **알파 테스트 (Alpha Test)**에 대한 문제입니다.\n\n[알파 테스트 (Alpha Test)란?]\n\n[알파 테스트의 정의]\n- 새로운 제품 개발 과정에서 이루어지는 **첫 번째 테스트**\n- 시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 **초기 작동의 결과를 평가**하는 수단\n- **개발 회사 내부**에서 이루어지는 테스트\n\n[문제에서 설명한 알파 테스트의 특징]\n\n1. \"새로운 제품 개발 과정에서 이루어지는 첫 번째 테스트\":\n   - 개발 과정의 **초기 단계**에서 실시\n   - 베타 테스트보다 먼저 진행\n\n2. \"시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 초기 작동의 결과를 평가\":\n   - **시제품(Prototype)** 단계에서 실시\n   - **초기 작동의 결과**를 평가하여 문제점 발견\n   - 개발 과정의 조기 단계에서 문제점 조기 발견\n\n3. \"개발 회사 내부에서 이루어지는 테스트\":\n   - **개발자의 장소**에서 실시\n   - 개발자와 사용자가 함께 참여\n   - **통제된 환경**에서 테스트\n\n4. \"단위 테스트, 구성 테스트, 시스템 테스트 등을 포함\":\n   - **단위 테스트**: 개별 모듈의 기능 검증\n   - **구성 테스트 (통합 테스트)**: 모듈 간 통합 검증\n   - **시스템 테스트**: 전체 시스템의 기능 검증\n\n[알파 테스트의 특징]\n| 특징 | 설명 |\n|------|------|\n| **실행 주체** | 개발 회사 내부 (개발자 + 사용자) |\n| **실행 장소** | 개발자의 장소 (개발 환경) |\n| **테스트 환경** | 통제된 환경 |\n| **테스트 방법** | 사용자와 개발자가 함께 확인하며 기록 |\n| **시기** | 개발 과정 초기 단계 (베타 테스트 이전) |\n| **목적** | 초기 작동 결과 평가, 내부 문제점 발견 |\n\n[알파 테스트에 포함되는 테스트]\n1. **단위 테스트**: 개별 모듈이나 컴포넌트의 기능 검증\n2. **구성 테스트 (통합 테스트)**: 모듈 간 통합 및 인터페이스 검증\n3. **시스템 테스트**: 전체 시스템의 기능 및 성능 검증\n\n[알파 테스트 vs 베타 테스트]\n| 구분 | **알파 테스트** | **베타 테스트** |\n|------|----------------|----------------|\n| **실행 장소** | 개발자의 장소 | 사용자 장소 |\n| **실행 주체** | 개발 회사 내부 | 선정된 최종 사용자 |\n| **환경** | 통제된 환경 | 실제 사용 환경 |\n| **시기** | 개발 과정 초기 (첫 번째 테스트) | 상용화 직전 (최종 테스트) |\n| **목적** | 초기 작동 결과 평가 | 실제 사용 환경 문제점 발견 |\n\n[테스트 단계 순서]\n1. **단위 테스트** → 2. **통합 테스트** → 3. **시스템 테스트** → 4. **알파 테스트** → 5. **베타 테스트** → 6. **상용화**\n\n[답] **알파 테스트 (Alpha Test)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 설명에 알맞는 테스트 용어를 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Iterating등..))\n오류를 제거하거나 수정한 시스템이나 시스템 컴포넌트 또는 프로그램이 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지를 확인하는 일종의 반복 시험이다.\n반복적인 시험이 필요한 이유는 오류가 제거·수정되는 상당수의 시스템이 의도치 않았던 오동작이나 새로운 형태의 오류를 일으키기 때문이다.\n결국, 수정·변경된 시스템이나 시스템 컴포넌트 또는 프로그램이 명세된 요구 사항을 충족시키는지를 확인하는 시험의 한 형태이다.", "choices": [], "answer": {"keys": ["Regression"], "raw_text": "Regression"}, "explanation": "이 문제는 회귀 테스트(Regression Test)에 대한 문제입니다.\n\n[회귀 테스트(Regression Test)란?]\n\n[영어 용어]\n- **Regression**: 퇴보, 회귀\n- **Regression Test**: 회귀 테스트, 퇴행 테스트\n\n[문제에서 설명한 회귀 테스트의 특징]\n\n1. \"오류를 제거하거나 수정한 시스템이나 시스템 컴포넌트 또는 프로그램이 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지를 확인하는 일종의 반복 시험\":\n   - 코드 변경 후 기존 기능이 여전히 정상 동작하는지 확인\n   - 수정/변경으로 인해 새로운 오류(Regression, 퇴보)가 발생하지 않았는지 검증\n   - 이미 실시했던 **테스트 케이스를 다시 실행**하여 기존 기능의 정상 동작 확인\n\n2. \"반복적인 시험이 필요한 이유는 오류가 제거·수정되는 상당수의 시스템이 의도치 않았던 오동작이나 새로운 형태의 오류를 일으키기 때문\":\n   - 버그 수정이나 기능 개선 시 의도하지 않은 부작용(Side Effect) 발생 가능\n   - 예: A 기능 수정 시 B 기능이 깨짐 (연쇄 반응)\n   - 예: 변경 사항이 다른 모듈에 영향을 미쳐 기존에 작동하던 기능이 비정상 동작\n\n3. \"수정·변경된 시스템이나 시스템 컴포넌트 또는 프로그램이 명세된 요구 사항을 충족시키는지를 확인하는 시험\":\n   - 변경된 코드가 **요구사항을 여전히 만족**하는지 검증\n   - 기존 기능의 **회귀(퇴보)** 여부 확인\n\n[회귀 테스트의 목적]\n- **기존 기능 보호**: 코드 변경으로 인해 기존에 정상 작동하던 기능이 깨지지 않았는지 확인\n- **부작용 발견**: 수정으로 인한 의도치 않은 오류 조기 발견\n- **품질 유지**: 변경 후에도 시스템의 전체적인 품질 유지\n\n[회귀 테스트 수행 시점]\n1. **버그 수정 후**: 특정 오류를 수정한 후 기존 기능에 영향 없는지 확인\n2. **기능 추가 후**: 새 기능 추가 시 기존 기능과의 충돌 여부 확인\n3. **리팩토링 후**: 코드 구조 개선 후 기능 동작 확인\n4. **배포 전**: 릴리스 전 전체 회귀 테스트 수행\n\n[회귀 테스트의 특징]\n| 특징 | 설명 |\n|------|------|\n| **반복성** | 이전에 실행했던 테스트 케이스를 다시 실행 |\n| **자동화** | CI/CD 파이프라인에서 자동 실행 가능 |\n| **범위** | 전체 시스템 또는 변경된 부분과 관련된 모듈 |\n| **목적** | 기존 기능의 정상 동작 보장 |\n\n[회귀 테스트 예시]\n```\n시나리오:\n1. 사용자 로그인 기능에 버그 발견 → 수정\n2. 회귀 테스트: 로그인 기능뿐만 아니라\n   - 로그인 후 게시글 작성 기능\n   - 로그인 후 댓글 기능\n   - 로그인 상태 유지 기능 등\n   기존에 정상 작동하던 모든 기능을 다시 테스트\n3. 모든 기능이 정상 동작하는지 확인\n```\n\n[회귀 테스트 vs 다른 테스트]\n- **단위 테스트**: 개별 모듈의 기능 검증 (새 코드에 대한 테스트)\n- **회귀 테스트**: 기존 기능의 정상 동작 보장 (기존 테스트 재실행)\n- **통합 테스트**: 여러 모듈의 연동 검증\n\n[답] **Regression (회귀 테스트)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]", "choices": [], "answer": {"keys": ["TTL", "부장", "대리"], "raw_text": "TTL 부장 대리"}, "explanation": "이 문제는 관계대수(Relational Algebra)의 **프로젝션(Projection) 연산**에 관한 문제입니다.\n\n[관계대수 프로젝션 연산 π (파이, Pi)]\n\n[프로젝션 연산의 정의]\n- π(속성1, 속성2, ...)(테이블명): 지정한 **속성(컬럼)만 선택**하는 연산\n- 테이블에서 **필요한 컬럼만 추출**하여 새로운 관계(테이블) 생성\n- **수직 부분 집합**: 행은 유지하되, 컬럼만 선택\n\n[프로젝션 연산의 특징]\n1. **컬럼 선택**: 지정한 속성(컬럼)만 추출\n2. **중복 제거**: 프로젝션 연산 결과에서 중복된 튜플(행)은 자동으로 제거\n3. **순서 무관**: 결과의 순서는 중요하지 않음\n\n[문제 해석]\n\n[주어진 연산] `πTTL(employee)`\n\n[의미]\n- `employee` 테이블에서 **TTL 속성(컬럼)만 선택**\n- 즉, employee 테이블의 다른 속성들은 제외하고 **TTL 컬럼의 값만** 추출\n\n[연산 과정]\n1. `employee` 테이블의 **TTL 컬럼 값들을 모두 선택**\n2. 중복된 값이 있으면 제거\n3. 결과: TTL 컬럼의 **고유한 값들만** 반환\n\n[SQL로 표현하면]\n```sql\nSELECT DISTINCT TTL \nFROM employee;\n```\n- `DISTINCT`: 중복 제거 (프로젝션 연산의 특징)\n\n[답]\n- 문제에서 주어진 `employee` 테이블의 TTL 컬럼 값들을 추출하면:\n  - **TTL** (컬럼 헤더 또는 특수 값)\n  - **부장**\n  - **대리**\n  - (참고: 해설에 \"과장, 차장도 포함\"이라고 되어 있으나, 답안에는 \"TTL, 부장, 대리\"만 포함)\n\n[관계대수 연산 기호]\n| 연산 | 기호 | 의미 | SQL 예시 |\n|------|------|------|----------|\n| **선택** | σ (시그마) | 조건에 맞는 행 선택 | `SELECT * FROM 테이블 WHERE 조건` |\n| **프로젝션** | **π (파이)** | **지정한 속성만 선택** | **`SELECT 속성 FROM 테이블`** |\n| **조인** | ⋈ (보우타이) | 두 테이블 결합 | `SELECT * FROM A JOIN B ON 조건` |\n| **합집합** | ∪ | 두 관계의 합 | `UNION` |\n| **차집합** | − | 두 관계의 차 | `EXCEPT` |\n| **교집합** | ∩ | 두 관계의 교 | `INTERSECT` |\n\n[답] **TTL, 부장, 대리**", "table_refs": [], "image_refs": ["images/2022_round2/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 파이썬 코드이다.\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["REMEMBER AND STR"], "raw_text": "REMEMBER AND STR"}, "explanation": "문제의 이미지를 참고하여 코드 실행 과정을 분석합니다.\n\n[출력값이 \"REMEMBER AND STR\"인 경우 가능한 코드 패턴]\n\n[패턴 1: 문자열 대문자 변환]\n```python\ntext = \"remember and str\"\nresult = text.upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n[패턴 2: 리스트 join 후 대문자 변환]\n```python\nwords = [\"remember\", \"and\", \"str\"]\nresult = \" \".join(words).upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n[패턴 3: split 후 join 및 대문자 변환]\n```python\ntext = \"remember,and,str\"\nwords = text.split(\",\")\nresult = \" AND \".join(words).upper()\nprint(result)  # \"REMEMBER AND STR\"\n```\n\n[Python 코드 실행 시 확인사항]\n- 문자열 메서드: `.upper()`, `.lower()`, `.split()`, `.join()`\n- 리스트 인덱싱 및 슬라이싱\n- 문자열 연결 (`+` 연산자 또는 `join()`)\n- 반복문 내부의 변수 변화\n- 출력문 (`print()`)\n\n[답] 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출합니다. 이 경우 출력값은 **\"REMEMBER AND STR\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round2/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 설명에 대해 보기에 주어진 답을 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ARP, RARP 등..))", "choices": [], "answer": {"keys": ["1. IGP / 2. EGP / 3. OSPF / 4. BGP"], "raw_text": "1. IGP / 2. EGP / 3. OSPF / 4. BGP"}, "explanation": "이 문제는 **라우팅 프로토콜의 분류 및 종류**에 관한 문제입니다.\n\n[라우팅 프로토콜 분류]\n\n[1. IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)]\n\n[영어 약자 풀이]\n- **I**nterior: 내부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- IGP = Interior Gateway Protocol\n\n[IGP의 정의]\n- AS(Autonomous System, 자율시스템) 내부에서 사용하는 라우팅 프로토콜\n- 같은 관리 영역 내의 라우터 간 경로 정보 교환\n- 예: OSPF, RIP, IS-IS\n\n[IGP의 특징]\n- **범위**: 단일 AS 내부\n- **목적**: AS 내부 최적 경로 선택\n- **신뢰성**: AS 내부 라우터들은 서로 신뢰할 수 있음\n\n[2. EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)]\n\n[영어 약자 풀이]\n- **E**xterior: 외부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- EGP = Exterior Gateway Protocol\n\n[EGP의 정의]\n- **서로 다른 AS 간** 라우팅 정보를 교환하는 프로토콜\n- AS 간 경로 설정 및 정책 기반 라우팅\n- 예: BGP (현재 가장 널리 사용)\n\n[EGP의 특징]\n- **범위**: AS 간\n- **목적**: AS 간 경로 설정 및 정책 기반 라우팅\n- **신뢰성**: 서로 다른 AS 간 신뢰도가 낮을 수 있음\n- **보안**: 보안과 제어가 중요 (빠른 수행보다 보안 우선)\n\n[3. OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜)]\n\n[영어 약자 풀이]\n- **O**pen: 개방형\n- **S**hortest: 최단\n- **P**ath: 경로\n- **F**irst: 우선\n- OSPF = Open Shortest Path First\n\n[OSPF의 정의]\n- **링크 상태(Link State) 기반** 라우팅 프로토콜\n- **IGP의 한 종류**: AS 내부 라우팅에 사용\n- **RIP의 단점을 개선**한 프로토콜\n\n[OSPF의 특징]\n- **링크 상태 알고리즘**: 각 라우터가 전체 네트워크 토폴로지를 알고 최단 경로 계산\n- **대규모 네트워크 지원**: RIP보다 규모가 큰 네트워크에서 사용 가능\n- **자세한 제어**: 다양한 메트릭과 정책 설정 가능\n- **관리 정보 트래픽 감소**: RIP보다 효율적인 업데이트 방식\n- **계층적 구조**: Area(영역) 개념으로 확장성 향상\n\n[OSPF vs RIP]\n| 특징 | **OSPF** | **RIP** |\n|------|----------|---------|\n| **알고리즘** | 링크 상태 | 거리 벡터 |\n| **네트워크 규모** | 대규모 네트워크 지원 | 소규모 네트워크 (15 홉 제한) |\n| **수렴 속도** | 빠름 | 느림 |\n| **트래픽** | 변경 시에만 업데이트 | 주기적 업데이트 |\n\n[4. BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜)]\n\n[BGP의 정의]\n- 경로 벡터(Path Vector) 프로토콜\n- **EGP의 한 종류**: AS 간 라우팅에 사용\n- 인터넷의 백본 프로토콜\n\n[BGP의 특징]\n- **AS 간 라우팅**: 서로 다른 AS 간 경로 정보 교환\n- **전체 경로 정보**: AS Path 정보 포함\n- **정책 기반**: AS 수준에서 정책 결정 가능\n- **라우팅 루프 제거**: AS Path를 통한 루프 방지\n\n[라우팅 프로토콜 분류 요약]\n\n| 분류 | 프로토콜 | 범위 | 특징 |\n|------|----------|------|------|\n| **IGP** | OSPF, RIP, IS-IS | AS 내부 | AS 내부 최적 경로 |\n| **EGP** | BGP | AS 간 | AS 간 경로 설정, 정책 기반 |\n| **OSPF** | - | AS 내부 (IGP) | 링크 상태, 대규모 네트워크 |\n| **BGP** | - | AS 간 (EGP) | 경로 벡터, 정책 기반 |\n\n[답]\n- (1) IGP (Interior Gateway Protocol)\n- (2) EGP (Exterior Gateway Protocol)\n- (3) OSPF (Open Shortest Path First)\n- (4) BGP (Border Gateway Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.997448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다.\n같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다.", "choices": [], "answer": {"keys": ["IGP"], "raw_text": "IGP"}, "explanation": "이 문제는 IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)에 대한 문제입니다.\n\n[IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **I**nterior: 내부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- IGP = Interior Gateway Protocol\n\n[문제에서 설명한 IGP의 특징]\n\n1. \"라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다\":\n   - AS (Autonomous System, 자율시스템): 하나의 관리 정책 하에 운영되는 네트워크 집합\n   - 여러 개의 네트워크가 라우터로 상호 접속되어 하나의 도메인(AS)을 형성\n\n2. \"같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다\":\n   - **도메인 내부 라우터**: 같은 AS 내부에 있는 라우터\n   - **도메인 외부 라우터**: AS 외부에 있는 라우터\n   - **IGP**: **도메인 내부(AS 내부) 경로 설정**을 담당하는 프로토콜\n\n[IGP의 정의]\n- AS(Autonomous System) 내부에서 사용하는 라우팅 프로토콜\n- 같은 관리 영역 내의 라우터 간 경로 정보 교환\n- AS 내부에서 최적 경로 선택\n\n[IGP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **범위** | 단일 AS 내부 |\n| **목적** | AS 내부 최적 경로 선택 |\n| **신뢰성** | AS 내부 라우터들은 서로 신뢰할 수 있음 |\n| **예시** | OSPF, RIP, IS-IS |\n\n[IGP vs EGP]\n| 구분 | **IGP** | **EGP** |\n|------|---------|---------|\n| **범위** | AS 내부 | AS 간 |\n| **목적** | AS 내부 최적 경로 | AS 간 경로 설정, 정책 기반 |\n| **예시** | OSPF, RIP, IS-IS | BGP |\n| **신뢰성** | 높음 (같은 관리 영역) | 낮을 수 있음 (다른 관리 영역) |\n\n[IGP의 종류]\n1. OSPF (Open Shortest Path First): 링크 상태 기반\n2. RIP (Routing Information Protocol): 거리 벡터 기반\n3. IS-IS (Intermediate System to Intermediate System): 링크 상태 기반\n\n[답] IGP (Interior Gateway Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜로써,\n다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다.", "choices": [], "answer": {"keys": ["EGP"], "raw_text": "EGP"}, "explanation": "이 문제는 EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)에 대한 문제입니다.\n\n[EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **E**xterior: 외부의\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- EGP = Exterior Gateway Protocol\n\n[문제에서 설명한 EGP의 특징]\n\n1. \"시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜\":\n   - 서로 다른 AS(Autonomous System) 간 라우팅 정보를 교환\n   - AS 간 경로 설정 및 정책 기반 라우팅\n\n2. \"다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다\":\n   - **다른 도메인(AS) 간**: 서로 다른 관리 정책 하에 운영되는 네트워크 간\n   - **정리된 관리가 거의 없음**: AS 간에는 통합 관리가 없음\n   - **신용도가 매우 낮음**: 서로 다른 AS 간 신뢰도가 낮을 수 있음\n   - **빠른 수행보다는 보안과 제어**: 성능보다는 **보안과 정책 기반 제어**가 우선\n\n[EGP의 정의]\n- **서로 다른 AS 간** 라우팅 정보를 교환하는 프로토콜\n- AS 간 경로 설정 및 정책 기반 라우팅\n- 예: BGP (현재 가장 널리 사용되는 EGP)\n\n[EGP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **범위** | AS 간 라우팅 |\n| **목적** | AS 간 경로 설정 및 정책 기반 라우팅 |\n| **신뢰성** | 서로 다른 AS 간 신뢰도가 낮을 수 있음 |\n| **보안** | 보안과 제어가 중요 (빠른 수행보다 보안 우선) |\n| **예시** | BGP (Border Gateway Protocol) |\n\n[EGP의 주요 특징]\n1. **정책 기반 라우팅**: 각 AS는 자신의 정책에 따라 경로 선택\n2. **보안 강조**: 빠른 수행보다 보안과 제어가 우선\n3. **신뢰도 문제**: 서로 다른 AS 간 신뢰도가 낮아 보안이 중요\n4. **관리 독립성**: AS 간 통합 관리가 없어 정책 기반 제어 필요\n\n[EGP vs IGP]\n| 구분 | **IGP** | **EGP** |\n|------|---------|---------|\n| **범위** | AS 내부 | AS 간 |\n| **목적** | AS 내부 최적 경로 | AS 간 경로 설정, 정책 기반 |\n| **신뢰성** | 높음 (같은 관리 영역) | 낮을 수 있음 (다른 관리 영역) |\n| **보안** | 상대적으로 낮은 우선순위 | 높은 우선순위 (보안과 제어) |\n| **예시** | OSPF, RIP, IS-IS | BGP |\n\n[BGP (Border Gateway Protocol)]\n- 현재 가장 널리 사용되는 EGP\n- 인터넷의 백본 프로토콜\n- AS 간 라우팅에 사용\n- 정책 기반 라우팅 지원\n\n[답] EGP (Exterior Gateway Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다.\n규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜로써 RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다.", "choices": [], "answer": {"keys": ["OSPF"], "raw_text": "OSPF"}, "explanation": "이 문제는 OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜)에 대한 문제입니다.\n\n[OSPF (Open Shortest Path First, 최단 경로 우선 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **O**pen: 개방형\n- **S**hortest: 최단\n- **P**ath: 경로\n- **F**irst: 우선\n- OSPF = Open Shortest Path First\n\n[문제에서 설명한 OSPF의 특징]\n\n1. \"IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다\":\n   - **IGP의 한 종류**: AS 내부 라우팅에 사용\n   - **대규모 네트워크 지원**: RIP보다 규모가 큰 네트워크에서 사용 가능\n   - RIP는 15 홉 제한이 있어 대규모 네트워크에 부적합\n\n2. \"규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜\":\n   - **RIP의 단점 개선**: RIP의 제한사항을 해결한 프로토콜\n   - **대규모/복잡한 네트워크**: TCP/IP 네트워크에서 널리 사용\n\n3. \"RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다\":\n   - **자세한 제어**: 다양한 메트릭과 정책 설정 가능\n   - **관리 정보 트래픽 감소**: RIP보다 효율적인 업데이트 방식\n   - RIP는 주기적 업데이트로 트래픽이 많음\n   - OSPF는 변경 시에만 업데이트하여 트래픽 감소\n\n[OSPF의 정의]\n- **링크 상태(Link State) 기반** 라우팅 프로토콜\n- **IGP의 한 종류**: AS 내부 라우팅에 사용\n- **RIP의 단점을 개선**한 프로토콜\n\n[OSPF의 특징]\n| 특징 | 설명 |\n|------|------|\n| **알고리즘** | 링크 상태 (Link State) |\n| **네트워크 규모** | 대규모 네트워크 지원 |\n| **수렴 속도** | 빠름 |\n| **트래픽** | 변경 시에만 업데이트 (효율적) |\n| **제어** | 자세한 제어 가능 (다양한 메트릭) |\n| **구조** | 계층적 구조 (Area 개념) |\n\n[OSPF vs RIP]\n| 특징 | **OSPF** | **RIP** |\n|------|----------|---------|\n| **알고리즘** | 링크 상태 | 거리 벡터 |\n| **네트워크 규모** | 대규모 네트워크 지원 | 소규모 네트워크 (15 홉 제한) |\n| **수렴 속도** | 빠름 | 느림 |\n| **트래픽** | 변경 시에만 업데이트 | 주기적 업데이트 |\n| **제어** | 자세한 제어 가능 | 제한적 |\n| **메트릭** | 비용(Cost) 기반 | 홉(Hop) 수 기반 |\n\n[OSPF의 동작 원리]\n1. **링크 상태 정보 수집**: 각 라우터가 자신의 링크 상태 정보를 광고\n2. **전체 토폴로지 구성**: 모든 라우터가 전체 네트워크 토폴로지를 파악\n3. **최단 경로 계산**: 다익스트라 알고리즘을 사용하여 최단 경로 계산\n4. **라우팅 테이블 업데이트**: 계산된 최단 경로를 라우팅 테이블에 반영\n\n[OSPF의 장점]\n- **빠른 수렴**: 네트워크 변화에 빠르게 대응\n- **대규모 네트워크 지원**: Area 개념으로 확장성 향상\n- **트래픽 효율**: 변경 시에만 업데이트\n- **자세한 제어**: 다양한 정책 및 메트릭 설정 가능\n\n[답] OSPF (Open Shortest Path First)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅", "TCP/IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환하는 데 사용되는 외부 게이트웨이 프로토콜(EGP)이다.\n각 목적지에 대한 전체 경로가 포함되며, 다른 시스템과 교환하는 네트워크 도달 가능성 정보의 데이터베이스를 유지한다.\n네트워크 도달 가능성 정보를 사용하여 AS 연결 그래프를 구성하며, 이를 통해 라우팅 루프를 제거하고 AS 수준에서 정책 결정을 실행할 수 있다.", "choices": [], "answer": {"keys": ["BGP"], "raw_text": "BGP"}, "explanation": "이 문제는 BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜)에 대한 문제입니다.\n\n[BGP (Border Gateway Protocol, 경계 게이트웨이 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **B**order: 경계\n- **G**ateway: 게이트웨이\n- **P**rotocol: 프로토콜\n- BGP = Border Gateway Protocol\n\n[BGP의 정의]\n- 서로 다른 자율 시스템(AS, Autonomous System) 간 라우팅 정보를 교환하는 외부 게이트웨이 프로토콜(EGP, Exterior Gateway Protocol)\n- 인터넷의 **백본 프로토콜**: 인터넷 전체를 연결하는 핵심 라우팅 프로토콜\n\n[문제에서 설명한 BGP의 특징]\n\n1. \"서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환\":\n   - AS (Autonomous System): 하나의 관리 정책 하에 운영되는 네트워크 집합\n   - EGP (Exterior Gateway Protocol): AS 간 라우팅 프로토콜\n   - BGP는 **AS 간 라우팅**에 사용 (AS 내부 라우팅은 IGP 사용)\n\n2. \"각 목적지에 대한 전체 경로가 포함\":\n   - BGP는 경로 벡터(Path Vector) 프로토콜\n   - 각 경로에 **전체 AS 경로(AS Path)** 정보를 포함\n   - 예: 목적지로 가는 경로 = AS100 → AS200 → AS300\n\n3. \"네트워크 도달 가능성 정보의 데이터베이스를 유지\":\n   - BGP 라우터는 네트워크 도달 가능성 정보(NLRI, Network Layer Reachability Information)를 데이터베이스로 관리\n   - 다른 AS와 경로 정보를 교환하여 최신 라우팅 정보 유지\n\n4. \"AS 연결 그래프를 구성하여 라우팅 루프를 제거\":\n   - AS 간 연결 관계를 그래프로 표현\n   - AS Path에 자신의 AS가 포함되면 루프로 판단하여 경로 거부\n   - 예: AS100에서 AS200으로 가는 경로에 이미 AS100이 포함되어 있으면 루프로 판단\n\n5. **\"AS 수준에서 정책 결정을 실행\"**:\n   - BGP는 **정책 기반 라우팅** 지원\n   - 각 AS는 자신의 정책에 따라 경로를 선택하거나 거부 가능\n   - 예: 특정 AS를 통한 경로 차단, 특정 경로 우선 선택\n\n[BGP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **프로토콜 유형** | 경로 벡터(Path Vector) 프로토콜 |\n| **사용 범위** | AS 간 라우팅 (EGP) |\n| **포트** | TCP 179 포트 사용 |\n| **신뢰성** | TCP 기반으로 신뢰성 있는 전송 보장 |\n| **경로 선택 기준** | AS Path 길이, 정책 등 |\n| **업데이트** | 트리거 기반 (변경 시에만 업데이트) |\n\n[BGP vs IGP]\n| 구분 | **BGP (EGP)** | IGP (Interior Gateway Protocol) |\n|------|----------------|-----------------------------------|\n| **범위** | AS 간 라우팅 | AS 내부 라우팅 |\n| **예시** | BGP, EGP | OSPF, RIP, IS-IS |\n| **특징** | 정책 기반, 경로 벡터 | 거리/링크 상태 기반 |\n\n[BGP의 주요 용도]\n- **인터넷 백본**: ISP(인터넷 서비스 제공자) 간 라우팅\n- **멀티홈**: 여러 ISP와 연결된 네트워크의 라우팅\n- **트래픽 제어**: 정책을 통한 경로 선택 및 제어\n\n[답] BGP (Border Gateway Protocol)", "table_refs": [], "image_refs": ["images/2022_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 C언어에서 출력에 대한 알맞은 답을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 문제는 C언어 문자열 포인터와 문자열 길이 계산 함수에 관한 문제입니다.\n\n[주어진 코드]\n```c\n#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n  }\n return r;\n}\n```\n\n[코드 실행 과정]\n\n[1. main() 함수 시작]\n\n[변수 초기화]\n- `char* p1 = \"2022\";`\n  - `p1`은 문자열 리터럴 \"2022\"의 주소를 가리키는 포인터\n  - 문자열 \"2022\"는 4개의 문자: '2', '0', '2', '2', '\\0' (널 문자 포함 5바이트)\n  - **실제 문자 개수: 4개** (널 문자 제외)\n\n- `char* p2 = \"202207\";`\n  - `p2`는 문자열 리터럴 \"202207\"의 주소를 가리키는 포인터\n  - 문자열 \"202207\"는 6개의 문자: '2', '0', '2', '2', '0', '7', '\\0' (널 문자 포함 7바이트)\n  - **실제 문자 개수: 6개** (널 문자 제외)\n\n[2. len(p1) 함수 호출]\n```c\nint len(char* p)  // p는 \"2022\"의 주소를 받음\n```\n\n[len() 함수 내부 실행]\n- `int r = 0;` - 길이 카운터 초기화\n- `while(*p != '\\0')` - 포인터가 가리키는 문자가 널 문자가 아닐 때까지 반복\n\n[반복 과정]\n| 반복 | `*p` (현재 문자) | `*p != '\\0'` | `p++` | `r++` | `r` 값 |\n|------|----------------|--------------|-------|-------|--------|\n| 초기 | '2' | true | p 이동 | 1 | 1 |\n| 1 | '0' | true | p 이동 | 2 | 2 |\n| 2 | '2' | true | p 이동 | 3 | 3 |\n| 3 | '2' | true | p 이동 | 4 | 4 |\n| 4 | '\\0' | **false** | - | - | - |\n\n- **반복 종료**: 널 문자('\\0')를 만나면 반복 종료\n- `return r;` → **a = 4** 반환\n\n[3. len(p2) 함수 호출]\n```c\nint len(char* p)  // p는 \"202207\"의 주소를 받음\n```\n\n[len() 함수 내부 실행]\n- `int r = 0;` - 길이 카운터 초기화\n- `while(*p != '\\0')` - 널 문자까지 반복\n\n[반복 과정]\n| 반복 | `*p` (현재 문자) | `*p != '\\0'` | `p++` | `r++` | `r` 값 |\n|------|----------------|--------------|-------|-------|--------|\n| 초기 | '2' | true | p 이동 | 1 | 1 |\n| 1 | '0' | true | p 이동 | 2 | 2 |\n| 2 | '2' | true | p 이동 | 3 | 3 |\n| 3 | '2' | true | p 이동 | 4 | 4 |\n| 4 | '0' | true | p 이동 | 5 | 5 |\n| 5 | '7' | true | p 이동 | 6 | 6 |\n| 6 | '\\0' | **false** | - | - | - |\n\n- **반복 종료**: 널 문자를 만나면 반복 종료\n- `return r;` → **b = 6** 반환\n\n[4. 최종 계산]\n```c\nprintf(\"%d\", a + b);\n```\n- `a = 4` (\"2022\"의 길이)\n- `b = 6` (\"202207\"의 길이)\n- `a + b = 4 + 6 = 10`\n\n[출력] `10`\n\n[핵심 개념]\n1. **문자열 포인터**: `char*`는 문자열의 첫 번째 문자 주소를 가리킴\n2. **널 문자**: 문자열 끝에는 자동으로 '\\0' (널 문자)가 추가됨\n3. **포인터 연산**: `p++`는 다음 문자 위치로 포인터 이동\n4. **문자열 길이**: 널 문자를 제외한 실제 문자의 개수\n\n[답] **10**", "table_refs": [], "image_refs": ["images/2022_round2/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n }\n return r;\n}", "line_numbers": [1, 17], "file": "data/codes/2022_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 C언어 코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["22"], "raw_text": "22"}, "explanation": "C언어 코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"22\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round2/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 자바코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["61"], "raw_text": "61"}, "explanation": "이 문제는 **자바(Java) 코드 실행**에 관한 문제입니다.\n\n[자바 코드 실행 주요 개념]\n\n[1. 변수 선언 및 초기화]\n- **정수형 변수**: `int`, `long`, `short`, `byte`\n- **실수형 변수**: `float`, `double`\n- **변수 초기화**: 변수 선언 시 초기값 할당\n\n[2. 산술 연산]\n- **덧셈**: `+`\n- **뺄셈**: `-`\n- **곱셈**: `*`\n- **나눗셈**: `/` (정수 나눗셈은 몫만 반환)\n- **나머지**: `%`\n\n[3. 반복문]\n- **for 반복문**: `for(초기화; 조건; 증감)`\n- **while 반복문**: `while(조건)`\n- **향상된 for문**: `for(타입 변수 : 배열)`\n\n[4. 조건문]\n- **if-else**: 조건에 따른 분기\n- **switch-case**: 여러 값에 따른 분기\n\n[5. 배열]\n- **배열 선언**: `int[] arr = new int[10]`\n- **배열 초기화**: `int[] arr = {1, 2, 3}`\n- **배열 접근**: `arr[0]`, `arr[1]` 등\n\n[6. 출력]\n- System.out.println(): 출력 후 줄바꿈\n- System.out.print(): 출력만 (줄바꿈 없음)\n\n[답이 \"61\"인 경우 가능한 코드 패턴]\n\n[예시 1: 덧셈 연산]\n```java\nint a = 30;\nint b = 31;\nint result = a + b;\nSystem.out.println(result);  // 61\n```\n\n[예시 2: 반복문을 이용한 합계]\n```java\nint sum = 0;\nfor(int i = 1; i <= 11; i++) {\n    sum += i;\n}\nSystem.out.println(sum);  // 1+2+...+11 = 66이 아니므로 다른 계산\n```\n\n[예시 3: 배열 합계]\n```java\nint[] arr = {10, 20, 31};\nint sum = 0;\nfor(int i = 0; i < arr.length; i++) {\n    sum += arr[i];\n}\nSystem.out.println(sum);  // 10+20+31 = 61\n```\n\n[일반적인 자바 코드 실행 흐름]\n1. **변수 초기화**: 변수 선언 및 초기값 설정\n2. **연산 수행**: 산술, 논리, 비교 연산\n3. **조건/반복 처리**: 필요한 경우 조건문이나 반복문 사용\n4. **출력**: System.out.println()으로 최종 결과 출력\n\n[핵심 개념]\n- **정수 연산**: 정수끼리 나눗셈은 몫만 반환 (소수점 이하 버림)\n- **연산자 우선순위**: 곱셈/나눗셈이 덧셈/뺄셈보다 우선\n- **변수 추적**: 각 단계에서 변수 값의 변화를 추적해야 함\n- **반복문 변수**: 반복문 내에서 변수 값이 계속 변화\n\n[답] **61**", "table_refs": [], "image_refs": ["images/2022_round2/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 함수 종속성에 대한 설명이다.\n해당 문제에 대한 알맞는 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nunion 등..))", "choices": [], "answer": {"keys": ["1. Full", "2. Partial", "3. Transitive"], "raw_text": "1. Full 2. Partial 3. Transitive"}, "explanation": "[함수 종속성(Functional Dependency, FD)의 종류]\n\n[함수 종속성 정의]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정됨 (X가 Y를 함수적으로 결정)\n- 예: `학번 → 이름` (학번이 결정되면 이름이 결정됨)\n\n[1. Full Functional Dependency (완전 함수 종속, 완전 종속)]\n- **정의**: 종속 속성(Y)이 **결정자(X)의 모든 속성**에 종속\n- **조건**: X의 어떤 부분 집합도 Y를 결정할 수 없음\n- **표기**: `X → Y` (X의 모든 속성이 필요)\n- **예시**: `{학생, 학과} → 성적`\n  - 성적은 학생과 학과 **모두** 알아야 결정됨\n  - 학생만으로는 성적을 결정할 수 없고, 학과만으로도 성적을 결정할 수 없음\n\n[2. Partial Functional Dependency (부분 함수 종속, 부분 종속)]\n- **정의**: 종속 속성(Y)이 **결정자(X)의 일부 속성**에만 종속\n- **조건**: X의 **부분 집합이 Y를 결정**할 수 있음\n- **표기**: `X의 부분집합 → Y`\n- **예시**:\n  - 기본키: `{학생, 학과}`\n  - `{학생, 학과} → 성적` (완전 종속)\n  - `학과 → 성적` (부분 종속: 학과만으로도 성적 결정 가능)\n  - 즉, 성적은 학과만 알아도 식별 가능\n\n[3. Transitive Functional Dependency (이행 함수 종속, 이행 종속)]\n- **정의**: **간접적인 종속 관계** (연쇄 종속)\n- **조건**: `X → Y`이고 `Y → Z`이면 `X → Z` (이행 종속)\n- **표기**: `X → Y → Z` (X가 Y를 결정하고, Y가 Z를 결정)\n- **예시**:\n  - `학번 → 학과`\n  - `학과 → 학과장`\n  - 따라서 `학번 → 학과장` (이행 종속)\n  - 학번이 학과를 결정하고, 학과가 학과장을 결정하므로 학번이 학과장을 결정\n\n[함수 종속성 종류 비교]\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n| **Transitive (이행)** | **간접적인 종속** 관계 | 연쇄 종속 | `학번 → 학과 → 학과장` |\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n\n[답]\n- (1) **Full (완전 함수 종속)**\n- (2) **Partial (부분 함수 종속)**\n- (3) Transitive (이행 함수 종속)", "table_refs": [], "image_refs": ["images/2022_round2/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": ["프로그래밍", "데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "성적은 {학생,학과}에 대해서 ( ) Functional Dependency이다.", "choices": [], "answer": {"keys": ["Full"], "raw_text": "Full"}, "explanation": "이 문제는 함수 종속성(Functional Dependency, FD)의 종류 중 Full Functional Dependency (완전 함수 종속)에 대한 문제입니다.\n\n[함수 종속성(Functional Dependency, FD)이란?]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정된다 (X가 Y를 함수적으로 결정)\n- 예: `학번 → 이름` (학번이 결정되면 이름이 결정됨)\n\n[문제 해석]\n\n[주어진 조건]\n- **성적**은 **{학생, 학과}**에 대해서 함수 종속\n- 즉, `{학생, 학과} → 성적`\n\n[Full Functional Dependency (완전 함수 종속, 완전 종속)]\n\n[정의]\n- 종속 속성(Y)이 **결정자(X)의 모든 속성**에 종속\n- X의 어떤 부분 집합도 Y를 결정할 수 없음\n\n[문제에서의 적용]\n- `{학생, 학과} → 성적`\n- 성적은 **학생과 학과 모두** 알아야 결정됨\n- **학생만**으로는 성적을 결정할 수 없음 (같은 학생이라도 학과에 따라 성적이 다를 수 있음)\n- **학과만**으로도 성적을 결정할 수 없음 (같은 학과라도 학생에 따라 성적이 다름)\n- 따라서 **{학생, 학과}의 모든 속성이 필요** → **Full (완전) 종속**\n\n[Full vs Partial 비교]\n\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n\n[예시 설명]\n- **Full 종속**: 성적은 학생과 학과 **모두** 알아야 결정됨\n  - 학생 A, 학과 컴퓨터공학 → 성적 90\n  - 학생 A, 학과 전자공학 → 성적 85 (같은 학생이어도 학과가 다르면 성적이 다름)\n  - 학생 B, 학과 컴퓨터공학 → 성적 95 (같은 학과여도 학생이 다르면 성적이 다름)\n- **Partial 종속**: 만약 성적이 학과만으로 결정된다면 → `학과 → 성적` (부분 종속)\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n\n[답] **Full (완전 함수 종속)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "성적은 학과만 알아도 식별이 가능하므로, 이 경우에는 성적 속성은 기본키에 ( ) Functional Dependency이다.", "choices": [], "answer": {"keys": ["Partial"], "raw_text": "Partial"}, "explanation": "이 문제는 함수 종속성(Functional Dependency, FD)의 종류 중 Partial Functional Dependency (부분 함수 종속)에 대한 문제입니다.\n\n[함수 종속성(Functional Dependency, FD)이란?]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정된다 (X가 Y를 함수적으로 결정)\n\n[문제 해석]\n\n[주어진 조건]\n- **기본키**: `{학생, 학과}` (복합 기본키)\n- **성적**은 **학과만 알아도 식별이 가능**\n- 즉, `학과 → 성적` (학과만으로도 성적 결정 가능)\n\n[Partial Functional Dependency (부분 함수 종속, 부분 종속)]\n\n[정의]\n- 종속 속성(Y)이 **결정자(X)의 일부 속성**에만 종속\n- X의 **부분 집합이 Y를 결정**할 수 있음\n\n[문제에서의 적용]\n- 기본키: `{학생, 학과}`\n- `{학생, 학과} → 성적` (완전 종속)\n- 하지만 `학과 → 성적` (부분 종속: 학과만으로도 성적 결정 가능)\n- 즉, 성적은 **기본키의 일부 속성(학과)만** 알아도 식별 가능\n- 따라서 **Partial (부분) 종속**\n\n[부분 종속의 특징]\n- 기본키가 복합 키일 때 발생\n- 기본키의 **일부 속성만**으로도 종속 속성을 결정할 수 있음\n- 예: `{학생, 학과} → 성적`이지만 `학과 → 성적`도 성립\n\n[Full vs Partial 비교]\n\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n\n[예시 설명]\n- **부분 종속**: 성적이 학과만으로 결정됨\n  - 학과 컴퓨터공학 → 성적 90 (모든 컴퓨터공학 학생의 성적이 90)\n  - 학과 전자공학 → 성적 85 (모든 전자공학 학생의 성적이 85)\n  - 학생 정보는 필요 없음 (학과만으로 성적 결정)\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n  - 기본키의 일부 속성에만 종속되는 속성을 별도 릴레이션으로 분리\n  - 예: `{학생, 학과} → 성적`에서 `학과 → 성적`이면\n    - 릴레이션1: `{학생, 학과}` (학생 정보)\n    - 릴레이션2: `{학과, 성적}` (학과별 성적)\n\n[답] **Partial (부분 함수 종속)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 경우", "choices": [], "answer": {"keys": ["Transitive"], "raw_text": "Transitive"}, "explanation": "이 문제는 함수 종속성(Functional Dependency, FD)의 종류 중 Transitive Functional Dependency (이행 함수 종속, 이행 종속)에 대한 문제입니다.\n\n[함수 종속성(Functional Dependency, FD)이란?]\n- 관계형 데이터베이스에서 **속성 간의 의존 관계**를 나타내는 개념\n- `X → Y`: X가 결정되면 Y가 결정된다 (X가 Y를 함수적으로 결정)\n\n[문제 해석]\n\n[주어진 조건]\n- `X → Y`: X가 Y를 결정\n- `Y → Z`: Y가 Z를 결정\n- 따라서 `X → Z`: X가 Z를 결정 (이행 종속)\n\n[Transitive Functional Dependency (이행 함수 종속, 이행 종속)]\n\n[정의]\n- **간접적인 종속 관계** (연쇄 종속)\n- `X → Y`이고 `Y → Z`이면 `X → Z` (이행 종속)\n- X가 Y를 결정하고, Y가 Z를 결정하므로 X가 Z를 결정\n\n[이행 종속의 특징]\n- **간접적인 종속**: X가 Z를 직접 결정하는 것이 아니라 Y를 통해 간접적으로 결정\n- **연쇄 종속**: X → Y → Z 형태의 연쇄적인 종속 관계\n\n[예시 설명]\n- `학번 → 학과` (학번이 학과를 결정)\n- `학과 → 학과장` (학과가 학과장을 결정)\n- 따라서 `학번 → 학과장` (이행 종속)\n  - 학번이 학과를 결정하고, 학과가 학과장을 결정하므로 학번이 학과장을 결정\n  - 하지만 학번이 학과장을 **직접** 결정하는 것이 아니라 학과를 통해 **간접적으로** 결정\n\n[이행 종속의 문제점]\n- **데이터 중복**: 학과장 정보가 각 학생 레코드에 중복 저장\n- **이상(Anomaly) 발생**: 학과장이 변경되면 여러 레코드를 수정해야 함\n- **정규화 필요**: 3NF로 정규화하여 이행 종속 제거\n\n[함수 종속성 종류 비교]\n\n| 종류 | 정의 | 조건 | 예시 |\n|------|------|------|------|\n| **Full (완전)** | 결정자의 **모든 속성**에 종속 | 부분 집합이 결정 불가 | `{학생, 학과} → 성적` (둘 다 필요) |\n| **Partial (부분)** | 결정자의 **일부 속성**에만 종속 | 부분 집합이 결정 가능 | `{학생, 학과} → 성적`에서 `학과 → 성적` |\n| **Transitive (이행)** | **간접적인 종속** 관계 | 연쇄 종속 | `학번 → 학과 → 학과장` |\n\n[정규화와의 관계]\n- **부분 종속 제거**: 2NF (제2정규형)로 정규화\n- **이행 종속 제거**: 3NF (제3정규형)로 정규화\n  - 이행 종속을 제거하기 위해 별도 릴레이션으로 분리\n  - 예: `학번 → 학과 → 학과장`\n    - 릴레이션1: `{학번, 학과}` (학생 정보)\n    - 릴레이션2: `{학과, 학과장}` (학과 정보)\n\n[답] Transitive (이행 함수 종속)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 설명에 대한 알맞는 답을 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ajax, 등..))", "choices": [], "answer": {"keys": ["1. HTTP", "2. Hypertext", "3. HTML"], "raw_text": "1. HTTP 2. Hypertext 3. HTML"}, "explanation": "이 문제는 **웹 기술의 기본 개념**에 관한 문제입니다.\n\n[1. HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)]\n\n[HTTP의 정의]\n- 인터넷에서 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약\n- 인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약\n- 이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 됨\n\n[HTTP의 특징]\n- **웹 서버와 브라우저 간** 문서 전송 프로토콜\n- **응용 계층 프로토콜** (TCP/IP 기반)\n- **포트 번호**: 80 (HTTPS는 443)\n- **요청-응답 방식**: 클라이언트가 요청하고 서버가 응답\n\n[2. Hypertext (하이퍼텍스트)]\n\n[Hypertext의 정의]\n- 문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결시킨 정보 제공 방법\n- **제시된 순서에 관계없이** 이용자가 관련된 정보를 검색할 수 있도록 함\n- 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 **클릭함으로써 원하는 정보에 쉽게 접근**하는 방식\n\n[Hypertext의 특징]\n- **비선형적 구조**: 거미집처럼 연결된 구조\n- **링크 기반**: 링크를 통해 정보 간 이동\n- **다양한 미디어**: 텍스트, 그래픽, 음성, 영상 포함\n- **사용자 주도 탐색**: 순서 없이 자유롭게 정보 탐색\n\n[3. HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)]\n\n[HTML의 정의]\n- 웹 페이지 표시를 위해 개발된 지배적인 마크업 언어\n- 제목, 단락, 목록 등과 같은 본문을 위한 **구조적 의미를 나타내는 것**\n- 링크, 인용과 그 밖의 항목으로 **구조적 문서를 만들 수 있는 방법**을 제공\n\n[HTML의 특징]\n- **마크업 언어**: 태그를 사용하여 문서 구조 표현\n- **웹 페이지 작성**: 웹 브라우저에서 표시되는 페이지 작성\n- **구조적 의미**: 태그로 문서의 의미와 구조 표현\n- **표준화**: W3C에서 표준화\n\n[웹 기술의 관계]\n\n| 기술 | 역할 | 관계 |\n|------|------|------|\n| **Hypertext** | 정보 제공 방법 (개념) | 웹의 기본 개념 |\n| **HTML** | 웹 페이지 작성 언어 | Hypertext를 표현하는 언어 |\n| **HTTP** | 문서 전송 프로토콜 | HTML 문서를 전송하는 프로토콜 |\n\n[웹의 동작 흐름]\n1. **HTML로 웹 페이지 작성** (Hypertext 구조)\n2. **HTTP로 HTML 문서 전송** (웹 서버 → 브라우저)\n3. **브라우저가 HTML 해석하여 표시** (Hypertext 구조로 표시)\n4. **사용자가 링크 클릭** (Hypertext 탐색)\n5. **새로운 페이지 요청** (HTTP로 전송)\n\n[답]\n- (1) HTTP (Hypertext Transfer Protocol)\n- (2) **Hypertext (하이퍼텍스트)**\n- (3) HTML (HyperText Markup Language)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "인터넷에서, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약을 말한다.\n인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다.\n이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "이 문제는 HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)에 대한 문제입니다.\n\n[HTTP (Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)이란?]\n\n[영어 약자 풀이]\n- **H**ypertext: 하이퍼텍스트\n- **T**ransfer: 전송\n- **P**rotocol: 프로토콜\n- HTTP = Hypertext Transfer Protocol\n\n[문제에서 설명한 HTTP의 특징]\n\n1. \"인터넷에서, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약\":\n   - **웹 서버**: 웹 페이지를 제공하는 서버\n   - **인터넷 브라우저**: 사용자가 사용하는 웹 브라우저 (Chrome, Firefox, Safari 등)\n   - **문서 전송**: HTML 문서, 이미지, CSS, JavaScript 등 웹 리소스 전송\n   - **통신 규약**: 웹 서버와 브라우저 간의 통신 규칙\n\n2. \"인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약\":\n   - **하이퍼텍스트**: 링크로 연결된 텍스트 문서\n   - **문서 교환**: 웹 서버와 브라우저 간 하이퍼텍스트 문서 주고받기\n\n3. \"이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다\":\n   - HTTP 규약을 따르면 서로 다른 시스템 간에도 정보 교환 가능\n   - 표준화된 프로토콜로 인터넷의 상호 운용성 보장\n\n[HTTP의 정의]\n- **웹 서버와 클라이언트(브라우저) 간** 문서 및 리소스를 전송하기 위한 **응용 계층 프로토콜**\n- **TCP/IP 기반**: 전송 계층에서 TCP 사용\n- **포트 번호**: 기본 포트 80 (HTTPS는 443)\n\n[HTTP의 특징]\n| 특징 | 설명 |\n|------|------|\n| **계층** | 응용 계층 (Application Layer) |\n| **기반** | TCP/IP |\n| **포트** | 80 (HTTPS는 443) |\n| **특성** | 상태 비저장 (Stateless) |\n| **방식** | 요청-응답 (Request-Response) |\n\n[HTTP의 동작 방식]\n1. **클라이언트 요청**: 브라우저가 웹 서버에 HTTP 요청 전송\n2. **서버 응답**: 웹 서버가 요청한 리소스를 HTTP 응답으로 전송\n3. **문서 전송**: HTML 문서, 이미지, CSS, JavaScript 등 전송\n\n[HTTP 요청/응답 예시]\n```\n요청 (Request):\nGET /index.html HTTP/1.1\nHost: example.com\n\n응답 (Response):\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<html>...</html>\n```\n\n[HTTP vs HTTPS]\n| 구분 | **HTTP** | **HTTPS** |\n|------|----------|-----------|\n| **포트** | 80 | 443 |\n| **보안** | 암호화 없음 | SSL/TLS 암호화 |\n| **용도** | 일반 웹 페이지 | 보안이 필요한 페이지 |\n\n[HTTP의 주요 메서드]\n- **GET**: 리소스 조회\n- **POST**: 리소스 생성/전송\n- **PUT**: 리소스 수정\n- **DELETE**: 리소스 삭제\n\n[답] HTTP (Hypertext Transfer Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결시켜, 제시된 순서에 관계없이 이용자가 관련된 정보를 검색할 수 있도록 하는 정보 제공 방법이다.\n즉, 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 클릭함으로써 원하는 정보에 쉽게 접근하는 방식을 말한다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "이 문제는 **Hypertext (하이퍼텍스트)**에 대한 문제입니다.\n\n[Hypertext (하이퍼텍스트)란?]\n\n[영어 단어 풀이]\n- **Hyper**: 초월, 넘어서는\n- **Text**: 텍스트, 문서\n- **Hypertext**: 하이퍼텍스트, 초월 텍스트\n\n[문제에서 설명한 Hypertext의 특징]\n\n1. \"문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결\":\n   - **다양한 미디어**: 문자뿐만 아니라 그래픽, 음성, 영상도 포함\n   - **연상 거미집**: 거미줄처럼 복잡하게 연결된 구조\n   - **상호 연결**: 여러 정보가 링크로 서로 연결됨\n\n2. \"제시된 순서에 관계없이 이용자가 관련된 정보를 검색할 수 있도록 하는 정보 제공 방법\":\n   - **순서 무관**: 선형적 순서가 아닌 비선형적 구조\n   - **사용자 주도**: 이용자가 원하는 순서로 정보 탐색\n   - **관련 정보 검색**: 링크를 통해 관련 정보로 바로 이동\n\n3. \"한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 클릭함으로써 원하는 정보에 쉽게 접근하는 방식\":\n   - **링크 기반**: 링크를 통해 정보 간 이동\n   - **클릭으로 접근**: 링크를 클릭하여 원하는 정보로 바로 이동\n   - **쉬운 접근**: 정보 탐색이 용이함\n\n[Hypertext의 정의]\n- 텍스트, 그래픽, 음성, 영상 등을 링크로 연결하여 사용자가 비선형적으로 정보를 탐색할 수 있게 하는 정보 제공 방법\n- **웹(WWW)의 핵심 개념**: 웹 페이지들이 하이퍼링크로 연결되어 있음\n\n[Hypertext의 특징]\n| 특징 | 설명 |\n|------|------|\n| **구조** | 비선형적 구조 (거미집 형태) |\n| **미디어** | 텍스트, 그래픽, 음성, 영상 포함 |\n| **접근** | 링크를 통한 자유로운 정보 탐색 |\n| **순서** | 고정된 순서 없음, 사용자 주도 |\n\n[Hypertext의 예시]\n- **웹 페이지**: HTML 문서들이 하이퍼링크로 연결\n- **위키피디아**: 문서들이 상호 링크로 연결\n- **전자책**: 하이퍼링크로 관련 내용 참조\n\n[Hypertext vs 일반 텍스트]\n| 구분 | **일반 텍스트** | **Hypertext** |\n|------|----------------|---------------|\n| **구조** | 선형적 (순서대로 읽음) | 비선형적 (자유롭게 탐색) |\n| **연결** | 연결 없음 | 링크로 연결 |\n| **탐색** | 순차적 탐색 | 링크 클릭으로 탐색 |\n\n[웹과 Hypertext]\n- **WWW (World Wide Web)**: 하이퍼텍스트 기반의 정보 시스템\n- HTML (HyperText Markup Language): 하이퍼텍스트를 표현하는 마크업 언어\n- HTTP (HyperText Transfer Protocol): 하이퍼텍스트 문서를 전송하는 프로토콜\n\n[답] **Hypertext (하이퍼텍스트)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "웹 페이지 표시를 위해 개발된 지배적인 마크업 언어다.\n또한, 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.", "choices": [], "answer": {"keys": ["HTML"], "raw_text": "HTML"}, "explanation": "이 문제는 HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)에 대한 문제입니다.\n\n[HTML (HyperText Markup Language, 하이퍼텍스트 마크업 언어)이란?]\n\n[영어 약자 풀이]\n- **H**ypertext: 하이퍼텍스트\n- **T**ext: 텍스트\n- **M**arkup: 마크업\n- **L**anguage: 언어\n- HTML = HyperText Markup Language\n\n[문제에서 설명한 HTML의 특징]\n\n1. \"웹 페이지 표시를 위해 개발된 지배적인 마크업 언어\":\n   - **웹 페이지 표시**: 웹 브라우저에서 웹 페이지를 표시하기 위한 언어\n   - **지배적인**: 웹에서 가장 널리 사용되는 마크업 언어\n   - **마크업 언어**: 문서의 구조와 의미를 태그로 표현하는 언어\n\n2. \"제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것\":\n   - **구조적 의미**: 문서의 구조를 태그로 표현\n   - **제목**: `<h1>`, `<h2>` 등\n   - **단락**: `<p>` 태그\n   - **목록**: `<ul>`, `<ol>`, `<li>` 태그\n\n3. \"링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공\":\n   - **링크**: `<a>` 태그로 하이퍼링크 생성\n   - **인용**: `<blockquote>`, `<q>` 태그\n   - **구조적 문서**: 의미 있는 구조로 문서 작성 가능\n\n[HTML의 정의]\n- 웹 페이지를 작성하기 위한 마크업 언어\n- **태그(Tag)**를 사용하여 문서의 구조와 의미를 표현\n- **웹 브라우저**가 HTML을 해석하여 웹 페이지로 표시\n\n[HTML의 특징]\n| 특징 | 설명 |\n|------|------|\n| **용도** | 웹 페이지 작성 |\n| **형식** | 마크업 언어 (태그 기반) |\n| **표준** | W3C에서 표준화 |\n| **버전** | HTML5 (현재 최신 버전) |\n\n[HTML의 주요 태그]\n- **제목**: `<h1>`, `<h2>`, `<h3>` 등\n- **단락**: `<p>`\n- **목록**: `<ul>`, `<ol>`, `<li>`\n- **링크**: `<a href=\"...\">`\n- **이미지**: `<img src=\"...\">`\n- **인용**: `<blockquote>`, `<q>`\n- **구조**: `<div>`, `<span>`, `<section>`, `<article>` 등\n\n[HTML의 구조]\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>제목</title>\n</head>\n<body>\n    <h1>제목</h1>\n    <p>단락</p>\n    <a href=\"링크\">링크</a>\n</body>\n</html>\n```\n\n[HTML vs 다른 마크업 언어]\n| 구분 | **HTML** | **XML** | **XHTML** |\n|------|----------|---------|-----------|\n| **용도** | 웹 페이지 | 데이터 표현 | HTML의 XML 버전 |\n| **구조** | 태그 기반 | 태그 기반 | 태그 기반 (엄격한 문법) |\n\n[HTML과 웹 기술]\n- **HTML**: 웹 페이지 구조와 내용\n- **CSS**: 웹 페이지 스타일 (디자인)\n- **JavaScript**: 웹 페이지 동작 (인터랙션)\n- **HTTP**: HTML 문서 전송 프로토콜\n\n[답] HTML (HyperText Markup Language)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 모듈 F에 대한 Fan-in과 Fan-out을 작성하시오.", "choices": [], "answer": {"keys": ["Fan-in : 3", "Fan-out : 2"], "raw_text": "Fan-in : 3 Fan-out : 2"}, "explanation": "이 문제는 Fan-in과 Fan-out (모듈 결합도 측정)에 관한 문제입니다.\n\n[Fan-in과 Fan-out이란?]\n\n[Fan-in (팬인)]\n- **정의**: **특정 모듈을 호출하는 모듈의 개수**\n- **방향**: 다른 모듈 → 대상 모듈 (들어오는 호출)\n- **측정**: 대상 모듈로 들어오는 제어 흐름(Control Flow)의 개수\n- **예시**: 모듈 F를 호출하는 모듈이 A, B, C 3개이면 Fan-in = 3\n\n[Fan-out (팬아웃)]\n- **정의**: **특정 모듈이 호출하는 모듈의 개수**\n- **방향**: 대상 모듈 → 다른 모듈 (나가는 호출)\n- **측정**: 대상 모듈에서 나가는 제어 흐름(Control Flow)의 개수\n- **예시**: 모듈 F가 호출하는 모듈이 X, Y 2개이면 Fan-out = 2\n\n[Fan-in과 Fan-out의 특징]\n\n| 개념 | 정의 | 측정 방법 | 좋은 값 | 나쁜 값 |\n|------|------|----------|---------|--------|\n| **Fan-in** | **들어오는 호출의 개수** | 모듈을 호출하는 모듈 수 | **높을수록 좋음** (재사용성 높음) | 낮음 (독립적) |\n| **Fan-out** | **나가는 호출의 개수** | 모듈이 호출하는 모듈 수 | **적절한 값** (5~7 이하 권장) | 너무 높음 (복잡도 증가) |\n\n[Fan-in이 높으면 좋은 이유]\n- **재사용성 높음**: 여러 모듈에서 사용되는 모듈은 재사용성이 높음\n- **공통 기능**: 여러 곳에서 필요한 공통 기능을 모듈화한 경우\n- **모듈화 성공**: 잘 설계된 모듈의 지표\n\n[Fan-out이 높으면 문제가 되는 이유]\n- **복잡도 증가**: 한 모듈이 너무 많은 모듈을 호출하면 복잡도가 증가\n- **의존성 증가**: 많은 모듈에 의존하면 유지보수 어려움\n- **결합도 증가**: 모듈 간 결합도가 높아져 수정이 어려움\n\n[문제 해석]\n\n[모듈 구조도 예시]\n```\n    A ──┐\n    B ──┼──> F ──> X\n    C ──┘     │\n              └──> Y\n```\n\n[Fan-in 계산]\n- 모듈 F를 호출하는 모듈: A, B, C\n- **Fan-in = 3**\n\n[Fan-out 계산]\n- 모듈 F가 호출하는 모듈: X, Y\n- **Fan-out = 2**\n\n[Fan-in과 Fan-out의 관계]\n- Fan-in이 높고 Fan-out이 낮은 모듈: 재사용성이 높고 복잡도가 낮은 이상적인 모듈\n- Fan-in이 낮고 Fan-out이 높은 모듈: 독립적이지만 복잡도가 높은 모듈\n- Fan-in과 Fan-out이 모두 높은 모듈: 재사용성은 높지만 복잡도도 높은 모듈\n\n[소프트웨어 공학에서의 중요성]\n- **모듈 설계 평가**: 모듈의 재사용성과 복잡도를 평가하는 지표\n- **리팩토링 기준**: Fan-out이 너무 높으면 모듈 분리 고려\n- **품질 측정**: 모듈의 품질을 측정하는 지표 중 하나\n\n[답]\n- **Fan-in : 3**\n- **Fan-out : 2**", "table_refs": [], "image_refs": ["images/2022_round2/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.998448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "아래는 C언어의 2차원 배열 형태이다.\nfield의 경우 2차원 배열 형태는 예시처럼 출력되므로, 이를 참고하여\n\nmines의 2차원 배열 형태를 작성하시오.", "choices": [], "answer": {"keys": ["1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3"], "raw_text": "1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3"}, "explanation": "C언어 2차원 배열 형태 작성 문제입니다.\n\n[문제의 이미지를 참고하여 field 배열의 출력 형태를 확인하고, mines 배열의 형태를 작성합니다.]\n\n[C언어 2차원 배열]\n- 2차원 배열은 행(row)과 열(column)로 구성된 데이터 구조입니다\n- 배열 선언: `int arr[행][열];`\n- 배열 요소 접근: `arr[i][j]` (i번째 행, j번째 열)\n\n[배열 출력 형태]\n- 각 행의 요소들을 공백으로 구분하여 출력\n- 행 구분은 `/` 또는 줄바꿈으로 표현\n- 예: `1 2 3 / 4 5 6` (첫 번째 행: 1 2 3, 두 번째 행: 4 5 6)\n\n[답] 문제의 이미지에서 field 배열의 출력 형태를 참고하여 mines 배열의 형태를 작성합니다. 답은 \"1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3\"입니다.", "table_refs": [], "image_refs": ["images/2022_round3/1-1.png", "images/2022_round3/1-2.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["자료구조"], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "아래 예시를 보고\n\n관계 대수에 대한 기호를 작성하시오.", "choices": [], "answer": {"keys": ["U", "-", "X π ⋈"], "raw_text": "U\n-\nX π ⋈"}, "explanation": "[관계 대수(Relational Algebra) 연산 기호]\n\n[관계 대수 연산 종류 및 기호]\n\n[1. UNION (합집합) - 기호: `∪` (U)]\n- 두 릴레이션의 합집합\n- 중복 제거\n- 예: `R ∪ S`\n\n[2. DIFFERENCE (차집합) - 기호: `-`]\n- 두 릴레이션의 차집합\n- R에만 있고 S에는 없는 튜플\n- 예: `R - S`\n\n[3. CARTESIAN PRODUCT (곱집합) - 기호: `×` (X)]\n- 두 릴레이션의 카티시안 곱\n- 모든 조합 생성\n- 예: `R × S`\n\n[4. PROJECT (투영) - 기호: `π` (파이)]\n- 특정 속성(컬럼)만 선택\n- 중복 튜플 제거\n- 예: `π_속성1,속성2(R)`\n\n[5. JOIN (조인) - 기호: `⋈` (보울)]\n- 두 릴레이션을 조건에 따라 결합\n- **Theta JOIN**: `R ⋈_θ S`\n- **EQUI JOIN**: `R ⋈_A=B S` (등호 조건)\n- **NATURAL JOIN**: `R ⋈ S` (같은 속성명으로 자동 결합)\n\n[관계 대수 연산 기호 정리]\n| 연산 | 기호 | 설명 |\n|------|------|------|\n| **UNION (합집합)** | `∪` (U) | 합집합 (중복 제거) |\n| **DIFFERENCE (차집합)** | `-` | 차집합 |\n| CARTESIAN PRODUCT (곱집합) | `×` (X) | 카티시안 곱 |\n| **PROJECT (투영)** | `π` (파이) | 특정 속성만 선택 |\n| **SELECT (선택)** | `σ` (시그마) | 조건에 맞는 행 선택 |\n| **JOIN (조인)** | `⋈` (보울) | 두 릴레이션 결합 |\n\n[답] 문제의 이미지와 예시를 확인하여 관계 대수 기호를 작성합니다. 답은 **\"U, -, X π ⋈\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round3/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 디자인 패턴에 대한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(기호식 보기가 있습니다. ex: Abstract Factory, Mediator 등)\n(   1   )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.\n구현뿐 아니라 추상화도 독립적 변경이 필요할 때 브리지 패턴을 사용한다.\n기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,\n새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.\n(   2   )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.\n일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.", "choices": [], "answer": {"keys": ["1. Bridge", "2. Observer"], "raw_text": "1. Bridge 2. Observer"}, "explanation": "이 문제는 **디자인 패턴** 중 **Bridge 패턴**과 **Observer 패턴**에 대한 문제입니다.\n\n[1. Bridge 패턴 (브리지 패턴)]\n\n[Bridge 패턴의 정의]\n- **기능을 처리하는 클래스**와 **구현을 담당하는 추상 클래스**로 구별하는 구조적 디자인 패턴\n- **추상화(Abstraction)**와 **구현(Implementation)**을 분리하여 독립적으로 변경 가능하게 함\n\n[문제에서 설명한 Bridge 패턴의 특징]\n\n1. \"기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별\":\n   - **추상화 계층**: 기능을 처리하는 클래스 (Abstraction)\n   - **구현 계층**: 실제 구현을 담당하는 추상 클래스 (Implementation)\n   - 두 계층을 **브리지(다리)**로 연결하여 독립적으로 유지\n\n2. \"구현뿐 아니라 추상화도 독립적 변경이 필요할 때\":\n   - 추상화와 구현을 분리하여 **각각 독립적으로 변경** 가능\n   - 구현을 변경해도 추상화에 영향 없음\n   - 추상화를 변경해도 구현에 영향 없음\n\n3. \"기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용\":\n   - **확장성**: 새로운 기능을 추가할 때 기존 코드 변경 최소화\n   - **유연성**: 다양한 구현을 쉽게 추가 가능\n\n4. \"새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장\":\n   - **Decorator 패턴과 혼동 주의**: 문제 설명은 Bridge 패턴이지만, \"기능 확장\"이라는 표현이 있어 혼동 가능\n   - 하지만 \"구현과 추상화 분리\"라는 핵심 특징이 Bridge 패턴\n   - Bridge 패턴은 구조를 분리하고, Decorator 패턴은 기능을 동적으로 추가\n\n[Bridge 패턴 예시]\n```java\n// 추상화 계층\nabstract class Shape {\n    protected Color color;  // 구현 계층 참조\n    // ...\n}\n\n// 구현 계층\ninterface Color {\n    void fill();\n}\n\nclass RedColor implements Color { ... }\nclass BlueColor implements Color { ... }\n```\n\n[2. Observer 패턴 (옵저버 패턴)]\n\n[Observer 패턴의 정의]\n- **한 객체의 상태가 변화하면** 그 객체에 상속되어 있는(등록된) 다른 객체들에게 변화된 상태를 **전달해주는** 행위 디자인 패턴\n- **일대다(One-to-Many) 의존성**을 정의하는 패턴\n\n[문제에서 설명한 Observer 패턴의 특징]\n\n1. \"한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달\":\n   - **Subject (주제)**: 상태가 변화하는 객체\n   - **Observer (관찰자)**: 변화를 감지하고 반응하는 객체들\n   - Subject의 상태 변화 시 등록된 모든 Observer에게 알림\n\n2. **\"일대다 관계를 가지며\"**:\n   - 하나의 Subject가 여러 Observer를 가질 수 있음\n   - Subject ↔ Observer: 1:N 관계\n\n3. \"주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용\":\n   - **Publish-Subscribe 패턴**과 유사\n   - **이벤트 기반 아키텍처**: 이벤트 발생 시 구독자들에게 알림\n   - **느슨한 결합**: Subject와 Observer가 독립적\n\n[Observer 패턴 예시]\n```java\n// Subject\nclass NewsAgency {\n    private List<Observer> observers = new ArrayList<>();\n    \n    public void addObserver(Observer observer) { ... }\n    public void notifyObservers(String news) { ... }\n}\n\n// Observer\ninterface Observer {\n    void update(String news);\n}\n\nclass NewsChannel implements Observer {\n    public void update(String news) { ... }\n}\n```\n\n[디자인 패턴 비교]\n| 패턴 | 목적 | 특징 |\n|------|------|------|\n| **Bridge** | 추상화와 구현 분리 | 구조적 패턴, 독립적 변경 |\n| **Observer** | 상태 변화 알림 | 행위 패턴, 일대다 관계 |\n| **Decorator** | 기능 동적 추가 | 구조적 패턴, 기능 확장 |\n\n[답]\n- (1) **Bridge (브리지 패턴)**\n- (2) **Observer (옵저버 패턴)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "아래 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["24513"], "raw_text": "24513"}, "explanation": "코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"24513\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round3/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 코드에 대한 출력 값을 작성하시오.\n첫번째 네트워크 주소가 192.168.1.0/24일때 FLSM 3개로 분할했을때 두번째 네트워크 브로드캐스드 IP를 10진수로 변환한 값을 작성하시오.", "choices": [], "answer": {"keys": ["192.168.1.127"], "raw_text": "192.168.1.127"}, "explanation": "이 문제는 FLSM (Fixed Length Subnet Mask, 고정 길이 서브넷 마스크)을 이용한 서브넷팅 문제입니다.\n\n[주어진 정보]\n- **원본 네트워크**: 192.168.1.0/24\n- **FLSM 3개로 분할**: 원본 네트워크를 3개의 서브넷으로 분할\n- **요구사항**: 두 번째 서브넷의 브로드캐스트 IP\n\n[FLSM (Fixed Length Subnet Mask)이란?]\n- 모든 서브넷이 **동일한 서브넷 마스크 길이**를 사용하는 방식\n- 서브넷팅 후에도 모든 서브넷의 크기가 같음\n- 예: /24 네트워크를 3개로 분할하면 각 서브넷은 /26\n\n[서브넷팅 계산 과정]\n\n[1단계: 원본 네트워크 분석]\n- **네트워크 주소**: 192.168.1.0/24\n- **서브넷 마스크**: 255.255.255.0 (24비트)\n- **호스트 비트**: 8비트 (32 - 24 = 8)\n- **총 주소 수**: 2^8 = 256개\n- **사용 가능한 호스트**: 256 - 2 = 254개 (네트워크 주소와 브로드캐스트 주소 제외)\n\n[2단계: 3개 서브넷으로 분할]\n- 3개 서브넷을 만들려면 **2^2 = 4개** 이상이 필요 (2비트 서브넷 비트)\n- 따라서 **서브넷 비트**: 2비트 추가\n- **새로운 서브넷 마스크**: /26 (24 + 2 = 26)\n- **서브넷 마스크**: 255.255.255.192\n\n[3단계: 각 서브넷 계산]\n\n[서브넷 비트 2비트로 가능한 서브넷]\n- 00: 첫 번째 서브넷\n- 01: 두 번째 서브넷\n- 10: 세 번째 서브넷\n- 11: 네 번째 서브넷 (4개 서브넷 생성 가능, 3개만 사용)\n\n[각 서브넷의 호스트 비트]\n- 원본 호스트 비트: 8비트\n- 서브넷 비트: 2비트\n- 남은 호스트 비트: 8 - 2 = 6비트\n- 각 서브넷의 주소 수: 2^6 = 64개\n- 각 서브넷의 사용 가능한 호스트: 64 - 2 = 62개\n\n[4단계: 두 번째 서브넷 주소 계산]\n\n[서브넷 비트 01 (두 번째 서브넷)]\n- **서브넷 ID (이진수)**: 192.168.1.**01**000000 = 192.168.1.64\n- **네트워크 주소**: 192.168.1.64\n- **브로드캐스트 주소**: 192.168.1.64 + 64 - 1 = 192.168.1.127\n\n[계산 상세]\n- 네트워크 주소: 192.168.1.64 (서브넷 비트 01, 호스트 비트 000000)\n- 첫 번째 호스트: 192.168.1.65\n- 마지막 호스트: 192.168.1.126\n- **브로드캐스트 주소**: 192.168.1.127 (서브넷 비트 01, 호스트 비트 111111)\n\n[서브넷 분할 요약]\n| 서브넷 | 서브넷 비트 | 네트워크 주소 | 브로드캐스트 주소 | 호스트 범위 |\n|--------|------------|--------------|----------------|------------|\n| 1번 | 00 | 192.168.1.0 | 192.168.1.63 | 192.168.1.1 ~ 192.168.1.62 |\n| **2번** | **01** | 192.168.1.64 | 192.168.1.127 | 192.168.1.65 ~ 192.168.1.126 |\n| 3번 | 10 | 192.168.1.128 | 192.168.1.191 | 192.168.1.129 ~ 192.168.1.190 |\n\n[답] 192.168.1.127 (두 번째 서브넷의 브로드캐스트 주소)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["프로그래밍"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 표를 확인하여\n\n보기에 알맞는 값을 고르시오.\n(기호식 보기가 있습니다. ex: Boundary Value Partitioning​, Equivalence Partitioning 등)", "choices": [], "answer": {"keys": ["Boundary Value Analysis"], "raw_text": "Boundary Value Analysis"}, "explanation": "이 문제는 **테스트 기법** 중 Boundary Value Analysis (경계값 분석)에 대한 문제입니다.\n\n[Boundary Value Analysis (경계값 분석, BVA)란?]\n\n[정의]\n- 입력 값의 **경계(boundary)**에서 오류가 발생할 가능성이 높다는 원리에 기반한 테스트 기법\n- **경계값**과 **경계값 바로 앞뒤 값**을 테스트 케이스로 선택\n- 예: 입력 범위가 1~100이면, 0, 1, 2, 99, 100, 101을 테스트\n\n[Boundary Value Analysis의 특징]\n\n1. **경계값 집중**:\n   - 입력 값의 **최소값(Min)**, **최대값(Max)**\n   - 최소값 바로 아래(Min-1), 최소값 바로 위(Min+1)\n   - 최대값 바로 아래(Max-1), 최대값 바로 위(Max+1)\n\n2. **오류 발견 효율성**:\n   - 프로그램 오류는 경계값에서 자주 발생\n   - 예: 배열 인덱스 오류, 루프 조건 오류 등\n\n3. Equivalence Partitioning과의 관계:\n   - Equivalence Partitioning (동등 분할): 입력 범위를 동등 클래스로 분할\n   - Boundary Value Analysis: 동등 클래스의 경계값을 테스트\n   - 두 기법을 함께 사용하면 효과적\n\n[Boundary Value Analysis 예시]\n\n[입력 범위: 1 ~ 100 (정수)]\n- **유효한 경계값**: 1, 2, 99, 100\n- **무효한 경계값**: 0 (Min-1), 101 (Max+1)\n- **테스트 케이스**: 0, 1, 2, 99, 100, 101\n\n[입력 범위: 0.0 ~ 10.0 (실수)]\n- **유효한 경계값**: 0.0, 0.1, 9.9, 10.0\n- **무효한 경계값**: -0.1, 10.1\n\n[Boundary Value Analysis vs 다른 테스트 기법]\n\n| 테스트 기법 | 정의 | 특징 |\n|-----------|------|------|\n| Boundary Value Analysis | 경계값 중심 테스트 | 경계값과 그 앞뒤 값 테스트 |\n| Equivalence Partitioning | 동등 분할 테스트 | 각 동등 클래스에서 대표값 테스트 |\n| **Decision Table** | 결정 테이블 테스트 | 조건과 행동을 표로 정리하여 테스트 |\n| **Cause-Effect Graph** | 원인-결과 그래프 | 원인과 결과의 관계를 그래프로 표현 |\n\n[문제에서 표를 확인한 결과]\n- 표에 나온 테스트 케이스들이 경계값과 그 앞뒤 값을 포함하고 있음\n- 이는 Boundary Value Analysis의 특징과 일치\n\n[Boundary Value Analysis의 장점]\n1. **효율성**: 적은 테스트 케이스로 많은 오류 발견\n2. **체계성**: 경계값을 체계적으로 선택\n3. **실용성**: 실제 개발에서 자주 사용되는 기법\n\n[답] Boundary Value Analysis (경계값 분석)", "table_refs": [], "image_refs": ["images/2022_round3/6-1.png", "images/2022_round3/6-2.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 데이터 명령어를 적용할 경우 알맞는 출력값을 작성하시오.\n\n​", "choices": [], "answer": {"keys": ["(1). 3", "(2). 4"], "raw_text": "(1). 3\n(2). 4"}, "explanation": "데이터 명령어 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 데이터 명령어 실행 과정을 분석해야 합니다.]\n\n[데이터 명령어 일반적인 분석 방법]\n1. 초기 데이터 상태 확인\n2. 명령어 실행 순서 추적\n3. 데이터 변경 과정 추적\n4. 각 단계별 결과 확인\n\n[답] 문제의 이미지와 데이터 명령어를 확인하여 정확한 출력값을 작성합니다. 답은 \"(1). 3, (2). 4\"입니다.", "table_refs": [], "image_refs": ["images/2022_round3/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 설명에 대한 알맞는 답을 작성하시오.\n(     1     ) 은/는 보안학적 측면에서 기술적인 방법이 아닌 사람들간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법이다.\n(     2     ) 은/는  빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, 더는 사용하지 않는 '죽은' 데이터를 의미한다. 일반적으로 정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니며,  저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다.", "choices": [], "answer": {"keys": ["1. 사회공학", "2. 다크 데이터"], "raw_text": "1. 사회공학 2. 다크 데이터"}, "explanation": "이 문제는 **정보보안** 분야의 사회공학(Social Engineering)과 **다크 데이터(Dark Data)**에 대한 문제입니다.\n\n[1. 사회공학 (Social Engineering)]\n\n[사회공학의 정의]\n- 보안학적 측면에서 기술적인 방법이 아닌 사람들 간의 **기본적인 신뢰를 기반**으로 사람을 속여 **비밀 정보를 획득하는 기법**\n- 기술적 공격이 아닌 **심리적 공격**을 통한 정보 유출\n\n[사회공학의 특징]\n\n1. **\"기술적인 방법이 아닌\"**:\n   - 해킹, 바이러스 등 기술적 공격이 아님\n   - **사람의 심리**를 이용한 공격\n\n2. **\"사람들 간의 기본적인 신뢰를 기반\"**:\n   - 사람들이 서로를 신뢰하는 심리를 악용\n   - 예: 직원인 것처럼 행동, 고객인 것처럼 행동\n\n3. **\"사람을 속여 비밀 정보를 획득\"**:\n   - 위장, 협박, 유혹 등으로 정보를 얻음\n   - 예: 비밀번호, 계좌번호, 개인정보 등\n\n[사회공학 공격 예시]\n- **피싱(Phishing)**: 이메일로 위장하여 정보 유출\n- **프리텍스팅(Pretexting)**: 거짓 상황을 만들어 정보 획득\n- 숄더 서핑(Shoulder Surfing): 어깨 너머로 비밀번호 확인\n- **테일게이팅(Tailgating)**: 출입 허가 없이 사람 뒤를 따라 들어감\n- 덤스터 다이빙(Dumpster Diving): 쓰레기에서 정보 수집\n\n[2. 다크 데이터 (Dark Data)]\n\n[다크 데이터의 정의]\n- 빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, **더는 사용하지 않는 '죽은' 데이터**\n- 수집은 했지만 **분석이나 활용을 하지 않는 데이터**\n\n[문제에서 설명한 다크 데이터의 특징]\n\n1. \"빅데이터와 비슷하면서도 구조화돼 있지 않다\":\n   - 빅데이터처럼 **대량의 데이터**이지만\n   - **비구조화 데이터** 또는 구조가 불명확한 데이터\n   - 예: 로그 파일, 이메일, 문서 등\n\n2. \"더는 사용하지 않는 '죽은' 데이터\":\n   - 한 번 수집한 후 **더 이상 사용하지 않음**\n   - **활용되지 않는 데이터**\n\n3. \"정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니다\":\n   - 수집과 저장은 했지만 **분석이나 활용을 하지 않음**\n   - 단순히 **저장만 되어 있는 데이터**\n\n4. \"저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다\":\n   - **저장 비용만 발생**하고 활용 가치 없음\n   - 하지만 **보안 위험** 존재:\n     - 개인정보가 포함될 수 있음\n     - 악의적 공격의 대상이 될 수 있음\n     - 데이터 유출 시 법적 책임\n     - 보안 정책 미준수 데이터 포함 가능\n\n[다크 데이터의 문제점]\n- **저장 비용**: 불필요한 저장 공간 사용\n- **보안 위험**: 개인정보 유출, 규정 위반\n- **리소스 낭비**: 분석 가능한 데이터를 활용하지 않음\n\n[다크 데이터 vs 빅데이터]\n| 구분 | **빅데이터** | **다크 데이터** |\n|------|------------|---------------|\n| **활용** | 분석 및 활용 | 활용하지 않음 |\n| **구조** | 구조화/비구조화 모두 | 주로 비구조화 |\n| **목적** | 의도적으로 분석 | 수집 후 미활용 |\n| **가치** | 높은 가치 | 낮은 가치 (보안 위험) |\n\n[답]\n- (1) 사회공학 (Social Engineering)\n- (2) **다크 데이터 (Dark Data)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 파이썬 코드에 대한 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["[101 102 103 104 105]"], "raw_text": "[101 102 103 104 105]"}, "explanation": "파이썬 코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 파이썬 코드 실행 과정을 분석해야 합니다.]\n\n[파이썬 코드 일반적인 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 리스트/배열 조작 메서드 확인 (append, extend, 슬라이싱 등)\n3. 반복문/조건문 실행 순서 추적\n4. 변수 값 변화 추적\n5. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 파이썬 코드를 확인하여 정확한 출력값을 작성합니다. 답은 \"[101 102 103 104 105]\"입니다.", "table_refs": [], "image_refs": ["images/2022_round3/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 보안 관련 설명으로 가장 알맞는 용어를  작성하시오.\n(          )  은/는 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.\n서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 미리 감지할 수 있다.", "choices": [], "answer": {"keys": ["SIEM"], "raw_text": "SIEM"}, "explanation": "이 문제는 SIEM (Security Information and Event Management, 보안 정보 및 이벤트 관리)에 대한 문제입니다.\n\n[SIEM (Security Information and Event Management)이란?]\n\n[영어 약자 풀이]\n- **S**ecurity: 보안\n- **I**nformation: 정보\n- **E**vent: 이벤트\n- **M**anagement: 관리\n- SIEM = Security Information and Event Management\n\n[문제에서 설명한 SIEM의 특징]\n\n1. \"머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석\":\n   - **머신러닝 기반**: AI/ML 기술을 활용한 이상 탐지\n   - **대량의 로그**: 시스템, 네트워크, 애플리케이션 등에서 발생하는 모든 로그\n   - **통합관리**: 여러 소스의 로그를 하나의 플랫폼에서 관리\n   - **분석**: 로그 분석을 통한 위협 탐지\n\n2. \"사전에 위협에 대응하는 보안 솔루션\":\n   - **실시간 모니터링**: 위협 발생 시 즉시 감지\n   - **사전 대응**: 공격이 발생하기 전 예방\n   - **자동 대응**: 자동화된 위협 대응 기능\n\n3. \"서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집\":\n   - **다양한 보안 솔루션**: 방화벽, IPS/IDS, 안티바이러스 등\n   - **중앙 집중식 수집**: 모든 로그를 한 곳에서 수집\n   - **통합 관리**: 여러 시스템의 로그를 통합하여 관리\n\n4. \"네트워크 상태의 monitoring 및 이상징후를 미리 감지\":\n   - **네트워크 모니터링**: 네트워크 트래픽 및 상태 실시간 감시\n   - **이상징후 감지**: 비정상적인 패턴이나 행위 탐지\n   - **조기 경고**: 위협 발생 전 경고\n\n[SIEM의 주요 기능]\n\n1. **로그 수집 및 통합**:\n   - 다양한 보안 솔루션에서 로그 수집\n   - 표준화된 형식으로 통합\n\n2. **실시간 모니터링**:\n   - 24/7 실시간 보안 모니터링\n   - 네트워크, 시스템, 애플리케이션 상태 감시\n\n3. **이상 탐지**:\n   - 머신러닝 기반 이상 행위 탐지\n   - 패턴 분석을 통한 위협 식별\n\n4. **사고 대응**:\n   - 위협 발생 시 자동 알림\n   - 사고 분석 및 대응 절차 지원\n\n5. **보고서 생성**:\n   - 보안 이벤트 분석 보고서\n   - 규정 준수 보고서\n\n[SIEM의 주요 용도]\n- **보안 모니터링**: 실시간 보안 이벤트 모니터링\n- **위협 탐지**: 고급 지속적 위협(APT) 탐지\n- **사고 대응**: 보안 사고 분석 및 대응\n- **규정 준수**: 보안 규정 준수 확인\n\n[SIEM vs 다른 보안 솔루션]\n| 구분 | **SIEM** | **방화벽** | **IDS/IPS** |\n|------|----------|-----------|------------|\n| **기능** | 로그 통합 분석 | 트래픽 차단 | 침입 탐지/차단 |\n| **범위** | 전체 보안 이벤트 | 네트워크 경계 | 네트워크 트래픽 |\n| **분석** | 머신러닝 기반 | 규칙 기반 | 패턴 기반 |\n\n[답] SIEM (Security Information and Event Management)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스", "네트워크"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 보기 중, 형상 관리 항목을 3가지 고르시오.", "choices": [], "answer": {"keys": ["CVS", "SVN", "GIT"], "raw_text": "CVS SVN GIT"}, "explanation": "이 문제는 형상 관리(Configuration Management, 버전 관리) 도구에 대한 문제입니다.\n\n[형상 관리(Configuration Management)란?]\n- 소프트웨어 개발 과정에서 **소스 코드의 변경 이력을 관리**하는 도구\n- 버전 관리 시스템(Version Control System, VCS)이라고도 함\n- 여러 개발자가 동시에 작업할 때 **충돌 방지** 및 **변경 이력 추적**\n\n[형상 관리 도구의 주요 기능]\n1. **버전 관리**: 파일의 변경 이력 추적\n2. **병합(Merge)**: 여러 개발자의 변경사항 통합\n3. **브랜치(Branch)**: 기능별로 독립적인 개발 라인 생성\n4. **롤백(Rollback)**: 이전 버전으로 되돌리기\n\n[주요 형상 관리 도구]\n\n[1. CVS (Concurrent Versions System)]\n- **개발 시기**: 1980년대 후반\n- **특징**: 초기 버전 관리 시스템, 현재는 거의 사용 안 함\n- **아키텍처**: 중앙 집중식 (Centralized)\n- **상태**: 레거시 시스템, 현재는 거의 사용되지 않음\n\n[2. SVN (Subversion)]\n- **개발 시기**: 2000년대 초반\n- **특징**: CVS의 개선 버전, 널리 사용됨\n- **아키텍처**: 중앙 집중식 (Centralized)\n- **주요 기능**:\n  - 원자적 커밋 (Atomic Commit)\n  - 디렉토리 버전 관리\n  - 바이너리 파일 지원\n- **상태**: 현재도 많이 사용됨 (특히 기업 환경)\n\n[3. GIT (Global Information Tracker)]\n- **개발 시기**: 2005년 (Linus Torvalds가 개발)\n- **특징**: 현재 가장 널리 사용되는 분산 버전 관리 시스템\n- **아키텍처**: 분산형 (Distributed)\n- **주요 기능**:\n  - 분산 저장소 (로컬에 전체 히스토리 보관)\n  - 빠른 성능\n  - 강력한 브랜치 기능\n  - GitHub, GitLab 등과 통합\n- **상태**: 현재 가장 널리 사용됨\n\n[형상 관리 도구 비교]\n| 도구 | 아키텍처 | 개발 시기 | 현재 사용률 | 특징 |\n|------|----------|----------|------------|------|\n| **CVS** | 중앙 집중식 | 1980년대 후반 | 낮음 (레거시) | 초기 버전 관리 시스템 |\n| **SVN** | 중앙 집중식 | 2000년대 초반 | 중간 | CVS의 개선 버전 |\n| **GIT** | 분산형 | 2005년 | 높음 (가장 널리 사용) | 현재 표준 |\n\n[중앙 집중식 vs 분산형]\n\n| 구분 | **중앙 집중식 (CVS, SVN)** | **분산형 (GIT)** |\n|------|------------------------|----------------|\n| **저장소** | 중앙 서버 1개 | 로컬 + 원격 여러 개 |\n| **오프라인 작업** | 불가능 | 가능 (로컬에 전체 히스토리) |\n| **성능** | 상대적으로 느림 | 빠름 |\n| **브랜치** | 제한적 | 강력함 |\n\n[형상 관리 도구의 역할]\n- **버전 추적**: 누가, 언제, 무엇을 변경했는지 기록\n- **협업 지원**: 여러 개발자가 동시에 작업 가능\n- **백업**: 코드 변경 이력 보관\n- **롤백**: 문제 발생 시 이전 버전으로 복구\n\n[답] **CVS, SVN, GIT** (모두 형상 관리 도구)", "table_refs": [], "image_refs": ["images/2022_round3/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "STUDENT 테이블에서 컴퓨터과 학생 50명, 전기과 학생 100명, 인터넷과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과에 따른 튜플의 수는? (단, DEPT 칼럼은 학과명이다.\n)\n1) SELECT DERP FROM STUDENT;\n2) SELECT DISTINCT DEPT FROM STUDENT;\n3) SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '인터넷과';", "choices": [], "answer": {"keys": ["1) 200", "2) 3", "3) 1"], "raw_text": "1) 200 2) 3) 1"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n[SQL 쿼리 실행 순서와 분석]\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 1) 200, 2) 3, 3) 1입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n[문제 해석 과정]\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"2\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래 설명에 대하여 알맞는 답을 보기에서 고르시오.\n(기호식 보기가 있습니다. ex: CSRF 등)\n(   1   )은/는 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 ARM사에서 개발한 하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하는 하드웨어 기반의 보안 기술이다.\n(   2   )은/는 사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 유사한 유명 도메인을 미리 등록하는 일로 URL 하이재킹(hijacking)이라고도 한다.", "choices": [], "answer": {"keys": ["1. Trustzone", "2. typosquatting"], "raw_text": "1. Trustzone 2. typosquatting"}, "explanation": "이 문제는 **정보보안** 분야의 **Trustzone**과 **typosquatting**에 대한 문제입니다.\n\n[1. Trustzone (트러스트존)]\n\n[Trustzone의 정의]\n- ARM사에서 개발한 하드웨어 기반의 보안 기술\n- 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, **중요한 정보를 보호**하는 기술\n\n[문제에서 설명한 Trustzone의 특징]\n\n1. \"ARM사에서 개발한 하드웨어 기반의 보안 기술\":\n   - ARM (Advanced RISC Machines): 프로세서 설계 회사\n   - **하드웨어 기반**: 소프트웨어가 아닌 **하드웨어 레벨**에서 보안 구현\n   - 프로세서 칩 내부에 보안 기능 내장\n\n2. \"프로세서 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호\":\n   - **독립적인 보안 구역**: 프로세서 내부에 **보안 영역(Secure World)**과 **일반 영역(Normal World)** 분리\n   - **중요한 정보 보호**: 암호화 키, 인증 정보 등 보안이 중요한 데이터를 보안 구역에 저장\n   - **격리**: 보안 구역과 일반 구역 간 **하드웨어 레벨 격리**\n\n[Trustzone의 동작 원리]\n- **Normal World**: 일반 애플리케이션 실행 환경\n- **Secure World**: 보안이 중요한 코드 및 데이터 실행 환경\n- **하드웨어 전환**: 프로세서가 자동으로 두 세계 간 전환\n- **보안 보장**: Normal World에서 Secure World의 데이터 접근 불가\n\n[Trustzone의 주요 용도]\n- **모바일 기기**: 스마트폰, 태블릿 등\n- **IoT 디바이스**: 보안이 중요한 임베디드 시스템\n- **결제 시스템**: 신용카드 정보, 결제 인증\n- **생체 인증**: 지문, 얼굴 인식 데이터\n\n[2. typosquatting (타이포스쿼팅)]\n\n[typosquatting의 정의]\n- 사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 **유사한 유명 도메인을 미리 등록**하는 일\n- **URL 하이재킹(hijacking)**이라고도 함\n\n[영어 단어 풀이]\n- **Typo**: 오타, 철자 오류\n- **Squatting**: 불법 점유, 악의적 등록\n- **typosquatting**: 오타를 이용한 도메인 하이재킹\n\n[문제에서 설명한 typosquatting의 특징]\n\n1. \"사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수\":\n   - **오타 이용**: 사용자의 실수(오타)를 악용\n   - 예: \"google.com\" → \"googel.com\" (오타)\n   - 예: \"naver.com\" → \"naverr.com\" (철자 추가)\n\n2. **\"유사한 유명 도메인을 미리 등록\"**:\n   - **유명 도메인**: 구글, 네이버 등 잘 알려진 사이트\n   - **유사 도메인**: 원본과 비슷하게 보이는 도메인 등록\n   - 예: \"facebook.com\" → \"faceboook.com\" (글자 추가)\n   - 예: \"amazon.com\" → \"amazom.com\" (글자 누락)\n\n3. \"URL 하이재킹(hijacking)이라고도 한다\":\n   - **하이재킹**: 남의 것을 가로채는 행위\n   - URL을 가로채서 사용자를 속임\n\n[typosquatting의 공격 목적]\n- **피싱**: 사용자를 속여 개인정보 유출\n- **멀웨어 배포**: 악성 코드 다운로드 유도\n- **광고 수익**: 클릭 유도로 광고 수익 창출\n- **브랜드 손상**: 유명 브랜드의 평판 손상\n\n[typosquatting 예시]\n- \"google.com\" → \"gooogle.com\", \"gogle.com\"\n- \"microsoft.com\" → \"micrsoft.com\", \"microsft.com\"\n- \"apple.com\" → \"appple.com\", \"aple.com\"\n\n[typosquatting 방어 방법]\n- **도메인 사전 등록**: 유사 도메인을 미리 등록하여 보호\n- **사용자 교육**: 정확한 URL 입력 교육\n- **브라우저 보안**: 브라우저의 피싱 경고 기능\n\n[답]\n- (1) **Trustzone (트러스트존)**\n- (2) typosquatting (타이포스쿼팅)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "아래 설명에 대하여 알맞는 용어를 작성하시오.\n(       )은/는 여러 개의 사이트에서 한번의 로그인으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을 말한다. 일반적으로 서로 다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 하나의 사용자 정보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하게 하는 것을 말한다.\n즉 하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고 있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.", "choices": [], "answer": {"keys": ["SSO"], "raw_text": "SSO"}, "explanation": "이 문제는 SSO (Single Sign-On, 단일 로그인)에 대한 문제입니다.\n\n[SSO (Single Sign-On, 단일 로그인)이란?]\n\n[영어 약자 풀이]\n- **S**ingle: 단일, 하나의\n- **S**ign: 로그인\n- **O**n: 켜다, 시작하다\n- **SSO = Single Sign-On**\n\n[문제에서 설명한 SSO의 특징]\n\n1. \"여러 개의 사이트에서 한번의 로그인으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법\":\n   - **한 번의 로그인**: 사용자가 **한 번만** 로그인하면\n   - **여러 사이트 접속**: 여러 다른 사이트에 **자동으로 로그인**되어 이용 가능\n   - **자동 접속**: 추가 로그인 없이 다른 서비스 이용\n\n2. \"서로 다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 하나의 사용자 정보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하게 하는 것\":\n   - **통합 인증**: 여러 시스템이 **하나의 인증 시스템**을 공유\n   - **단일 사용자 정보**: 여러 시스템이 **같은 사용자 정보**를 사용\n   - **중앙 관리**: 사용자 인증 정보를 **중앙에서 관리**\n\n3. \"하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고 있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것\":\n   - **인증 정보 확인**: 다른 시스템에서 **인증 정보를 확인**\n   - **자동 로그인**: 인증 정보가 있으면 **자동으로 로그인 처리**\n   - **통합 인증 재시도**: 인증 정보가 없으면 **통합 인증 시스템으로 리다이렉트**\n\n[SSO의 동작 원리]\n\n1. **사용자가 첫 번째 시스템에 로그인**:\n   - 사용자가 통합 인증 서버에 로그인\n   - 인증 토큰(Token) 또는 세션 생성\n\n2. **다른 시스템 접근 시**:\n   - 사용자가 다른 시스템에 접근하려고 시도\n   - 해당 시스템이 **인증 정보 확인**\n   - 인증 정보가 있으면 **자동 로그인 처리**\n   - 인증 정보가 없으면 **통합 인증 서버로 리다이렉트**\n\n3. **통합 인증 서버**:\n   - 사용자 인증 정보를 중앙에서 관리\n   - 인증 토큰 발급 및 검증\n   - 여러 시스템 간 인증 정보 공유\n\n[SSO의 장점]\n\n1. **사용자 편의성**:\n   - 여러 번 로그인할 필요 없음\n   - 사용자 경험 향상\n\n2. **관리 효율성**:\n   - 사용자 정보를 중앙에서 관리\n   - 관리 비용 절감\n\n3. **보안 강화**:\n   - 중앙 집중식 보안 관리\n   - 비밀번호 정책 일원화\n\n[SSO의 주요 기술]\n- SAML (Security Assertion Markup Language): XML 기반 인증 프로토콜\n- **OAuth**: 인증 및 권한 부여 프레임워크\n- **OpenID Connect**: OAuth 2.0 기반 인증 프로토콜\n- **Kerberos**: 네트워크 인증 프로토콜\n\n[SSO 예시]\n- **Google 계정**: Gmail, YouTube, Google Drive 등에 한 번 로그인으로 모두 접근\n- **Microsoft 계정**: Office 365, OneDrive, Azure 등에 통합 인증\n- **기업 내부 시스템**: 여러 사내 시스템에 한 번 로그인으로 접근\n\n[SSO vs 일반 로그인]\n| 구분 | **일반 로그인** | **SSO** |\n|------|--------------|---------|\n| **로그인 횟수** | 각 사이트마다 로그인 필요 | 한 번만 로그인 |\n| **사용자 정보** | 각 시스템마다 별도 관리 | 통합 관리 |\n| **편의성** | 낮음 | 높음 |\n| **관리** | 분산 관리 | 중앙 관리 |\n\n[답] SSO (Single Sign-On, 단일 로그인)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 스케줄링에 관한 내용이다.\n괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["SJF", "RR", "SRT"], "raw_text": "SJF RR SRT"}, "explanation": "이 문제는 운영체제 분야의 핵심 개념을 이해하는 문제입니다.\n\n[문제 해석 과정]\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"SJF, RR, SRT\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 UML에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\nUML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.\n구성 요소로는 사물, (    1    ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (     2    ) 다이어그램은 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다.\n또한 UML 모델링에서 (     3    )은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는 오퍼레이션 세트를 정의하는 모델 요소이다.", "choices": [], "answer": {"keys": ["1. 관계", "2. 클래스", "3. 인터페이스"], "raw_text": "1. 관계 2. 클래스 3. 인터페이스"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n[문제 해석 과정]\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"1. 관계, 2. 클래스, 3. 인터페이스\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 E-R다이어그램에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(아래 그래프 기호는 정확히 기억이 나지 않아 임의로 작성한 것이니 참고만 해주세요.)\n(    1    )  :  개체집합 - 관계집합 연결\n(    2    )  :  개체 집합과의 연결\n(    3    )  :  관계집합 - 관계집합의 속성 연결\n(    4    )  :  두 개체집합 관계에서 생성되는 값을 저장하는 속성\n(    5    )  :  같은 속성을 공유하는 개체들의 모임", "choices": [], "answer": {"keys": ["1. 실선", "2. 관계집합", "3. 점선"], "raw_text": "1. 실선 2. 관계집합 3. 점선"}, "explanation": "이 문제는 E-R 다이어그램(Entity-Relationship Diagram)의 구성 요소와 기호에 대한 문제입니다.\n\n[E-R 다이어그램이란?]\n- 데이터베이스 설계에서 **개념적 설계 단계**에서 사용하는 다이어그램\n- 엔티티(Entity), 속성(Attribute), 관계(Relationship)를 시각적으로 표현\n\n[문제에서 설명한 각 구성 요소]\n\n[1. (1) 개체집합 - 관계집합 연결]\n- **답: 실선**\n- 개체집합(Entity Set)과 관계집합(Relationship Set)을 연결하는 선\n- E-R 다이어그램에서 개체와 관계를 연결하는 **실선(직선)**으로 표현\n- 예: 학생(개체)과 수강(관계)을 실선으로 연결\n\n[2. (2) 개체 집합과의 연결]\n- **답: 관계집합**\n- 개체집합들을 연결하는 관계집합(Relationship Set)을 의미\n- 여러 개체집합 간의 관계를 나타내는 집합\n- 예: 학생 개체집합과 과목 개체집합을 연결하는 \"수강\" 관계집합\n\n[3. (3) 관계집합 - 관계집합의 속성 연결]\n- **답: 점선**\n- 관계집합과 그 관계집합의 속성을 연결하는 **점선(Dashed Line)**\n- 관계집합 자체가 가지고 있는 속성(예: 수강 날짜, 성적 등)을 연결할 때 사용\n- 개체집합과 속성을 연결하는 점선과 유사하지만, 관계집합의 속성임을 구분\n\n[4. (4) 두 개체집합 관계에서 생성되는 값을 저장하는 속성]\n- **답: 관계집합의 속성**\n- 두 개체집합 간의 관계에서 발생하는 값을 저장하는 속성\n- 예: \"학생\"과 \"과목\" 관계에서 \"수강일자\", \"성적\" 등은 관계집합의 속성\n- 개체집합의 속성이 아닌 관계 자체의 속성\n\n[5. (5) 같은 속성을 공유하는 개체들의 모임]\n- **답: 개체집합**\n- **개체집합(Entity Set)**: 같은 속성을 공유하는 개체들의 모임\n- 예: \"학생\" 개체집합은 학번, 이름, 학과 등의 속성을 공유하는 학생들의 모임\n- 데이터베이스에서 테이블(릴레이션)에 해당\n\n[E-R 다이어그램 기호 요약]\n| 요소 | 기호 | 설명 |\n|------|------|------|\n| **개체집합** | 사각형 | 엔티티를 나타냄 |\n| **관계집합** | 마름모 | 관계를 나타냄 |\n| **속성** | 타원 | 속성을 나타냄 |\n| **개체-관계 연결** | **실선** | 개체와 관계를 연결 |\n| **관계-속성 연결** | **점선** | 관계와 속성을 연결 |\n| **개체-속성 연결** | 점선 | 개체와 속성을 연결 |\n\n[답]\n- (1) **실선**\n- (2) **관계집합**\n- (3) **점선**\n- (4) **관계집합의 속성**\n- (5) **개체집합**", "table_refs": [], "image_refs": ["images/2022_round3/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["0123"], "raw_text": "0123"}, "explanation": "Java 배열과 반복문 문제입니다.\n\n[문제의 전체 코드]\n\n```java\npublic class Main {\n    static int[] MakeArray(){\n        int[] tempArr = new int[4];\n        \n        for(int i=0; i<tempArr.Length; i++){\n            tempArr[i] = i;\n        }\n        \n        return tempArr;\n    }\n    \n    public static void main(String[] args){\n        int[] intArr;\n        intArr = MakeArray();\n        \n        for(int i=0; i < intArr.Length; i++)\n            System.out.print(intArr[i]);\n    }\n}\n```\n\n[코드 실행 과정]\n\n1. [`MakeArray()` 메서드]\n   - `int[] tempArr = new int[4];`: 크기 4인 배열 생성\n   - 초기값: `[0, 0, 0, 0]`\n   \n   - `for(int i=0; i<tempArr.Length; i++)`: 0부터 3까지 반복\n     - `i=0`: `tempArr[0] = 0` → `[0, 0, 0, 0]`\n     - `i=1`: `tempArr[1] = 1` → `[0, 1, 0, 0]`\n     - `i=2`: `tempArr[2] = 2` → `[0, 1, 2, 0]`\n     - `i=3`: `tempArr[3] = 3` → `[0, 1, 2, 3]`\n   \n   - `return tempArr;`: `[0, 1, 2, 3]` 반환\n\n2. [`main()` 메서드]\n   - `intArr = MakeArray();`: `intArr = [0, 1, 2, 3]`\n   \n   - `for(int i=0; i < intArr.Length; i++)`: 0부터 3까지 반복\n     - `i=0`: `System.out.print(intArr[0]);` → 출력: **0**\n     - `i=1`: `System.out.print(intArr[1]);` → 출력: **1**\n     - `i=2`: `System.out.print(intArr[2]);` → 출력: **2**\n     - `i=3`: `System.out.print(intArr[3]);` → 출력: **3**\n\n[최종 출력] **0123**\n\n[핵심 포인트]\n\n- 배열의 각 인덱스에 인덱스 값 자체를 저장 (`tempArr[i] = i`)\n- `System.out.print()`는 줄바꿈 없이 출력 (println과 다름)\n- 배열 길이: `.length` (Java에서는 소문자 'l'이지만, 문제 코드는 'L'로 표기)\n\n[답] **0123** 타입과 초기값 확인\n   - 인스턴스 변수 vs 클래스 변수 vs 지역 변수 구분\n\n2. **반복문**:\n   - `for`, `while`, `do-while` 등의 반복문 구조 확인\n   - 반복 횟수와 조건 확인\n   - `System.out.print()` vs `System.out.println()` 구분 (줄바꿈 여부)\n\n3. **출력 순서**:\n   - 출력문의 실행 순서 확인\n   - 여러 출력문이 있을 경우 순서대로 출력\n\n4. **문자열/배열 처리**:\n   - 문자열의 인덱스 접근 (`charAt()`, `substring()` 등)\n   - 배열의 인덱스 접근 (`arr[i]`)\n\n[일반적인 \"0123\" 출력 패턴]\n- **0부터 3까지**의 숫자를 순차적으로 출력하는 코드\n- `System.out.print()`를 사용하여 줄바꿈 없이 연속 출력\n- 반복문이나 순차적인 출력문으로 구현\n\n[답] 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 변수의 초기값부터 시작하여 각 문장의 실행 결과를 순서대로 추적하면 정확한 답을 얻을 수 있습니다. 이 경우 출력값은 **\"0123\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round3/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["993"], "raw_text": "993"}, "explanation": "Java 코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"993\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round3/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "class Static{\n\npublic int a = 20;\nstatic int b = 0;\n\n}\n\npublic class Main{\npublic static void main(String[] args) {\n\nint a;\na = 10;\nStatic.b = a;\n\nStatic st = new Static();\n\nSystem.out.println(Static.b++);\nSystem.out.println(st.b);\nSystem.out.println(a);\nSystem.out.print(st.a);\n}\n}", "choices": [], "answer": {"keys": ["10", "11", "10", "20"], "raw_text": "10 11 10 20"}, "explanation": "이 문제는 **Java의 static 변수**와 **인스턴스 변수**, 그리고 **후위 증감 연산자**를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java\nclass Static{\n    public int a = 20;        // 인스턴스 변수\n    static int b = 0;         // static 변수 (클래스 변수)\n}\n\npublic class Main{\n    public static void main(String[] args) {\n        int a;                // 지역 변수\n        a = 10;               // 지역 변수 a = 10\n        Static.b = a;         // Static.b = 10 (static 변수는 클래스 이름으로 접근)\n        Static st = new Static();  // Static 객체 생성 (st.a = 20)\n        \n        System.out.println(Static.b++);  // 10 출력 후 b 증가 (후위 증감)\n        System.out.println(st.b);         // 11 출력 (static 변수는 모든 인스턴스 공유)\n        System.out.println(a);            // 10 출력 (지역 변수)\n        System.out.print(st.a);           // 20 출력 (인스턴스 변수)\n    }\n}\n```\n\n[실행 과정]\n\n1. **`int a; a = 10;`**: 지역 변수 `a`에 10 저장\n\n2. `Static.b = a;`: static 변수 `Static.b`에 10 저장\n   - static 변수는 클래스 이름으로 직접 접근 가능\n   - 모든 인스턴스가 공유하는 변수\n\n3. `Static st = new Static();`: Static 객체 생성\n   - `st.a = 20` (인스턴스 변수 초기화)\n   - `st.b`는 `Static.b`와 같은 변수 (static 변수는 공유)\n\n4. `System.out.println(Static.b++);`:\n   - **후위 증감 연산자(`++`)**: 먼저 값을 사용한 후 증가\n   - `Static.b`의 현재 값 **10** 출력\n   - 출력 후 `Static.b`가 **11**로 증가\n\n5. `System.out.println(st.b);`:\n   - `st.b`는 `Static.b`와 같은 변수 (static 변수 공유)\n   - 현재 값 **11** 출력\n\n6. `System.out.println(a);`:\n   - 지역 변수 `a`의 값 **10** 출력\n\n7. `System.out.print(st.a);`:\n   - 인스턴스 변수 `st.a`의 값 **20** 출력\n\n[핵심 개념]\n\n- **static 변수**: 클래스 변수, 모든 인스턴스가 공유, 클래스 이름으로 접근\n- **인스턴스 변수**: 각 객체마다 독립적인 변수\n- **후위 증감 연산자(`++`)**: 값을 먼저 사용한 후 증가\n\n[답] **10 11 10 20**", "table_refs": [], "image_refs": ["images/2023_round1/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "java", "code": "class Static{\n    public int a = 20;\n    static int b = 0;\n}\npublic class Main{\n    public static void main(String[] args) {\n        int a;\n        a = 10;\n        Static.b = a;\n        Static st = new Static();\n        System.out.println(Static.b++);\n        System.out.println(st.b);\n        System.out.println(a);\n        System.out.print(st.a);\n    }\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round1/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java", "python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "#include <stdio.h>\n\nint main(){\nchar a[] = \"Art\";\nchar* p = NULL;\np = a;\n\nprintf(\"%s\\n\", a);\nprintf(\"%c\\n\", *p);\nprintf(\"%c\\n\", *a);\nprintf(\"%s\\n\", p);\n\nfor(int i = 0; a[i] != '\\0'; i++)\nprintf(\"%c\", a[i]);\n\n}", "choices": [], "answer": {"keys": ["Art", "A", "A", "Art", "Art"], "raw_text": "Art\nA\nA\nArt\nArt"}, "explanation": "이 문제는 **C언어의 포인터와 문자열 배열**, 그리고 **printf 포맷 지정자**를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c\n#include <stdio.h>\nint main(){\n    char a[] = \"Art\";      // 문자 배열 a[] = {'A', 'r', 't', '\\0'}\n    char* p = NULL;         // 문자 포인터 초기화\n    p = a;                  // 포인터 p가 배열 a의 시작 주소를 가리킴\n    \n    printf(\"%s\\n\", a);    // 문자열 출력: \"Art\"\n    printf(\"%c\\n\", *p);   // 문자 출력: 'A' (포인터가 가리키는 첫 번째 문자)\n    printf(\"%c\\n\", *a);   // 문자 출력: 'A' (배열 이름은 첫 번째 요소의 주소)\n    printf(\"%s\\n\", p);    // 문자열 출력: \"Art\" (포인터가 가리키는 문자열)\n    \n    for(int i = 0; a[i] != '\\0'; i++)\n        printf(\"%c\", a[i]);  // 각 문자 출력: 'A', 'r', 't'\n}\n```\n\n[실행 과정]\n\n1. **`char a[] = \"Art\";`**:\n   - 문자 배열 `a[]`에 \"Art\" 저장\n   - `a[0] = 'A'`, `a[1] = 'r'`, `a[2] = 't'`, `a[3] = '\\0'`\n   - 배열 이름 `a`는 첫 번째 요소의 주소를 의미\n\n2. **`char* p = NULL; p = a;`:\n   - 포인터 `p`가 배열 `a`의 시작 주소를 가리킴\n   - `p`와 `a`는 같은 주소를 가리킴\n\n3. `printf(\"%s\\n\", a);`**:\n   - **`%s`: 문자열 출력 포맷\n   - 배열 `a`의 문자열 출력: \"Art\"\n   - 개행 문자(`\\n`)로 줄바꿈\n\n4. `printf(\"%c\\n\", *p);`**:\n   - **`%c`**: 문자 출력 포맷\n   - **`*p`**: 포인터 `p`가 가리키는 값 (역참조)\n   - `p`는 `a[0]`의 주소를 가리키므로 `*p = 'A'`\n   - 출력: **'A'**\n\n5. **`printf(\"%c\\n\", *a);`**:\n   - **`*a`**: 배열 이름 `a`는 첫 번째 요소의 주소이므로 역참조하면 `a[0]`\n   - `*a = 'A'`\n   - 출력: **'A'**\n\n6. **`printf(\"%s\\n\", p);`**:\n   - 포인터 `p`가 가리키는 문자열 출력\n   - `p`는 `a`의 시작 주소를 가리키므로 문자열 \"Art\" 출력\n   - 출력: **\"Art\"**\n\n7. `for(int i = 0; a[i] != '\\0'; i++) printf(\"%c\", a[i]);`:\n   - 배열의 각 문자를 순회하며 출력\n   - `a[0] = 'A'`, `a[1] = 'r'`, `a[2] = 't'` 출력\n   - 출력: **\"Art\"** (줄바꿈 없음)\n\n[핵심 개념]\n\n- **배열 이름**: 첫 번째 요소의 주소를 의미 (`a` == `&a[0]`)\n- **포인터**: 메모리 주소를 저장하는 변수\n- **역참조(`*`): 포인터가 가리키는 값을 가져옴\n- `%s`: 문자열 출력 (널 문자(`\\0`)까지)\n- `%c`**: 문자 하나 출력\n\n[답]\n```\nArt\nA\nA\nArt\nArt\n```", "table_refs": [], "image_refs": ["images/2023_round1/2.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main(){\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n}", "line_numbers": [1, 12], "file": "data/codes/2023_round1/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "#include <stdio.h>\n\nint main(){\n\nchar* a = \"qwer\";\nchar* b = \"qwtety\";\n\nfor(int i = 0; a[i] != '\\0' ; i++){\nfor(int j = 0; b[j] != '\\0'; j++){\nif(a[i] == b[j]) printf(\"%c\", a[i]);\n}\n}\n\n}", "choices": [], "answer": {"keys": ["qwe"], "raw_text": "qwe"}, "explanation": "이 문제는 **C언어의 중첩 반복문**과 **문자열 비교**를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c\n#include <stdio.h>\nint main(){\n    char* a = \"qwer\";      // 문자열 a = \"qwer\"\n    char* b = \"qwtety\";    // 문자열 b = \"qwtety\"\n    \n    for(int i = 0; a[i] != '\\0'; i++){           // 외부 반복문: a의 각 문자 순회\n        for(int j = 0; b[j] != '\\0'; j++){       // 내부 반복문: b의 각 문자 순회\n            if(a[i] == b[j])                     // a[i]와 b[j]가 같으면\n                printf(\"%c\", a[i]);             // a[i] 출력\n        }\n    }\n}\n```\n\n[실행 과정]\n\n[문자열 분석]\n- `a = \"qwer\"`: `a[0] = 'q'`, `a[1] = 'w'`, `a[2] = 'e'`, `a[3] = 'r'`, `a[4] = '\\0'`\n- `b = \"qwtety\"`: `b[0] = 'q'`, `b[1] = 'w'`, `b[2] = 't'`, `b[3] = 'e'`, `b[4] = 't'`, `b[5] = 'y'`, `b[6] = '\\0'`\n\n[중첩 반복문 실행]\n\n1. **`i = 0` (a[0] = 'q')**:\n   - `j = 0`: `a[0] == b[0]` → `'q' == 'q'` → **TRUE** → `'q'` 출력\n   - `j = 1`: `a[0] == b[1]` → `'q' == 'w'` → FALSE\n   - `j = 2`: `a[0] == b[2]` → `'q' == 't'` → FALSE\n   - `j = 3`: `a[0] == b[3]` → `'q' == 'e'` → FALSE\n   - `j = 4`: `a[0] == b[4]` → `'q' == 't'` → FALSE\n   - `j = 5`: `a[0] == b[5]` → `'q' == 'y'` → FALSE\n\n2. **`i = 1` (a[1] = 'w')**:\n   - `j = 0`: `a[1] == b[0]` → `'w' == 'q'` → FALSE\n   - `j = 1`: `a[1] == b[1]` → `'w' == 'w'` → **TRUE** → `'w'` 출력\n   - `j = 2`: `a[1] == b[2]` → `'w' == 't'` → FALSE\n   - `j = 3`: `a[1] == b[3]` → `'w' == 'e'` → FALSE\n   - `j = 4`: `a[1] == b[4]` → `'w' == 't'` → FALSE\n   - `j = 5`: `a[1] == b[5]` → `'w' == 'y'` → FALSE\n\n3. **`i = 2` (a[2] = 'e')**:\n   - `j = 0`: `a[2] == b[0]` → `'e' == 'q'` → FALSE\n   - `j = 1`: `a[2] == b[1]` → `'e' == 'w'` → FALSE\n   - `j = 2`: `a[2] == b[2]` → `'e' == 't'` → FALSE\n   - `j = 3`: `a[2] == b[3]` → `'e' == 'e'` → **TRUE** → `'e'` 출력\n   - `j = 4`: `a[2] == b[4]` → `'e' == 't'` → FALSE\n   - `j = 5`: `a[2] == b[5]` → `'e' == 'y'` → FALSE\n\n4. **`i = 3` (a[3] = 'r')**:\n   - `j = 0`: `a[3] == b[0]` → `'r' == 'q'` → FALSE\n   - `j = 1`: `a[3] == b[1]` → `'r' == 'w'` → FALSE\n   - `j = 2`: `a[3] == b[2]` → `'r' == 't'` → FALSE\n   - `j = 3`: `a[3] == b[3]` → `'r' == 'e'` → FALSE\n   - `j = 4`: `a[3] == b[4]` → `'r' == 't'` → FALSE\n   - `j = 5`: `a[3] == b[5]` → `'r' == 'y'` → FALSE\n   - 일치하는 문자 없음 (출력 없음)\n\n[출력 결과]\n- `'q'` (a[0]과 b[0] 일치)\n- `'w'` (a[1]과 b[1] 일치)\n- `'e'` (a[2]과 b[3] 일치)\n- **최종 출력: \"qwe\"**\n\n[핵심 개념]\n\n- **중첩 반복문**: 외부 반복문의 각 반복마다 내부 반복문이 완전히 실행됨\n- **문자열 비교**: 각 문자를 하나씩 비교하여 일치하는 문자를 찾음\n- **교집합**: 두 문자열에 공통으로 포함된 문자를 찾는 알고리즘\n\n[답] **\"qwe\"**", "table_refs": [], "image_refs": ["images/2023_round1/3.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main(){\n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n    for(int i = 0; a[i] != '\\0'; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n}", "line_numbers": [1, 10], "file": "data/codes/2023_round1/Q003_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 내용을 확인하여\n\n괄호 안에 용어를 표안에 알맞는 값을 고르시오.\n(보기가 있습니다.\nex: 패킷​\n등)", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "[SSH (Secure Shell, 시큐어 셸)]\n\n[영어 약자 풀이]\n- **S**ecure: 보안의, 안전한\n- **S**hell: 셸 (명령 프롬프트)\n- **H** (없음, SSH는 두 단어)\n- **SSH = Secure Shell**\n\n[SSH의 정의]\n- **원격 접속을 위한 보안 프로토콜**\n- 네트워크상의 다른 컴퓨터에 **암호화된 통신**으로 접속\n- 기본 포트: **22번**\n\n[SSH의 주요 특징]\n\n1. [원격 접속]\n   - 네트워크상의 다른 컴퓨터에 로그인\n   - 원격 시스템에서 명령 실행\n   - `ssh user@hostname` 형태로 접속\n\n2. [파일 전송]\n   - **SCP (Secure Copy)**: 암호화된 파일 복사\n   - SFTP (SSH File Transfer Protocol): 암호화된 파일 전송\n\n3. [보안 기능]\n   - **암호화된 통신**: 모든 데이터가 암호화되어 전송\n   - **공개키 기반 인증**: 비밀번호 없이 키 기반 인증 가능\n   - **IP 스푸핑 방지**: 연결 무결성 보장\n\n4. [기존 프로토콜의 보안 버전]\n   - rsh, rcp, rlogin, rexec: 평문 통신 → SSH로 대체\n   - **Telnet**: 평문 통신 → SSH로 대체\n   - **FTP**: 평문 파일 전송 → SFTP로 대체\n\n[SSH vs 기존 프로토콜]\n| 구분 | **기존 프로토콜** | **SSH** |\n|------|------------------|---------|\n| **통신** | 평문 (암호화 없음) | 암호화 |\n| **보안** | 취약 | 안전 |\n| **포트** | Telnet(23), FTP(21) | 22 |\n\n[답] **SSH**", "table_refs": [], "image_refs": ["images/2023_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 내용을 확인하여\n\n알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. 웜", "2. 트로이 목마", "3. 바이러스"], "raw_text": "1. 웜 2. 트로이 목마 3. 바이러스"}, "explanation": "악성코드는 그 특성에 따라 웜, 트로이 목마, 바이러스로 분류됩니다.\n\n[악성코드의 특징]\n\n1. [웜(Worm)]\n- 자기 복제를 통해 네트워크로 확산\n- 다른 파일에 기생하지 않고 독립적으로 실행\n- 네트워크 취약점을 이용해 빠르게 전파\n- 예: Code Red, Nimda\n\n2. [트로이 목마(Trojan Horse)]\n- 정상 프로그램으로 위장한 악성 코드\n- 사용자가 의도적으로 설치 (위장된 정상 프로그램처럼 보임)\n- 다른 파일에 기생하지 않음\n- 백도어 설치, 정보 탈취 등 수행\n\n3. [바이러스(Virus)]\n- 다른 파일에 기생하여 감염\n- 실행 파일, 문서 파일 등에 삽입\n- 사용자가 감염된 파일을 실행하면 활성화\n- 자기 복제 기능\n\n[비교]\n- **바이러스**: 파일에 기생, 사용자 개입 필요\n- **웜**: 독립 실행, 네트워크 자동 전파\n- **트로이 목마**: 정상 프로그램 위장, 사용자 설치 유도\n\n[답] \"1. 웜, 2. 트로이 목마, 3. 바이러스\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 내용에서 괄호 안에 알맞는 용어를 작성하시오.\n​\n(    )  네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜을 가리킨다.\n(    )  보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공한다.\n(    )  기본적으로 포트는 22번이다.\n​", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "이 문제는 SSH (Secure Shell, 시큐어 셸)에 대한 문제입니다.\n\n[SSH (Secure Shell)란?]\n\n[영어 약자 풀이]\n- **S**ecure: 보안\n- **S**hell: 셸 (명령 줄 인터페이스)\n- **H**: 생략 (일반적으로 SSH로 표기)\n- **SSH = Secure Shell**\n\n[문제에서 설명한 SSH의 특징]\n\n1. \"네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜을 가리킨다\":\n   - **원격 로그인**: 네트워크를 통해 다른 컴퓨터에 접속\n   - **원격 명령 실행**: 원격 시스템에서 명령어 실행\n   - **파일 전송**: 다른 시스템으로 파일 복사 (SCP, SFTP 사용)\n   - **응용 프로그램**: SSH 클라이언트 (PuTTY, OpenSSH 등)\n   - **프로토콜**: 네트워크 통신 규약\n\n2. \"보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공한다\":\n   - **보안 접속**: 암호화된 통신 제공\n   - rsh, rcp, rlogin, rexec: 기존의 보안 취약한 원격 접속 도구들의 보안 버전\n   - **telnet**: 평문 통신 (보안 취약) → SSH로 대체\n   - **ftp**: 평문 파일 전송 (보안 취약) → SFTP로 대체\n   - **IP spoofing 방지**: IP 주소 위/변조 공격 방지 기능\n\n3. **\"기본적으로 포트는 22번이다\"**:\n   - **포트 22번**: SSH의 기본 포트 번호\n   - 이것이 SSH를 식별하는 중요한 특징\n   - 보안을 위해 다른 포트로 변경 가능 (포트 변경)\n\n[SSH의 주요 기능]\n\n1. **원격 접속**:\n   - 네트워크상의 다른 컴퓨터에 로그인\n   - 원격 시스템에서 명령 실행\n\n2. **파일 전송**:\n   - **SCP (Secure Copy)**: 암호화된 파일 복사\n   - SFTP (SSH File Transfer Protocol): 암호화된 파일 전송\n\n3. [보안 기능]\n   - **암호화 통신**: 모든 데이터가 암호화되어 전송\n   - **공개키 인증**: 비밀번호 대신 공개키/개인키 사용 가능\n   - **IP spoofing 방지**: IP 주소 위조 방지\n\n[SSH vs 기존 프로토콜]\n| 구분 | **Telnet** | **FTP** | **SSH** |\n|------|-----------|---------|---------|\n| **통신** | 평문 | 평문 | 암호화 |\n| **보안** | 취약 | 취약 | 안전 |\n| **포트** | 23 | 21 | 22 |\n| **파일 전송** | 불가 | 가능 (FTP) | 가능 (SFTP/SCP) |\n\n[SSH의 사용 예시]\n- **서버 관리**: 원격 서버에 접속하여 관리\n- **파일 전송**: SFTP를 통한 안전한 파일 전송\n- **포트 포워딩**: SSH 터널링을 통한 보안 연결\n\n[답] **SSH (Secure Shell)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 설명에 대한 알맞는 답을 작성하시오.\n(보기가 있습니다.\nex:\n랜섬웨어,\n스파이웨어\n​\n등)", "choices": [], "answer": {"keys": ["ICMP"], "raw_text": "ICMP"}, "explanation": "이 문제는 **악성코드 분류**에 대한 문제입니다. 문제의 표를 확인하여 각 악성코드의 특징을 매칭해야 합니다.\n\n[악성코드의 주요 분류]\n\n1. **웜(Worm)**:\n   - 자기 복제를 통해 네트워크로 확산\n   - 다른 파일에 기생하지 않고 독립적으로 실행\n   - 네트워크 취약점을 이용해 빠르게 전파\n\n2. **트로이 목마(Trojan Horse)**:\n   - 정상 프로그램으로 위장한 악성 코드\n   - 사용자가 의도적으로 설치 (위장된 정상 프로그램처럼 보임)\n   - 다른 파일에 기생하지 않음\n   - 백도어 설치, 정보 탈취 등 수행\n\n3. **바이러스(Virus)**:\n   - 다른 파일에 기생하여 감염\n   - 실행 파일, 문서 파일 등에 삽입\n   - 사용자가 감염된 파일을 실행하면 활성화\n   - 자기 복제 기능\n\n4. **랜섬웨어(Ransomware)**:\n   - 사용자의 파일을 암호화하여 접근 불가능하게 만듦\n   - 복구를 위해 돈을 요구하는 악성코드\n   - 파일 암호화, 시스템 잠금 등의 피해\n\n5. **스파이웨어(Spyware)**:\n   - 사용자의 개인정보를 수집하여 전송하는 악성코드\n   - 키로거, 브라우저 히스토리 수집 등\n   - 사용자 모르게 정보 수집\n\n[문제의 표를 확인하여]\n표에 나온 각 악성코드의 특징(네트워크 전파, 파일 기생, 위장 등)을 확인하고, 보기에서 가장 알맞는 답을 선택해야 합니다.\n\n[답] 표의 내용에 따라 결정됩니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round1/Q008_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2023_round1/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.", "choices": [], "answer": {"keys": ["%", "10"], "raw_text": "(a) % (b) 10"}, "explanation": "이 문제는 C언어의 이진수를 십진수로 변환하는 알고리즘을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c\n#include <stdio.h>\nint main() {\n    int input = 101110;      // 이진수로 표현된 숫자 (십진수 101110)\n    int di = 1;              // 가중치 (2의 거듭제곱)\n    int sum = 0;             // 결과값\n    while (1) {\n        if (input == 0) break\n        else {\n          sum = sum + (input (a)(b)) * di;  // (a)와 (b)를 채워야 함\n             di = di * 2;                    // 가중치를 2배씩 증가\n             input = input / 10;             // 다음 자릿수로 이동\n        }\n    }\n    printf(\"%d\", sum);\n    return 0;\n}\n```\n\n[이진수를 십진수로 변환하는 방법]\n\n1. **마지막 자리(일의 자리)부터 처리**:\n   - 이진수 `101110`의 각 자릿수를 오른쪽부터 추출\n   - 각 자릿수에 2의 거듭제곱을 곱함\n\n2. **각 자릿수 추출**:\n   - `input % 10`: 마지막 자릿수를 추출 (나머지 연산)\n   - `input / 10`: 마지막 자릿수를 제거하고 다음 자릿수로 이동\n\n3. **가중치 계산**:\n   - `di = 1` (2^0 = 1)\n   - `di = di * 2` (2^1 = 2)\n   - `di = di * 2` (2^2 = 4)\n   - ...\n\n[실행 과정 (이진수 101110 → 십진수)]\n\n- **초기값**: `input = 101110`, `di = 1`, `sum = 0`\n\n1. **1회 반복**:\n   - `input % 10 = 101110 % 10 = 0` (마지막 자릿수)\n   - `sum = 0 + (0 * 1) = 0`\n   - `di = 1 * 2 = 2`\n   - `input = 101110 / 10 = 10111`\n\n2. **2회 반복**:\n   - `input % 10 = 10111 % 10 = 1`\n   - `sum = 0 + (1 * 2) = 2`\n   - `di = 2 * 2 = 4`\n   - `input = 10111 / 10 = 1011`\n\n3. **3회 반복**:\n   - `input % 10 = 1011 % 10 = 1`\n   - `sum = 2 + (1 * 4) = 6`\n   - `di = 4 * 2 = 8`\n   - `input = 1011 / 10 = 101`\n\n4. **4회 반복**:\n   - `input % 10 = 101 % 10 = 1`\n   - `sum = 6 + (1 * 8) = 14`\n   - `di = 8 * 2 = 16`\n   - `input = 101 / 10 = 10`\n\n5. **5회 반복**:\n   - `input % 10 = 10 % 10 = 0`\n   - `sum = 14 + (0 * 16) = 14`\n   - `di = 16 * 2 = 32`\n   - `input = 10 / 10 = 1`\n\n6. **6회 반복**:\n   - `input % 10 = 1 % 10 = 1`\n   - `sum = 14 + (1 * 32) = 46`\n   - `di = 32 * 2 = 64`\n   - `input = 1 / 10 = 0`\n\n7. **`input == 0`이므로 종료**\n\n**결과**: `sum = 46` (이진수 101110 = 십진수 46)\n\n[핵심 개념]\n\n- **나머지 연산(`%`)**: `input % 10`으로 마지막 자릿수 추출\n- **나눗셈(`/`)**: `input / 10`으로 마지막 자릿수 제거\n- **가중치**: 각 자릿수에 2의 거듭제곱을 곱함\n\n[답] **(a) % (b) 10**", "table_refs": [], "image_refs": ["images/2023_round1/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n    while (1) {\n        if (input == 0) break\n        else {\n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n        }\n    }\n    printf(\"%d\", sum);\n    return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round1/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 보안 관련 설명으로 괄호 안에 알맞는 용어를  작성하시오.\n(    )은/는 TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다.\n(    ) 프로토콜은 보통 다른 호스트나 게이트웨이 와 연결된 네트웍에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다.\n(    ) 을/를 이용한 공격에는\n(    )\nFlooding가 있는데 ping 명령어를 통한 (     ) 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른작업을 하지 못하도록 하는 공격이다.", "choices": [], "answer": {"keys": ["ICMP"], "raw_text": "ICMP"}, "explanation": "이 문제는 ICMP (Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)에 대한 문제입니다.\n\n[ICMP (Internet Control Message Protocol)란?]\n\n[영어 약자 풀이]\n- **I**nternet: 인터넷\n- **C**ontrol: 제어\n- **M**essage: 메시지\n- **P**rotocol: 프로토콜\n- ICMP = Internet Control Message Protocol\n\n[문제에서 설명한 ICMP의 특징]\n\n1. \"TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다\":\n   - **네트워크 계층 프로토콜**: IP 계층에서 동작\n   - **오류 보고**: IP 패킷 전송 중 오류나 문제 발생 시 ICMP 메시지로 알림\n   - **예시**: 목적지 도달 불가, 시간 초과, 네트워크 혼잡 등\n\n2. \"프로토콜은 보통 다른 호스트나 게이트웨이와 연결된 네트워크에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다\":\n   - **네트워크 진단 도구**: 네트워크 상태 확인\n   - **`ping` 명령어**: ICMP Echo Request/Reply 사용\n   - **`traceroute`**: ICMP Time Exceeded 메시지 활용\n   - **연결성 확인**: 호스트나 게이트웨이와의 연결 상태 확인\n\n3. \"ICMP를 이용한 공격에는 ICMP Flooding이 있는데 ping 명령어를 통한 ICMP 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른 작업을 하지 못하도록 하는 공격이다\":\n   - ICMP Flooding (Ping Flood): DoS(Denial of Service) 공격\n   - **ping 명령어**: ICMP Echo Request 패킷을 대량으로 전송\n   - **서버 부하**: 서버가 응답 처리에만 집중하여 다른 작업 불가\n   - **방어 방법**: ICMP 패킷 필터링, Rate Limiting\n\n[ICMP 메시지 종류]\n\n1. **Echo Request/Reply**:\n   - **ping** 명령어에서 사용\n   - Echo Request를 보내고 Echo Reply를 받아 연결 확인\n\n2. Destination Unreachable:\n   - 목적지에 도달할 수 없을 때\n   - 예: 호스트 도달 불가, 포트 도달 불가\n\n3. **Time Exceeded**:\n   - 패킷이 TTL(Time To Live)을 초과했을 때\n   - **traceroute**에서 사용\n\n4. **Source Quench**:\n   - 네트워크 혼잡 시 전송 속도 조절 요청\n\n[ICMP의 주요 용도]\n- **네트워크 진단**: ping, traceroute 등\n- **오류 보고**: IP 패킷 전송 오류 알림\n- **라우팅 정보**: 네트워크 경로 정보 제공\n\n[ICMP Flooding 공격]\n- **공격 방식**: 대량의 ICMP Echo Request 패킷 전송\n- **목적**: 서버의 리소스를 소모하여 서비스 거부\n- **방어**: ICMP 패킷 차단, Rate Limiting, 방화벽 설정\n\n[답] ICMP (Internet Control Message Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "TCP/IP"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 데이터베이스에 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.\nex:\n릴레이션 스키마\n​\n등)", "choices": [], "answer": {"keys": ["idx2", "nx"], "raw_text": "idx2 nx"}, "explanation": "데이터베이스의 3단계 스키마 구조를 묻는 문제입니다.\n\n[이미지의 표 내용 분석]\n\n문제 이미지에는 스키마의 3단계 구조에 대한 설명이 나와 있습니다:\n\n[( 1 ) 스키마]\n- 실 수 있는 수량의 손서 있는 열기이다\n- 어떤 요소의 집합, 혹은 테이블에서의 행을 가리키지만 일반적인 집합과는 달리 중복이 허용될 수 있다\n- 리스트와 동일하게 여러 객체를 모아 담으며, 숫자, 문자, 문자, 객체, 배열, 튜플 안의 튜플 전부 가능하다\n\n[( 2 ) 스키마]\n- 어느 한 시점에 릴레이션의 내용(상태), 즉 저장된 데이터 전체를 의미한다\n- 단순히 릴레이션 또는 릴레이션 익스텐션(Relation Extension)이라고도 한다\n- 특정 데이터 집합의 유니크(Unique)한 값의 개수이다\n- 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다\n\n[( 3 ) 스키마]\n- 물리적인 저장장치 입장에서 데이터가 저장되는 방법을 기술한 것이다\n- 실제 데이터베이스에 저장될 레코드의 물리적인 구조를 정의한다\n- 저장 데이터 항목의 표현방법, 내부 레코드의 물리적 순서, 인덱스 유/무 등을 나타낸다\n- 시스템 프로그래머나 시스템 설계자가 관리한다\n\n[데이터베이스 3단계 스키마 구조]\n\n1. 외부 스키마 (External Schema):\n   - 사용자나 응용 프로그램이 개인의 입장에서 필요한 데이터베이스의 논리적 구조를 정의한다\n   - 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있다\n   - 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있다\n   - 하나의 외부 스키마를 여러개의 응용 프로그램 혹은 사용자가 공유할 수 있다\n\n2. 개념 스키마 (Conceptual Schema):\n   - 개체 간의 관계(Relationship)와 제약 조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다\n   - 데이터베이스의 전체적인 논리적 구조로, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스\n   - 기관이나 조직의 관점에서 데이터베이스를 정의한 것이다\n   - 데이터베이스 파일에 저장되는 데이터의 형태를 나타내는 것이다\n\n3. 내부 스키마 (Internal Schema):\n   - 물리적 저장장치 입장에서 데이터가 저장되는 방법을 기술한 것이다\n   - 실제 데이터베이스에 저장될 레코드의 물리적인 구조를 정의한다\n   - 저장 데이터 항목의 표현방법, 내부 레코드의 물리적 순서, 인덱스 유/무 등을 나타낸다\n\n[답] 이미지의 표 내용에서 각 괄호 ( 1 ), ( 2 ), ( 3 )에 해당하는 스키마 종류를 보기에서 선택하여 작성합니다.", "table_refs": [], "image_refs": ["images/2023_round1/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "[학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.\n조건\n\n- 컬럼의 값이 문자열일 경우 작은 따움표 ('  ')를 표시하시오.\n\n- SQL 마지막에 세미콜론(;)은 표기하지 않아도 관계 없습니다.", "choices": [], "answer": {"keys": ["DELETE FROM 학생 WHERE 이름 = '민수'"], "raw_text": "DELETE FROM 학생 WHERE 이름 = '민수'"}, "explanation": "이 문제는 **SQL DELETE 문**을 작성하는 문제입니다.\n\n[DELETE 문의 기본 구조]\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n[답] DELETE FROM 학생 WHERE 이름 = '민수'", "table_refs": [], "image_refs": ["images/2023_round1/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": ["데이터베이스", "프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 코드에서 괄호 안에 알맞는 값을 변수명으로 작성하시오.\n(코드가 해깔려 시험문제와 동일하지 않지만 패턴이 비슷하다는 점만 참고해주세요.)\n출력 값 : 1 2 3 5 7 8", "choices": [], "answer": {"keys": ["SELECT 과목이름 MIN(점수) AS 최소점수 MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"], "raw_text": "SELECT 과목이름 MIN(점수) AS 최소점수 MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"}, "explanation": "이 문제는 **프로그래밍 코드에서 변수명을 찾는** 문제입니다. 출력값이 \"1 2 3 5 7 8\"이므로, 이 순서대로 출력하는 코드를 분석해야 합니다.\n\n[문제 분석]\n\n**출력값**: \"1 2 3 5 7 8\"\n- 숫자가 순차적으로 나열되어 있지만, 4와 6이 빠져있음\n- 이는 특정 조건에 따라 숫자를 선택적으로 출력하는 패턴\n\n[일반적인 코드 패턴]\n\n1. **반복문과 조건문 조합**:\n   - 1부터 8까지 반복하면서 특정 조건을 만족하는 경우만 출력\n   - 예: 소수 출력, 홀수 출력, 특정 조건 만족하는 숫자 출력\n\n2. **배열/리스트 처리**:\n   - 배열의 특정 인덱스 값을 출력\n   - 조건에 따라 배열 요소를 선택적으로 출력\n\n3. **변수 추적**:\n   - 각 반복에서 변수 값의 변화를 추적\n   - 조건문의 조건을 확인하여 출력 여부 결정\n\n[가능한 코드 패턴 예시]\n\n```\n// 예시 1: 조건부 출력\nfor (int i = 1; i <= 8; i++) {\n    if (조건) {\n        System.out.print(i + \" \");\n    }\n}\n\n// 예시 2: 배열 인덱스\nint[] arr = {1, 2, 3, 4, 5, 6, 7, 8};\nfor (int i = 0; i < arr.length; i++) {\n    if (조건) {\n        System.out.print(arr[i] + \" \");\n    }\n}\n```\n\n[문제 해결 방법]\n\n1. **출력값 분석**: \"1 2 3 5 7 8\"에서 4와 6이 빠진 이유 확인\n2. **코드 구조 파악**: 반복문, 조건문, 변수 사용 확인\n3. **변수명 추론**: 괄호 안에 들어갈 변수명이 출력값과 어떤 관계인지 확인\n4. **패턴 매칭**: 출력값과 코드의 로직을 연결하여 변수명 도출\n\n[답] 문제의 이미지에서 코드를 확인하고, 출력값 \"1 2 3 5 7 8\"과 코드의 로직을 연결하여 괄호 안에 들어갈 변수명을 정확히 작성해야 합니다.", "table_refs": [], "image_refs": ["images/2023_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 파이썬 코드의 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["{'중국', '한국', '일본', '베트남'}"], "raw_text": "{'중국', '한국', '일본', '베트남'}"}, "explanation": "Python Set 연산 문제입니다.\n\n[문제의 전체 코드]\n\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홀츠', '한국', '태국'})\nprint(a)\n```\n\n[코드 실행 과정]\n\n1. [초기 Set 생성]\n   ```python\n   a = {'한국', '중국', '일본'}\n   ```\n   - `a = {'한국', '중국', '일본'}`\n\n2. [`a.add('베트남')`]\n   - Set에 '베트남' 추가\n   - `a = {'한국', '중국', '일본', '베트남'}`\n\n3. [`a.add('중국')`]\n   - Set에 '중국' 추가 시도\n   - **Set은 중복을 허용하지 않음** → '중국'은 이미 있으므로 변화 없음\n   - `a = {'한국', '중국', '일본', '베트남'}`\n\n4. [`a.remove('일본')`]\n   - Set에서 '일본' 제거\n   - `a = {'한국', '중국', '베트남'}`\n\n5. [`a.update({'홀츠', '한국', '태국'})`]\n   - `update()`: 다른 Set의 모든 요소를 현재 Set에 추가 (합집합 연산)\n   - '홀츠', '한국', '태국' 추가 시도\n   - '한국'은 이미 있으므로 중복 제거됨\n   - '홀츠', '태국'만 추가됨\n   - `a = {'한국', '중국', '베트남', '홀츠', '태국'}`\n\n[그런데 이미지를 보면]\n\n이미지의 실제 코드에서는 `update` 대신 다른 연산이 있을 수 있습니다. 문제의 정답이 \"{'중국', '한국', '일본', '베트남'}\"이므로, 실제 코드를 확인하여 정확한 연산을 파악해야 합니다.\n\n[Python Set 연산 정리]\n\n- **`add(element)`**: 요소 1개 추가 (중복 시 무시)\n- **`remove(element)`**: 요소 제거 (없으면 에러)\n- **`update(set)`**: 다른 Set의 모든 요소 추가 (합집합)\n- **`discard(element)`**: 요소 제거 (없어도 에러 없음)\n\n[Set의 특징]\n\n- **중복 허용 안 됨**: 같은 요소는 하나만 저장\n- **순서 없음**: 출력 순서는 보장되지 않음 (Python 3.7+에서는 입력 순서 유지)\n- **가변**: 요소 추가/제거 가능\n\n[답] 문제 이미지의 실제 코드를 기반으로 연산을 추적하면 {'중국', '한국', '일본', '베트남'} - **메서드 오버라이딩**: 자식 클래스의 `display()`가 부모 클래스의 `display()`를 덮어씀\n   - 자식 클래스의 `display()` 메서드 실행\n   - `print(f\"Vehicle name: {self.name}\")` 실행\n   - `self.name = \"Spark\"`이므로 출력: \"Vehicle name: Spark\"\n\n[핵심 개념]\n\n- **상속**: `Car(Vehicle)` - `Car`가 `Vehicle`을 상속받음\n- **`super()`**: 부모 클래스의 메서드나 생성자를 호출\n- **메서드 오버라이딩**: 자식 클래스에서 부모 클래스의 메서드를 재정의\n- **메서드 호출 순서**: 자식 클래스에 메서드가 있으면 자식 클래스의 메서드가 우선 호출됨\n\n[답] \"Vehicle name: Spark\"", "table_refs": [], "image_refs": ["images/2023_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 성적 테이블에서 과목별 점수의 평균이 90점 이상인 '과목이름', '최소점수', '최대점수' 를 검색하고자 한다. [조건]을 참고하여\n\n적합한 SQL문을 작성하시오.\n조건\n:\n\n- where사용하지 말하야 한다.\n\n- SELECT절에 별칭을 사용하여 작성해야 한다.\n\n- SQL 구문 마지막에 세미콜론 생락 가능하다.\n\n- 반드시 GROUP BY와 having을 사용해야 한다.\n\n- 집계함수를 사용해야 한다.", "choices": [], "answer": {"keys": ["SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"], "raw_text": "SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"}, "explanation": "이 문제는 **SQL 쿼리 작성** 문제입니다. GROUP BY와 HAVING을 사용하여 그룹별 집계 조건을 적용해야 합니다.\n\n[SQL 쿼리 작성 방법]\n\n[요구사항 분석]\n- **조회할 컬럼**: 과목이름, 최소점수, 최대점수\n- **조건**: 과목별 평균 점수가 90점 이상\n- **제약사항**: WHERE 사용 불가, GROUP BY와 HAVING 필수, 별칭(AS) 사용, 집계 함수 사용\n\n[SQL 쿼리 구조]\n\n```sql\nSELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수\nFROM 성적\nGROUP BY 과목이름\nHAVING AVG(점수) >= 90\n```\n\n[각 절의 역할]\n\n1. **SELECT 절**:\n   - `과목이름`: 그룹화 기준 컬럼 (GROUP BY에 포함되어야 함)\n   - `MIN(점수) AS 최소점수`: 각 과목별 최소 점수 (집계 함수)\n   - `MAX(점수) AS 최대점수`: 각 과목별 최대 점수 (집계 함수)\n   - **별칭(AS) 사용**: `AS 최소점수`, `AS 최대점수`로 별칭 지정\n\n2. **FROM 절**:\n   - `FROM 성적`: 성적 테이블에서 조회\n\n3. **GROUP BY 절**:\n   - `GROUP BY 과목이름`: 과목별로 그룹화\n   - 각 과목별로 집계 함수(MIN, MAX, AVG) 적용\n\n4. **HAVING 절**:\n   - `HAVING AVG(점수) >= 90`: 그룹화된 결과 중 평균 점수가 90점 이상인 그룹만 선택\n   - **WHERE vs HAVING**:\n     - WHERE: 그룹화 전 행 단위 필터링\n     - HAVING: 그룹화 후 그룹 단위 필터링 (집계 함수 조건)\n   - 문제에서 WHERE 사용 불가라고 했으므로 HAVING 사용\n\n[실행 순서]\n1. FROM 성적: 성적 테이블 조회\n2. GROUP BY 과목이름: 과목별로 그룹화\n3. HAVING AVG(점수) >= 90: 평균 90점 이상인 그룹만 선택\n4. SELECT: 과목이름, 최소점수, 최대점수 출력\n\n[핵심 개념]\n- **GROUP BY**: 특정 컬럼 기준으로 그룹화\n- **집계 함수**: MIN, MAX, AVG, COUNT, SUM 등\n- **HAVING**: 그룹화 후 조건 필터링 (집계 함수 조건 사용 가능)\n- **별칭(AS)**: 컬럼명을 별칭으로 표시\n\n[답] SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90", "table_refs": [], "image_refs": ["images/2023_round1/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Vehicle name: Spark"], "raw_text": "Vehicle name: Spark"}, "explanation": "Java 추상 클래스, 메서드 오버로딩, 다형성을 묻는 문제입니다.\n\n[이미지의 코드 분석]\n\n```java\nabstract class Vehicle {\n    String name;\n    abstract public String getName(String val);\n    \n    public String getName() {\n        return \"Vehicle name: \" + name;\n    }\n}\n\nclass Car extends Vehicle {\n    public Car(String val) {\n        name=super.name=val;\n    }\n    \n    public String getName(String val) {\n        return \"Car name:\" + val;\n    }\n    \n    public String getName(byte val[]) {\n        return \"Car name:\" + val;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle obj = new Car(\"Spark\");\n        System.out.println(obj.getName());\n    }\n}\n```\n\n[코드 실행 과정]\n\n1. [추상 클래스 Vehicle]\n   - `String name` 필드 선언\n   - `abstract public String getName(String val)`: 추상 메서드 (파라미터 1개)\n   - `public String getName()`: 구현된 메서드 (파라미터 없음)\n\n2. [Car 클래스 (Vehicle 상속)]\n   - `public Car(String val)`: 생성자에서 `name = \"Spark\"` 설정\n   - `getName(String val)`: 추상 메서드 구현 (파라미터 String 1개)\n   - `getName(byte val[])`: 추가 오버로딩 메서드 (파라미터 byte배열)\n   - **주의**: `getName()` (파라미터 없음)은 오버라이딩하지 않음!\n\n3. [main 실행]\n   - `Vehicle obj = new Car(\"Spark\");`\n     - Car 객체 생성, Vehicle 타입 변수에 저장 (다형성)\n     - 생성자 실행: `name = \"Spark\"`\n   \n   - `obj.getName()` 호출:\n     - Car 클래스에 `getName()` (파라미터 없음)이 **오버라이딩되지 않음**\n     - 따라서 부모 클래스 Vehicle의 `getName()` 메서드 호출\n     - `return \"Vehicle name: \" + name;`\n     - `name = \"Spark\"`이므로 반환값: \"Vehicle name: Spark\"\n   \n   - `System.out.println(...)`: \"Vehicle name: Spark\" 출력\n\n[핵심 개념]\n\n1. [추상 클래스와 추상 메서드]\n   - `abstract` 키워드로 선언\n   - 추상 메서드는 자식 클래스에서 반드시 구현해야 함\n   - 추상 클래스도 구현된 메서드를 가질 수 있음\n\n2. [메서드 오버로딩(Overloading)]\n   - 같은 이름의 메서드를 **파라미터 타입/개수**를 다르게 하여 여러 개 정의\n   - Car 클래스에서 `getName(String)`, `getName(byte[])`로 오버로딩\n\n3. [메서드 오버라이딩(Overriding) vs 오버로딩]\n   - **오버라이딩**: 부모 클래스의 메서드를 **같은 시그니처(이름, 파라미터)**로 재정의\n   - **오버로딩**: 같은 이름의 메서드를 **다른 파라미터**로 정의\n   - 이 문제에서 `getName()`은 오버라이딩되지 않았으므로 부모 클래스 메서드 사용\n\n4. [다형성(Polymorphism)]\n   - `Vehicle obj = new Car(\"Spark\");`\n   - 부모 타입 변수에 자식 객체 저장\n   - 메서드 호출 시 실제 객체 타입(Car)의 메서드 우선 호출\n   - 단, 오버라이딩되지 않은 메서드는 부모 클래스 메서드 호출\n\n[메서드 호출 규칙]\n\n| 메서드 | Car 클래스 정의 여부 | 호출되는 메서드 |\n|--------|---------------------|----------------|\n| `getName()` (파라미터 없음) | X (오버라이딩 안 됨) | Vehicle.getName() |\n| `getName(String)` | O (구현됨) | Car.getName(String) |\n| `getName(byte[])` | O (오버로딩) | Car.getName(byte[]) |\n\n[답] \"Vehicle name: Spark\"", "table_refs": [], "image_refs": ["images/2023_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 스키마와 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.)", "choices": [], "answer": {"keys": ["500"], "raw_text": "500"}, "explanation": "이 문제는 **데이터베이스 스키마**와 관련된 내용을 이해하는 문제입니다. 문제의 이미지와 보기를 확인하여 정확한 답을 찾아야 합니다.\n\n[데이터베이스 스키마 관련 개념]\n\n1. **스키마(Schema)**:\n   - 데이터베이스의 구조를 정의하는 메타데이터\n   - 릴레이션, 속성, 제약조건 등을 정의\n\n2. 외부 스키마(External Schema):\n   - 사용자나 응용 프로그램이 보는 데이터베이스 뷰\n   - 서브스키마라고도 함\n   - 여러 외부 스키마가 존재할 수 있음\n\n3. 개념 스키마(Conceptual Schema):\n   - 전체 데이터베이스의 논리적 구조\n   - 모든 데이터와 관계를 정의\n   - 하나만 존재\n\n4. 내부 스키마(Internal Schema):\n   - 물리적 저장 구조를 정의\n   - 인덱스, 파일 구조, 저장 방식 등\n   - 하나만 존재\n\n[3단계 스키마 구조(Three-Schema Architecture)]\n\n| 단계 | 스키마 | 설명 | 개수 |\n|------|--------|------|------|\n| **외부** | 외부 스키마 | 사용자 뷰 | 여러 개 |\n| **개념** | 개념 스키마 | 논리적 구조 | 1개 |\n| **내부** | 내부 스키마 | 물리적 구조 | 1개 |\n\n[문제 해결 방법]\n\n문제의 이미지와 보기를 확인하여:\n1. 스키마의 3단계 구조를 이해\n2. 각 괄호에 해당하는 스키마 단계를 식별\n3. 보기에서 가장 적합한 답을 선택\n\n[일반적인 스키마 문제 유형]\n- 사용자 뷰를 나타내는 스키마: **외부 스키마**\n- 논리적 구조를 나타내는 스키마: **개념 스키마**\n- 물리적 구조를 나타내는 스키마: **내부 스키마**\n\n[답] 문제의 이미지와 보기를 확인하여 각 괄호에 해당하는 스키마 단계를 정확히 매칭하여 작성해야 합니다.", "table_refs": [], "image_refs": ["images/2023_round1/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.", "choices": [], "answer": {"keys": ["1234561 124567"], "raw_text": "1234561 124567"}, "explanation": "이 문제는 제어 흐름 그래프(Control Flow Graph)에서 분기 커버리지(Branch Coverage)를 만족하는 테스트 경로를 찾는 문제입니다.\n\n[분기 커버리지(Branch Coverage)란?]\n\n[정의]\n- 모든 분기(decision)의 True와 False 경로를 최소 한 번씩 실행하는 테스트 커버리지\n- **Decision Coverage**, **Branch Coverage**라고도 함\n- 각 조건문의 참(true)과 거짓(false) 경로를 모두 테스트\n\n[제어 흐름 그래프 분석]\n\n문제의 이미지를 참고하여 제어 흐름 그래프를 분석해야 합니다:\n\n1. **노드(정점)**: 각 문장이나 명령을 나타냄\n2. **간선(화살표)**: 제어 흐름을 나타냄\n3. **분기점**: 조건문(if, while 등)이 있는 노드\n\n[분기 커버리지 만족 방법]\n\n1. **각 분기점 식별**:\n   - 조건문이 있는 노드를 찾음\n   - 각 분기점에서 True 경로와 False 경로 확인\n\n2. **테스트 경로 구성**:\n   - 각 분기의 True 경로를 포함하는 경로 선택\n   - 각 분기의 False 경로를 포함하는 경로 선택\n   - 최소한의 경로로 모든 분기를 커버하도록 구성\n\n3. **경로 순서 작성**:\n   - 노드 번호를 순서대로 나열하여 테스트 경로 표현\n   - 예: \"1 2 3 4 5 6 1 2 4 5 6 7\"\n\n[일반적인 제어 흐름 그래프 구조]\n- **시작 노드**: 1\n- **중간 노드**: 2, 3, 4, 5, 6, ...\n- **종료 노드**: 마지막 노드\n\n[분기 커버리지 예시]\n\n제어 흐름 그래프가 다음과 같다면:\n- 노드 1 → 노드 2 (조건문)\n- 노드 2 → True: 노드 3, False: 노드 4\n- 노드 3 → 노드 5\n- 노드 4 → 노드 5\n- 노드 5 → 노드 6\n\n[분기 커버리지 테스트 경로]\n- 경로 1: 1 → 2(True) → 3 → 5 → 6 (조건문 True 경로)\n- 경로 2: 1 → 2(False) → 4 → 5 → 6 (조건문 False 경로)\n\n[답] 문제의 이미지에서 제어 흐름 그래프를 확인하고, 모든 분기의 True/False 경로를 포함하는 최소 테스트 경로를 작성해야 합니다. 일반적으로 여러 경로를 조합하여 분기 커버리지를 만족시킵니다.", "table_refs": [], "image_refs": ["images/2023_round1/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["500"], "raw_text": "500"}, "explanation": "Java 코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"500\"**입니다.", "table_refs": [], "image_refs": ["images/2023_round1/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 C언어 코드의 문제이다.\n보기의 조건에 맞도록 괄호 안에 알맞은 코드를 작성하시오.\n입력값이 54321일 경우 출력값이 43215로 출력되어야 한다.", "choices": [], "answer": {"keys": ["n[(i+1) % 5]"], "raw_text": "n[(i+1) % 5]"}, "explanation": "이 C언어 코드는 배열을 한 칸씩 왼쪽으로 시프트하는 문제입니다.\n\n[문제 요구사항]\n- 입력값: 54321\n- 출력값: 43215\n- 첫 번째 요소가 마지막으로 이동\n\n[해결 방법]\n- 배열을 한 칸씩 왼쪽으로 이동\n- 첫 번째 요소를 마지막으로 이동\n\n[빈칸 분석]\n- 각 요소를 한 칸 앞으로 이동시키는 인덱스 계산 필요\n- 원형 이동: `(i+1) % 5`로 인덱스 계산\n\n[답] \"n[(i+1) % 5]\"", "table_refs": [], "image_refs": ["images/2023_round2/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 JAVA 코드 문제이다.\n가지고 있는 돈이 총 4620원일 경우 1000원, 500원, 100원, 10원의 지폐 및 동전을 이용하여 보기의 조건에 맞춰 최소한의 코드를 통해 괄호안을 작성하시오.\n아래 주어진 항목들을 갖고 괄호안의 코드를 작성 변수 : m 연산자 : / , %\n괄호 : [ , ] , ( , )\n정수 : 1000, 500, 100, 10", "choices": [], "answer": {"keys": ["a = m / 1000", "b = (m % 1000) / 500", "c = (m % 500) / 100"], "raw_text": "a = m / 1000 b = (m % 1000) / 500 c = (m % 500) / 100"}, "explanation": "이 문제는 Java 코드에서 금액을 지폐/동전 단위로 분해하는 문제입니다.\n\n[문제 분석]\n- 총 금액: `m = 4620원`\n- 지폐/동전 단위: 1000원, 500원, 100원, 10원\n- 각 단위의 개수를 구하는 코드 작성\n\n[각 단위 개수 계산 방법]\n\n1. **1000원 개수 (`a`)**:\n   - `a = m / 1000`\n   - `4620 / 1000 = 4` (정수 나눗셈)\n   - 1000원 지폐 4개\n\n2. **500원 개수 (`b`)**:\n   - 먼저 1000원을 제외한 나머지 계산: `m % 1000`\n   - 그 나머지를 500으로 나눔: `(m % 1000) / 500`\n   - `(4620 % 1000) / 500 = 620 / 500 = 1`\n   - 500원 동전 1개\n\n3. **100원 개수 (`c`)**:\n   - 먼저 1000원과 500원을 제외한 나머지 계산: `m % 500`\n   - 그 나머지를 100으로 나눔: `(m % 500) / 100`\n   - `(4620 % 500) / 100 = 120 / 100 = 1`\n   - 100원 동전 1개\n\n4. **10원 개수 (`d`)**:\n   - 먼저 100원을 제외한 나머지 계산: `m % 100`\n   - 그 나머지를 10으로 나눔: `(m % 100) / 10`\n   - `(4620 % 100) / 10 = 20 / 10 = 2`\n   - 10원 동전 2개\n\n[검증]\n- `4 × 1000 + 1 × 500 + 1 × 100 + 2 × 10 = 4000 + 500 + 100 + 20 = 4620원` ✓\n\n[핵심 개념]\n- **나눗셈(`/`)**: 몫을 구하여 개수 계산\n- **나머지(`%`)**: 상위 단위를 제외한 나머지 금액 계산\n- **계산 순서**: 큰 단위부터 순차적으로 계산\n\n[답]\n- `a = m / 1000`\n- `b = (m % 1000) / 500`\n- `c = (m % 500) / 100`\n- `d = (m % 100) / 10`", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q002_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2023_round2/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 c언어의 코드이다.\n보기의 조건에 맞추어 알맞은 출력값을 작성하시오.\n입력값은 홍길동, 김철수, 박영희 순서로 주어진다.", "choices": [], "answer": {"keys": ["박영희", "박영희", "박영희"], "raw_text": "박영희"}, "explanation": "이 문제는 **C언어의 문자열 배열과 포인터**를 활용하는 문제입니다.\n\n[문제 분석]\n- 입력값: \"홍길동\", \"김철수\", \"박영희\"\n- 출력값: \"박영희\"가 3번 출력\n\n[코드 실행 과정]\n\n1. [문자열 배열 선언]\n   - 문자열 배열에 3개의 이름이 저장됨\n   - 배열의 각 요소는 문자열 포인터를 가리킴\n\n2. [포인터 연산]\n   - 포인터가 배열의 마지막 요소(박영희)를 가리키도록 설정\n   - 반복문에서 포인터를 통해 배열 요소에 접근\n\n3. [출력 과정]\n   - 반복문이 3번 실행되며, 매번 포인터가 가리키는 값(박영희) 출력\n   - 또는 포인터가 마지막 요소를 가리키고 있어서 항상 \"박영희\" 출력\n\n[일반적인 C언어 문자열 배열 코드 패턴]\n```c\nchar *names[3] = {\"홍길동\", \"김철수\", \"박영희\"};\nchar **p = names + 2;  // 마지막 요소(박영희)를 가리킴\nfor(int i = 0; i < 3; i++) {\n    printf(\"%s\\n\", *p);  // 항상 \"박영희\" 출력\n}\n```\n\n[핵심 개념]\n- **문자열 배열**: `char *names[]` - 각 요소가 문자열 포인터\n- **포인터 연산**: 배열 이름 + 오프셋으로 특정 요소 접근\n- **포인터 참조**: `*p`로 포인터가 가리키는 값(문자열) 접근\n\n[답] **\"박영희\"** (3번 출력)", "table_refs": [], "image_refs": ["images/2023_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 테이블에 데이터를 삽입하기 위한 과정이다.\n보기의 조건식에 맞게 데이터 삽입을 위한 SQL문을 작성하시오.\nCREATE TABLE 학생 (\n학번 int,\n이름 varchar(20),\n학년 int,\n전공 varchar(30),\n전화번호varchar(20)\n);\n문자열일 경우 작은따음표\n(작은따음표가 아니라 다른 단어로 명시되었습니다.)", "choices": [], "answer": {"keys": ["INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')"], "raw_text": "INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')"}, "explanation": "이 문제는 **SQL INSERT 문**을 작성하는 문제입니다.\n\n[INSERT 문의 기본 구조]\n\n```sql\nINSERT INTO 테이블명 (컬럼1, 컬럼2, ...)\nVALUES (값1, 값2, ...);\n```\n\n[문제 분석]\n\n- **테이블명**: `학생`\n- **컬럼**: 학번(int), 이름(varchar(20)), 학년(int), 전공(varchar(30)), 전화번호(varchar(20))\n- **삽입할 데이터**: 테이블의 보기를 확인하여 정확한 값 입력\n\n[SQL INSERT 문 작성]\n\n```sql\nINSERT INTO 학생(학번, 이름, 학년, 전공, 전화번호)\nVALUES(9830287, '뉴진스', 3, '경영학개론', '010-1234-1234');\n```\n\n[각 값의 데이터 타입]\n\n1. **학번**: `9830287` (정수, 작은따옴표 불필요)\n2. **이름**: `'뉴진스'` (문자열, 작은따옴표 필수)\n3. **학년**: `3` (정수, 작은따옴표 불필요)\n4. **전공**: `'경영학개론'` (문자열, 작은따옴표 필수)\n5. **전화번호**: `'010-1234-1234'` (문자열, 작은따옴표 필수)\n\n[주의사항]\n\n- **문자열 값**: 작은따옴표(`'`)로 감싸야 함\n- **정수 값**: 작은따옴표 없이 숫자만 입력\n- **컬럼 순서**: INSERT INTO 절의 컬럼 순서와 VALUES 절의 값 순서가 일치해야 함\n- **컬럼명 생략 가능**: 모든 컬럼에 값을 입력할 경우 컬럼명 생략 가능\n\n[INSERT vs 다른 SQL 문]\n\n| 문장 | 목적 | 예시 |\n|------|------|------|\n| **SELECT** | 조회 | `SELECT * FROM 학생` |\n| **INSERT** | 삽입 | `INSERT INTO 학생 VALUES(...)` |\n| **UPDATE** | 수정 | `UPDATE 학생 SET 이름 = '철수'` |\n| **DELETE** | 삭제 | `DELETE FROM 학생 WHERE 학번 = 1` |\n\n[답] INSERT INTO 학생(학번, 이름, 학년, 전공, 전화번호) VALUES(9830287, '뉴진스', 3, '경영학개론', '010-1234-1234')", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q004_table1.json", "rows": 1, "cols": 5}], "image_refs": ["images/2023_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 C언어의 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["BCD"], "raw_text": "BCD"}, "explanation": "[주어진 코드]\n```c\n#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0; i<3; i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}\n```\n\n[실행 과정]\n\n1. [배열 합 계산]\n   - `sum = 73 + 95 + 82 = 250`\n\n2. [switch 조건]\n   - `sum / 30 = 250 / 30 = 8` (정수 나눗셈)\n\n3. [switch 실행]\n   - `case 8:`로 이동\n   - break가 없으므로 아래로 fall-through\n   - `printf(\"B\")` 실행 → \"B\" 출력\n   - `case 7:` (빈 case, 계속 진행)\n   - `case 6:` → `printf(\"C\")` 실행 → \"C\" 출력\n   - `default:` → `printf(\"D\")` 실행 → \"D\" 출력\n\n[최종 출력] **\"BCD\"**\n\n[핵심 포인트]\n- **switch fall-through**: `break` 문이 없으면 다음 case로 계속 실행됨\n- **정수 나눗셈**: `250 / 30 = 8` (소수점 버림)\n\n[답] **\"BCD\"**", "table_refs": [], "image_refs": ["images/2023_round2/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0;i<3;i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round2/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 테스트 커버리지에 대한 내용이다.\n내용을 보고\n\n보기에 알맞는 기호를 고르시오.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 경로 커버리지\n\nㄷ. 조건/결정 커버리지\n\nㄹ. 변형 조건/결정 커버리지\n\nㅂ. 다중 조건 커버리지\n\nㅅ. 결정 커버리지\n\nㅇ. 조건 커버리지", "choices": [], "answer": {"keys": ["ㅇ"], "raw_text": "ㅇ"}, "explanation": "이 문제는 테스트 커버리지(Test Coverage) 중 조건 커버리지(Condition Coverage)에 대한 문제입니다.\n\n[조건 커버리지(Condition Coverage)란?]\n\n[정의]\n- 각 **조건문(condition)**의 참(true)과 거짓(false) 값을 최소 한 번씩 실행하는 테스트 커버리지\n- **Predicate Coverage**라고도 함\n- 조건식의 각 부분 조건을 개별적으로 테스트\n\n[조건 커버리지의 특징]\n\n1. [조건문 단위 테스트]\n   - `if (A && B)` 같은 복합 조건에서\n   - `A = true`, `A = false`, `B = true`, `B = false`를 각각 테스트\n\n2. [결정 커버리지와의 차이]\n   - **결정 커버리지**: 전체 조건식의 참/거짓만 테스트\n   - **조건 커버리지**: 각 부분 조건의 참/거짓을 개별적으로 테스트\n\n[예시]\n\n```c\nif (A && B) {  // A와 B가 모두 참이어야 실행\n    // 코드\n}\n```\n\n[조건 커버리지 테스트 케이스]\n- 케이스 1: `A = true, B = false` (A는 참, B는 거짓)\n- 케이스 2: `A = false, B = true` (A는 거짓, B는 참)\n- 케이스 3: `A = true, B = true` (A는 참, B는 참)\n- 케이스 4: `A = false, B = false` (A는 거짓, B는 거짓)\n\n[테스트 커버리지 종류 비교]\n\n| 커버리지 | 정의 | 예시 |\n|---------|------|------|\n| **구문 커버리지** | 모든 문장 실행 | 코드의 모든 줄 실행 |\n| **분기 커버리지** | 모든 분기의 참/거짓 경로 실행 | if문의 true/false 경로 |\n| **조건 커버리지** | 각 조건문의 참/거짓 값 실행 | `A && B`에서 A와 B 각각 테스트 |\n| **결정 커버리지** | 전체 조건식의 참/거짓 실행 | `A && B` 전체 결과만 테스트 |\n| **경로 커버리지** | 모든 실행 경로 실행 | 모든 가능한 경로 조합 |\n\n[답] **ㅇ (조건 커버리지)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 소스코드의 알맞은 출력을 작성하시오.", "choices": [], "answer": {"keys": ["505"], "raw_text": "505"}, "explanation": "이 문제는 **프로그래밍 코드의 실행 결과**를 구하는 문제입니다. 문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.\n\n[문제 해결 방법]\n\n이 문제는 코드의 실행 흐름을 추적하여 출력값을 구하는 문제입니다. 코드의 실제 내용(변수, 메서드, 반복문, 조건문 등)을 확인하고, 각 단계별로 변수 값의 변화를 추적하여 최종 출력값을 도출해야 합니다.\n\n[코드 분석 시 확인사항]\n\n1. **변수 선언 및 초기화**:\n   - 변수의 타입과 초기값 확인\n   - 전역 변수 vs 지역 변수 구분\n\n2. **연산 및 계산**:\n   - 산술 연산: `+`, `-`, `*`, `/`, `%`\n   - 논리 연산: `&&`, `||`, `!`\n   - 비교 연산: `==`, `!=`, `<`, `>`, `<=`, `>=`\n\n3. **제어 구조**:\n   - 조건문: `if`, `else`, `switch`\n   - 반복문: `for`, `while`, `do-while`\n   - 반복 횟수와 종료 조건 확인\n\n4. **출력문**:\n   - 출력문의 위치와 순서 확인\n   - 출력 형식 확인 (`printf`, `System.out.println` 등)\n\n[일반적인 코드 실행 순서]\n1. 변수 선언 및 초기화\n2. 조건문 확인 및 실행\n3. 반복문 실행 (조건 확인 → 실행 → 증가/감소)\n4. 연산 및 계산 수행\n5. 출력문 실행\n\n[답] 문제의 이미지에서 코드를 확인하고, 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 변수의 초기값부터 시작하여 각 문장의 실행 결과를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round2/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 내용에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["템퍼프루핑"], "raw_text": "템퍼프루핑"}, "explanation": "템퍼프루핑(Tamper Proofing)은 소프트웨어나 시스템이 변조되지 않도록 보호하는 기술입니다.\n\n[템퍼프루핑의 특징]\n- 소프트웨어 코드나 데이터가 무단으로 수정되는 것을 방지\n- 변조 시도를 감지하고 대응\n- 무결성 검증 기능 제공\n\n[답] \"템퍼프루핑\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.011449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 C언어 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["213465"], "raw_text": "213465"}, "explanation": "이 C언어 코드는 스택(Stack) 자료구조를 구현하고 사용하는 문제입니다.\n\n[코드 분석]\n\n```c void into(int num) {\nif (point >= 10) printf(\"Full\");\nelse isWhat[++point] = num; // push (전위 증가)\n}\n\nint take() {\nif (isEmpty() == 1) printf(\"Empty\");\nelse return isWhat[point--]; // pop (후위 감소)\nreturn 0;\n}\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `point = -1` (빈 스택)\n\n2. `into(5); into(2);`• \n- 스택: `[5, 2]`, `point = 1`\n\n3. [while 루프]첫 번째 반복:\n- `take()` → `isWhat[1] = 2` 반환, `point = 0` → \"2\" 출력\n- `into(4);` → 스택: `[5, 4]`, `point = 1`\n- `into(1);` → 스택: `[5, 4, 1]`, `point = 2`\n- `take()` → `isWhat[2] = 1` 반환, `point = 1` → \"1\" 출력\n- `into(3);` → 스택: `[5, 4, 3]`, `point = 2`\n- `take()` → `isWhat[2] = 3` 반환, `point = 1` → \"3\" 출력\n- `take()` → `isWhat[1] = 4` 반환, `point = 0` → \"4\" 출력\n- `into(6);` → 스택: `[5, 6]`, `point = 1`\n- `take()` → `isWhat[1] = 6` 반환, `point = 0` → \"6\" 출력\n- `take()` → `isWhat[0] = 5` 반환, `point = -1` → \"5\"** 출력\n\n[두 번째 반복]\n- `isEmpty() == 1` → 루프 종료\n\n[최종 출력] \"213465\"\n\n[답] \"213465\"", "table_refs": [], "image_refs": ["images/2023_round2/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#define MAX_SIZE 10\nint isWhat[MAX_SIZE];\nint point= -1;\nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    else isWhat[++point] = num;\n}\nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    else return isWhat[point--];\n    return 0;\n}\nint main(int argc, char const *argv[]){\n    int e;\n    into(5); into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take());\n        into(3); printf(\"%d\", take()); printf(\"%d\", take());\n        into(6); printf(\"%d\", take()); printf(\"%d\", take());\n    }\n    return 0;\n}", "line_numbers": [1, 32], "file": "data/codes/2023_round2/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 디자인 패턴에 관한 문제이다.\n보기에서 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. Singleton", "2. Visitor"], "raw_text": "1. Singleton 2. Visitor"}, "explanation": "GoF 디자인 패턴 분류 문제입니다.\n\n[문제의 보기 (이미지 참조)]\n\n| **생성패턴** | **구조패턴** | **행위패턴** |\n|-------------|-------------|-------------|\n| Singleton | Adapter | Observer |\n| Factory Method | Bridge | Strategy |\n| Builder | Decorator | Visitor |\n\n[GoF 디자인 패턴은 3가지 범주로 분류됩니다]\n\n[1. 생성 패턴 (Creational Patterns)]\n- 객체의 생성과 관련된 패턴\n- 객체 생성 방식을 구조화하여 시스템의 유연성과 재사용성을 높임\n\n[보기의 생성 패턴]\n- **Singleton**: 클래스의 인스턴스가 **하나만** 존재하도록 보장\n  - 전역 접근 지점 제공\n  - 예: Database 연결, Logger\n  \n- **Factory Method**: 객체 생성 인터페이스를 정의하고 서브클래스에서 구체적인 객체 생성\n  - 객체 생성 로직을 서브클래스에 위임\n  \n- **Builder**: 복잡한 객체를 단계별로 생성\n  - 생성 과정과 표현 분리\n\n[2. 구조 패턴 (Structural Patterns)]\n- 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴\n- 서로 다른 인터페이스를 가진 객체들을 묶어 새로운 기능 제공\n\n[보기의 구조 패턴]\n- **Adapter**: 서로 다른 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 변환\n  - 호환성 없는 인터페이스를 연결\n  \n- **Bridge**: 구현부와 추상부를 분리하여 독립적으로 변형 가능\n  - 기능 계층과 구현 계층 분리\n  \n- **Decorator**: 객체에 동적으로 새로운 책임/기능 추가\n  - 상속 대신 조합으로 기능 확장\n\n[3. 행위 패턴 (Behavioral Patterns)]\n- 객체나 클래스 간의 알고리즘, 책임 분배에 관한 패턴\n- 객체들 간의 상호작용과 책임 분배 정의\n\n[보기의 행위 패턴]\n- **Observer**: 한 객체의 상태 변화를 다른 객체들에게 자동으로 통지\n  - 발행-구독(Publish-Subscribe) 모델\n  - 예: Event Listener, MVC 패턴\n  \n- **Strategy**: 알고리즘 군을 정의하고 각각을 캡슐화하여 교환 가능하게 만듦\n  - 알고리즘을 동적으로 교체\n  \n- **Visitor**: 객체 구조와 연산을 분리\n  - 구조 변경 없이 새로운 연산 추가\n  - Double Dispatch 기법 사용\n\n[문제 해결]\n\n문제에서 요구하는 것은 보기 표에서 특정 패턴을 찾는 것입니다.\n\n- **1번 답**: 생성 패턴 중 하나 → **Singleton**\n- **2번 답**: 행위 패턴 중 하나 → **Visitor**\n\n[답] 1. Singleton, 2. Visitor", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q011_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2023_round2/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 내용에서 설명하는 문제에 대해 보기에 알맞는 답을 골라 작성하시오.\n\n(1) Code는 데이터 전송시 1 비트의 에러를 정정할 수 있는, 오류정정부호의 일종으로 미국의 Bell 연구소의 Hamming에 의해 고안되었다. 선형블록부호 및 순회부호에 속에 속한다.\n( 2 ) 은/는 송신측이 전송할 문자나 프레임에 부가적 정보(Redundancy)를 첨가하여 전송하고 수신측이 부가적 정보를 이용하여 에러검출 및 에러정정을 하는 방식이다.\n( 3 ) 은/는 데이터 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 방식이다. 오류를 검출하는 방법은 Parity검사와 CRC, 블록 합 검사 등이 있다.\n( 4 ) 은/는 데이터가 저장장치 내의 한 장소에서 다른 장소로 이동되거나, 컴퓨터들간에 전송될 때, 데이터가 유실 또는 손상되었는지 여부를 점검하는 기술과 관련된 용어이다.\n( 5 ) 은/는 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.\nEAC, FEC, hamming, CRC, PDS, parity, BEC", "choices": [], "answer": {"keys": ["1. hamming", "2. FEC", "3. BEC"], "raw_text": "1. hamming 2. FEC 3. BEC"}, "explanation": "이 문제는 **오류 검출 및 정정 기법**에 대한 문제입니다.\n\n[각 용어의 정의]\n\n1. **Hamming (해밍 코드)**:\n   - **정의**: 데이터 전송 시 **1비트의 에러를 정정**할 수 있는 오류 정정 부호\n   - **고안자**: 미국 Bell 연구소의 Hamming\n   - **특징**: 선형 블록 부호 및 순회 부호에 속함\n   - **용도**: 단일 비트 오류 정정\n\n2. FEC (Forward Error Correction, 순방향 오류 정정):\n   - **정의**: 송신측이 전송할 문자나 프레임에 **부가적 정보(Redundancy)**를 첨가하여 전송하고, 수신측이 부가적 정보를 이용하여 **에러 검출 및 에러 정정**을 하는 방식\n   - **특징**: 재전송 없이 오류 정정 가능\n   - **예시**: Hamming 코드, Reed-Solomon 코드\n\n3. BEC (Backward Error Correction, 역방향 오류 정정):\n   - **정의**: 데이터 전송 과정에서 오류가 발생하면 **송신 측에 재전송을 요구**하는 방식\n   - **특징**: 오류 검출 후 재전송 요청\n   - **오류 검출 방법**: Parity 검사, CRC, 블록 합 검사 등\n\n4. **Parity (패리티)**:\n   - **정의**: 데이터가 저장장치 내의 한 장소에서 다른 장소로 이동되거나, 컴퓨터들 간에 전송될 때, 데이터가 **유실 또는 손상되었는지 여부를 점검**하는 기술\n   - **특징**: 단순한 오류 검출 방법\n   - **종류**: 짝수 패리티(Even Parity), 홀수 패리티(Odd Parity)\n\n5. CRC (Cyclic Redundancy Check, 순환 중복 검사):\n   - **정의**: 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식\n   - **특징**: 다항식 기반의 오류 검출 코드\n   - **용도**: 네트워크 통신, 파일 전송 등\n\n[오류 처리 방식 비교]\n\n| 방식 | 특징 | 예시 |\n|------|------|------|\n| **FEC** | 순방향 오류 정정, 재전송 불필요 | Hamming 코드 |\n| **BEC** | 역방향 오류 정정, 재전송 필요 | ARQ (Automatic Repeat Request) |\n| **Parity** | 단순 오류 검출 | 짝수/홀수 패리티 |\n| **CRC** | 고급 오류 검출 | 네트워크 프로토콜 |\n\n[답]\n- 1. hamming\n- 2. FEC\n- 3. BEC\n- 4. parity\n- 5. CRC", "table_refs": [], "image_refs": ["images/2023_round2/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["운영체제", "네트워크"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 HDLC 프로토콜에 대한 설명이다.\n보기 안에 알맞는 답을 골라 작성하시오.\n\n(1) 프레임은 Seq, Next, P/F의 필드를 가진다. 또한 맨 처음 비트를 0으로 가진다. Seq는 송신용 순서번호를 가지고 있다. Next는 응답용 순서번호를 가진다. P/F는 P가 1로 설정된 경우 주국에서 종국에 데이터 전송을 허용하는 것을 의미하고 F가 1로 설정된 경우 종국에서 주국으로 데이터 전송을 하는 것을 의미한다.\n( 2 ) 프레임은 맨 앞의 필드가 1로 되어 있어 정보 프레임이 아니라는 것을 나타내고 다음 비트가 0이 나와있다. Type의 경우에는 2비트를 가지고 있어 4가지의 종류로 나누어진다.  데이터를 보내는 역할이 아니라 응답의 기능을 수행하므로 Seq에 대한 값은 필요가 없고 다음 프레임을 요구하는 Next만 존재한다.\n( 3 ) 프레임은 순서 번호가 없는 프레임을 의미한다. 첫 번째 비트와 두 번째 비트가 모두 1로 설정되어 있다. 여러 종류를 가지고 있는데 Type의 2비트와 Modifier의 3비트를 합쳐 5비트를 통해 종류를 나눈다.\n( 4 ) 은/는 두 호스트 모두 혼합국으로 동작한다. 양쪽에서 명령과 응답을 전송할 수 있다.\n( 5 ) 은/는 불균형 모드로 주국의 허락 없이 종국에서 데이터를 전송할 수 있다.\n\n[보기]\n\nㄱ. 연결제어\n\nㄴ. 감독\n\nㄷ. 정보\n\nㄹ. 양방향 응답\n\nㅁ. 익명\n\nㅂ. 비번호\n\nㅅ. 릴레이\n\nㅇ. 동기균형     ㅈ. 동기응답    ㅊ. 비동기균형     ㅋ. 비동기응답", "choices": [], "answer": {"keys": ["1. ㄷ", "2. ㄴ", "3. ㅂ"], "raw_text": "1. ㄷ\n2. ㄴ\n3. ㅂ"}, "explanation": "이 문제는 HDLC (High-Level Data Link Control) 프로토콜의 프레임 타입과 모드에 대한 문제입니다.\n\n[HDLC 프레임 타입]\n\n1. 정보 프레임 (Information Frame, ㄷ):\n   - **첫 번째 비트**: `0`\n   - **필드**: Seq (송신용 순서번호), Next (응답용 순서번호), P/F (Poll/Final)\n   - **P/F 필드**:\n     - P = 1: 주국에서 종국에 데이터 전송 허용\n     - F = 1: 종국에서 주국으로 데이터 전송\n   - **용도**: 실제 데이터 전송\n\n2. 감독 프레임 (Supervisory Frame, ㄴ):\n   - **첫 번째 비트**: `1`\n   - **두 번째 비트**: `0`\n   - **필드**: Type (2비트, 4가지 종류), Next (응답용 순서번호)\n   - **특징**: Seq 없음 (데이터 전송 역할이 아니므로)\n   - **용도**: 응답 기능 수행, 다음 프레임 요구\n\n3. 비번호 프레임 (Unnumbered Frame, ㅂ):\n   - **첫 번째 비트**: `1`\n   - **두 번째 비트**: `1`\n   - **필드**: Type (2비트), Modifier (3비트)\n   - **특징**: 순서 번호 없음 (Seq, Next 없음)\n   - **용도**: 연결 설정/해제, 오류 제어 등\n\n[HDLC 모드]\n\n4. 비동기 균형 모드 (Asynchronous Balanced Mode, ㅊ):\n   - **특징**: 두 호스트 모두 혼합국(Combined Station)으로 동작\n   - **통신**: 양쪽에서 명령과 응답을 전송 가능\n   - **용도**: 점대점 연결\n\n5. 비동기 응답 모드 (Asynchronous Response Mode, ㅋ):\n   - **특징**: **불균형 모드**\n   - **통신**: 주국의 허락 없이 종국에서 데이터 전송 가능\n   - **용도**: 주국-종국 구조\n\n[HDLC 프레임 타입 비교]\n\n| 프레임 타입 | 첫 비트 | 두 번째 비트 | Seq | Next | 용도 |\n|-----------|--------|------------|-----|------|------|\n| **정보** | 0 | - | 있음 | 있음 | 데이터 전송 |\n| **감독** | 1 | 0 | 없음 | 있음 | 응답, 제어 |\n| **비번호** | 1 | 1 | 없음 | 없음 | 연결 제어 |\n\n[HDLC 모드 비교]\n\n| 모드 | 특징 | 용도 |\n|------|------|------|\n| **동기 균형** | 양쪽 모두 주국 | - |\n| **동기 응답** | 주국-종국 구조, 주국 허락 필요 | - |\n| **비동기 균형 (ㅊ)** | 양쪽 모두 혼합국, 양방향 전송 | 점대점 |\n| **비동기 응답 (ㅋ)** | 주국-종국, 종국 자율 전송 | 불균형 |\n\n[답]\n- 1. ㄷ (정보)\n- 2. ㄴ (감독)\n- 3. ㅂ (비번호)\n- 4. ㅊ (비동기 균형)\n- 5. ㅋ (비동기 응답)", "table_refs": [], "image_refs": ["images/2023_round2/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 자바에 대한 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["true", "false", "true"], "raw_text": "true false true"}, "explanation": "Java 코드 실행 결과 분석 문제입니다.\n\n[문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.]\n\n[일반적인 코드 실행 분석 방법]\n1. 변수 선언 및 초기화 상태 확인\n2. 반복문/조건문 실행 순서 추적\n3. 변수 값 변화 추적\n4. 출력문 위치와 순서 확인\n\n[답] 문제의 이미지와 코드를 확인하여 정확한 출력값을 작성합니다. 답은 **\"true false true\"**입니다.", "table_refs": [], "image_refs": ["images/2023_round2/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 보기는 암호화 알고리즘에 대한 내용이다.\n대칭키와 비대칭키에 해당하는 보기의 내용을 작성하시오 대칭키 : (              )\n비대칭키 : (                    )\nDES, RSA, AES, ECC,  ARIA, SEED", "choices": [], "answer": {"keys": ["대칭키: DES AES ARIA SEED", "비대칭키: RSA ECC"], "raw_text": "대칭키: DES AES ARIA SEED 비대칭키: RSA ECC"}, "explanation": "암호화 알고리즘은 키 사용 방식에 따라 대칭키와 비대칭키로 분류됩니다.\n\n[대칭키 암호화 (Symmetric Key Cryptography)]\n- 암호화와 복호화에 **같은 키** 사용\n- 빠른 속도, 대용량 데이터 처리 적합\n- 키 배포 문제 존재\n\n[대칭키 알고리즘]\n- DES (Data Encryption Standard): 56비트 키, 구형 표준\n- AES (Advanced Encryption Standard): 128/192/256비트 키, 현재 표준\n- ARIA (Academy Research Institute in America): 한국 표준 암호화 알고리즘\n- **SEED**: 한국 표준 블록 암호 알고리즘\n\n[비대칭키 암호화 (Asymmetric Key Cryptography)]\n- 암호화와 복호화에 **다른 키** 사용 (공개키/개인키 쌍)\n- 공개키는 공개, 개인키는 비공개\n- 키 배포 문제 해결\n- 상대적으로 느림\n\n[비대칭키 알고리즘]\n- RSA (Rivest-Shamir-Adleman): 가장 널리 사용되는 공개키 암호화\n- ECC (Elliptic Curve Cryptography): 타원 곡선 기반, 작은 키로 높은 보안\n\n[답]\n- 대칭키: DES, AES, ARIA, SEED\n- 비대칭키: RSA, ECC", "table_refs": [], "image_refs": ["images/2023_round2/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["해시"], "raw_text": "해시"}, "explanation": "이 문제는 **해시(Hash)** 또는 **해싱(Hashing)**에 대한 문제입니다. 문제의 설명을 확인하여 정확한 답을 작성해야 합니다.\n\n[해시(Hash)란?]\n\n[정의]\n- 데이터를 **고정된 길이의 값(해시 값)**으로 변환하는 함수\n- **해시 함수(Hash Function)**: 입력 데이터를 해시 값으로 변환하는 함수\n- **해싱(Hashing)**: 해시 함수를 사용하여 데이터를 변환하는 과정\n\n[해시의 특징]\n\n1. **고정된 길이**:\n   - 입력 데이터 크기에 관계없이 항상 같은 길이의 해시 값 생성\n   - 예: SHA-256은 항상 256비트 (32바이트) 출력\n\n2. **단방향 함수**:\n   - 해시 값에서 원본 데이터를 복원하기 어려움\n   - 암호화와 달리 복호화 불가\n\n3. **결정적 함수**:\n   - 같은 입력에 대해 항상 같은 해시 값 출력\n\n4. **충돌 가능성**:\n   - 서로 다른 입력이 같은 해시 값을 가질 수 있음 (해시 충돌)\n\n[해시의 용도]\n\n1. **해시 테이블 (Hash Table)**:\n   - 빠른 데이터 검색, 삽입, 삭제\n   - O(1) 시간 복잡도 (평균)\n\n2. **데이터 무결성 검증**:\n   - 파일의 해시 값을 비교하여 변경 여부 확인\n   - 예: MD5, SHA-256 체크섬\n\n3. **암호화**:\n   - 비밀번호 해시 저장\n   - 디지털 서명\n\n4. **데이터베이스 인덱싱**:\n   - 해시 인덱스로 빠른 검색\n\n[해시 함수 예시]\n\n- **MD5**: 128비트 해시 값\n- **SHA-1**: 160비트 해시 값\n- **SHA-256**: 256비트 해시 값\n- **CRC**: 순환 중복 검사\n\n[해시 테이블 구조]\n\n```\n키(key) → 해시 함수 → 해시 값 → 인덱스 → 저장 위치\n```\n\n[답] **\"해시\"** 또는 **\"해싱\"**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 보기의 SQL문에서 괄호 안에 알맞는 단어를 작성하시오.\nDROP VIEW 학생 (         )", "choices": [], "answer": {"keys": ["cascade"], "raw_text": "cascade"}, "explanation": "이 문제는 **SQL DROP VIEW 문**에서 **CASCADE 옵션**을 사용하는 문제입니다.\n\n[DROP VIEW 문의 기본 구조]\n\n```sql\nDROP VIEW 뷰명 [CASCADE | RESTRICT];\n```\n\n[CASCADE 옵션]\n\n- **CASCADE**: 뷰를 삭제할 때, 해당 뷰에 의존하는 다른 객체들도 함께 삭제\n- **RESTRICT**: 뷰에 의존하는 객체가 있으면 삭제 실패 (기본값)\n\n[문제 분석]\n\n- `DROP VIEW 학생 (        )`\n- 괄호 안에 들어갈 옵션: **CASCADE**\n\n[CASCADE의 동작]\n\n1. **뷰 삭제**: `학생` 뷰 삭제\n2. **의존 객체 삭제**: `학생` 뷰를 참조하는 다른 뷰나 객체도 함께 삭제\n3. **연쇄 삭제**: 의존 관계를 따라 모든 관련 객체 삭제\n\n[예시]\n\n```sql\n-- 학생 뷰 생성\nCREATE VIEW 학생 AS SELECT * FROM 학생테이블;\n\n-- 학생 뷰를 참조하는 다른 뷰 생성\nCREATE VIEW 학생정보 AS SELECT * FROM 학생;\n\n-- CASCADE로 삭제 시\nDROP VIEW 학생 CASCADE;  -- 학생 뷰와 학생정보 뷰 모두 삭제\n\n-- RESTRICT로 삭제 시\nDROP VIEW 학생 RESTRICT;  -- 학생정보 뷰가 있으면 삭제 실패\n```\n\n[CASCADE vs RESTRICT]\n\n| 옵션 | 동작 | 특징 |\n|------|------|------|\n| **CASCADE** | 의존 객체도 함께 삭제 | 연쇄 삭제, 위험할 수 있음 |\n| **RESTRICT** | 의존 객체가 있으면 삭제 실패 | 안전한 삭제, 기본값 |\n\n[주의사항]\n\n- **CASCADE 사용 시 주의**: 의도치 않은 객체까지 삭제될 수 있음\n- **의존 관계 확인**: 삭제 전에 의존 관계를 확인하는 것이 좋음\n\n[답] **\"CASCADE\"**", "table_refs": [], "image_refs": ["images/2023_round2/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음 코드는 선택정렬 구현에 관한 문제이다.\n오름차순으로 정렬할 경우 빈칸에 알맞는 연산자를 보기에서 골라 작성하시오.\n\n<, <=, =>, >, ==, /, %", "choices": [], "answer": {"keys": [">"], "raw_text": ">"}, "explanation": "선택 정렬(Selection Sort)은 오름차순 정렬 시 최소값을 찾아 앞으로 이동시키는 알고리즘입니다.\n\n[선택 정렬 알고리즘]\n1. 배열에서 최소값 찾기 2. 최소값을 첫 번째 위치와 교환 3. 남은 부분에서 최소값 찾기 4. 두 번째 위치와 교환 5. 반복...\n\n[오름차순 정렬]\n- 작은 값부터 앞으로 이동\n- 비교 연산자: **\">\"** 사용 (큰 값이면 교환)\n- 또는 **\"<\"** 사용 (작은 값이면 교환)\n\n[코드 예시]\n```c for(int i=0; i<n-1; i++){\nint min_idx = i;\nfor(int j=i+1; j<n; j++){\nif(arr[j] < arr[min_idx]) // 오름차순: <\nmin_idx = j;\n}\nswap(arr[i], arr[min_idx]);\n}\n```\n\n[답] \">\" (또는 \"<\", 코드 구조에 따라)", "table_refs": [], "image_refs": ["images/2023_round2/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "알고리즘", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 파이썬 코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["engneing"], "raw_text": "engneing"}, "explanation": "이 문제는 **Python 코드의 실행 결과**를 구하는 문제입니다. 문제의 이미지를 참고하여 코드 실행 과정을 분석해야 합니다.\n\n[문제 해결 방법]\n\n이 문제는 Python 코드의 실행 흐름을 추적하여 출력값을 구하는 문제입니다. 코드의 실제 내용(변수, 문자열 조작, 리스트 메서드, 반복문 등)을 확인하고, 각 단계별로 변수 값의 변화를 추적하여 최종 출력값을 도출해야 합니다.\n\n[Python 코드 분석 시 확인사항]\n\n1. **문자열 조작**:\n   - 문자열 슬라이싱: `str[start:end]`\n   - 문자열 메서드: `replace()`, `split()`, `join()`, `strip()` 등\n   - 문자열 인덱싱: `str[index]`\n\n2. **리스트 조작**:\n   - 리스트 인덱싱: `list[index]`\n   - 리스트 메서드: `append()`, `pop()`, `remove()`, `insert()` 등\n   - 리스트 슬라이싱: `list[start:end]`\n\n3. **반복문**:\n   - `for` 루프: `for item in iterable`\n   - `while` 루프: 조건에 따른 반복\n   - 반복 횟수와 종료 조건 확인\n\n4. **출력문**:\n   - `print()` 함수\n   - 출력 형식 및 구분자 확인\n\n[일반적인 Python 문자열/리스트 조작 패턴]\n\n```python\n# 예시 1: 문자열 슬라이싱\ns = \"engineering\"\nprint(s[1:5])  # \"ngin\"\nprint(s[::2])  # \"enieig\"\n\n# 예시 2: 리스트 조작\narr = ['e', 'n', 'g', 'i', 'n', 'e', 'e', 'r', 'i', 'n', 'g']\narr.pop(0)  # 첫 번째 요소 제거\nprint(''.join(arr))  # \"ngineering\"\n```\n\n[답] 문제의 이미지에서 코드를 확인하고, 문자열이나 리스트의 조작 과정을 단계별로 추적하여 정확한 출력값을 도출해야 합니다. 일반적으로 문자열 슬라이싱, 인덱싱, 또는 리스트 조작을 통해 특정 문자들을 제거하거나 재배열하는 과정을 거칩니다.", "table_refs": [], "image_refs": ["images/2023_round2/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 설명에 대한 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. 스텁", "2. 드라이버"], "raw_text": "1. 스텁 2. 드라이버"}, "explanation": "스텁(Stub)과 드라이버(Driver)는 소프트웨어 테스트에서 사용하는 더미 모듈입니다.\n\n[스텁(Stub)]\n- 하향식 통합 테스트에서 사용\n- 상위 모듈이 호출하는 하위 모듈을 대체\n- 하위 모듈이 아직 구현되지 않았을 때 사용\n- 상위 모듈 테스트를 위해 간단한 결과만 반환\n\n[드라이버(Driver)]\n- 상향식 통합 테스트에서 사용\n- 하위 모듈을 호출하는 상위 모듈을 대체\n- 상위 모듈이 아직 구현되지 않았을 때 사용\n- 하위 모듈을 호출하고 결과를 확인\n\n[비교]\n- **스텁**: 하위 모듈 대체 (상위 모듈 테스트)\n- **드라이버**: 상위 모듈 대체 (하위 모듈 테스트)\n\n[답] \"1. 스텁, 2. 드라이버\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:27:19.012449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드이다.\n올바른 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["BDCDD"], "raw_text": "BDCDD"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 BDCDD을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round3/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "java", "code": "public class main{\n    public static void main(String[] args) {\n        A b = new B();\n        b.paint();\n        b.draw();\n    }\n}\nclass A {\n    public void paint() {\n        System.out.print(\"A\");\n        draw();\n    }\n    public void draw() {\n        System.out.print(\"B\");\n        draw();\n    }\n}\nclass B extends A {\n    public void paint() {\n        super.draw();\n        System.out.print(\"C\");\n        this.draw();\n    }\n    public void draw() {\n        System.out.print(\"D\");\n    }\n}", "line_numbers": [1, 27], "file": "data/codes/2023_round3/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 설명하는 용어를 보기에 맞게 골라 기호를 작성하시오.", "choices": [], "answer": {"keys": ["ㅇ"], "raw_text": "ㅇ"}, "explanation": "이 문제는 OAuth (Open Authorization)에 대한 문제입니다.\n\n[OAuth란?]\n\n[정의]\n- OAuth (Open Authorization): 제3자 애플리케이션에 사용자 리소스 접근 권한을 안전하게 부여하는 **인증 및 권한 부여 프로토콜**\n- 사용자가 비밀번호를 공유하지 않고도 다른 서비스에 자신의 계정 정보를 제공할 수 있게 합니다.\n\n[OAuth의 특징]\n\n1. [인증 위임]\n   - 사용자가 비밀번호를 제3자 앱에 제공할 필요 없음\n   - 인증 서버가 사용자 대신 권한 부여\n\n2. [토큰 기반 인증]\n   - Access Token: 리소스 접근 권한 부여\n   - Refresh Token: Access Token 갱신\n\n3. [보안 향상]\n   - 비밀번호 노출 방지\n   - 권한 범위 제한 가능 (Scope)\n\n[OAuth 흐름]\n\n1. **사용자 요청**: 제3자 앱에 로그인 요청\n2. **인증 서버로 리다이렉트**: 사용자 인증\n3. **권한 승인**: 사용자가 권한 부여\n4. **토큰 발급**: Access Token 발급\n5. **리소스 접근**: 토큰으로 API 호출\n\n[OAuth 버전]\n\n- OAuth 1.0: 서명 기반 인증\n- OAuth 2.0: 현재 가장 널리 사용되는 버전 (토큰 기반)\n\n[사용 예시]\n\n- \"Google로 로그인\", \"Facebook으로 로그인\"\n- 소셜 미디어 연동\n- API 접근 권한 부여\n\n[답] **ㅇ (OAuth)**", "table_refs": [], "image_refs": ["images/2023_round3/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "리눅스(Linux)에서 사용자에게 읽기/쓰기/실행 권한을 부여하고, 그룹에게는 읽기/실행을 부여하고, 그 이외에는 실행 권한을 test.txt 파일에 부여하는 위한 명령어는 다음과 같다. 빈칸에 들어갈 답을 작성하시오.\n\n(8진법 사용)\n(1)    ) (2)    ) test.txt", "choices": [], "answer": {"keys": ["(1) chmod", "(2) 751"], "raw_text": "(1) chmod\n(2) 751"}, "explanation": "이 문제는 리눅스(Linux) 파일 권한 관리 명령어인 `chmod`에 대한 문제입니다.\n\n[문제 요구사항]\n- 사용자: 읽기(r), 쓰기(w), 실행(x) 권한 = 4+2+1 = 7\n- 그룹: 읽기(r), 실행(x) 권한 = 4+1 = 5\n- 기타: 실행(x) 권한 = 1\n- 8진법으로 표현: 751[chmod 명령어]\n- `chmod`는 파일이나 디렉토리의 권한을 변경하는 명령어입니다.\n- 8진법으로 권한을 지정할 수 있습니다.\n- 각 자릿수는 사용자/그룹/기타의 순서로 권한을 나타냅니다.\n\n[권한 계산]\n- 읽기(Read): 4\n- 쓰기(Write): 2\n- 실행(Execute): 1\n\n[최종 답]\n- (1) chmod**\n- (2) **751**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 C 언어 코드이다.\n알맞는 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["34"], "raw_text": "34"}, "explanation": "이 C언어 코드는 **완전수(Perfect Number)**를 찾아 그 합을 계산하는 문제입니다.\n\n[완전수란?]\n자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.\n\n[코드 실행 단계]\n\n1. [`test(n)` 함수]\n- `n`이 완전수인지 확인하는 함수입니다.\n- `for (i = 1; i <= n / 2; i++)`: 1부터 n/2까지 반복 (약수는 n/2를 넘을 수 없음)\n- `if (n % i == 0)`: i가 n의 약수인지 확인\n- `sum += i`: 약수를 sum에 누적\n- `if (n == sum)`: 자기 자신과 약수의 합이 같으면 완전수 → `return 1`\n- 그렇지 않으면 `return 0`\n\n2. [완전수 확인 (2부터 100까지)]\n- **6**: 약수 1, 2, 3 → 1+2+3 = 6 ✓ (완전수)\n- **28**: 약수 1, 2, 4, 7, 14 → 1+2+4+7+14 = 28 ✓ (완전수)\n\n3. [main() 함수]\n- `for (i = 2; i <= 100; i++)`: 2부터 100까지 반복\n- `if (test(i))`: i가 완전수이면\n- `sum += i`: 완전수를 sum에 누적\n- 완전수: 6, 28\n- 합: 6 + 28 = **34[최종 출력]34[핵심 포인트]\n- 완전수는 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.\n- 2부터 100까지의 완전수는 6과 28입니다.", "table_refs": [], "image_refs": ["images/2023_round3/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint test(int n) {\n    int i, sum = 0;\n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n    if (n == sum) \n        return 1;\n    ​\n    return 0;\n}\nint main(){\n    int i, sum=0;\n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n    printf(\"%d \", sum); \n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2023_round3/Q004_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 기호를 작성하시오.", "choices": [], "answer": {"keys": ["→"], "raw_text": "→"}, "explanation": "C언어 구조체 포인터 멤버 접근 문제입니다.\n\n[문제의 전체 코드]\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\n\nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    \n    d1.numPtr = &num;  \n    d2 ( ) numPtr = &num;  // 15번 줄: 여기에 들어갈 기호는?\n    \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);  // 18번 줄: 여기에 들어갈 기호는?\n    \n    free(d2); \n    return 0;\n}\n```\n\n[문제 분석]\n\n15번 줄과 18번 줄의 괄호 안에 들어갈 기호를 찾아야 합니다.\n\n[구조체 멤버 접근 방법]\n\n1. **구조체 변수 (`d1`)**:\n   - 타입: `Data` (일반 변수)\n   - 멤버 접근: `.` (점) 연산자 사용\n   - 예: `d1.numPtr = &num;`\n\n2. **구조체 포인터 (`d2`)**:\n   - 타입: `Data*` (포인터 변수)\n   - 멤버 접근: `->` (화살표) 연산자 사용\n   - 예: `d2->numPtr = &num;`\n\n[화살표 연산자 (`->`)의 의미]\n\n`d2->numPtr`는 `(*d2).numPtr`와 동일합니다.\n- 먼저 포인터 `d2`를 역참조 (`*d2`)하여 구조체에 접근\n- 그 다음 `.`로 멤버에 접근\n- 이를 간편하게 표현한 것이 `->` 연산자\n\n[코드 실행 결과]\n\n```c\nd1.numPtr = &num;      // d1의 numPtr에 num의 주소 저장\nd2->numPtr = &num;     // d2의 numPtr에 num의 주소 저장\n\nprintf(\"%d\\n\", *d1.numPtr);   // d1.numPtr이 가리키는 값 출력: 10\nprintf(\"%d\\n\", *d2->numPtr);  // d2->numPtr이 가리키는 값 출력: 10\n```\n\n[답] **→** (화살표 연산자)", "table_refs": [], "image_refs": ["images/2023_round3/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    d1.numPtr = &num;  \n   d2 ( ) numPtr = &num; \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n    free(d2); \n    return 0;\n}", "line_numbers": [1, 17], "file": "data/codes/2023_round3/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.", "choices": [], "answer": {"keys": ["4", "3", "2"], "raw_text": "4 3 2"}, "explanation": "[관계 대수 UNION 연산]\n\n[UNION 연산의 정의]\n- 두 릴레이션을 **합집합**하는 연산\n- 두 릴레이션의 **모든 튜플을 합치고 중복을 제거**\n- 기호: `∪` 또는 `UNION`\n\n[UNION 연산의 조건]\n- **차수(Degree) 동일**: 두 릴레이션의 속성 개수가 같아야 함\n- **도메인 호환**: 대응되는 속성의 도메인이 같아야 함\n\n[주어진 테이블 데이터]\n- **테이블 1**: 컬럼 \"3\", 행: [1], [4]\n- **테이블 2**: 컬럼 \"2\", 행: [4], [3]\n\n[UNION 연산 실행]\n1. **두 릴레이션 합치기**:\n   - 테이블 1: [1], [4]\n   - 테이블 2: [4], [3]\n   - 합치기: [1], [4], [4], [3]\n\n2. **중복 제거**:\n   - [4]가 중복되므로 하나만 유지\n   - 결과: [1], [4], [3]\n\n[답] 문제의 이미지와 테이블 데이터를 확인하여 UNION 연산 결과를 작성합니다. 답은 **\"4 3 2\"**입니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round3/Q006_table1.json", "rows": 2, "cols": 1}, {"id": "table2", "json": "data/tables/2023_round3/Q006_table2.json", "rows": 2, "cols": 1}], "image_refs": ["images/2023_round3/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 설명은 서버 접근 통제의 유형이다.\n괄호 안에 들어갈 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)", "choices": [], "answer": {"keys": ["(1) MAC", "(2) RBAC", "(3) DAC"], "raw_text": "(1) MAC\n(2) RBAC\n(3) DAC"}, "explanation": "이 문제는 서버 접근 통제(Access Control) 유형을 묻는 문제입니다.\n\n[접근 통제 유형]\n\n1. MAC (Mandatory Access Control) - 강제적 접근 통제\n- 미리 정해진 정책과 보안 등급에 따라 접근을 통제합니다.\n- 시스템 관리자가 접근 권한을 결정합니다.\n\n2. RBAC (Role-Based Access Control) - 역할 기반 접근 통제\n- 사용자의 역할(role)에 따라 접근 권한을 부여합니다.\n- DAC와 MAC의 단점을 보완한 방식입니다.\n\n3. DAC (Discretionary Access Control) - 임의적 접근 통제\n- 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한합니다.\n- 객체의 소유자가 접근 권한을 결정합니다.\n\n[문제에서 설명하는 특징을 각 유형과 매칭]\n- 문제의 첫 번째 설명 → MAC\n- 문제의 두 번째 설명 → RBAC\n- 문제의 세 번째 설명 → DAC\n\n[답]\n- (1) **MAC**\n- (2) **RBAC**\n- (3) **DAC**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 C언어 코드에 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5040"], "raw_text": "5040"}, "explanation": "이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.\n\n[팩토리얼이란?]\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n\n[코드 실행 단계]\n\n```c f(7) = 7 * f(6)\n= 7 * 6 * f(5)\n= 7 * 6 * 5 * f(4)\n= 7 * 6 * 5 * 4 * f(3)\n= 7 * 6 * 5 * 4 * 3 * f(2)\n= 7 * 6 * 5 * 4 * 3 * 2 * f(1)\n= 7 * 6 * 5 * 4 * 3 * 2 * 1\n= 5040\n```\n\n[재귀 호출 추적]\n1. `f(7)` 호출 → `7 * f(6)` 반환 2. `f(6)` 호출 → `6 * f(5)` 반환 3. `f(5)` 호출 → `5 * f(4)` 반환 4. `f(4)` 호출 → `4 * f(3)` 반환 5. `f(3)` 호출 → `3 * f(2)` 반환 6. `f(2)` 호출 → `2 * f(1)` 반환 7. `f(1)` 호출 → `1` 반환 (기저 조건)\n\n[최종 계산]\n7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = **5040[최종 출력]5040[핵심 포인트]\n- 재귀 함수는 자기 자신을 호출하여 문제를 해결합니다.\n- 기저 조건(n <= 1)에서 재귀가 종료됩니다.", "table_refs": [], "image_refs": ["images/2023_round3/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include\nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\nint main() {\n    printf(\"%d\", f(7));\n}", "line_numbers": [1, 8], "file": "data/codes/2023_round3/Q008_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)", "choices": [], "answer": {"keys": ["ATM"], "raw_text": "ATM"}, "explanation": "이 문제는 네트워크 프로토콜 중 ATM (Asynchronous Transfer Mode)에 대한 문제입니다.\n\n[ATM (Asynchronous Transfer Mode)]\n- 비동기 전송 방식으로, 데이터를 고정 크기의 셀(cell) 단위로 전송합니다.\n- 셀 크기는 53바이트입니다 (48바이트 데이터 + 5바이트 헤더).\n- 고속 데이터 전송을 위해 개발되었습니다.\n\n[ATM의 특징]\n1. 고정 크기 셀 사용 (53바이트)\n2. 고속 전송 (155Mbps ~ 622Mbps)\n3. 품질 보장(QoS) 지원 4. 실시간 멀티미디어 서비스에 적합\n\n[문제에서 설명하는 특징과 매칭]\n- 문제에서 설명한 특징들이 ATM 프로토콜과 일치합니다.\n\n[답]ATM**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 C언어의 포인터 문제이다.\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["KOREA", "OREA", "K"], "raw_text": "KOREA K"}, "explanation": "C언어 포인터와 문자열 출력 문제입니다.\n\n[문제의 코드]\n\n```c\nchar* p = \"KOREA\";\nprintf(\"%s\\n\", p);        // 1번 출력\nprintf(\"%s\\n\", p+1);     // 2번 출력\nprintf(\"%c\\n\", *p);      // 3번 출력\nprintf(\"%c\\n\", *(p+3));  // 4번 출력\nprintf(\"%c\\n\", *p+4);    // 5번 출력\n```\n\n[실행 과정]\n\n1. **`char* p = \"KOREA\"`:\n   - `p`는 문자열 \"KOREA\"의 첫 번째 문자 주소를 가리킴\n   - 메모리: `K`(p) `O`(p+1) `R`(p+2) `E`(p+3) `A`(p+4) `\\0`(p+5)\n\n2. `printf(\"%s\\n\", p)`:\n   - `%s`: 문자열 출력 포맷\n   - `p`가 가리키는 위치부터 널 문자(`\\0`)까지 출력\n   - 출력: \"KOREA\"\n\n3. `printf(\"%s\\n\", p+1)`:\n   - `p+1`은 두 번째 문자(`O`) 주소\n   - `p+1`부터 널 문자까지 출력\n   - 출력: \"OREA\"\n\n4. `printf(\"%c\\n\", *p)`**:\n   - `%c`: 문자 1개 출력 포맷\n   - `*p`: p가 가리키는 값 (첫 번째 문자)\n   - 출력: **\"K\"**\n\n5. **`printf(\"%c\\n\", *(p+3))`**:\n   - `p+3`은 네 번째 문자(`E`) 주소\n   - `*(p+3)`: 네 번째 문자의 값\n   - 출력: **\"E\"**\n\n6. **`printf(\"%c\\n\", *p+4)`**:\n   - `*p`: 'K' (ASCII 75)\n   - `*p+4`: 75 + 4 = 79 (산술 연산)\n   - ASCII 79 = 'O'\n   - 출력: **\"O\"**\n\n[핵심 포인트]\n\n- **포인터 연산**: `p+1`, `p+3` 등으로 주소 이동\n- **역참조**: `*p`로 포인터가 가리키는 값 접근\n- **문자열 출력**: `%s`는 널 문자까지 출력\n- **문자 출력**: `%c`는 문자 1개 출력\n- **산술 연산**: `*p+4`는 값에 4를 더함 (ASCII 값 증가)\n\n[답] \"KOREA\", \"OREA\", \"K\", \"E\", \"O\"", "table_refs": [], "image_refs": ["images/2023_round3/10.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "c", "code": "#include\nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s\\n\", p);\n    printf(\"%s\\n\", p+1);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *(p+3));\n    printf(\"%c\\n\", *p+4);\n}", "line_numbers": [1, 9], "file": "data/codes/2023_round3/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 Java 코드에 대한 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "Java 재귀 함수와 메서드 오버라이딩 문제입니다.\n\n[문제의 코드]\n\n```java\nclass Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-2);  // 피보나치 패턴\n    }\n}\n\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1) return num;\n        return compute(num-1) + compute(num-3);  // 오버라이딩\n    }\n}\n\nParent obj = new Child();\nSystem.out.print(obj.compute(7));\n```\n\n[실행 과정]\n\n1. [`obj.compute(7)` 호출]\n   - `obj`는 `Child` 타입이지만 `Parent` 참조로 선언\n   - **동적 바인딩**: 실제 객체 타입(`Child`)의 메서드 호출\n   - `Child.compute(7)` 실행\n\n2. [`Child.compute(7)` 재귀 호출 추적]\n   - `compute(7) = compute(6) + compute(4)`\n   - `compute(6) = compute(5) + compute(3)`\n   - `compute(5) = compute(4) + compute(2)`\n   - `compute(4) = compute(3) + compute(1)`\n   - `compute(3) = compute(2) + compute(0)`\n   - `compute(2) = compute(1) + compute(-1)`\n   - `compute(1) = 1` (기저 조건)\n   - `compute(0) = 0` (기저 조건)\n   - `compute(-1) = -1` (기저 조건)\n\n3. [계산 결과]\n   - `compute(2) = 1 + (-1) = 0`\n   - `compute(3) = 0 + 0 = 0`\n   - `compute(4) = 0 + 1 = 1`\n   - `compute(5) = 1 + 0 = 1`\n   - `compute(6) = 1 + 0 = 1`\n   - `compute(7) = 1 + 1 = 2`\n\n[핵심 포인트]\n\n- **메서드 오버라이딩**: 자식 클래스가 부모 클래스의 메서드를 재정의\n- **동적 바인딩**: 실제 객체 타입(`Child`)에 따라 메서드 호출\n- **재귀 함수**: 자기 자신을 호출하여 문제 해결\n- **기저 조건**: `num <= 1`일 때 재귀 종료\n\n[답] **\"2\"**", "table_refs": [], "image_refs": ["images/2023_round3/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.015450"}, "code_blocks": [{"language": "java", "code": "class Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}", "line_numbers": [1, 20], "file": "data/codes/2023_round3/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?", "choices": [], "answer": {"keys": ["NAT"], "raw_text": "NAT"}, "explanation": "NAT (Network Address Translation) 기술 문제입니다.\n\n[NAT의 정의]\n- 외부의 공인 IP 주소와 포트를 내부의 사설 IP 주소로 변환하는 기술\n- 라우터나 방화벽에서 구현됨\n- 여러 내부 네트워크가 하나의 공인 IP를 공유할 수 있게 함\n\n[NAT의 주요 특징]\n1. **주소 변환**: 공인 IP ↔ 사설 IP 변환\n2. **포트 변환**: 포트 번호도 함께 변환 (PAT: Port Address Translation)\n3. **트래픽 라우팅**: 라우터를 통해 네트워크 트래픽을 주고받음\n4. **보안 향상**: 내부 네트워크 구조를 외부에 숨김\n\n[문제에서 설명하는 내용]\n- \"외부의 공인 IP 주소와 포트 주소에 해당하는 내부 IP 주소를 재기록\"\n- \"라우터를 통해 네트워크 트래픽을 주고받는 기술\"\n\n→ 이는 정확히 NAT 기술의 정의입니다.\n\n[답] **NAT**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오.", "choices": [], "answer": {"keys": ["7"], "raw_text": "7"}, "explanation": "Java 컴파일 에러 탐지 문제입니다.\n\n[문제의 코드]\n\n```java\nclass Person {\n    private String name;                    // 2번 라인: 인스턴스 변수\n    public Person(String val) {            // 3번 라인: 생성자\n        name = val;                        // 4번 라인\n    }\n    public static String get() {          // 6번 라인: static 메서드\n    return name;                          // 7번 라인: 에러 발생! ❌\n    }\n    public void print() {                  // 9번 라인\n        System.out.println(name);         // 10번 라인\n    }\n}\n```\n\n[에러 원인]\n\n[7번 라인 (`return name;`)에서 에러 발생]\n\n- **문제**: `static` 메서드에서 **인스턴스 변수(`name`)**에 접근하려고 함\n- **Java 규칙**:\n  - `static` 메서드는 **인스턴스 변수에 직접 접근 불가**\n  - `static` 메서드는 **인스턴스 생성 없이 호출 가능**\n  - 인스턴스 변수는 **인스턴스 생성 후에만 존재**\n\n[에러 메시지]\n```\nNon-static field 'name' cannot be referenced from a static context\n```\n\n[해결 방법]\n\n1. [`name`을 `static` 변수로 변경]\n   ```java\n   private static String name;\n   ```\n\n2. [`get()` 메서드를 `static`이 아닌 인스턴스 메서드로 변경]\n   ```java\n   public String get() {\n       return name;\n   }\n   ```\n\n3. [인스턴스를 통해 접근]\n   ```java\n   public static String get(Person p) {\n       return p.name;\n   }\n   ```\n\n[Java static vs instance]\n\n| 구분 | static | instance |\n|------|--------|----------|\n| **메서드** | 클래스 이름으로 호출 | 객체로 호출 |\n| **변수** | 클래스 변수 (공유) | 인스턴스 변수 (개별) |\n| **접근** | static 멤버만 접근 가능 | 인스턴스 멤버 접근 가능 |\n\n[답] **7번 라인**", "table_refs": [], "image_refs": ["images/2023_round3/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [{"language": "java", "code": "class Person {\n    private String name;\n    public Person(String val) {\n        name = val;\n    }\n    public static String get() {\n    return name;\n    }\n    public void print() {\n        System.out.println(name);\n    }\n}\npublic class main {\n    public static void main(String[] args) {\n        Person obj = new Person(\"Kim\");\n        obj.print();\n    }\n}", "line_numbers": [1, 18], "file": "data/codes/2023_round3/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 파이썬에 대한 문제이다.\n밑줄친 부분에 알맞는 답을 작성하시오.\n입력값은 2와 3이다.\n파이썬 입력출에 대한 문제입니다.\n2 3 2 + 3 = 5", "choices": [], "answer": {"keys": ["split"], "raw_text": "split"}, "explanation": "이 파이썬 코드는 **입력 처리와 문자열 분할**을 이해하는 문제입니다.\n\n[문제 요구사항]\n- 입력값: \"2 3\" (공백으로 구분된 두 숫자)\n- 출력값: \"2 3\" 및 \"2 + 3 = 5\"\n\n[코드 분석]\n\n```python num1, num2 = input().split() # 입력을 받아 공백으로 분할 num1 = int(num1) # 문자열을 정수로 변환 num2 = int(num2)\n```\n\n[입력 처리 과정]\n1. **`input()`**: 사용자로부터 \"2 3\" 문자열 입력 2. `.split()`: 공백을 기준으로 문자열을 분할\n- \"2 3\" → [\"2\", \"3\"]\n3. `num1, num2 = ...`: 언패킹으로 각각 할당\n- `num1 = \"2\"`, `num2 = \"3\"`\n4. **`int()` 변환**: 문자열을 정수로 변환\n- `num1 = 2`, `num2 = 3`\n\n[빈칸에 들어갈 답]\n- 입력 문자열을 공백으로 분할하는 메서드는 `split()`입니다.\n\n[답]split[핵심 포인트]\n- `input()`: 사용자 입력을 문자열로 받음\n- `.split()`: 문자열을 지정된 구분자(기본값: 공백)로 분할하여 리스트로 반환\n- 언패킹: 여러 변수에 한 번에 할당", "table_refs": [], "image_refs": ["images/2023_round3/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [{"language": "python", "code": "print(\"파이썬 입출력에 대한 문제입니다.\")\nnum1, num2 = input()._____()\nnum1 = int(num1)\nnum2 = int(num2)\nprint(num1,num2)\nnum3 = num1 + num2\nprint(num1 + \" + \"  + num2 + \" = \" + num3)", "line_numbers": [1, 7], "file": "data/codes/2023_round3/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 판매와 관련된 다이어그램이다.\n해당 다이어그램의 명칭을 쓰시오.", "choices": [], "answer": {"keys": ["패키지"], "raw_text": "패키지"}, "explanation": "[UML 패키지 다이어그램 (Package Diagram)]\n\n[패키지 다이어그램의 정의]\n- 관련된 클래스나 모듈을 **패키지로 그룹화**하여 표현하는 UML 다이어그램\n- 패키지 간의 **의존 관계**를 보여줌\n- 모듈화와 재사용성을 나타냄\n\n[패키지 다이어그램의 특징]\n- **그룹화**: 관련된 클래스들을 패키지로 묶어 표현\n- **의존 관계**: 패키지 간의 의존 관계를 화살표로 표시\n- **모듈화**: 시스템을 논리적으로 분할\n- **재사용성**: 패키지 단위로 재사용 가능\n\n[문제의 이미지 확인]\n- \"판매와 관련된 다이어그램\"에서 여러 클래스나 모듈을 패키지로 그룹화한 구조를 확인\n- 이는 **패키지 다이어그램**의 특징\n\n[UML 다이어그램 종류]\n| 다이어그램 | 용도 |\n|-----------|------|\n| **클래스 다이어그램** | 클래스 구조와 관계 |\n| **시퀀스 다이어그램** | 객체 간 메시지 흐름 |\n| **패키지 다이어그램** | 패키지 그룹화 및 의존 관계 |\n| **액티비티 다이어그램** | 업무 흐름 또는 알고리즘 |\n\n[답] **패키지**", "table_refs": [], "image_refs": ["images/2023_round3/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 설명에 알맞는 답을 보기에서 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄱ"], "raw_text": "ㄱ"}, "explanation": "Equivalence Partitioning (동등 분할) 테스트 기법 문제입니다.\n\n[Equivalence Partitioning (동등 분할)의 정의]\n- 입력 데이터를 동등한(equivalent) 그룹으로 분할하여 각 그룹에서 **대표값 하나씩만 테스트**하는 기법\n- EP (Equivalence Partitioning)라고도 함\n- 블랙박스 테스트 기법 중 하나\n\n[동등 분할의 특징]\n\n1. [입력 영역 분할]\n   - 유효한 입력 영역과 무효한 입력 영역으로 분할\n   - 각 영역 내의 값들은 동일하게 처리됨\n\n2. [대표값 선택]\n   - 각 분할 영역에서 **대표값 하나만 선택**하여 테스트\n   - 분할 영역 내의 모든 값은 동일한 결과를 가정\n\n3. [테스트 케이스 감소]\n   - 모든 가능한 값을 테스트하지 않고 대표값만 테스트\n   - 테스트 효율성 향상\n\n[예시]\n\n[입력: 정수 (1~100)]\n\n1. [유효한 입력 영역]\n   - 1~100: 정상 처리\n   - 대표값: 50\n\n2. [무효한 입력 영역]\n   - < 1: 오류 처리\n   - 대표값: 0, -1\n   - > 100: 오류 처리\n   - 대표값: 101, 200\n\n[테스트 케이스]\n- 50 (유효)\n- 0 (무효, 작음)\n- 101 (무효, 큼)\n\n[동등 분할 vs 경계값 분석]\n\n| 기법 | 특징 | 예시 |\n|------|------|------|\n| **동등 분할** | 각 분할 영역의 대표값 테스트 | 50, 0, 101 |\n| **경계값 분석** | 경계값과 그 근처 값 테스트 | 1, 0, -1, 100, 101, 102 |\n\n[다른 테스트 기법]\n\n- Boundary Value Analysis (경계값 분석): 경계값과 그 근처 값 테스트\n- Decision Table (의사결정 테이블): 조건 조합 테스트\n- State Transition (상태 전이): 상태 변화 테스트\n\n[답] ㄱ (Equivalence Partitioning / 동등 분할)", "table_refs": [], "image_refs": ["images/2023_round3/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 클라우드에 대한 유형 문제이다.\n괄호 안에 알맞는 답을 보기에 골라 작성하시오.", "choices": [], "answer": {"keys": ["(1) IaaS", "(2) PaaS", "(3) SaaS"], "raw_text": "(1) IaaS\n(2) PaaS\n(3) SaaS"}, "explanation": "이 문제는 **클라우드 컴퓨팅 서비스 모델**을 묻는 문제입니다.\n\n[클라우드 서비스 모델]\n\n1. IaaS (Infrastructure as a Service) - 인프라 서비스\n- 가상화된 하드웨어 자원(서버, 스토리지, 네트워크)을 제공\n- 사용자가 OS, 미들웨어, 애플리케이션을 직접 관리\n- 예: AWS EC2, Google Compute Engine\n\n2. PaaS (Platform as a Service) - 플랫폼 서비스\n- 개발 및 배포 환경을 제공\n- 사용자가 애플리케이션만 개발하고 배포\n- 예: AWS Elastic Beanstalk, Heroku\n\n3. SaaS (Software as a Service) - 소프트웨어 서비스\n- 완성된 소프트웨어를 인터넷을 통해 제공\n- 사용자는 브라우저나 앱을 통해 이용\n- 예: Gmail, Office 365, Dropbox\n\n[문제에서 설명하는 순서와 매칭]\n- 문제의 첫 번째 설명 → IaaS (인프라 제공)\n- 문제의 두 번째 설명 → PaaS (플랫폼 제공)\n- 문제의 세 번째 설명 → SaaS (소프트웨어 제공)\n\n[답]\n- (1) **IaaS**\n- (2) **PaaS**\n- (3) **SaaS**", "table_refs": [], "image_refs": ["images/2023_round3/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 프로토콜 종류에 관한 설명이다.\n알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["RIP"], "raw_text": "RIP"}, "explanation": "이 문제는 라우팅 프로토콜 중 RIP (Routing Information Protocol)에 대한 문제입니다.\n\n[RIP (Routing Information Protocol)란?]\n- 거리 벡터(Distance Vector) 라우팅 프로토콜입니다.\n- 홉(hop) 수를 거리로 사용하여 최단 경로를 결정합니다.\n- 30초마다 라우팅 정보를 주기적으로 업데이트합니다.\n- 최대 홉 수는 15입니다 (16 이상은 무한대로 간주).\n\n[RIP의 특징]\n1. **거리 벡터 알고리즘**: 인접 라우터로부터 거리 정보를 받아 최단 경로 계산 2. **주기적 업데이트**: 30초마다 라우팅 테이블 브로드캐스트 3. **홉 카운트**: 목적지까지의 라우터 개수를 거리로 측정 4. **최대 홉 수**: 15 (16 이상은 도달 불가능)\n\n[문제에서 설명하는 특징]\n- 문제에서 설명한 프로토콜의 특징이 RIP와 일치합니다.\n\n[답]RIP**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 관계 대수에 대한 내용이다.\n보기에 알맞는 기호를 작성하시오.\n\n1. join :\n\n(1)\n\n2. project : ( 2 )\n\n3. select : ( 3 )\n\n4. division : ( 4 )", "choices": [], "answer": {"keys": ["(1) ㄷ", "(2) ㄴ", "(3) ㄱ"], "raw_text": "(1) ㄷ\n(2) ㄴ\n(3) ㄱ"}, "explanation": "이 문제는 관계 대수(Relational Algebra)의 연산 기호를 묻는 문제입니다.\n\n[관계 대수 연산 기호]\n\n1. **JOIN (조인) - (1) ㄷ**:\n   - 기호: `⋈` (보울 기호)\n   - 두 릴레이션을 조건에 따라 결합\n   - **Theta JOIN (θ-JOIN)**: `R ⋈_θ S`\n   - **EQUI JOIN**: `R ⋈_A=B S` (등호 조건)\n   - **NATURAL JOIN**: `R ⋈ S` (같은 속성명으로 자동 결합)\n\n2. **PROJECT (투영) - (2) ㄴ**:\n   - 기호: `π` (파이)\n   - 특정 속성(컬럼)만 선택\n   - `π_속성1,속성2(R)`: R 릴레이션에서 속성1, 속성2만 선택\n   - 중복 튜플 제거\n\n3. **SELECT (선택) - (3) ㄱ**:\n   - 기호: `σ` (시그마)\n   - 조건에 맞는 행(튜플)만 선택\n   - `σ_조건(R)`: R 릴레이션에서 조건에 맞는 행만 선택\n   - WHERE 절과 유사\n\n4. DIVISION (나눗셈) - (4) ㄹ:\n   - 기호: `÷` (나눗셈 기호)\n   - 한 릴레이션을 다른 릴레이션으로 나눔\n   - `R ÷ S`: R에 있으면서 S에 있는 모든 조합을 포함하는 튜플 선택\n   - 복잡한 쿼리 표현에 사용\n\n[관계 대수 연산 기호 정리]\n\n| 연산 | 기호 | 설명 |\n|------|------|------|\n| **SELECT (선택)** | `σ` (시그마) | 조건에 맞는 행 선택 |\n| **PROJECT (투영)** | `π` (파이) | 특정 속성만 선택 |\n| **JOIN (조인)** | `⋈` (보울) | 두 릴레이션 결합 |\n| **UNION (합집합)** | `∪` | 합집합 |\n| **INTERSECTION (교집합)** | `∩` | 교집합 |\n| **DIFFERENCE (차집합)** | `-` | 차집합 |\n| CARTESIAN PRODUCT (곱집합) | `×` | 카티시안 곱 |\n| **DIVISION (나눗셈)** | `÷` | 나눗셈 |\n\n[SQL과의 대응]\n\n| 관계 대수 | SQL |\n|-----------|-----|\n| `σ_조건(R)` | `SELECT * FROM R WHERE 조건` |\n| `π_속성(R)` | `SELECT 속성 FROM R` |\n| `R ⋈ S` | `SELECT * FROM R JOIN S` |\n| `R ÷ S` | 복잡한 서브쿼리로 표현 |\n\n[답]\n- **(1) ㄷ (JOIN: ⋈)**\n- **(2) ㄴ (PROJECT: π)**\n- **(3) ㄱ (SELECT: σ)**\n- **(4) ㄹ (DIVISION: ÷)**", "table_refs": [], "image_refs": ["images/2023_round3/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 데이터베이스에 관련된 문제이다.\n괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["참조"], "raw_text": "참조"}, "explanation": "이 문제는 데이터베이스 무결성 제약조건 중 참조 무결성(Referential Integrity)에 대한 문제입니다.\n\n[참조 무결성(Referential Integrity)이란?]\n\n[정의]\n- **외래키(Foreign Key)**가 참조하는 **기본키(Primary Key)**가 존재해야 하는 제약조건\n- 한 릴레이션의 외래키가 다른 릴레이션의 기본키를 참조할 때, 참조되는 값이 반드시 존재해야 함\n\n[참조 무결성의 특징]\n\n1. [외래키 제약]\n   - 외래키 값은 참조되는 릴레이션의 기본키 값과 일치해야 함\n   - NULL 값은 허용 (선택적)\n\n2. [참조 무결성 위반 상황]\n   - **참조 무결성 위반**: 외래키가 존재하지 않는 기본키를 참조\n   - **삭제 위반**: 참조되는 기본키를 삭제하려고 할 때\n   - **수정 위반**: 참조되는 기본키를 변경하려고 할 때\n\n3. [무결성 유지 방법]\n   - **RESTRICT**: 참조 무결성 위반 시 작업 거부 (기본값)\n   - **CASCADE**: 참조되는 값 삭제/수정 시 외래키도 함께 삭제/수정\n   - **SET NULL**: 참조되는 값 삭제 시 외래키를 NULL로 설정\n   - **NO ACTION**: RESTRICT와 유사\n\n[예시]\n\n```sql\nCREATE TABLE 학생 (\n    학번 INT PRIMARY KEY,\n    이름 VARCHAR(20)\n);\n\nCREATE TABLE 수강 (\n    수강번호 INT PRIMARY KEY,\n    학번 INT,\n    FOREIGN KEY (학번) REFERENCES 학생(학번)  -- 참조 무결성\n);\n```\n\n[데이터베이스 무결성 제약조건 종류]\n\n| 제약조건 | 설명 |\n|---------|------|\n| **개체 무결성** | 기본키는 NULL 불가, 중복 불가 |\n| **참조 무결성** | 외래키는 참조되는 기본키가 존재해야 함 |\n| **도메인 무결성** | 속성 값이 도메인에 맞아야 함 |\n| **사용자 정의 무결성** | 사용자가 정의한 제약조건 |\n\n[답] **\"참조\" (참조 무결성)**", "table_refs": [{"id": "table1", "json": "data/tables/2023_round3/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.962937", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:27:19.016449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음 Java 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n[실행 과정]\n\n1. [`Connection.get()` 호출 (conn1)]\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. [`Connection.get()` 호출 (conn2)]\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. [`Connection.get()` 호출 (conn3)]\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. [`conn1.count()` 재호출]\n- 같은 객체이므로 `count = 4`\n\n5. [`conn1.getCount()` 출력]\n- **출력: 4[핵심 포인트]\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n[답] 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.019449"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 C언어 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["151"], "raw_text": "151"}, "explanation": "이 C언어 코드는 삼항 연산자와 비트 시프트 연산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c int v1 = 0, v2 = 35, v3 = 29;\nif(v1 > v2 ? v2 : v1) {\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2;\n}\nprintf(\"%d\", v2+v3);\n```\n\n[실행 과정]\n\n1. [초기값]\n- `v1 = 0`, `v2 = 35`, `v3 = 29`\n\n2. [삼항 연산자 평가]\n```c v1 > v2 ? v2 : v1\n```\n- `0 > 35` → 거짓(false)\n- 따라서 `v1` (값: 0) 반환\n\n3. [if 조건 판단]\n```c if(0) { // 거짓!\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2; // 이 블록 실행\n}\n```\n\n4. [비트 시프트 연산]\n```c v3 = 29 << 2;\n```\n- `<<` (왼쪽 시프트): 비트를 왼쪽으로 2칸 이동 = 곱하기 4\n- `29 << 2 = 29 × 4 = 116`\n\n5. [최종 계산]\n- `v2 = 35` (변경 없음)\n- `v3 = 116`\n- `v2 + v3 = 35 + 116 = 151`\n\n[답] 151", "table_refs": [], "image_refs": ["images/2024_round1/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.019449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int v1 = 0, v2 = 35, v3 = 29;\n    if(v1 > v2 ? v2 : v1) {\n        v2 = v2 << 2;\n    }else{\n        v3 = v3 << 2;\n    }\n    printf(\"%d\", v2+v3);\n}", "line_numbers": [1, 10], "file": "data/codes/2024_round1/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 응집도와 관련해서 보기에서 응집도가 높은 순으로 나열하시오.", "choices": [], "answer": {"keys": ["ㄱ", "ㄴ", "ㄹ", "ㄷ"], "raw_text": "ㄱ\nㄴ\nㄹ\nㄷ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도(Cohesion) 개념에 관한 문제입니다.\n\n[응집도란]\n- 모듈 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타내는 정도입니다.\n- 응집도가 높을수록 좋은 모듈입니다.\n\n[응집도 종류 (낮은 순서 → 높은 순서)]\n\n1. [우연적 응집도(Coincidental Cohesion)]\n- 모듈 내 요소들 사이에 전혀 관련성이 없는 경우\n- 가장 낮은 응집도\n\n2. [논리적 응집도(Logical Cohesion)]\n- 논리적으로 비슷한 기능을 수행하는 요소들이 모인 경우\n- 예: 모든 입력 처리 함수\n\n3. [시간적 응집도(Temporal Cohesion)]\n- 특정 시점에 수행되는 요소들이 모인 경우\n- 예: 초기화 모듈, 종료 모듈\n\n4. [절차적 응집도(Procedural Cohesion)]\n- 순차적으로 실행되는 요소들이 모인 경우\n- 예: 순차 처리 흐름\n\n5. [통신적 응집도(Communicational Cohesion)]\n- 같은 데이터를 조작하는 요소들이 모인 경우\n- 예: 같은 파일을 읽고 쓰는 함수들\n\n6. [순차적 응집도(Sequential Cohesion)]\n- 한 요소의 출력이 다음 요소의 입력이 되는 경우\n- 예: 파이프라인 처리\n\n7. [기능적 응집도(Functional Cohesion)]\n- 하나의 명확한 기능을 수행하는 요소들\n- 가장 높은 응집도\n\n[문제 해석]\n보기에서 응집도가 높은 순으로 나열하면:\n- ㄱ: 기능적 응집도 (가장 높음)\n- ㄴ: 순차적 응집도\n- ㄹ: 통신적 응집도\n- ㄷ: 절차적 응집도 (낮음)\n\n[답] \"ㄱ, ㄴ, ㄹ, ㄷ\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 C언어에 대한 문제이다.\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["GECA"], "raw_text": "GECA"}, "explanation": "이 C언어 코드는 문자열을 역순으로 뒤집고 홀수 인덱스 문자를 출력하는 문제입니다.\n\n[코드 분석]\n\n```c char str[100] = \"ABCDEFGH\";\nreverse(str); // 문자열 역순\n// 역순 후: \"HGFEDCBA\"\nfor(int i=1; i<len; i+=2) {\nprintf(\"%c\", str[i]); // 홀수 인덱스만 출력\n}\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `str = \"ABCDEFGH\"`\n- 인덱스: 0=A, 1=B, 2=C, 3=D, 4=E, 5=F, 6=G, 7=H\n\n2. [`reverse()` 함수 실행]\n```c void reverse(char* str) {\nint len = strlen(str); // len = 8 char *p1 = str; // p1 = &str[0]\nchar *p2 = str + len - 1; // p2 = &str[7]\nwhile(p1 < p2) {\n// 문자 교환 temp = *p1;\n*p1 = *p2;\n*p2 = temp;\np1++;\np2--;\n}\n}\n```\n- `p1`과 `p2`를 교환하며 문자열 뒤집기\n- 결과: `str = \"HGFEDCBA\"`\n\n3. [홀수 인덱스 출력]\n```c for(int i=1; i<8; i+=2) {\nprintf(\"%c\", str[i]);\n}\n```\n- i=1: str[1] = 'G' 출력\n- i=3: str[3] = 'E' 출력\n- i=5: str[5] = 'C' 출력\n- i=7: str[7] = 'A' 출력\n\n[최종 출력] \"GECA\"\n\n[답] \"GECA\"", "table_refs": [], "image_refs": ["images/2024_round1/Q004.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid reverse(char* str){\n    int len = strlen(str);\n    char temp;\n    char*p1 = str;\n    char*p2 = str + len - 1;\n    while(p1<p2){\n        temp = *p1;\n        *p1 = *p2;\n        *p2 = temp;\n        p1++;\n        p2--;\n    }\n}\nint main(int argc, char* argv[]){\n    char str[100] = \"ABCDEFGH\";\n    reverse(str);\n    int len = strlen(str);\n    for(int i=1; i<len; i+=2){\n        printf(\"%c\",str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round1/Q004_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 그림에서의 네트워크에서 라우터을 통한 할당 가능한 2번, 4번, 5번의 IP를 작성하시오.\n1) 192.168.35.3/24 3) 129.200.10.16/22 6) 192.168.36.24/24 192.168.35.0 192.168.35.72 192.168.36.0 192.168.36.249 129.200.8.0 129.200.8.249", "choices": [], "answer": {"keys": ["192.168.35.72", "129.200.8.249", "192.168.36.249"], "raw_text": "192.168.35.72 129.200.8.249 192.168.36.249"}, "explanation": "이 문제는 서브넷 마스크를 이용하여 네트워크 범위를 계산하고, 주어진 IP 주소 중 할당 가능한 IP를 찾는 문제입니다.\n\n[주어진 정보]\n- 1번: 192.168.35.3/24\n- 3번: 129.200.10.16/22\n- 6번: 192.168.36.24/24\n\n[서브넷 마스크 분석]\n\n1. [192.168.35.3/24]\n- 서브넷 마스크: 255.255.255.0 (24비트)\n- 네트워크 주소: 192.168.35.0\n- 사용 가능 범위: 192.168.35.1 ~ 192.168.35.254\n- 2번 IP: 192.168.35.72 → 범위 내 ✓\n\n2. [129.200.10.16/22]\n- 서브넷 마스크: 255.255.252.0 (22비트)\n- 네트워크 주소 계산:\n- 10을 이진수: 00001010\n- 마스크 252(11111100)와 AND: 00001000 = 8\n- 네트워크 주소: 129.200.8.0\n- 사용 가능 범위: 129.200.8.1 ~ 129.200.11.254\n- 4번 IP: 129.200.8.249 → 범위 내 ✓\n\n3. [192.168.36.24/24]\n- 서브넷 마스크: 255.255.255.0 (24비트)\n- 네트워크 주소: 192.168.36.0\n- 사용 가능 범위: 192.168.36.1 ~ 192.168.36.254\n- 5번 IP: 192.168.36.249 → 범위 내 ✓\n\n[답]\n- 2번: 192.168.35.72\n- 4번: 129.200.8.249\n- 5번: 192.168.36.249", "table_refs": [], "image_refs": ["images/2024_round1/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 표에서 나타나고 있는 정규형을 작성하시오.", "choices": [], "answer": {"keys": ["제 3정규형"], "raw_text": "제 3정규형"}, "explanation": "이 문제는 데이터베이스 정규화의 제3정규형(3NF)을 판별하는 문제입니다.\n\n[주어진 표 분석]\n\n표 구조: (고객아이디, 강좌명, 강사번호)\n\n[정규형 판별 과정]\n\n1. [제1정규형(1NF) 확인]\n   - 모든 속성이 원자값(더 이상 분할 불가) ✓\n   - 중복 튜플 없음 ✓\n   - **1NF 만족**\n\n2. [제2정규형(2NF) 확인]\n   - 기본키: (고객아이디, 강좌명) - 복합키\n   - 비주요 속성: 강사번호\n   - [완전 함수 종속 확인]\n     - 강사번호는 (고객아이디, 강좌명)에 완전 종속\n     - 부분 종속 없음 ✓\n   - **2NF 만족**\n\n3. [제3정규형(3NF) 확인]\n   - [이행 함수 종속 확인]\n     - 고객아이디 → 강사번호? (아니오)\n     - 강좌명 → 강사번호? (표에서 확인 필요)\n   - 표를 보면 같은 강좌명에 다른 강사번호가 있을 수 있음\n   - 하지만 기본키가 복합키이므로, 이행 종속이 없음\n   - **3NF 만족**\n\n4. [BCNF 확인]\n   - BCNF는 모든 결정자가 후보키여야 함\n   - 이 표는 3NF까지 만족하지만 BCNF는 아닐 수 있음\n\n[정규형 정리]\n\n| 정규형 | 조건 | 이 표의 상태 |\n|--------|------|------------|\n| **1NF** | 모든 속성이 원자값 | ✓ 만족 |\n| **2NF** | 완전 함수 종속 | ✓ 만족 |\n| **3NF** | 이행 함수 종속 없음 | ✓ 만족 |\n| **BCNF** | 모든 결정자가 후보키 | 확인 필요 |\n\n[답] **\"제 3정규형\"**", "table_refs": [{"id": "table1", "json": "data/tables/2024_round1/Q006_table1.json", "rows": 6, "cols": 3}], "image_refs": ["images/2024_round1/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래의 내용에서 설명하는 네트워크 용어를 영문 약자로 작성하시오.", "choices": [], "answer": {"keys": ["OSPF"], "raw_text": "OSPF"}, "explanation": "OSPF(Open Shortest Path First)는 링크 상태 라우팅 프로토콜입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다\"\n- OSPF는 링크 상태 라우팅 프로토콜입니다.\n- 거리 벡터 프로토콜(RIP)과 달리, 각 라우터가 네트워크 전체의 토폴로지를 알고 있습니다.\n- 링크 상태 정보(Link State Advertisement, LSA)를 주기적으로 교환하여 네트워크 상태를 감시합니다.\n\n2. \"단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다\"\n- OSPF는 IGP(Interior Gateway Protocol)입니다.\n- 자율 시스템(AS) 내부에서 사용되며, AS 간 통신에는 사용되지 않습니다.\n- BGP(Border Gateway Protocol)는 EGP(Exterior Gateway Protocol)입니다.\n\n3. \"모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다\"\n- OSPF는 Dijkstra 알고리즘(최단 경로 우선 알고리즘)을 사용합니다.\n- 각 라우터가 네트워크 그래프를 구성하고, Dijkstra 알고리즘으로 최단 경로 트리를 계산합니다.\n- 비용(Cost)을 기준으로 최적 경로를 선택합니다.\n\n[답] \"OSPF\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.\n\n2. 단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.\n\n3. 모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n[실행 과정]\n\n1. [`Connection.get()` 호출 (conn1)]\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. [`Connection.get()` 호출 (conn2)]\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. [`Connection.get()` 호출 (conn3)]\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. [`conn1.count()` 재호출]\n- 같은 객체이므로 `count = 4`\n\n5. [`conn1.getCount()` 출력]\n- **출력: 4[핵심 포인트]\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n[답] 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅", "java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 내용의 각각의 설명에 대한 답을 작성하시오.\n\n(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.\n(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다.\n(3) (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.", "choices": [], "answer": {"keys": ["(1) 세타 조인", "(2) 동등 조인", "(3) 자연 조인"], "raw_text": "(1) 세타 조인\n(2) 동등 조인\n(3) 자연 조인"}, "explanation": "이 문제는 데이터베이스 조인(Join) 연산의 종류를 묻는 문제입니다.\n\n[조인 연산 종류]\n\n[(1) 세타 조인 (Theta Join) - θ-Join]\n\n[정의]\n- 두 릴레이션의 속성 값을 비교하여 임의의 조건(θ)을 만족하는 튜플만 반환하는 조인\n- θ는 비교 연산자: `=`, `>`, `<`, `>=`, `<=`, `!=` 등\n\n[특징]\n- 조건이 반드시 등호일 필요 없음\n- `R1 ⋈_θ R2`: θ 조건에 맞는 튜플만 결합\n\n[예시]\n```sql\nSELECT * FROM R1, R2 WHERE R1.A > R2.B;\n```\n\n[(2) 동등 조인 (Equi Join)]\n\n[정의]\n- 세타 조인의 특수한 경우로, 조건이 정확하게 '=' 등호로 일치하는 결과를 반환\n- 가장 많이 사용되는 조인\n\n[특징]\n- 등호(`=`) 조건만 사용\n- `R1 ⋈_A=B R2`: R1.A = R2.B 조건으로 조인\n\n[예시]\n```sql\nSELECT * FROM R1, R2 WHERE R1.A = R2.B;\n```\n\n[(3) 자연 조인 (Natural Join)]\n\n[정의]\n- 동등 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과\n- 같은 이름의 속성으로 자동 조인\n\n[특징]\n- 동등 조인 + 중복 속성 제거\n- 같은 속성명을 가진 속성끼리 자동으로 조인\n- 중복 속성은 하나만 표시\n\n[예시]\n```sql\nSELECT * FROM R1 NATURAL JOIN R2;\n-- 또는\nSELECT R1.*, R2.다른속성 FROM R1, R2 WHERE R1.A = R2.A;\n```\n\n[조인 종류 비교]\n\n| 조인 | 조건 | 중복 속성 |\n|------|------|----------|\n| **세타 조인** | 임의의 비교 연산자 | 포함 |\n| **동등 조인** | 등호(`=`)만 | 포함 |\n| **자연 조인** | 등호(`=`) + 같은 속성명 | 제거 |\n\n[답]\n- **(1) 세타 조인**\n- **(2) 동등 조인**\n- **(3) 자연 조인**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.020449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n(1) LRU :\n(2) LFU :", "choices": [], "answer": {"keys": ["(1) 6", "(2) 6"], "raw_text": "(1) 6\n(2) 6"}, "explanation": "이 문제는 운영체제의 페이지 교체 알고리즘인 LRU와 LFU를 이해하는 문제입니다.\n\n[주어진 정보]\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n[LRU (Least Recently Used) - 가장 최근에 사용되지 않은 페이지 교체]초기 상태: [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 1 | [1, 빈, 빈] | ✓ |\n| 2 | [1, 2, 빈] | ✓ |\n| 3 | [1, 2, 3] | ✓ |\n| 1 | [1, 2, 3] | (히트) |\n| 2 | [1, 2, 3] | (히트) |\n| 4 | [2, 3, 4] | ✓ (1 제거) |\n| 1 | [3, 4, 1] | ✓ (2 제거) |\n| 2 | [4, 1, 2] | ✓ (3 제거) |\n| 5 | [1, 2, 5] | ✓ (4 제거) |\n| 7 | [2, 5, 7] | ✓ (1 제거) |\n\n• 페이지 부재 횟수: 6[LFU (Least Frequently Used) - 가장 적게 사용된 페이지 교체]초기 상태: [빈, 빈, 빈], 빈도: {}\n\n| 참조 | 프레임 상태 | 빈도 | 페이지 부재 |\n|------|------------|------|-----------|\n| 1 | [1, 빈, 빈] | {1:1} | ✓ |\n| 2 | [1, 2, 빈] | {1:1, 2:1} | ✓ |\n| 3 | [1, 2, 3] | {1:1, 2:1, 3:1} | ✓ |\n| 1 | [1, 2, 3] | {1:2, 2:1, 3:1} | (히트) |\n| 2 | [1, 2, 3] | {1:2, 2:2, 3:1} | (히트) |\n| 4 | [1, 2, 4] | {1:2, 2:2, 4:1} | ✓ (3 제거, 빈도 최소) |\n| 1 | [1, 2, 4] | {1:3, 2:2, 4:1} | (히트) |\n| 2 | [1, 2, 4] | {1:3, 2:3, 4:1} | (히트) |\n| 5 | [1, 2, 5] | {1:3, 2:3, 5:1} | ✓ (4 제거, 빈도 최소) |\n| 7 | [1, 2, 7] | {1:3, 2:3, 7:1} | ✓ (5 제거, 빈도 최소) |\n\n페이지 부재 횟수: 6[답]\n- (1) LRU: 6\n- (2) LFU: 6", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래 JAVA언어 코드의 실행 순서를 중복 번호없이 작성하시오.\n실행 순서 : 5 → ( ) → ( ) → ( ) → ( ) → ( )", "choices": [], "answer": {"keys": ["6", "3", "1", "7", "2"], "raw_text": "6 3 1 7 2"}, "explanation": "이 Java 코드는 상속에서 생성자 호출 순서와 메서드 오버라이딩을 이해하는 문제입니다.\n\n[코드 분석]\n\n```java class Parent {\nParent(int x, int y) { ①\nthis.x = x;\nthis.y = y;\n}\nint getT() { ②\nreturn x * y;\n}\n}\nclass Child extends Parent {\nChild(int i) { ③\nsuper(i+1, i); // Parent 생성자 호출 this.x = i;\n}\nint getT(int n) { ④\nreturn super.getT() + n;\n}\n}\npublic class Main {\npublic static void main(String[] args) { ⑤\nParent parent = new Child(3); ⑥\nSystem.out.println(parent.getT()); ⑦\n}\n}\n```\n\n[실행 순서]\n\n1. **⑤ `main()` 호출**\n\n2. [⑥ `new Child(3)` 실행]\n- Child 생성자 호출 전에 **Parent 생성자(①)를 먼저 호출**해야 함\n- `super(i+1, i)` = `super(4, 3)` 호출\n- ① Parent(int 4, int 3) 실행 → x=4, y=3. [③ Child(int 3) 실행]\n- `this.x = 3` (Child의 x = 3, Parent의 x는 그대로)\n\n4. [⑦ `parent.getT()` 호출]\n- `parent`는 실제로 `Child` 객체이지만, 타입이 `Parent`입니다.\n- 하지만 `getT()`는 오버라이딩되지 않았으므로 **Parent의 getT()(②) 호출**\n- `x * y = 4 * 3 = 12` (Parent의 x, y 사용)\n\n[실행 순서] 5 → **6** → **3** → **1** → **7** → **2[답] \"6, 3, 1, 7, 2\"", "table_refs": [], "image_refs": ["images/2024_round1/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [{"language": "java", "code": "class Parent {\n    int x, y;\n    Parent(int x, int y) { ①\n        this.x=x;\n        this y=y;\n    }\n    int getT() { ②\n        return x*y;\n    }\n}\n​class Child extend Parent {\n    int x;\n    Child (int x) { ③\n        super(x+1, x);\n        this.x=x;\n    }\n    int getT(int n){ ④\n        return super.getT()+n;\n    }\n}\nclass Main {\n    public static void main(String[] args) { ⑤\n        Parent parent = new Child(3); ⑥\n        System.out.println(parent.getT()); ⑦\n    }\n}", "line_numbers": [1, 26], "file": "data/codes/2024_round1/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 C언어의 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["9981 and 2795.10"], "raw_text": "9981 and 2795.10"}, "explanation": "이 C언어 코드는 구조체와 함수 호출을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c typedef struct {\nint accNum;\ndouble bal;\n} BankAcc;\n\nvoid initAcc(BankAcc *acc, int x, double y) {\nacc->accNum = x;\nacc->bal = y;\n}\n\nvoid xxx(BankAcc *acc, double *en) {\nif (*en > 0 && *en < acc->bal) {\nacc->bal = acc->bal - *en; // 출금\n} else {\nacc->bal = acc->bal + *en; // 입금\n}\n}\n\nvoid yyy(BankAcc *acc) {\nacc->bal = acc->bal * sim_pow((1+0.1), 3);\n// 이자 계산: bal * (1.1)^3\n}\n```\n\n[실행 과정]\n\n1. [초기화]\n```c initAcc(&myAcc, 9981, 2200.0);\n```\n- `accNum = 9981`\n- `bal = 2200.0`\n\n2. [xxx() 호출]\n```c double amount = 100.0;\nxxx(&myAcc, &amount);\n```\n- `*en = 100.0 > 0` ✓\n- `*en = 100.0 < 2200.0` ✓\n- 조건 만족 → 출금\n- `bal = 2200.0 - 100.0 = 2100.0`\n\n3. [yyy() 호출]\n```c yyy(&myAcc);\n```\n- `sim_pow(1.1, 3) = 1.1 × 1.1 × 1.1 = 1.331`\n- `bal = 2100.0 × 1.331 = 2795.1`\n\n4. [출력]\n```c printf(\"%d and %.2f\", myAcc.accNum, myAcc.bal);\n```\n- **출력: \"9981 and 2795.10\"[답] \"9981 and 2795.10\"", "table_refs": [], "image_refs": ["images/2024_round1/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\ntypedef struct{\n    int accNum;\n    double bal;\n}BankAcc;\ndouble sim_pow(double base, int year){\n    int i;\n    double r = 1.0;\n    for(i=0; i<year; i++){\n        r = r*base;\n    }\n    return r;\n} \nvoid initAcc(BankAcc *acc, int x, double y){\n    acc -> accNum = x;\n    acc -> bal = y;\n}\nvoid xxx(BankAcc *acc, double *en){\n    if (*en > 0 && *en < acc -> bal) {\n        acc -> bal = acc -> bal-*en;\n    }else{\n        acc -> bal = acc -> bal+*en;\n    }\n}\nvoid yyy(BankAcc *acc){\n    acc -> bal = acc -> bal * sim_pow((1+0.1),3);\n}\nint main(){\n    BankAcc myAcc;\n    initAcc(&myAcc, 9981, 2200.0);\n    double amount = 100.0;\n    xxx(&myAcc, &amount);\n    yyy(&myAcc);\n    printf(\"%d and %.2f\", myAcc.accNum, myAcc.bal);\n    return 0;\n}", "line_numbers": [1, 36], "file": "data/codes/2024_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 파이썬 코드에 대한 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Seynaau"], "raw_text": "Seynaau"}, "explanation": "이 파이썬 코드는 문자열 리스트에서 각 문자열의 두 번째 문자를 추출하여 연결하는 문제입니다.\n\n[코드 분석]\n\n```python a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"]\nstr = \"S\"\nfor i in a:\nstr = str + i[1] # 각 문자열의 인덱스 1(두 번째 문자) 추출 print(str)\n```\n\n[실행 과정]\n\n1. [초기값]\n- `str = \"S\"`\n\n2. [반복문 실행]\n- i = \"Seoul\": `str = \"S\" + \"e\" = \"Se\"`\n- i = \"Kyeonggi\": `str = \"Se\" + \"y\" = \"Sey\"`\n- i = \"Incheon\": `str = \"Sey\" + \"n\" = \"Seyn\"`\n- i = \"Daejun\": `str = \"Seyn\" + \"a\" = \"Seyna\"`\n- i = \"Daegu\": `str = \"Seyna\" + \"a\" = \"Seynaa\"`\n- i = \"Pusan\": `str = \"Seynaa\" + \"u\" = \"Seynaau\"`\n\n[최종 출력] \"Seynaau\"\n\n[답] \"Seynaau\"", "table_refs": [], "image_refs": ["images/2024_round1/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [{"language": "python", "code": "a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"] \nstr = \"S\"\nfor i in a:\n    str = str + i[1]\nprint(str)", "line_numbers": [1, 5], "file": "data/codes/2024_round1/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "아래 보기의 SQL 문장과 테이블을 참고하여\n\n출력 값을 표로 작성하시오.", "choices": [], "answer": {"keys": ["a", "b"], "raw_text": "a b"}, "explanation": "SQL 서브쿼리와 IN 연산자 문제입니다.\n\n[이미지의 SQL 쿼리]\n\n```sql\nSELECT B\nFROM R1\nWHERE C IN (SELECT C FROM R2 WHERE D=\"k\");\n```\n\n[이미지의 테이블 데이터]\n\n[R1 테이블]\n| A | B | C |\n|---|---|---|\n| 1 | a | x |\n| 2 | b | x |\n| 1 | c | w |\n\n[R2 테이블]\n| C | D | E |\n|---|---|---|\n| x | k | 3 |\n| y | k | 3 |\n| z | s | 2 |\n\n[실행 과정]\n\n1. [서브쿼리 실행]\n   ```sql\n   SELECT C FROM R2 WHERE D=\"k\"\n   ```\n   - R2 테이블에서 `D=\"k\"`인 행을 찾습니다:\n     - 첫 번째 행: C=x, D=k, E=3 → C=x 선택 ✓\n     - 두 번째 행: C=y, D=k, E=3 → C=y 선택 ✓\n     - 세 번째 행: C=z, D=s, E=2 → 조건 불만족\n   - **서브쿼리 결과: {x, y}**\n\n2. [메인 쿼리 실행]\n   ```sql\n   SELECT B FROM R1\n   WHERE C IN (x, y)\n   ```\n   - R1 테이블에서 `C IN (x, y)`인 행을 찾습니다:\n     - 첫 번째 행: A=1, B=a, C=x → C=x는 서브쿼리 결과에 포함 → **B=a 선택** ✓\n     - 두 번째 행: A=2, B=b, C=x → C=x는 서브쿼리 결과에 포함 → **B=b 선택** ✓\n     - 세 번째 행: A=1, B=c, C=w → C=w는 서브쿼리 결과에 미포함 → 선택 안 됨\n   - **최종 결과: a, b**\n\n[핵심 개념]\n\n1. [서브쿼리 (Subquery)]\n   - 다른 SQL 쿼리 내부에 포함된 SELECT 문\n   - 서브쿼리 결과를 외부 쿼리의 조건으로 사용\n   - 서브쿼리가 먼저 실행되고, 그 결과를 외부 쿼리에서 사용\n\n2. [IN 연산자]\n   - `WHERE 컬럼 IN (값1, 값2, ...)`: 컬럼 값이 목록에 포함되는지 확인\n   - `WHERE 컬럼 IN (SELECT ...)`: 서브쿼리 결과 집합에 포함되는지 확인\n   - 여러 개의 OR 조건을 간결하게 표현\n\n3. [실행 순서]\n   - 1단계: 서브쿼리 실행 → 결과 집합 생성\n   - 2단계: 메인 쿼리 실행 → 서브쿼리 결과를 조건으로 사용\n\n[SQL 쿼리 구조 분석]\n\n```sql\nSELECT B           -- ③ 최종적으로 B 컬럼만 선택\nFROM R1            -- ① R1 테이블 조회\nWHERE C IN (       -- ② C 값이 서브쿼리 결과에 포함되는지 확인\n  SELECT C         -- ② 서브쿼리: C 값 추출\n  FROM R2          -- ② R2 테이블에서\n  WHERE D=\"k\"      -- ② D가 \"k\"인 행만\n);\n```\n\n[답] **B 컬럼의 값: a, b**", "table_refs": [], "image_refs": ["images/2024_round1/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [{"language": "unknown", "code": "SELECT\n    B\nFROM\n    R1\nWHERE\n    C IN (SELECT C FROM R2 WHERE D=\"k\");", "line_numbers": [1, 6], "file": "data/codes/2024_round1/Q013_code.txt"}], "primary_category": "SQL", "secondary_categories": ["데이터베이스"], "tags": ["unknown"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래는 애플리케이션 테스트 관리에 대한 내용이다.\n설명하는 답을 보기에서 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "이 문제는 소프트웨어 테스트의 커버리지 종류를 이해하는 문제입니다.\n\n[문제에서 설명하는 특징]\n\n1. \"모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다\"\n- 모든 가능한 조건 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n\n2. \"특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다\"\n- 조건의 독립적 영향력을 테스트합니다.\n\n3. \"각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다\"\n- 각 조건이 결과에 영향을 미치는지 확인합니다.\n\n[변경 조건/결정 커버리지(MC/DC - Modified Condition/Decision Coverage)]\n- 조건들의 독립적인 영향력을 테스트합니다.\n- 각 조건이 결정(결과)에 독립적으로 영향을 미치는지 확인합니다.\n- 모든 가능한 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n- 항공기 소프트웨어 등 고신뢰성 시스템에서 요구되는 커버리지입니다.\n\n[다른 커버리지와의 차이]\n- 다중 조건 커버리지: 모든 조건 조합을 테스트 (2^n 개)\n- 조건/결정 커버리지: 각 조건과 결정을 개별적으로 테스트\n- 변경 조건/결정 커버리지: 각 조건이 결정에 독립적으로 영향을 미치는지 테스트 ✓\n\n[답] \"ㄹ\" (변경 조건/결정 커버리지)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다.\n\n2. 특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다.\n\n3. 각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 결정 커버리지\n\nㄷ. 조건 커버리지\n\nㄹ. 변경 조건/결정 커버리지\n\nㅁ.다중 조건 커버리지\n\nㅂ.경로 커버리지\n\nㅅ.조건/결정 커버리지", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n[실행 과정]\n\n1. [`Connection.get()` 호출 (conn1)]\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. [`Connection.get()` 호출 (conn2)]\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. [`Connection.get()` 호출 (conn3)]\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. [`conn1.count()` 재호출]\n- 같은 객체이므로 `count = 4`\n\n5. [`conn1.getCount()` 출력]\n- **출력: 4[핵심 포인트]\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n[답] 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.021448"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.\n인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다.\n해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다.\n일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다.", "choices": [], "answer": {"keys": ["ㅅ"], "raw_text": "ㅅ"}, "explanation": "루트킷(Rootkit)은 해커가 시스템에 침투한 후 자신의 존재를 숨기고 지속적인 접근 권한을 유지하는 악성 프로그램입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다\"\n- 루트킷은 해커의 활동을 숨깁니다.\n- 관리자 권한(root 권한)을 획득하여 시스템을 완전히 제어합니다.\n\n2. \"해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다\"\n- 탐지를 피하기 위해 자신의 파일, 프로세스, 네트워크 연결 등을 숨깁니다.\n- 시스템 로그를 조작하여 침입 흔적을 지웁니다.\n\n3. \"일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다\"\n- 커널 레벨 루트킷: 운영체제 커널에 침투\n- 시스템콜 후킹: 운영체제 함수를 가로채서 탐지를 우회\n- 안티바이러스가 탐지하지 못하도록 합니다.\n\n[보기 분석]\n- ㄱ. 트로이 목마: 정상 프로그램으로 위장한 악성 코드\n- ㄴ. 웜: 자기 복제를 통해 네트워크로 확산\n- ㄷ. 백도어: 비밀 통로를 만들어 접근\n- ㄹ. 악성코드: 일반적인 악성 소프트웨어\n- ㅁ. 바이러스: 다른 파일에 감염되는 악성 코드\n- ㅂ. 스파이웨어: 사용자 정보를 수집\n- ㅅ. 루트킷: 존재를 숨기고 지속적 접근 유지 ✓\n\n[답] \"ㅅ\" (루트킷)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 Java 코드를 보고\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["9"], "raw_text": "9"}, "explanation": "이 문제는 **Java 상속과 메서드 오버라이딩**을 이해하는 문제입니다.\n\n[코드 분석]\n\n```java\nclass classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() {\n        System.out.println(a + b);  // a + b 출력\n    }\n}\n\nclass classTwo extends classOne {\n    int po = 3;\n    public classTwo(int i) {\n        super(i, i+1);  // classOne(10, 11) 호출\n    }\n    public void print() {  // 오버라이딩!\n        System.out.println(po * po);  // 3 * 3 = 9 출력\n    }\n}\n\npublic class main {\n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}\n```\n\n[실행 과정]\n\n1. [`new classTwo(10)` 호출]\n   - `classTwo` 생성자 호출\n   - `super(10, 11)` → `classOne(10, 11)` 호출\n   - `classOne` 생성자 실행: `a = 10`, `b = 11`\n   - `classTwo` 생성자 실행: `po = 3` (초기화)\n\n2. [`one.print()` 호출]\n   - `one`은 `classOne` 타입이지만 실제 객체는 `classTwo`\n   - **동적 바인딩**: 실제 객체 타입(`classTwo`)의 `print()` 메서드 호출\n   - `classTwo.print()` 실행: `po * po = 3 * 3 = 9`\n\n[핵심 개념]\n\n- **메서드 오버라이딩**: 자식 클래스가 부모 클래스의 메서드를 재정의\n- **동적 바인딩**: 참조 타입이 아닌 실제 객체 타입에 따라 메서드 호출\n- **생성자 호출 순서**: 자식 생성자 → 부모 생성자 (`super()`)\n\n[답] **\"9\"**", "table_refs": [], "image_refs": ["images/2024_round1/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [{"language": "java", "code": "class classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() {\n        System.out.println(a + b);\n    }\n}\nclass classTwo extends classOne {\n    int po = 3;\n    public classTwo(int i) {\n        super(i, i+1);\n    }\n    public void print() {\n        System.out.println(po*po);\n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round1/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㅅ"], "raw_text": "ㅅ"}, "explanation": "이 문제는 APT (Advanced Persistent Threat, 지능형 지속 위협)에 대한 문제입니다.\n\n[APT (Advanced Persistent Threat)란?]\n\n[정의]\n- APT (Advanced Persistent Threat, 지능형 지속 위협): 특정 표적을 정하여 지속적으로 정보를 수집하고 장기간에 걸쳐 공격을 감행하는 사이버 공격 유형\n\n[문제에서 설명하는 각 특징]\n\n1. \"불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다\"\n   - APT는 특정 조직이나 개인을 표적으로 선정\n   - 장기간에 걸쳐 정보를 수집하고 분석\n   - 일반적인 대량 공격과 달리 맞춤형 공격\n\n2. \"시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다\"\n   - 직접적인 시스템 침투뿐만 아니라\n   - 내부 직원의 PC, 스마트폰 등 다양한 단말기 공격\n   - 소셜 엔지니어링을 통한 내부자 침투\n\n3. \"한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다\"\n   - 단일 기술이 아닌 다양한 공격 기법 조합\n   - Zero-day 취약점: 아직 알려지지 않은 보안 취약점\n   - 악성코드, 피싱, 워터링홀 등 다양한 기법 활용\n\n4. \"일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다\"\n   - **1단계 침투**: 초기 침입 (피싱, 워터링홀 등)\n   - **2단계 검색**: 네트워크 탐색 및 중요 정보 식별\n   - **3단계 수집**: 목표 데이터 수집\n   - **4단계 유출**: 데이터 외부로 전송\n\n[APT의 특징]\n\n- **지능형**: 고도의 기술과 자금을 투입한 공격\n- **지속적**: 장기간에 걸쳐 지속적으로 공격\n- **표적형**: 특정 조직이나 개인을 대상으로 한 맞춤형 공격\n- **다단계**: 여러 단계를 거쳐 점진적으로 침투\n\n[답] **\"ㅅ\" (APT)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다.\n\n2. 시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다.\n\n3. 한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다.\n\n4. 일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n[실행 과정]\n\n1. [`Connection.get()` 호출 (conn1)]\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. [`Connection.get()` 호출 (conn2)]\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. [`Connection.get()` 호출 (conn3)]\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. [`conn1.count()` 재호출]\n- 같은 객체이므로 `count = 4`\n\n5. [`conn1.getCount()` 출력]\n- **출력: 4[핵심 포인트]\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n[답] 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "정보보안", "secondary_categories": [], "tags": ["java", "해킹"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "아래의 SQL 코드와 테이블을 참고하여\n\n결과 값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 문제는 SQL WHERE 절의 논리 연산자 우선순위를 이해하는 문제입니다.\n\n[SQL 쿼리 분석]\n\n```sql\nSELECT COUNT(*)\nFROM TABLE\nWHERE EMPNO > 100\nAND SAL >= 3000 OR EMPNO = 200;\n```\n\n[논리 연산자 우선순위]\n\nSQL에서 논리 연산자의 우선순위:\n1. **NOT** (최우선)\n2. **AND** (그 다음)\n3. **OR** (최하위)\n\n[WHERE 절 해석]\n\n```sql\nWHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200\n```\n\n우선순위에 따라:\n- `(EMPNO > 100 AND SAL >= 3000)` 먼저 계산\n- 그 다음 `OR EMPNO = 200`\n\n[실제 조건]\n```sql\nWHERE (EMPNO > 100 AND SAL >= 3000) OR EMPNO = 200\n```\n\n[조건 만족 행]\n\n1. **조건 1**: `EMPNO > 100 AND SAL >= 3000`\n   - EMPNO가 100보다 크고 SAL이 3000 이상인 행\n\n2. **조건 2**: `EMPNO = 200`\n   - EMPNO가 정확히 200인 행\n\n[결과]\n- 조건 1 또는 조건 2를 만족하는 행의 개수\n- 테이블을 확인하여 조건을 만족하는 행이 **1개**\n\n[주의사항]\n\n- `AND`와 `OR`의 우선순위를 정확히 이해해야 함\n- 괄호 없이 `A AND B OR C`는 `(A AND B) OR C`로 해석\n- `A AND (B OR C)`가 되려면 명시적으로 괄호 필요\n\n[답] **\"1\"**", "table_refs": [], "image_refs": ["images/2024_round1/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [{"language": "unknown", "code": "SELECT \n    COUNT(*) \nFROM \n    TABLE \nWHERE \n    EMPNO > 100 \nAND \n    SAL >= 3000 OR EMPNO = 200", "line_numbers": [1, 8], "file": "data/codes/2024_round1/Q018_code.txt"}], "primary_category": "SQL", "secondary_categories": ["프로그래밍", "데이터베이스"], "tags": ["unknown"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 C언어 코드의 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Nd sc 1"], "raw_text": "Nd sc 1"}, "explanation": "이 C언어 코드는 문자를 대문자, 소문자, 숫자로 구분하여 각각 다른 방식으로 변환하는 문제입니다.\n\n[코드 분석]\n\n```c char *p = \"It is 8\";\nfor(i=0; p[i]!='\\0'; i++) {\nif(isupper(p[i]))\nresult[i] = (p[i]-'A'+5) % 25 + 'A';\nelse if(islower(p[i]))\nresult[i] = (p[i]-'a'+10) % 26 + 'a';\nelse if(isdigit(p[i]))\nresult[i] = (p[i]-'0'+3) % 10 + '0';\nelse result[i] = p[i]; // 공백, 특수문자 등 그대로\n}\n```\n\n[실행 과정 (p = \"It is 8\")]\n\n1. [i=0, p[0]='I' (대문자)]\n- `('I'-'A'+5) % 25 + 'A' = (8+5) % 25 + 'A' = 13 + 'A' = 'N'`\n\n2. [i=1, p[1]='t' (소문자)]\n- `('t'-'a'+10) % 26 + 'a' = (19+10) % 26 + 'a' = 3 + 'a' = 'd'`\n\n3. [i=2, p[2]=' ' (공백)]\n- 그대로 복사: `result[2] = ' '`\n\n4. [i=3, p[3]='i' (소문자)]\n- `('i'-'a'+10) % 26 + 'a' = (8+10) % 26 + 'a' = 18 + 'a' = 's'`\n\n5. [i=4, p[4]='s' (소문자)]\n- `('s'-'a'+10) % 26 + 'a' = (18+10) % 26 + 'a' = 2 + 'a' = 'c'`\n\n6. [i=5, p[5]=' ' (공백)]\n- 그대로 복사: `result[5] = ' '`\n\n7. [i=6, p[6]='8' (숫자)]\n- `('8'-'0'+3) % 10 + '0' = (8+3) % 10 + '0' = 1 + '0' = '1'`\n\n[최종 출력] \"Nd sc 1\"\n\n[답] \"Nd sc 1\"", "table_refs": [], "image_refs": ["images/2024_round1/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [{"language": "c", "code": "#include<stdio.h>\n#include<ctype.h>\nint main(){\n    char*p = \"It is 8\";\n    char result[100];\n    int i;\n    for(i=0; p[i]!='\\0'; i++){\n        if(isupper(p[i]))\n            result[i] = (p[i]-'A'+5)% 25 + 'A';\n        else if(islower(p[i]))\n            result[i] = (p[i]-'a'+10)% 26 + 'a';\n        else if(isdigit(p[i]))\n            result[i] = (p[i]-'0'+3)% 10 + '0';\n        else if(!(isupper(p[i]) || islower(p[i]) || isdigit(p[i])))    \n            result[i] = p[i];\n    }\n    result[i] = '\\0';\n    printf(\"%s\\n\",result);\n    return 0;\n}", "line_numbers": [1, 20], "file": "data/codes/2024_round1/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 아래의 내용을 보고\n\n알맞는 용어를 작성하시오.\n구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다.\n연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다 관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다.\nkit라고도 불린다.", "choices": [], "answer": {"keys": ["Abstract Factory"], "raw_text": "Abstract Factory"}, "explanation": "Abstract Factory(추상 팩토리) 패턴은 관련된 객체들의 집합을 생성하는 디자인 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다\"\n- 클라이언트는 구체적인 클래스를 알 필요 없이 추상 인터페이스를 통해 객체를 생성합니다.\n- 의존성 역전 원칙(Dependency Inversion Principle)을 따릅니다.\n\n2. \"연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다\"\n- 관련된 객체들을 하나의 제품군(Product Family)으로 그룹화합니다.\n- 예: Windows 스타일의 버튼, 메뉴, 다이얼로그 vs Mac 스타일의 버튼, 메뉴, 다이얼로그\n- 팩토리 객체가 적절한 제품군을 선택하여 생성합니다.\n\n3. \"관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다\"\n- 여러 관련 객체를 함께 생성할 때 사용됩니다.\n- 일관성 있는 객체 집합을 보장합니다.\n\n4. **\"kit라고도 불린다\"**\n- Abstract Factory는 \"Kit\" 패턴이라고도 합니다.\n- 객체 키트를 제공하는 개념입니다.\n\n[Factory Method와의 차이]\n- Factory Method: 하나의 제품 객체 생성\n- **Abstract Factory: 관련된 여러 제품 객체들을 함께 생성[답] \"Abstract Factory\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.938824", "readability_improved": "2025-11-04T00:27:19.022449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["NNN"], "raw_text": "NNN"}, "explanation": "Java 배열 참조 비교 문제입니다.\n\n[이미지의 전체 코드]\n\n```java\nclass Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}\n```\n\n[실행 과정]\n\n1. [배열 생성]\n   - `int[] a = new int[]{1, 2, 3, 4};` → 새로운 배열 객체 생성 (주소: 0x1000 가정)\n   - `int[] b = new int[]{1, 2, 3, 4};` → 새로운 배열 객체 생성 (주소: 0x2000 가정)\n   - `int[] c = new int[]{1, 2, 3};` → 새로운 배열 객체 생성 (주소: 0x3000 가정)\n   - **중요**: 내용이 같아도 `new`를 사용하면 **서로 다른 객체** 생성!\n\n2. [`check(a, b)` 호출]\n   - `if (a == b)` 실행\n   - `a`의 주소: 0x1000\n   - `b`의 주소: 0x2000\n   - **0x1000 == 0x2000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n3. [`check(a, c)` 호출]\n   - `if (a == c)` 실행\n   - `a`의 주소: 0x1000\n   - `c`의 주소: 0x3000\n   - **0x1000 == 0x3000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n4. [`check(b, c)` 호출]\n   - `if (b == c)` 실행\n   - `b`의 주소: 0x2000\n   - `c`의 주소: 0x3000\n   - **0x2000 == 0x3000** → `false`\n   - `else` 블록 실행: **\"N\" 출력**\n\n[최종 출력] **\"NNN\"**\n\n[핵심 개념]\n\n1. [`==` 연산자의 동작]\n   - 기본 타입(int, char 등): **값** 비교\n   - 참조 타입(배열, 객체 등): **메모리 주소(참조)** 비교\n   - 배열은 참조 타입이므로 `==`는 주소를 비교합니다\n\n2. [배열 비교 방법]\n   ```java\n   // 참조(주소) 비교:\n   a == b  // 같은 객체인지 확인\n   \n   // 내용 비교:\n   Arrays.equals(a, b)  // 배열 내용이 같은지 확인\n   ```\n\n3. [예제]\n   ```java\n   int[] x = new int[]{1, 2, 3};\n   int[] y = new int[]{1, 2, 3};\n   int[] z = x;  // z는 x와 같은 객체를 참조\n   \n   x == y  // false (다른 객체)\n   x == z  // true (같은 객체)\n   Arrays.equals(x, y)  // true (내용 같음)\n   ```\n\n[메모리 구조]\n\n```\n변수      주소        배열 내용\n----      ----        --------\na    →  0x1000  →  [1, 2, 3, 4]\nb    →  0x2000  →  [1, 2, 3, 4]  (내용 같지만 다른 객체)\nc    →  0x3000  →  [1, 2, 3]\n```\n\n[왜 모두 \"N\"인가?]\n\n- 각 배열은 `new`로 생성되어 **서로 다른 메모리 주소**를 가집니다\n- `==` 연산자는 **주소**를 비교하므로 모두 `false`\n- 따라서 모든 `check()` 호출에서 \"N\"이 출력됩니다\n\n[답] **\"NNN\"**", "table_refs": [], "image_refs": ["images/2024_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.025449"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 문제에서 설명하는 용어를 작성하시오.\n데이터를 중복시켜 성능을 향상시키기 위한 기법으로 데이터를 중복 저장하거나 테이블을 합치는 등으로 성능을 향상시키지만 데이터 무결성이 저하될 수 있는 기법", "choices": [], "answer": {"keys": ["반정규화"], "raw_text": "반정규화"}, "explanation": "이 문제는 반정규화(Denormalization)에 대한 문제입니다.\n\n[반정규화(Denormalization)란?]\n\n[정의]\n- 정규화(Normalization)의 반대 개념으로, 데이터베이스 성능 향상을 위해 **의도적으로 중복을 허용**하는 기법\n- 정규화로 인해 분리된 테이블을 다시 합치거나, 중복 데이터를 저장하는 방식\n\n[반정규화의 특징]\n\n1. [성능 향상]\n   - JOIN 연산 감소로 **조회 속도 향상**\n   - 테이블 수 감소로 **쿼리 복잡도 감소**\n   - 자주 조회되는 데이터를 중복 저장하여 **I/O 감소**\n\n2. [데이터 무결성 저하]\n   - 중복 데이터로 인해 **일관성 유지 어려움**\n   - 수정 시 여러 곳을 동시에 업데이트해야 함\n   - 저장 공간 증가\n\n3. [반정규화 기법]\n   - **테이블 합치기**: 1:1 관계나 1:N 관계를 하나의 테이블로 통합\n   - **중복 컬럼 추가**: 자주 조회되는 컬럼을 다른 테이블에 중복 저장\n   - **파생 컬럼 추가**: 계산 결과를 미리 저장 (예: 합계, 평균)\n   - **테이블 분할**: 수평 분할(행 분할) 또는 수직 분할(컬럼 분할)\n\n[정규화 vs 반정규화]\n\n| 구분 | 정규화 | 반정규화 |\n|------|--------|----------|\n| 목적 | 데이터 무결성 | 성능 향상 |\n| 중복 | 제거 | 허용 |\n| 테이블 수 | 증가 | 감소 |\n| 조회 성능 | 저하 (JOIN 증가) | 향상 (JOIN 감소) |\n| 무결성 | 향상 | 저하 |\n\n[답] \"반정규화\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.025449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 SQL에 관한 문제이다.\n아래 SQL 구문의 빈칸을 작성하시오.\n사원 [사원번호(PK), 이름, 나이, 부서]\n부서 [사원번호(PK), 이름, 주소, 나이]\n신입 사원이 들어와서 사원 테이블에 추가 INSERT INTO 사원 (사원번호, 이름, 주소, 부서)   [\n\n①     ] (32431, '정실기', '서울', '영업');\n위에 신입사원을 검색하면서 부서 테이블에 추가 INSERT INTO 부서 (사원번호, 이름, 나이, 부서)\n[\n②\n] 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n전체 사원 테이블 조회 SELECT  *   [\n③\n]   사원;\n퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경 UPDATE 사원   [\n④\n]   부서  =  '퇴사'  WHERE 사원번호  =\n32431;", "choices": [], "answer": {"keys": ["① VALUES", "② SELECT", "③ FROM", "④ SET"], "raw_text": "① VALUES\n② SELECT\n③ FROM\n④ SET"}, "explanation": "이 문제는 **SQL 문법의 기본 키워드**를 묻는 문제입니다.\n\n[각 SQL 문의 빈칸 분석]\n\n1. [① INSERT 문 - VALUES]\n```sql\nINSERT INTO 사원 (사원번호, 이름, 주소, 부서) VALUES (32431, '정실기', '서울', '영업');\n```\n- `INSERT INTO` 문에서 **직접 값을 삽입**할 때는 `VALUES` 키워드를 사용합니다.\n- `VALUES` 다음에 괄호로 묶인 값들을 순서대로 입력합니다.\n\n2. [② INSERT ... SELECT 문 - SELECT]\n```sql\nINSERT INTO 부서 (사원번호, 이름, 나이, 부서)\nSELECT 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n```\n- 다른 테이블에서 **데이터를 조회하여 삽입**할 때는 `SELECT` 문을 사용합니다.\n- `INSERT INTO ... SELECT` 형태로 서브쿼리 결과를 삽입합니다.\n- `FROM` 절이 있으므로 `SELECT` 키워드가 필요합니다.\n\n3. [③ SELECT 문 - FROM]\n```sql\nSELECT * FROM 사원;\n```\n- `SELECT` 문에서 **조회할 테이블을 지정**할 때는 `FROM` 키워드를 사용합니다.\n- `SELECT *`는 모든 컬럼을 조회한다는 의미입니다.\n\n4. [④ UPDATE 문 - SET]\n```sql\nUPDATE 사원 SET 부서 = '퇴사' WHERE 사원번호 = 32431;\n```\n- `UPDATE` 문에서 **컬럼 값을 변경**할 때는 `SET` 키워드를 사용합니다.\n- `SET 컬럼명 = 값` 형태로 값을 설정합니다.\n\n[SQL 문법 요약]\n\n| 문법 | 키워드 | 용도 |\n|------|--------|------|\n| INSERT (직접 값) | VALUES | 직접 값을 삽입 |\n| INSERT (서브쿼리) | SELECT | 조회 결과를 삽입 |\n| SELECT | FROM | 조회할 테이블 지정 |\n| UPDATE | SET | 컬럼 값 변경 |\n\n[답] ① VALUES, ② SELECT, ③ FROM, ④ SET", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 릴레이션의 Cardinality와 Degree를 작성하시오.\nCardinality : (\n\n①  )\nDegree\n: (  ②  )", "choices": [], "answer": {"keys": ["① 5", "② 4"], "raw_text": "① 5\n② 4"}, "explanation": "이 문제는 릴레이션의 Cardinality와 Degree를 구하는 문제입니다.\n\n[Cardinality와 Degree란?]\n\n1. [Cardinality (카디널리티)]\n   - 릴레이션(테이블)에 포함된 튜플(행)의 개수\n   - 즉, **행의 개수**를 의미합니다.\n   - 예: 학생 테이블에 100명의 학생이 있으면 Cardinality = 100\n\n2. [Degree (차수)]\n   - **릴레이션에 포함된 속성(컬럼)의 개수**\n   - 즉, **컬럼의 개수**를 의미합니다.\n   - 예: 학생 테이블에 학번, 이름, 나이, 주소가 있으면 Degree = 4\n\n[문제 분석]\n\n문제에서 제공된 릴레이션 그림을 보면:\n- **행의 개수**: 5개 (튜플 5개)\n- **컬럼의 개수**: 4개 (속성 4개)\n\n[정리]\n- **Cardinality (①)**: 5 (행의 개수)\n- **Degree (②)**: 4 (컬럼의 개수)\n\n[참고]\n- Cardinality는 **동적**: 데이터 삽입/삭제에 따라 변경됨\n- Degree는 **정적**: 스키마가 변경되지 않는 한 고정됨\n\n[답] ① 5, ② 4", "table_refs": [], "image_refs": ["images/2024_round2/Q004_1.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 프로토콜에 대한 내용이다.\n아래 내용을 읽고 알맞는 답을 작성하시오.\n\n- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.\n\n- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.\n\n- AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다.", "choices": [], "answer": {"keys": ["IPSec"], "raw_text": "IPSec"}, "explanation": "IPSec(IP Security)는 네트워크 계층에서 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다\"\n- IPSec은 OSI 7계층 중 3계층(네트워크 계층)에서 동작합니다.\n- IP 패킷 자체를 암호화하여 데이터를 보호합니다.\n- 인증(Authentication)과 암호화(Encryption) 기능을 제공합니다.\n\n2. \"기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다\"\n- VPN(Virtual Private Network) 구축에 사용됩니다.\n- 인터넷을 통해 안전한 사설망을 구축할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등에 활용됩니다.\n\n3. \"AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다\"\n- AH(Authentication Header): 데이터 무결성과 인증을 제공 (암호화 없음)\n- ESP(Encapsulating Security Payload): 암호화와 인증을 모두 제공\n- 두 프로토콜을 개별 또는 조합하여 사용할 수 있습니다.\n\n[IPSec의 작동 방식]\n- 터널 모드(Tunnel Mode): 전체 IP 패킷을 암호화\n- 전송 모드(Transport Mode): 페이로드만 암호화\n\n[답] \"IPSec\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 Python에 대한 문제이다.\n아래 코드를 읽고 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["ab3ca3"], "raw_text": "ab3ca3"}, "explanation": "이 파이썬 코드는 문자열에서 패턴의 출현 횟수를 세는 문제입니다.\n\n[코드 분석]\n\n```python def fnCalculation(x, y):\nresult = 0 for i in range(len(x)):\ntemp = x[i:i+len(y)] # x에서 길이 len(y)만큼 슬라이싱 if temp == y:\nresult += 1 return result\n\na = \"abdcabcabca\"\np1 = \"ab\"\np2 = \"ca\"\nout = f\"ab{fnCalculation(a, p1)}ca{fnCalculation(a, p2)}\"\nprint(out)\n```\n\n[실행 과정]\n\n1. [`fnCalculation(a, \"ab\")` 계산]\n- a = \"abdcabcabca\"\n- i=0: \"ab\" == \"ab\" → result = 1\n- i=1: \"bd\" != \"ab\"\n- i=2: \"dc\" != \"ab\"\n- i=3: \"ca\" != \"ab\"\n- i=4: \"ab\" == \"ab\" → result = 2\n- i=5: \"bc\" != \"ab\"\n- i=6: \"ca\" != \"ab\"\n- i=7: \"ab\" == \"ab\" → result = 3\n- i=8: \"bc\" != \"ab\"\n- i=9: \"ca\" != \"ab\"\n- 결과: **3**\n\n2. [`fnCalculation(a, \"ca\")` 계산]\n- i=0: \"ab\" != \"ca\"\n- i=1: \"bd\" != \"ca\"\n- i=2: \"dc\" != \"ca\"\n- i=3: \"ca\" == \"ca\" → result = 1\n- i=4: \"ab\" != \"ca\"\n- i=5: \"bc\" != \"ca\"\n- i=6: \"ca\" == \"ca\" → result = 2\n- i=7: \"ab\" != \"ca\"\n- i=8: \"bc\" != \"ca\"\n- i=9: \"ca\" == \"ca\" → result = 3\n- 결과: **3**\n\n3. [최종 출력]\n```python out = f\"ab{3}ca{3}\" = \"ab3ca3\"\n```\n\n[답] \"ab3ca3\"", "table_refs": [], "image_refs": ["images/2024_round2/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [{"language": "python", "code": "def fnCalculation(x,y):\n    result = 0;\n    for i in range(len(x)):\n     temp = x[i:i+len(y)] \n     if temp == y:\n       result += 1;\n    return result\na = \"abdcabcabca\"\np1 = \"ab\";\np2 = \"ca\";\nout = f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\"\nprint(out)", "line_numbers": [1, 12], "file": "data/codes/2024_round2/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 설명하는 내용을 확인하여\n\n알맞는 알고리즘을 작성하시오.\n\n- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.\n\n- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.\n\n- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다.", "choices": [], "answer": {"keys": ["AES"], "raw_text": "AES"}, "explanation": "AES(Advanced Encryption Standard)는 고급 암호화 표준으로 대칭키 암호 알고리즘입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다\"\n- AES는 대칭키 암호 알고리즘입니다 (같은 키로 암호화/복호화).\n- 1997년 NIST가 DES의 취약점을 해결하기 위해 공모를 시작했습니다.\n- 2000년 Rijndael 알고리즘이 선택되어 AES로 지정되었습니다.\n- DES(56비트 키)의 취약점을 해결하기 위해 개발되었습니다.\n\n2. \"128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다\"\n- 키 크기: AES-128, AES-192, AES-256 (세 가지 버전)\n- 블록 크기: 항상 128비트 (고정)\n- 키가 길수록 보안성이 높아지지만 성능은 약간 저하됩니다.\n\n3. \"높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다\"\n- DES보다 훨씬 빠르고 안전합니다.\n- 하드웨어와 소프트웨어 모두에서 효율적으로 구현 가능합니다.\n- 현재 가장 널리 사용되는 대칭키 암호 알고리즘입니다.\n- SSL/TLS, Wi-Fi 보안(WPA2), 하드디스크 암호화 등에 사용됩니다.\n\n[AES의 작동 방식]\n- SubBytes: 바이트 치환\n- ShiftRows: 행 이동\n- MixColumns: 열 혼합\n- AddRoundKey: 라운드 키 적용\n\n[답] \"AES\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "패킷 교환 방식 중에 연결형과 비연결형에 해당하는 방식을 작성하시오.\n\n① 연결형 교환 방식\n② 비연결형 교환 방식", "choices": [], "answer": {"keys": ["① 가상회선", "② 데이터그램"], "raw_text": "① 가상회선\n② 데이터그램"}, "explanation": "패킷 교환 방식은 연결형과 비연결형으로 나뉩니다.\n\n① 연결형 교환 방식: 가상회선(Virtual Circuit)[특징]\n- 통신 시작 전에 경로를 설정합니다 (가상 회선 설정).\n- 모든 패킷이 같은 경로로 전송됩니다.\n- 패킷 순서가 보장됩니다.\n- 연결 설정과 해제 과정이 필요합니다.\n- 전화망과 유사한 방식입니다.\n\n[예시]\n- X.25\n- Frame Relay\n- ATM (Asynchronous Transfer Mode)\n\n② 비연결형 교환 방식: 데이터그램(Datagram)[특징]\n- 경로 설정 없이 각 패킷을 독립적으로 전송합니다.\n- 각 패킷은 목적지 주소를 포함하여 독립적으로 라우팅됩니다.\n- 패킷 순서가 보장되지 않을 수 있습니다.\n- 연결 설정/해제 과정이 없습니다.\n- 우편물과 유사한 방식입니다.\n\n[예시]\n- IP (Internet Protocol)\n- UDP (User Datagram Protocol)\n\n[비교]\n- **가상회선**: 연결 설정 필요, 순서 보장, 오버헤드 큼\n- **데이터그램**: 연결 설정 없음, 순서 보장 안 됨, 오버헤드 작음\n\n[답]\n- ① 가상회선 (Virtual Circuit)\n- ② 데이터그램 (Datagram)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "아래 내용을 확인하고 보기에서 알맞는 답을 고르시오.\n실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다.\n한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다.\n\n[보기]\n\nㄱ.  기능적(functional)\n\nㄴ.  우연적(Coincidental)\n\nㄷ.  통신적(Communication)\n\nㄹ.  절차적(Procedural)\n\nㅁ.  시간적(Temporal)\n\nㅂ.  순차적(sequential)\n\nㅅ.    논리적(Logical)", "choices": [], "answer": {"keys": ["ㅂ"], "raw_text": "ㅂ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도 중 순차적 응집도(Sequential Cohesion)를 구분하는 문제입니다.\n\n[문제에서 설명하는 특징]\n\n1. \"실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다\"\n- 순차적 응집도는 기능들이 시간적 순서대로 실행되는 경우입니다.\n\n2. \"한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다\"\n- 한 기능의 출력이 바로 다음 기능의 입력이 되는 파이프라인 형태입니다.\n- 예: 입력 처리 → 데이터 변환 → 출력 처리\n\n[응집도 종류 비교]\n\n- ㄱ. 기능적: 하나의 명확한 기능 수행 (가장 높음)\n- ㄴ. 우연적: 관련성 없는 요소들의 집합 (가장 낮음)\n- ㄷ. 통신적: 같은 데이터를 조작하는 요소들\n- ㄹ. 절차적: 순차적으로 실행되는 요소들\n- ㅁ. 시간적: 특정 시점에 실행되는 요소들\n- ㅂ. 순차적: 출력→입력 파이프라인 형태 ✓\n- ㅅ. 논리적: 논리적으로 비슷한 기능들\n\n[순차적 응집도의 예시]\n- 데이터 입력 → 검증 → 변환 → 저장\n- 이미지 로드 → 리사이즈 → 필터 적용 → 저장\n\n[답] \"ㅂ\" (순차적 응집도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.026449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래는 디자인 패턴에 관한 설명이다.\n아래 설명을 읽고 보기에서 알맞는 용어를 작성하시오.\n\n- 컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다.\n\n- 이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\n\n- 반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다.", "choices": [], "answer": {"keys": ["Iterator"], "raw_text": "Iterator"}, "explanation": "Iterator(반복자) 패턴은 컬렉션의 요소에 접근하는 방법을 표준화하는 디자인 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다\"\n- 클라이언트는 컬렉션의 내부 구현(배열, 리스트, 트리 등)을 알 필요가 없습니다.\n- 일관된 방식으로 요소에 접근할 수 있습니다.\n- 캡슐화 원칙을 따릅니다.\n\n2. \"이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\"\n- 컬렉션이 배열이든 리스트든 상관없이 같은 방식으로 접근 가능합니다.\n- 컬렉션의 구현이 바뀌어도 클라이언트 코드는 변경되지 않습니다.\n\n3. \"반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다\"\n- 반복 로직을 Iterator 객체에 위임합니다.\n- 클라이언트는 `hasNext()`, `next()` 같은 표준 메서드만 사용합니다.\n- 의존성 역전 원칙을 따릅니다.\n\n[Iterator 패턴의 구성요소]\n- **Iterator**: 반복 작업을 담당하는 인터페이스\n- **ConcreteIterator**: 구체적인 반복자 구현\n- **Aggregate**: 컬렉션 인터페이스\n- **ConcreteAggregate**: 구체적인 컬렉션 구현\n\n[사용 예시]\n- Java: `Iterator<String> it = list.iterator();`\n- C++: STL의 iterator\n- Python: `for item in collection:`\n\n[답] \"Iterator\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q010_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2024_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "아래 그림을 바탕으로 RIP을 구성하여 최단 경로 비용을 계산하여 흐름에 맞게 작성하시오.", "choices": [], "answer": {"keys": ["A → D → C → F"], "raw_text": "A → D → C → F"}, "explanation": "RIP(Routing Information Protocol)는 거리 벡터 라우팅 프로토콜입니다.\n\n[RIP의 작동 원리]\n- 각 라우터가 이웃 라우터와 라우팅 정보를 주기적으로 교환합니다.\n- 홉(Hop) 수를 거리로 사용합니다 (최대 15홉).\n- 최단 경로는 가장 적은 홉 수를 가진 경로입니다.\n\n[문제 해결 방법]\n\n1. [초기 상태]\n- 각 라우터는 직접 연결된 네트워크만 알고 있습니다.\n\n2. [라우팅 테이블 갱신]\n- 이웃 라우터로부터 받은 정보를 바탕으로 테이블을 업데이트합니다.\n- 홉 수가 1 증가합니다.\n\n3. [최단 경로 계산]\n- A에서 F로 가는 경로를 찾습니다.\n- 가능한 경로:\n- A → D → C → F\n- A → B → C → F\n- 기타 경로\n- 홉 수가 가장 적은 경로를 선택합니다.\n\n[답] \"A → D → C → F\"\"\"\n\n[참고] 문제의 네트워크 그림을 보면 A에서 F로 가는 최단 경로를 계산해야 합니다. RIP는 홉 수를 기준으로 최단 경로를 선택하므로, 그림상의 경로 비용을 확인하여 답을 결정합니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q011_1.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "아래의 표를 확인하여\n\nSRT 스케줄링의 평균 대기시간을 계산하여 작성하시오.", "choices": [], "answer": {"keys": ["6.5"], "raw_text": "6.5"}, "explanation": "SRT(Shortest Remaining Time) 스케줄링은 남은 실행 시간이 가장 짧은 프로세스를 우선 실행하는 선점형 스케줄링입니다.\n\n[SRT 스케줄링의 특징]\n- SJF(Shortest Job First)의 선점형 버전입니다.\n- 새 프로세스가 도착하면 남은 실행 시간을 비교하여 선점할 수 있습니다.\n- 평균 대기 시간이 짧습니다.\n\n[문제 해결 방법]\n\n주어진 표에서:\n- 프로세스들의 도착 시간과 실행 시간을 확인합니다.\n- Gantt 차트를 그려서 각 프로세스의 실행 순서를 결정합니다.\n- 각 프로세스의 대기 시간을 계산합니다.\n\n[대기 시간 계산]\n- 프로세스 i의 대기 시간 = 시작 시간 - 도착 시간\n- 평균 대기 시간 = (모든 프로세스의 대기 시간 합) / 프로세스 개수\n\n[예시 계산 (표 데이터 기준)]\n표의 실제 데이터를 바탕으로 Gantt 차트를 그려 계산하면:\n- 평균 대기 시간 = **6.5[답] \"6.5\"\"\"\n\n[참고] 문제의 표에 따라 각 프로세스의 도착 시간과 실행 시간이 다르므로, 정확한 답은 표의 데이터를 바탕으로 계산해야 합니다.", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q012_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2024_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["21"], "raw_text": "21"}, "explanation": "이 C언어 코드는 포인터 배열과 포인터 연산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint* parr[2] = {arr[1], arr[2]};\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n```\n\n[메모리 레이아웃]\n\n```\narr[0] → [1, 2, 3]\narr[1] → [4, 5, 6]\narr[2] → [7, 8, 9]\n```\n\n[실행 과정]\n\n1. [`parr` 배열 초기화]\n```c int* parr[2] = {arr[1], arr[2]};\n```\n- `parr[0]` = `arr[1]` (두 번째 행을 가리킴)\n- `parr[1]` = `arr[2]` (세 번째 행을 가리킴)\n\n2. [표현식 계산]\n```c parr[1][1] + *(parr[1]+2) + parr\n```\n\n- [`parr[1][1]`]\n- `parr[1]` = `arr[2]` → `[7, 8, 9]`\n- `parr[1][1]` = `arr[2][1]` = 8**\n\n- **`*(parr[1]+2)`:**\n- `parr[1]` = `arr[2]` (시작 주소)\n- `parr[1] + 2` = `arr[2] + 2` (두 칸 뒤)\n- `*(parr[1]+2)` = `arr[2][2]` = **9**\n\n- **`[parr`]\n- `parr` = `parr[0]`의 주소\n- `*parr` = `parr[0]` = `arr[1]` (주소)\n- `parr` = `arr[1][0]` = 4**\n\n3. [최종 계산]\n- `8 + 9 + 4 = 21`\n\n[답] 21", "table_refs": [], "image_refs": ["images/2024_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int* parr[2] = {arr[1], arr[2]};\n    printf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n    return 0;\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 Java 언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["25, 20"], "raw_text": "25, 20"}, "explanation": "이미지의 Java 코드를 분석하여 홀수 합과 짝수 합을 계산하는 문제입니다.\n\n[코드 분석]\n\n```java\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nODDNumber OE = new ODDNumber();\nSystem.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\n\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }\n        return result;\n    }\n}\n```\n\n[실행 과정]\n\n1. [`OE.sum(a, true)` 호출 (홀수 합)]\n   - `odd = true`이므로 조건: `(true && a[i] % 2 != 0)` → **홀수만 선택**\n   - 배열: `{1, 2, 3, 4, 5, 6, 7, 8, 9}`\n   - i=0: a[0]=1 (홀수) → result += 1 (result = 1)\n   - i=1: a[1]=2 (짝수) → 건너뜀\n   - i=2: a[2]=3 (홀수) → result += 3 (result = 4)\n   - i=3: a[3]=4 (짝수) → 건너뜀\n   - i=4: a[4]=5 (홀수) → result += 5 (result = 9)\n   - i=5: a[5]=6 (짝수) → 건너뜀\n   - i=6: a[6]=7 (홀수) → result += 7 (result = 16)\n   - i=7: a[7]=8 (짝수) → 건너뜀\n   - i=8: a[8]=9 (홀수) → result += 9 (result = 25)\n   - **결과: 25**\n\n2. [`OE.sum(a, false)` 호출 (짝수 합)]\n   - `odd = false`이므로 조건: `(!false && a[i] % 2 == 0)` → **짝수만 선택**\n   - i=0: a[0]=1 (홀수) → 건너뜀\n   - i=1: a[1]=2 (짝수) → result += 2 (result = 2)\n   - i=2: a[2]=3 (홀수) → 건너뜀\n   - i=3: a[3]=4 (짝수) → result += 4 (result = 6)\n   - i=4: a[4]=5 (홀수) → 건너뜀\n   - i=5: a[5]=6 (짝수) → result += 6 (result = 12)\n   - i=6: a[6]=7 (홀수) → 건너뜀\n   - i=7: a[7]=8 (짝수) → result += 8 (result = 20)\n   - i=8: a[8]=9 (홀수) → 건너뜀\n   - **결과: 20**\n\n3. [최종 출력]\n```java\nSystem.out.print(25 + \", \" + 20);\n// 출력: \"25, 20\"\n```\n\n[핵심 개념]\n- `odd && a[i] % 2 != 0`: 홀수 필터링\n- `!odd && a[i] % 2 == 0`: 짝수 필터링\n- `a[i] % 2 != 0`: 홀수 판별 (나머지가 1)\n- `a[i] % 2 == 0`: 짝수 판별 (나머지가 0)\n\n[답] \"25, 20\"", "table_refs": [], "image_refs": ["images/2024_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        ODDNumber OE = new ODDNumber();\n        System.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n    }\n}\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }        \n        return result;\n    }    \n}", "line_numbers": [1, 20], "file": "data/codes/2024_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 C언어 코드는 문자열 복사 함수와 인덱스 합 계산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c void sumFn(char* d, const char* s) {\nwhile (*s) {\n*d = *s;\nd++;\ns++;\n}\n*d = '\\0';\n}\n```\n\n[실행 과정]\n\n1. [초기값]\n```c const char* str1 = \"first\"; // 길이: 5 char str2[50] = \"teststring\"; // 길이: 10\n```\n\n2. [`sumFn(str2, str1)` 호출]\n- `str1 = \"first\"`를 `str2`에 복사\n- 복사 후: `str2 = \"first\\0...\"` (길이: 5)\n\n3. [인덱스 합 계산]\n```c for (int i = 0; str2[i] != '\\0'; i++) {\nresult += i;\n}\n```\n- i=0: result += 0 (result = 0)\n- i=1: result += 1 (result = 1)\n- i=2: result += 2 (result = 3)\n- i=3: result += 3 (result = 6)\n- i=4: result += 4 (result = 10)\n- i=5: `str2[5] == '\\0'` → 루프 종료\n\n4. [최종 출력]\n- **출력: 10[답] 10", "table_refs": [], "image_refs": ["images/2024_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid sumFn(char* d, const char* s) {\n    while (*s) {\n        *d = *s;\n        d++;\n        s++;\n    }\n    *d = '\\0'; \n}\nint main() {\n   const char* str1 = \"first\";\n    char str2[50] = \"teststring\";  \n    int result=0;\n    sumFn(str2, str1);\n    for (int i = 0; str2[i] != '\\0'; i++) {\n        result += i;\n    }\n    printf(\"%d\", result);\n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "아래는 소프트웨어 설계에 대한 내용이다.\n내용을 읽고 괄호 안에 알맞는 답을 작성하시오.\n\n- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다.\n\n- 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.\n(              ) Coupling", "choices": [], "answer": {"keys": ["제어"], "raw_text": "제어"}, "explanation": "제어 결합도(Control Coupling)는 한 모듈이 다른 모듈의 제어 흐름을 조작하는 결합도입니다.\n\n[문제에서 설명하는 특징]\n\n1. \"어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다\"\n- 한 모듈이 다른 모듈의 실행 흐름을 제어하는 경우입니다.\n- 플래그(flag)나 제어 변수를 전달하여 분기를 결정합니다.\n- 예: 함수에 `mode` 파라미터를 전달하여 다른 동작을 수행\n\n2. \"한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다\"\n- 모듈 A가 모듈 B의 내부 로직을 알고 있습니다.\n- 모듈 A가 모듈 B에게 \"어떻게 처리할지\" 지시합니다.\n\n[결합도 종류 비교]\n- 내용 결합도: 가장 강함 (내부 직접 접근)\n- 공통 결합도: 전역 변수 공유\n- 외부 결합도: 외부 인터페이스 공유\n- **제어 결합도: 제어 흐름 조작** ✓\n- 스탬프 결합도: 구조체 전달\n- 자료 결합도: 값만 전달 (가장 약함, 이상적)\n\n[예시]\n```c void process(int mode) {\nif (mode == 1) {\n// 처리 A\n} else {\n// 처리 B\n}\n}\n```\n\n[답] \"제어\" (Control Coupling)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["dcba"], "raw_text": "dcba"}, "explanation": "이미지의 Java 코드는 재귀 함수를 사용하여 문자열에서 뒤에서부터 중복을 제거하는 알고리즘입니다.\n\n[코드 분석]\n\n```java\nString str = \"abacabcd\";\nboolean[] seen = new boolean[256];\nSystem.out.print(calculFn(str, str.length()-1, seen));\n\npublic static String calculFn(String str, int index, boolean[] seen) {\n    if(index < 0) return \"\";\n    char c = str.charAt(index);\n    String result = calculFn(str, index-1, seen);\n    if(!seen[c]) {\n        seen[c] = true;\n        return c + result;\n    }\n    return result;\n}\n```\n\n[알고리즘 이해]\n\n1. **재귀 호출 순서**: 문자열을 **뒤에서 앞으로** 처리합니다 (index가 감소).\n2. **중복 제거**: `seen[]` 배열로 이미 본 문자를 체크합니다.\n3. **결과 구성**: 처음 본 문자를 **앞에 추가**합니다.\n\n[실행 과정 (재귀 스택)]\n\n```\ncalculFn(\"abacabcd\", 7, seen) // index=7, c='d'\n  → seen['d']=false → seen['d']=true → \"d\" + result\n  ↓\ncalculFn(\"abacabcd\", 6, seen) // index=6, c='c'\n  → seen['c']=false → seen['c']=true → \"c\" + result\n  ↓\ncalculFn(\"abacabcd\", 5, seen) // index=5, c='b'\n  → seen['b']=false → seen['b']=true → \"b\" + result\n  ↓\ncalculFn(\"abacabcd\", 4, seen) // index=4, c='a'\n  → seen['a']=false → seen['a']=true → \"a\" + result\n  ↓\ncalculFn(\"abacabcd\", 3, seen) // index=3, c='c'\n  → seen['c']=true (이미 본 문자) → result 반환 (\"a\" 추가 안 함)\n  ↓\ncalculFn(\"abacabcd\", 2, seen) // index=2, c='a'\n  → seen['a']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", 1, seen) // index=1, c='b'\n  → seen['b']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", 0, seen) // index=0, c='a'\n  → seen['a']=true (이미 본 문자) → result 반환\n  ↓\ncalculFn(\"abacabcd\", -1, seen) // 종료 조건\n  → return \"\"\n```\n\n[결과 구성 (재귀 반환 순서)]\n\n1. `calculFn(-1)` → `\"\"` 반환\n2. `calculFn(0)` → `\"\"` 반환 (a는 이미 봄)\n3. `calculFn(1)` → `\"\"` 반환 (b는 이미 봄)\n4. `calculFn(2)` → `\"\"` 반환 (a는 이미 봄)\n5. `calculFn(3)` → `\"\"` 반환 (c는 이미 봄)\n6. `calculFn(4)` → `\"a\" + \"\"` = `\"a\"` 반환 (처음 본 a)\n7. `calculFn(5)` → `\"b\" + \"a\"` = `\"ba\"` 반환 (처음 본 b)\n8. `calculFn(6)` → `\"c\" + \"ba\"` = `\"cba\"` 반환 (처음 본 c)\n9. `calculFn(7)` → `\"d\" + \"cba\"` = `\"dcba\"` 반환 (처음 본 d)\n\n[핵심 포인트]\n- 문자열을 **뒤에서 앞으로** 처리하므로, 결과는 **역순**으로 구성됩니다.\n- **처음 본 문자만 추가**하므로 중복이 제거됩니다.\n- `seen[c]`는 ASCII 코드를 인덱스로 사용합니다 (char → int 자동 변환).\n\n[답] \"dcba\"", "table_refs": [], "image_refs": ["images/2024_round2/Q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"abacabcd\";\n        boolean[] seen = new boolean[256];\n        System.out.print(calculFn(str, str.length()-1, seen));\n    }\n    public static String calculFn(String str, int index, boolean[] seen) {\n        if(index < 0) return \"\";\n        char c = str.charAt(index);\n        String result = calculFn(str, index-1, seen);\n        if(!seen[c]) {\n            seen[c] = true;\n            return c + result;\n        }\n        return result;\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["-13"], "raw_text": "-13"}, "explanation": "이 C언어 코드는 함수 파라미터의 값 전달과 switch 문의 fall-through를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c void swap(int a, int b) {\nint = a;\na = b;\nb = t;\n}\n```\n\n[실행 과정]\n\n1. [초기값]\n```c int a = 11;\nint b = 19;\n```\n\n2. [`swap(a, b)` 호출]\n- C언어는 값에 의한 전달(Call by Value)을 사용합니다.\n- `swap()` 함수 내부에서 `a`와 `b`의 값을 변경해도 원본 변수에는 영향이 없습니다.\n- 함수 호출 후에도 `a = 11`, `b = 19` (변경 없음)\n\n3. [switch 문 실행]\n```c switch(a) { // a = 11 case 1:\nb += 1;\ncase 11: // 매칭! (하지만 break 없음)\nb += 2; // 실행 default:\nb += 3; // 실행 (fall-through)\nbreak;\n}\n```\n- `a = 11`이므로 `case 11:`로 이동합니다.\n- break가 없으므로 아래로 fall-through합니다.\n- `b += 2` → `b = 19 + 2 = 21`\n- `default:` 실행 → `b += 3` → `b = 21 + 3 = 24`\n\n4. [최종 계산]\n```c printf(\"%d\", a - b); // 11 - 24 = -13\n```\n\n[답] \"-13\"", "table_refs": [], "image_refs": ["images/2024_round2/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.027448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int a = 11;\n    int b = 19;\n    swap(a, b);\n    switch(a) {\n        case 1:\n            b += 1;\n        case 11:\n            b += 2;\n        default:\n            b += 3;\n        break;\n    }\n    printf(\"%d\", a-b);\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 C언어의 구조체에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 구조체 포인터와 연결 리스트를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c struct node {\nint n1;\nstruct node *n2;\n};\n\nstruct node a = {10, NULL};\nstruct node b = {20, NULL};\nstruct node c = {30, NULL};\nstruct node *head = &a;\na.n2 = &b;\nb.n2 = &c;\nprintf(\"%d\\n\", head->n2->n1);\n```\n\n[메모리 구조]\n\n```\nhead → a {n1=10, n2=&b}\n↓\nb {n1=20, n2=&c}\n↓\nc {n1=30, n2=NULL}\n```\n\n[표현식 계산]\n\n```c head->n2->n1\n```\n\n1. **`head`**: `&a` (a의 주소)\n\n2. **`head->n2`**: `a.n2` = `&b` (b의 주소)\n\n3. **`head->n2->n1`**: `b.n1` = **20[답] 20", "table_refs": [], "image_refs": ["images/2024_round2/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.028447"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct node {\n    int n1;\n    struct node *n2;\n};\nint main() {\n    struct node a = {10, NULL};\n    struct node b = {20, NULL};\n    struct node c = {30, NULL};\n    struct node *head = &a;\n    a.n2 = &b;\n    b.n2 = &c;\n    printf(\"%d\\n\", head->n2->n1);\n    return 0;\n}", "line_numbers": [1, 15], "file": "data/codes/2024_round2/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["S"], "raw_text": "S"}, "explanation": "이미지의 Java 코드는 String의 split() 메서드를 사용하여 문자열을 분할하는 문제입니다.\n\n[코드 분석]\n\n```java\nString str = \"ITISTESTSTRING\";\nString[] result = str.split(\"T\");\nSystem.out.print(result[3]);\n```\n\n[String.split() 메서드]\n\n- `split(\"구분자\")`: 문자열을 **구분자를 기준으로 분할**하여 배열로 반환합니다.\n- 구분자는 **제거**되고, 나머지 부분들이 배열 요소가 됩니다.\n\n[실행 과정]\n\n1. [`str.split(\"T\")` 실행]\n   - 원본 문자열: `\"ITISTESTSTRING\"`\n   - 구분자: `\"T\"`\n   - 분할 위치 확인:\n     ```\n     I T I S T E S T S T R I N G\n       ↑   ↑   ↑   ↑   ↑\n     ```\n   - `\"T\"`로 분할:\n     - `\"I\"` (첫 번째)\n     - `\"IS\"` (두 번째)\n     - `\"ES\"` (세 번째)\n     - `\"S\"` (네 번째)\n     - `\"RING\"` (다섯 번째)\n\n2. [배열 생성]\n```java\nresult = [\"I\", \"IS\", \"ES\", \"S\", \"RING\"]\n// 인덱스:  0     1      2     3     4\n```\n\n3. [`result[3]` 출력]\n   - 인덱스 3의 값: `\"S\"`\n\n[주의사항]\n- `split()`은 구분자를 **제거**하므로, 결과 배열에는 구분자가 포함되지 않습니다.\n- 구분자 앞뒤의 문자열이 각각 배열 요소가 됩니다.\n- 빈 문자열도 배열 요소로 포함될 수 있습니다.\n\n[답] \"S\"", "table_refs": [], "image_refs": ["images/2024_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:27:19.028447"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"ITISTESTSTRING\";\n        String[] result = str.split(\"T\");\n        System.out.print(result[3]);\n    }\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["OOAAA"], "raw_text": "OOAAA"}, "explanation": "이미지의 Java 코드는 String의 equals() 메서드를 사용하여 내용을 비교하는 문제입니다.\n\n[코드 분석]\n\n```java\nstatic String[] s = new String[3];\ns[0] = \"A\";\ns[1] = \"A\";\ns[2] = new String(\"A\");\nfunc(s, 3);\n\nstatic void func(String[] s, int size) {\n    for(int i=1; i<size; i++) {\n        if(s[i-1].equals(s[i])) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"N\");\n        }\n    }\n    for (String m : s) {\n        System.out.print(m);\n    }\n}\n```\n\n[핵심 개념]\n\n1. [String 리터럴 vs `new String()`]\n   - `\"A\"` (리터럴): String 상수 풀에 저장, 같은 리터럴은 같은 참조\n   - `new String(\"A\")`: 새로운 객체 생성, 다른 참조\n\n2. [`equals()` 메서드]\n   - **내용 비교**: 문자열의 실제 값(내용)을 비교합니다.\n   - `==` 연산자와 달리 참조가 아닌 **내용**을 비교합니다.\n\n[실행 과정]\n\n1. [초기화]\n   - `s[0] = \"A\"` (리터럴)\n   - `s[1] = \"A\"` (리터럴, s[0]과 같은 참조 가능)\n   - `s[2] = new String(\"A\")` (새 객체, 다른 참조이지만 내용은 \"A\")\n\n2. [첫 번째 반복문 (`for(int i=1; i<3; i++)`)]\n   - [i=1] `s[0].equals(s[1])` → `\"A\".equals(\"A\")` → `True` → **\"O\" 출력**\n   - [i=2] `s[1].equals(s[2])` → `\"A\".equals(new String(\"A\"))` → `True` (내용이 같음) → **\"O\" 출력**\n\n3. [두 번째 반복문 (`for (String m : s)`)]\n   - `s[0]` = `\"A\"` → **\"A\" 출력**\n   - `s[1]` = `\"A\"` → **\"A\" 출력**\n   - `s[2]` = `new String(\"A\")` → **\"A\" 출력**\n\n[참고]\n- `==`는 참조 비교이므로 `s[1] == s[2]`는 `false`입니다.\n- `equals()`는 내용 비교이므로 `s[1].equals(s[2])`는 `true`입니다.\n\n[답] \"OOAAA\"", "table_refs": [], "image_refs": ["images/2024_round3/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.030449"}, "code_blocks": [{"language": "java", "code": "public class Main{\n  static String[] s = new String[3];\n  static void func(String[]s, int size){\n    for(int i=1; i<size; i++){\n      if(s[i-1].equals(s[i])){\n        System.out.print(\"O\");\n      }else{\n        System.out.print(\"N\");\n      }\n    }\n      for (String m : s){\n        System.out.print(m);\n      }\n    }\n  public static void main(String[] args){\n    s[0] = \"A\";\n    s[1] = \"A\";\n    s[2] = new String(\"A\");\n    func(s, 3);\n  }\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round3/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["3"], "raw_text": "3"}, "explanation": "이 파이썬 코드는 리스트를 역순으로 뒤집고 짝수 인덱스와 홀수 인덱스의 합 차이를 계산하는 문제입니다.\n\n[코드 분석]\n\n```python def func(lst):\nfor i in range(len(lst) // 2):\nlst[i], lst[-i-1] = lst[-i-1], lst[i] # 리스트 역순\n\nlst = [1, 2, 3, 4, 5, 6]\nfunc(lst) # 역순으로 뒤집기 print(sum(lst[::2]) - sum(lst[1::2])) # 짝수 인덱스 합 - 홀수 인덱스 합\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `lst = [1, 2, 3, 4, 5, 6]`\n\n2. [`func(lst)` 실행 (역순으로 뒤집기)]\n- `len(lst) // 2 = 6 // 2 = 3`\n- i=0: lst[0] ↔ lst[-1] → [6, 2, 3, 4, 5, 1]\n- i=1: lst[1] ↔ lst[-2] → [6, 5, 3, 4, 2, 1]\n- i=2: lst[2] ↔ lst[-3] → [6, 5, 4, 3, 2, 1]\n- 결과: `lst = [6, 5, 4, 3, 2, 1]`\n\n3. [합 차이 계산]\n```python sum(lst[::2]) # 짝수 인덱스 (0, 2, 4): 6 + 4 + 2 = 12 sum(lst[1::2]) # 홀수 인덱스 (1, 3, 5): 5 + 3 + 1 = 9\n```\n- `12 - 9 = 3`\n\n[답] 3", "table_refs": [], "image_refs": ["images/2024_round3/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.030449"}, "code_blocks": [{"language": "python", "code": "def func(lst):\n  for i in range(len(lst) //2):\n    lst[i], lst[-i-1] = lst[-i-1], lst[i]\nlst = [1,2,3,4,5,6] \nfunc(lst)\nprint(sum(lst[::2]) - sum(lst[1::2]))", "line_numbers": [1, 6], "file": "data/codes/2024_round3/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "아래의 employee테이블과 project테이블을 참고하여\n\n보기의 SQL명령어에 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 문제는 **중첩 서브쿼리와 JOIN**을 이해하는 SQL 문제입니다.\n\n[SQL 쿼리 분석]\n\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p \n    WHERE p.project_id IN (\n        SELECT project_id FROM employee \n        GROUP BY project_id \n        HAVING count(*) < 2\n    )\n);\n```\n\n[실행 순서 (안쪽부터 바깥쪽으로)]\n\n1. [가장 안쪽 서브쿼리]\n```sql\nSELECT project_id FROM employee \nGROUP BY project_id \nHAVING count(*) < 2\n```\n- **의미**: 직원이 1명 이하인 프로젝트 ID를 찾습니다.\n- 각 프로젝트별 직원 수를 세고, 직원이 1명 이하인 프로젝트만 선택합니다.\n- 예: 프로젝트 ID가 `P001`에 직원이 1명만 있으면 `P001` 반환\n\n2. [중간 서브쿼리]\n```sql\nSELECT name FROM project p \nWHERE p.project_id IN (위의 결과)\n```\n- **의미**: 위에서 찾은 프로젝트 ID에 해당하는 **프로젝트 이름**을 찾습니다.\n- 직원이 1명 이하인 프로젝트의 이름을 반환합니다.\n\n3. [외부 쿼리]\n```sql\nSELECT count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (위의 결과)\n```\n- **의미**: 직원과 프로젝트를 조인한 후, 직원이 1명 이하인 프로젝트에 **속한 직원 수**를 세습니다.\n- `JOIN`으로 employee와 project를 연결하고, `WHERE` 절로 프로젝트 이름을 필터링합니다.\n- `count(*)`로 해당 조건을 만족하는 직원 레코드 수를 세어 반환합니다.\n\n[요약]\n- **직원이 1명 이하인 프로젝트**를 찾고\n- 그 프로젝트에 **속한 직원의 수**를 세는 쿼리입니다.\n- 직원이 1명 이하인 프로젝트에 속한 직원이 1명이므로 결과는 **1**입니다.\n\n[답] 1", "table_refs": [], "image_refs": ["images/2024_round3/Q003_1.png", "images/2024_round3/Q003_2.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.030449"}, "code_blocks": [{"language": "sql", "code": "SELECT \n    count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p WHERE p.project_id IN (\n        SELECT project_id FROM employee GROUP BY project_id HAVING count(*) < 2\n    )\n);", "line_numbers": [1, 8], "file": "data/codes/2024_round3/Q003_code.txt"}], "primary_category": "데이터베이스", "secondary_categories": ["SQL"], "tags": ["sql"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 운영체제 페이지 순서를 참고하여\n\n할당된 프레임의 수가 3개일 때  LRU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서\n: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1", "choices": [], "answer": {"keys": ["12"], "raw_text": "12"}, "explanation": "LRU(Least Recently Used) 스케줄링은 가장 오래전에 사용된 페이지를 교체하는 알고리즘입니다.\n\n[주어진 정보]\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1\n\n[LRU 실행 과정]초기 상태: [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 7 | [7, 빈, 빈] | ✓ |\n| 0 | [7, 0, 빈] | ✓ |\n| 1 | [7, 0, 1] | ✓ |\n| 2 | [0, 1, 2] | ✓ (7 제거, 가장 오래됨) |\n| 0 | [0, 1, 2] | (히트) |\n| 3 | [1, 2, 3] | ✓ (0 제거) |\n| 0 | [2, 3, 0] | ✓ (1 제거) |\n| 4 | [3, 0, 4] | ✓ (2 제거) |\n| 2 | [0, 4, 2] | ✓ (3 제거) |\n| 3 | [4, 2, 3] | ✓ (0 제거) |\n| 0 | [2, 3, 0] | ✓ (4 제거) |\n| 3 | [2, 3, 0] | (히트) |\n| 2 | [2, 3, 0] | (히트) |\n| 1 | [3, 0, 1] | ✓ (2 제거) |\n| 2 | [0, 1, 2] | ✓ (3 제거) |\n| 0 | [0, 1, 2] | (히트) |\n| 1 | [0, 1, 2] | (히트) |\n| 7 | [1, 2, 7] | ✓ (0 제거) |\n| 0 | [2, 7, 0] | ✓ (1 제거) |\n| 1 | [7, 0, 1] | ✓ (2 제거) |\n\n페이지 부재 횟수: 12[답] 12", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 네트워크 취약점에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다.\n\n- 여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply 를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다.\n\n- 공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다.", "choices": [], "answer": {"keys": ["스머프"], "raw_text": "스머프"}, "explanation": "스머프(Smurf) 공격은 IP와 ICMP의 특성을 악용한 DDoS 공격입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다\"\n- 스머프 공격은 IP 브로드캐스트 주소를 악용합니다.\n- 공격자는 피해자의 IP 주소를 위조(spoofing)하여 브로드캐스트 주소로 ICMP Echo Request를 전송합니다.\n- 브로드캐스트 네트워크의 모든 호스트가 응답하여 트래픽이 증폭됩니다.\n\n2. \"여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다\"\n- 공격자는 피해자의 IP를 소스로 위조한 ICMP Echo Request를 브로드캐스트합니다.\n- 네트워크의 모든 호스트가 피해자에게 ICMP Echo Reply를 전송합니다.\n- 결과적으로 피해자는 엄청난 양의 응답 패킷을 받게 됩니다.\n\n3. \"공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다\"\n- 수신 대역폭이 포화되어 정상적인 통신이 불가능해집니다.\n- DoS(Denial of Service) 상태에 빠집니다.\n\n[스머프 공격의 방어 방법]\n- 라우터에서 브로드캐스트 주소로 향하는 패킷을 차단\n- ICMP 패킷 필터링\n- IP 스푸핑 방지\n\n[답] \"스머프\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 GoF 디자인 패턴과 관련된 문제이다.\n괄호 안에 알맞는 용어를 작성하시오.\n(        ) 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.\n(        ) 패턴은 객체들 간의 통신 방법을 정의하고 알고리즘을 캡슐화하여 객체 간의 결합도를 낮춘다.\n(        ) 패턴은 Chain of Responsibility나 Command 또는 Observer 패턴이 있다.", "choices": [], "answer": {"keys": ["행위"], "raw_text": "행위"}, "explanation": "행위(Behavioral) 패턴은 객체 간의 상호작용과 책임 분배를 정의하는 GoF 디자인 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다\"\n- 행위 패턴은 객체 간의 통신 방식을 정의합니다.\n- 각 객체의 역할과 책임을 명확히 분리합니다.\n- 예: Observer 패턴에서 주제와 관찰자의 상호작용\n\n2. \"객체들 간의 통신 방법을 정의하고 알고리즘을 캡슐화하여 객체 간의 결합도를 낮춘다\"\n- 통신 방법을 표준화하여 결합도를 낮춥니다.\n- 알고리즘을 객체로 캡슐화합니다.\n- 예: Strategy 패턴에서 알고리즘을 독립적인 객체로 분리\n\n3. \"Chain of Responsibility나 Command 또는 Observer 패턴이 있다\"\n- Chain of Responsibility: 요청을 객체 체인으로 전달\n- Command: 요청을 객체로 캡슐화\n- Observer: 객체 간 일대다 의존성 정의\n\n[GoF 패턴 분류]\n- **생성 패턴(Creational)**: 객체 생성 담당 (Singleton, Factory 등)\n- **구조 패턴(Structural)**: 클래스/객체 조합 (Adapter, Decorator 등)\n- **행위 패턴(Behavioral)**: 객체 간 상호작용 (Observer, Command 등) ✓\n\n[답] \"행위\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 static 변수의 특성을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c int func() {\nstatic int x = 0; // static 변수 (초기화는 한 번만!)\nx += 2;\nreturn x;\n}\n\nint main() {\nint x = 1; // 지역 변수 (func의 x와 별개)\nint sum = 0;\nfor(int i=0; i<4; i++) {\nx++; // 지역 변수 x 증가 sum += func(); // func() 호출\n}\nprintf(\"%d\", sum);\n}\n```\n\n[실행 과정]\n\n1. [초기값]\n- `main`의 지역 변수: `x = 1`\n- `func`의 static 변수: `x = 0` (초기화는 프로그램 시작 시 한 번만)\n\n2. [반복문 실행]i=0:\n- `x++` → `x = 2` (main의 지역 변수)\n- `func()` 호출:\n- static `x = 0` (유지됨)\n- `x += 2` → `x = 2`\n- 반환: 2\n- `sum = 0 + 2 = 2`\n\n[i=1]\n- `x++` → `x = 3`\n- `func()` 호출:\n- static `x = 2` (이전 값 유지!)\n- `x += 2` → `x = 4`\n- 반환: 4\n- `sum = 2 + 4 = 6`\n\n[i=2]\n- `x++` → `x = 4`\n- `func()` 호출:\n- static `x = 4`\n- `x += 2` → `x = 6`\n- 반환: 6\n- `sum = 6 + 6 = 12`\n\n[i=3]\n- `x++` → `x = 5`\n- `func()` 호출:\n- static `x = 6`\n- `x += 2` → `x = 8`\n- 반환: 8\n- `sum = 12 + 8 = 20`\n\n3. [최종 출력]\n- 출력: 20[핵심 포인트]\n- static 변수는 함수가 종료되어도 메모리에 유지됩니다.\n- static 변수의 초기화는 프로그램 시작 시 한 번만 실행됩니다.\n- 함수를 여러 번 호출해도 static 변수는 이전 값을 유지합니다.\n\n[답] 20", "table_refs": [], "image_refs": ["images/2024_round3/Q007.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint func(){\n static int x =0; \n  x+=2; \n  return x;\n}\nint main(){\n  int x = 1; \n  int sum=0; \n  for(int i=0;i<4;i++) {\n    x++; \n    sum+=func();\n  } \n  printf(\"%d\", sum);\n  return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2024_round3/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음은 무결성제약조건에 대한 문제이다.\n아래 표에서 어떠한 (       ) 무결성을 위반하였는지 작성하시오.", "choices": [], "answer": {"keys": ["개체"], "raw_text": "개체"}, "explanation": "이 문제는 데이터베이스의 제약조건(무결성 제약조건)에 대한 문제입니다.\n\n[제약조건의 정의와 목적]\n\n제약조건은 데이터베이스에 저장되는 데이터가 정확하고 일관성 있게 유지되도록 하는 규칙입니다. 잘못된 데이터가 입력되는 것을 방지하고 데이터의 무결성을 보장합니다.\n\n[제약조건의 종류]\n\n1. 도메인 제약조건(Domain Constraint): 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 지정합니다.\n- 예: 나이는 0 이상 150 이하의 정수만 허용\n\n2. 개체 제약조건(Entity Constraint, 엔티티 무결성): 기본키(Primary Key)와 관련된 제약조건입니다.\n- 기본키는 NULL 값을 가질 수 없습니다.\n- 기본키는 중복될 수 없으며, 각 튜플(행)을 유일하게 식별해야 합니다.\n\n3. 참조 제약조건(Referential Constraint, 참조 무결성): 외래키(Foreign Key)와 관련된 제약조건입니다.\n- 외래키는 참조하는 테이블의 기본키 값과 일치해야 하거나 NULL 값이어야 합니다.\n\n**문제 해석**: 문제에서 각 설명에 해당하는 제약조건을 보기에서 찾아야 합니다. 제약조건의 정의와 특징을 정확히 이해하면 답은 \"개체\"입니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q008.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 URL 구조에 관한 문제이다.\n아래  보기의 순서대로 URL에 해당하는 번호를 작성하시오.\nquery\n: 서버에 전달할 추가 데이터 path\n: 서버 내의 특정 자원을 가리키는 경로 scheme\n: 리소스에 접근하는 방법이나 프로토콜 authority\n: 사용자 정보, 호스트명, 포트 번호 fragment\n: 특정 문서 내의 위치", "choices": [], "answer": {"keys": ["43125"], "raw_text": "43125"}, "explanation": "URL(Uniform Resource Locator)의 구조를 이해하는 문제입니다.\n\n[URL 구조 예시]\n```\nhttps://user:pass@example.com:8080/path/to/resource?query=value#fragment\n│ │ │ │ │ │ │ │\n│ │ │ │ │ │ │ └─ fragment\n│ │ │ │ │ │ └─ query\n│ │ │ │ │ └─ path\n│ │ │ │ └─ port\n│ │ │ └─ hostname\n│ │ └─ password\n│ └─ username\n└─ scheme\n```\n\n[각 구성 요소]\n\n1. **scheme (3번)**: 리소스에 접근하는 방법이나 프로토콜\n- 예: `http`, `https`, `ftp`, `mailto`\n- URL의 가장 앞에 위치합니다.\n\n2. **authority (4번)**: 사용자 정보, 호스트명, 포트 번호\n- 형식: `[username:password@]hostname[:port]`\n- 예: `user:pass@example.com:8080`\n\n3. **path (1번)**: 서버 내의 특정 자원을 가리키는 경로\n- 예: `/path/to/resource`\n- 서버의 파일 시스템 경로를 나타냅니다.\n\n4. **query (2번)**: 서버에 전달할 추가 데이터\n- 형식: `?key=value&key2=value2`\n- GET 요청의 파라미터를 전달합니다.\n\n5. **fragment (5번)**: 특정 문서 내의 위치\n- 형식: `#section`\n- HTML 문서의 앵커를 가리킵니다.\n\n[순서]\n1. scheme → 2. authority → 3. path → 4. query → 5. fragment\n\n[보기 매칭]\n- query: 1\n- path: 2\n- scheme: 3\n- authority: 4\n- fragment: 5\n\n[답] \"43125\"", "table_refs": [], "image_refs": ["images/2024_round3/Q009.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["45"], "raw_text": "45"}, "explanation": "이 파이썬 코드는 `type()` 함수를 사용한 타입 체크를 이해하는 문제입니다.\n\n[코드 분석]\n\n```python def func(value):\nif type(value) == type(100): # int 타입 체크 return 100 elif type(value) == type(\"\"): # str 타입 체크 return len(value)\nelse:\nreturn 20\n\na = '100.0' # 문자열 b = 100.0 # float (실수)\nc = (100, 200) # tuple\n\nprint(func(a) + func(b) + func(c))\n```\n\n[실행 과정]\n\n1. [`func('100.0')` 호출]\n- `type('100.0') == type(\"\")` → `True` (문자열)\n- 반환: `len('100.0') = 5`\n\n2. [`func(100.0)` 호출]\n- `type(100.0) == type(100)` → `False` (float ≠ int)\n- `type(100.0) == type(\"\")` → `False` (float ≠ str)\n- else 블록 실행 → 반환: **20**\n\n3. [`func((100, 200))` 호출]\n- `type((100, 200)) == type(100)` → `False` (tuple ≠ int)\n- `type((100, 200)) == type(\"\")` → `False` (tuple ≠ str)\n- else 블록 실행 → 반환: **20**\n\n4. [최종 계산]\n- `5 + 20 + 20 = 45`\n\n[핵심 포인트]\n- `type()` 함수는 객체의 타입을 반환합니다.\n- `type(100)`은 `int` 타입 객체를 반환합니다.\n- `100.0`은 `float` 타입이므로 `int`와 다릅니다.\n\n[답] 45", "table_refs": [], "image_refs": ["images/2024_round3/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [{"language": "python", "code": "def func(value):\n    if type(value) == type(100):\n        return 100\n    elif type(value) == type(\"\"):\n        return len(value) \n    else:\n        return 20\na = '100.0'\nb = 100.0\nc = (100, 200)\nprint(func(a) + func(b) + func(c))", "line_numbers": [1, 11], "file": "data/codes/2024_round3/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["52"], "raw_text": "52"}, "explanation": "이미지의 Java 코드는 상속에서 필드 숨김과 메서드 오버라이딩의 차이를 보여주는 문제입니다.\n\n[코드 분석]\n\n```java\nBase a = new Derivate();\nDerivate b = new Derivate();\nSystem.out.print(a.getX() + a.x + b.getX() + b.x);\n\nclass Base {\n    int x = 3;\n    int getX() {\n        return x * 2;  // Base의 x 사용\n    }\n}\n\nclass Derivate extends Base {\n    int x = 7;  // 필드 숨김 (Base의 x를 숨김)\n    int getX() {\n        return x * 3;  // Derivate의 x 사용 (7 * 3 = 21)\n    }\n}\n```\n\n[핵심 개념]\n\n1. [필드 숨김 (Field Hiding)]\n   - 자식 클래스에서 부모 클래스의 필드와 같은 이름의 필드를 선언하면 부모의 필드가 **숨겨집니다**.\n   - `Base.x = 3`, `Derivate.x = 7` (서로 다른 필드)\n\n2. [메서드 오버라이딩 (Method Overriding)]\n   - 자식 클래스에서 부모 클래스의 메서드를 재정의하면 **항상 자식의 메서드가 호출**됩니다.\n   - 객체의 실제 타입(`Derivate`)에 따라 메서드가 결정됩니다.\n\n3. [필드 접근 vs 메서드 호출]\n   - 필드 접근 (`a.x`): 참조 변수의 타입(`Base`)에 따라 결정 → `Base.x = 3`\n   - 메서드 호출 (`a.getX()`): 객체의 실제 타입(`Derivate`)에 따라 결정 → `Derivate.getX()` 호출\n\n[실행 과정]\n\n1. [`a.getX()` 계산]\n   - `a`는 `Base` 타입으로 선언되었지만 실제 객체는 `Derivate`입니다.\n   - 메서드는 **실제 타입**에 따라 결정되므로 `Derivate.getX()` 호출됩니다.\n   - `Derivate.getX()`는 `Derivate.x`를 사용: `7 * 3 = 21`\n   - **결과: 21**\n\n2. [`a.x` 계산]\n   - 필드는 **참조 변수의 타입**에 따라 결정됩니다.\n   - `a`는 `Base` 타입이므로 `Base.x = 3`\n   - **결과: 3**\n\n3. [`b.getX()` 계산]\n   - `b`는 `Derivate` 타입으로 선언되었고 실제 객체도 `Derivate`입니다.\n   - `Derivate.getX()` 호출: `7 * 3 = 21`\n   - **결과: 21**\n\n4. [`b.x` 계산]\n   - `b`는 `Derivate` 타입이므로 `Derivate.x = 7`\n   - **결과: 7**\n\n5. [최종 출력]\n```java\nSystem.out.print(21 + 3 + 21 + 7);\n// 출력: \"52\"\n```\n\n[정리]\n- 필드: 참조 변수 타입에 따라 결정 (`a.x` → `Base.x`, `b.x` → `Derivate.x`)\n- 메서드: 실제 객체 타입에 따라 결정 (`a.getX()`, `b.getX()` → 모두 `Derivate.getX()`)\n\n[답] \"52\"", "table_refs": [], "image_refs": ["images/2024_round3/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.031449"}, "code_blocks": [{"language": "java", "code": "public class Main{\n  public static void main(String[] args){\n    Base a =  new Derivate();\n    Derivate b = new Derivate();\n    System.out.print(a.getX() + a.x + b.getX() + b.x);\n  }\n}\nclass Base{\n  int x = 3;\n  int getX(){\n     return x * 2; \n  }\n}\nclass Derivate extends Base{\n  int x = 7;\n  int getX(){\n     return x * 3;\n  }\n}", "line_numbers": [1, 19], "file": "data/codes/2024_round3/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["312"], "raw_text": "312"}, "explanation": "이 C언어 코드는 연결 리스트에서 인접한 노드 쌍의 값을 교환하는 문제입니다.\n\n[코드 분석]\n\n```c void func(struct Node* node) {\nwhile(node != NULL && node->next != NULL) {\nint = node->value;\nnode->value = node->next->value;\nnode->next->value = t; // 인접 노드 값 교환 node = node->next->next; // 두 칸 건너뛰기\n}\n}\n```\n\n[실행 과정]\n\n1. [초기 리스트 구성]\n```c n1 = {1, NULL}\nn2 = {2, NULL}\nn3 = {3, NULL}\nn1.next = &n3;\nn3.next = &n2;\n```\n- 리스트: 1 → 3 → 2 → NULL• \n\n2. [`func(&n1)` 실행]첫 번째 반복 (node = &n1):\n- node != NULL ✓, node->next != NULL ✓\n- 교환: n1.value(1) ↔ n3.value(3)\n- 리스트: 3 → 1 → 2 → NULL\n- `node = node->next->next` = `n3->next` = `&n2`\n\n[두 번째 반복 (node = &n2)]\n- node != NULL ✓, node->next == NULL ✗\n- 루프 종료\n\n3. [출력]\n```c while(current != NULL) {\nprintf(\"%d\", current->value);\ncurrent = current->next;\n}\n```\n- 출력: \"312\"[답] \"312\"", "table_refs": [], "image_refs": ["images/2024_round3/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct Node {\n int value;\n struct Node* next;\n};\nvoid func(struct Node* node){\n  while(node != NULL && node->next != NULL){\n     int t = node->value;\n     node->value = node->next->value;\n     node->next->value = t;\n     node = node->next->next;\n  }\n}\nint main(){\n  struct Node n1 = {1, NULL};\n  struct Node n2 = {2, NULL};\n  struct Node n3 = {3, NULL};\n  n1.next = &n3;\n  n3.next = &n2;\n  func(&n1);  \n  struct Node* current = &n1;\n  while(current != NULL){\n    printf(\"%d\", current->value);\n    current = current->next;\n }\n return 0;\n}", "line_numbers": [1, 27], "file": "data/codes/2024_round3/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 테스트 커버리지에 대한 문제이다.\n아래 내용에 알맞는 답을 보기에서 골라 작성하시오.\n\n1. 테스트를 통해 프로그램의 모든 문장을 최소한 번씩 실행했는지를 측정\n\n2. 프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 번씩 실행했는지를 측정\n\n3. 복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정\n\nㄱ. 조건\n\nㄴ. 경로\n\nㄷ. 결정\n\nㄹ. 분기\n\nㅁ.함수\n\nㅂ. 문장\n\nㅅ. 루프", "choices": [], "answer": {"keys": ["1. 문장", "2. 분기", "3. 조건"], "raw_text": "1. 문장 2. 분기 3. 조건"}, "explanation": "이 문제는 소프트웨어 테스트 커버리지(Test Coverage)의 종류를 구분하는 문제입니다.\n\n[문제에서 설명하는 각 커버리지]\n\n1. \"테스트를 통해 프로그램의 모든 문장을 최소한 번씩 실행했는지를 측정\"\n- 문장 커버리지(Statement Coverage) 또는 **구문 커버리지**\n- 모든 실행 가능한 문장이 한 번 이상 실행되었는지 확인합니다.\n- 가장 기본적인 커버리지입니다.\n- 예: `if-else` 문에서 각 분기가 실행되었는지 확인\n\n2. \"프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 번씩 실행했는지를 측정\"\n- 분기 커버리지(Branch Coverage) 또는 결정 커버리지(Decision Coverage)\n- 모든 조건문의 참/거짓 분기를 실행했는지 확인합니다.\n- 문장 커버리지보다 엄격합니다.\n- 예: `if (a > 0)`의 참과 거짓 경우를 모두 테스트\n\n3. \"복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정\"\n- 조건 커버리지(Condition Coverage)\n- 복합 조건문(`if (a > 0 && b < 0)`)의 각 조건을 개별적으로 테스트합니다.\n- 각 조건이 참과 거짓으로 평가되었는지 확인합니다.\n\n[커버리지 종류]\n- ㄱ. 조건 커버리지 ✓ (3번)\n- ㄴ. 경로 커버리지: 모든 실행 경로를 테스트\n- ㄷ. 결정 커버리지: 분기 커버리지와 유사\n- ㄹ. 분기 커버리지 ✓ (2번)\n- ㅁ. 함수 커버리지: 모든 함수 호출\n- ㅂ. 문장 커버리지 ✓ (1번)\n- ㅅ. 루프 커버리지: 모든 루프 실행\n\n[답]\n- 1. 문장 (ㅂ)\n- 2. 분기 (ㄹ)\n- 3. 조건 (ㄱ)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합\n\nㄱ. 슈퍼키\n\nㄴ. 외래키\n\nㄷ. 대체키\n\nㄹ. 후보키", "choices": [], "answer": {"keys": ["(1) 외래키", "(2) 후보키", "(3) 대체키", "(4) 슈퍼키"], "raw_text": "(1) 외래키\n(2) 후보키\n(3) 대체키\n(4) 슈퍼키"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n[문제에서 설명하는 내용]\n\n다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별...\n\n[핵심 특징]\n- 다음은 데이터베이스에 관한 문제이다.\n\n[답이 \"(1) 외래키, (2) 후보키, (3) 대체키\"인 이유]\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"(1) 외래키, (2) 후보키, (3) 대체키\"입니다.\n\n[구체적 매칭]\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 C언어 코드는 이중 포인터와 배열 연산을 이해하는 문제입니다.\n\n[코드 분석]\n\n```c void func(int** arr, int size) {\nfor(int i=0; i<size; i++) {\n*(*arr + i) = (*(*arr+i) + i) % size;\n}\n}\n\nint main() {\nint arr[] = {3, 1, 4, 1, 5};\nint* p = arr;\nint pp = &p;\nfunc(pp, 5);\nnum = arr[2];\nprintf(\"%d\", num);\n}\n```\n\n[실행 과정]\n\n1. [초기 상태]\n- `arr = {3, 1, 4, 1, 5}`\n- `p = arr` (arr의 시작 주소)\n- `pp = &p` (p의 주소)\n\n2. [`func(pp, 5)` 호출]\n- `arr` 파라미터는 `pp`이므로 `arr = *p = arr[0]`\n\n[i=0]\n- `*(*arr + 0) = arr[0] = 3`\n- `(3 + 0) % 5 = 3`\n- `arr[0] = 3`\n\n[i=1]\n- `*(*arr + 1) = arr[1] = 1`\n- `(1 + 1) % 5 = 2`\n- `arr[1] = 2`\n\n[i=2]\n- `*(*arr + 2) = arr[2] = 4`\n- `(4 + 2) % 5 = 1`\n- `arr[2] = 1`\n\n[i=3]\n- `*(*arr + 3) = arr[3] = 1`\n- `(1 + 3) % 5 = 4`\n- `arr[3] = 4`\n\n[i=4]\n- `*(*arr + 4) = arr[4] = 5`\n- `(5 + 4) % 5 = 4`\n- `arr[4] = 4`\n\n[최종 배열] `{3, 2, 1, 4, 4}`\n\n3. [출력]\n```c num = arr[2] = 1 printf(\"%d\", 1);\n```\n\n[답] 1", "table_refs": [], "image_refs": ["images/2024_round3/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid func(int** arr, int size){\n  for(int i=0; i<size; i++){\n     *(*arr + i) = (*(*arr+i) + i) % size;\n  }\n}\nint main(){\n  int arr[] = {3,1, 4, 1, 5};\n  int* p = arr;\n  int** pp = &p;\n  int num = 6;\n  func(pp, 5);  \n  num = arr[2];\n  printf(\"%d\", num);  \n  return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2024_round3/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n(3글자로 작성)\n\n- 공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다.\n\n- 사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다.\n\n- 종류로는 IPsec 또는 SSL, L2TP 등이 있다.", "choices": [], "answer": {"keys": ["VPN"], "raw_text": "VPN"}, "explanation": "VPN(Virtual Private Network)은 공용 네트워크를 통해 사설 네트워크를 확장하는 기술입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다\"\n- 인터넷 같은 공용 네트워크 위에 가상의 사설 네트워크를 구축합니다.\n- 물리적으로 멀리 떨어진 네트워크를 하나의 사설망처럼 사용할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등이 있습니다.\n\n2. \"사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다\"\n- VPN 서버를 통해 트래픽을 중계하므로 실제 IP가 숨겨집니다.\n- 위치 추적이 어려워집니다.\n- 프라이버시 보호에 도움이 됩니다.\n\n3. \"종류로는 IPsec 또는 SSL, L2TP 등이 있다\"\n- **IPsec (IP Security)**: 네트워크 계층 암호화\n- **SSL/TLS VPN**: 애플리케이션 계층 암호화\n- L2TP (Layer 2 Tunneling Protocol): 데이터 링크 계층 터널링\n\n[VPN의 주요 용도]\n- 원격 접근: 외부에서 회사 내부 네트워크 접속\n- 사이트 간 연결: 지사 간 안전한 통신\n- 프라이버시 보호: IP 주소 숨김\n\n[답] \"VPN\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["101"], "raw_text": "101"}, "explanation": "이 Java 코드는 예외 처리 메커니즘과 finally 블록의 실행 순서를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java public static void main(String[] args) {\nint sum = 0;\ntry {\nfunc(); // NullPointerException 발생\n} catch (NullPointerException e) {\nsum = sum + 1; // sum = 1\n} catch (Exception e) {\nsum = sum + 10;\n} finally {\nsum = sum + 100; // 항상 실행\n}\nSystem.out.print(sum);\n}\n\nstatic void func() throws Exception {\nthrow new NullPointerException();\n}\n```\n\n[실행 과정]\n\n1. [try 블록 실행]\n- `func()` 호출\n- `NullPointerException` 발생\n\n2. [예외 처리]\n- Java는 첫 번째로 일치하는 catch 블록을 찾습니다.\n- `catch (NullPointerException e)` → **일치!**\n- `sum = 0 + 1 = 1`\n\n3. [finally 블록 실행]\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- `sum = 1 + 100 = 101`\n\n4. [최종 출력]\n- **출력: 101[핵심 포인트]\n- 예외 처리 순서: try → catch(일치하는 예외) → finally\n- finally 블록은 반드시 실행됩니다.\n- `NullPointerException`은 `Exception`의 자식 클래스이므로, 더 구체적인 catch 블록이 먼저 매칭됩니다.\n\n[답] 101", "table_refs": [], "image_refs": ["images/2024_round3/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "java", "code": "public class ExceptionHandling {\n  public static void main(String[] args) {\n      int sum = 0;\n      try {\n          func();\n      } catch (NullPointerException e) {\n          sum = sum + 1;\n      } catch (Exception e) {\n          sum = sum + 10;\n      } finally {\n          sum = sum + 100;\n      }\n      System.out.print(sum);\n  }\n  static void func() throws Exception {\n      throw new NullPointerException(); \n  }\n}", "line_numbers": [1, 18], "file": "data/codes/2024_round3/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["B0"], "raw_text": "B0"}, "explanation": "이미지의 Java 코드는 제네릭 타입 소거(Type Erasure)로 인한 메서드 오버로딩 해석 문제입니다.\n\n[코드 분석]\n\n```java\nnew Collection<>(0).print();\n\nclass Collection<T> {\n    T value;\n    public Collection(T t) {\n        value = t;\n    }\n    public void print() {\n        new Printer().print(value);\n    }\n    \n    class Printer {\n        void print(Integer a) {\n            System.out.print(\"A\" + a);\n        }\n        void print(Object a) {\n            System.out.print(\"B\" + a);\n        }\n        void print(Number a) {\n            System.out.print(\"C\" + a);\n        }\n    }\n}\n```\n\n[핵심 개념]\n\n1. [제네릭 타입 소거 (Type Erasure)]\n   - 컴파일 시 제네릭 타입 정보가 **삭제**됩니다.\n   - `Collection<Integer>` → `Collection` (타입 정보 제거)\n   - 런타임에는 `T`가 `Object`로 취급됩니다.\n\n2. [메서드 오버로딩 해석]\n   - 컴파일 타임에 타입을 결정합니다.\n   - `value`는 `T` 타입이지만, 컴파일 시 `Object`로 취급됩니다.\n   - `0`은 `int` 리터럴이지만, `Integer`로 오토박싱됩니다.\n   - 하지만 `value`는 `Object` 타입이므로 `print(Object)`가 호출됩니다.\n\n[실행 과정]\n\n1. [객체 생성]\n   - `new Collection<>(0)` → `Collection<Integer>` 생성\n   - `value = 0` (Integer로 오토박싱)\n\n2. [`print()` 호출]\n   - `new Printer().print(value)` 실행\n   - `value`는 컴파일 타임에 `Object` 타입으로 취급됩니다.\n\n3. [메서드 오버로딩 해석]\n   - `print(Integer a)`: `Integer` 타입 매칭\n   - `print(Number a)`: `Number` 타입 매칭 (Integer는 Number의 자식)\n   - `print(Object a)`: `Object` 타입 매칭\n   - 컴파일러는 **가장 구체적인 타입**을 찾지만, `value`는 `Object` 타입이므로 `print(Object)`가 호출됩니다.\n\n4. [출력]\n   - `print(Object a)` 실행 → `\"B\" + 0` → **\"B0\" 출력**\n\n[참고]\n- 제네릭 타입 소거로 인해 런타임에는 타입 정보가 없습니다.\n- `print(Integer)`와 `print(Number)`는 `value`가 `Object` 타입이므로 매칭되지 않습니다.\n- `print(Object)`가 가장 넓은 범위를 가지므로 선택됩니다.\n\n[답] \"B0\"", "table_refs": [], "image_refs": ["images/2024_round3/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.032447"}, "code_blocks": [{"language": "java", "code": "class Main {\n  public static class Collection<T>{\n    T value;\n    public Collection(T t){\n        value = t;\n    }\n    public void print(){\n       new Printer().print(value);\n    }\n   class Printer{\n      void print(Integer a){\n        System.out.print(\"A\" + a);\n      }\n      void print(Object a){\n        System.out.print(\"B\" + a);\n      } \n      void print(Number a){\n        System.out.print(\"C\" + a);\n      }\n   }\n }\n  public static void main(String[] args) {\n      new Collection<>(0).print();\n  }\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round3/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 네트워크에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다.\n\n- 일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다.\n\n- 긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다.\n\n[보기]\n\nㄱ.Infrastructure Network\n\nㄴ. Firmware Network\n\nㄷ. Peer-to-Peer Network\n\nㄹ. Ad-hoc Network\n\nㅁ. Mesh Network\n\nㅂ.Sensor Network\n\nㅅ.Virtual Private Network", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "Ad-hoc Network(애드혹 네트워크)는 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다\"\n- 중앙 서버나 라우터 없이 노드들이 직접 통신합니다.\n- 인프라가 필요 없어 빠르게 구성 가능합니다.\n- 동적으로 네트워크를 형성합니다.\n\n2. \"일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다\"\n- 무선 기술(Wi-Fi, Bluetooth 등)을 사용합니다.\n- P2P(Peer-to-Peer) 방식으로 직접 통신합니다.\n- 각 노드가 라우터 역할을 할 수 있습니다.\n\n3. \"긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다\"\n- 인프라가 없는 상황에서도 통신 가능\n- 재난 상황, 야전 환경 등에서 활용\n- 임시 네트워크 구축에 적합\n\n[보기 분석]\n- ㄱ. Infrastructure Network: 인프라 기반 네트워크 (Wi-Fi AP 필요)\n- ㄴ. Firmware Network: 펌웨어 네트워크 (일반적 용어 아님)\n- ㄷ. Peer-to-Peer Network: P2P (일부 특징 유사하지만 Ad-hoc과 다름)\n- ㄹ. Ad-hoc Network: 중앙 인프라 없이 임시 구성 ✓\n- ㅁ. Mesh Network: 메시 네트워크 (Ad-hoc의 확장 형태)\n- ㅂ. Sensor Network: 센서 네트워크 (IoT)\n- ㅅ. Virtual Private Network: VPN (가상 사설망)\n\n[답] \"ㄹ\" (Ad-hoc Network)", "table_refs": [{"id": "table1", "json": "data/tables/2024_round3/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:27:19.033447"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 네트워크 보안에 관련된 문제이다.\n괄호 안에 알맞는 용어를 작성하시오.\n(   )은/는 '세션을 가로채다.' 라는 의미로 다른 사람의 세션 상태를 훔치거나 도용하여 액세스하는 해킹 기법이다.\nTCP (   )은/는 TCP의 3-way 핸드셰이크가 완료된 후에 공격자가 시퀀스 번호 등을 조작하여 정상적인 세션을 가로채고 인증 없이 통신을 탈취하는 공격이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 공격자가 정상 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다.\n\n[세션 하이재킹의 개념]\n\n• 기본 정의: 공격자가 정상 사용자의 세션을 가로채어 사용자 권한으로 시스템에 접근하는 공격 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.\n\n• 세션이란: 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.\n\n[TCP 세션 하이재킹]\n\n• 3-way 핸드셰이크: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.\n  - 클라이언트 → 서버: SYN 패킷 전송\n  - 서버 → 클라이언트: SYN-ACK 패킷 응답\n  - 클라이언트 → 서버: ACK 패킷 전송\n  - 이 과정이 완료되면 정상적인 통신이 시작됩니다.\n\n• 공격 과정:\n  - 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.\n  - TCP 시퀀스 번호를 예측하거나 조작합니다.\n  - 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.\n  - 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.\n\n답: 세션 하이재킹", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.900403", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.036449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 제약조건과 관련된 문제이다.\n괄호 안에 알맞는 용어를 보기에 골라 작성하시오.\n개체, 참조, 도메인", "choices": [], "answer": {"keys": ["ㄱ. 도메인", "ㄴ. 개체", "ㄷ. 참조"], "raw_text": "ㄱ. 도메인\nㄴ. 개체\nㄷ. 참조"}, "explanation": "이 문제는 데이터베이스의 제약조건 개념인 도메인(Domain), 개체 무결성(Entity Integrity), 참조 무결성(Referential Integrity)에 관한 문제입니다.\n\n[데이터베이스 제약조건 이해]\n\n1. [도메인(Domain) 제약조건]\n- 도메인은 특정 속성(컬럼)에 입력될 수 있는 값의 유형이나 범위를 정의합니다.\n- 예를 들어, 나이 속성의 도메인은 0 이상의 정수일 수 있습니다.\n- 도메인 제약조건은 데이터의 타입, 길이, 범위 등을 제한하여 데이터 무결성을 보장합니다.\n- 문제에서 \"특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준\"이라고 설명한 것이 도메인 제약조건입니다.\n\n2. [개체 무결성(Entity Integrity)]\n- 개체 무결성은 릴레이션(테이블)의 기본 키(Primary Key)가 NULL이 될 수 없고, 중복될 수 없다는 규칙입니다.\n- 기본 키는 각 튜플(행)을 고유하게 식별하는 역할을 하므로 반드시 값이 있어야 합니다.\n- 문제의 이미지나 설명에서 개체 무결성과 관련된 내용이 있을 것입니다.\n\n3. [참조 무결성(Referential Integrity)]\n- 참조 무결성은 한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조되는 값이 반드시 존재해야 한다는 규칙입니다.\n- 외래 키(Foreign Key)는 다른 릴레이션의 기본 키를 참조하는 속성입니다.\n- 문제에서 \"한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미\"라고 설명한 것이 외래 키(참조 무결성)입니다.\n\n[답] 보기에서:\n- ㄱ. domain: 도메인 제약조건 (4번 문제)\n- ㄴ. 개체: 개체 무결성 관련\n- ㄷ. 참조: 참조 무결성, 외래 키 (3번 문제)\n\n문제의 실제 설명과 이미지를 바탕으로 정확히 매칭하면 \"ㄱ. 도메인, ㄴ. 개체, ㄷ. 참조\"입니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.036449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "아래의 내용에서 설명 글의 괄호안의 용어를 영문 약자로 작성하시오.\n(        ) 은/는 3글자의 영어 약자로 이루어진 오류 기법으로 데이터를 전송하거나 저장할 때 데이터의 오류를 감지하는 데 사용되는 오류 검출 코드이다.\n(        ) 은/는 데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인하는 기법이다.\n(        ) 은/는 데이터 전송의 안정성을 높이는 데 중요한 역할을 한다.\n데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고나머지를 (       ) 값으로 삼는다.", "choices": [], "answer": {"keys": ["CRC"], "raw_text": "CRC"}, "explanation": "CRC(Cyclic Redundancy Check)는 데이터 전송 시 오류를 검출하는 코드입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"3글자의 영어 약자로 이루어진 오류 기법\"\n- CRC는 Cyclic Redundancy Check의 약자로 정확히 3글자입니다.\n- 데이터 전송이나 저장 시 오류를 감지하는 데 사용됩니다.\n\n2. \"데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인\"\n- CRC는 데이터에 체크섬(나머지 값)을 추가하여 전송합니다.\n- 수신 측에서 같은 방법으로 체크섬을 다시 계산하여 두 값이 일치하면 오류가 없는 것으로, 다르면 오류가 발생한 것으로 판단합니다.\n\n3. \"데이터 전송의 안정성을 높이는 데 중요한 역할\"\n- CRC는 통신이나 저장 매체에서 발생할 수 있는 데이터 손상을 감지하여 신뢰성을 높입니다.\n\n4. \"데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고 나머지를 ( ) 값으로 삼는다\"\n- CRC는 생성 다항식(Generator Polynomial)을 사용하여 계산합니다.\n- 예시로 주어진 \"x³ + x + 1\"은 다항식을 이진수로 표현하면 \"1011\"이 됩니다.\n- 데이터를 이 다항식으로 나눗셈 연산을 수행하고 나머지를 CRC 값으로 사용합니다.\n\n[CRC 계산 과정]\n1. 데이터에 0을 추가 (다항식 차수만큼)\n2. 생성 다항식으로 XOR 연산 (2진수 나눗셈)\n3. 나머지를 CRC 값으로 사용\n\n[답] 문제에서 설명한 모든 특징(3글자 약자, 체크섬 추가, 이진수 다항식 나눗셈)이 CRC와 정확히 일치하므로 답은 \"CRC\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.036449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 악성코드 관련된 문제이다.\n아래 내용을 확인하여\n\n보기에 골라 작성하시오.\n사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.\n‘겁을 주다’라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불 하거나 특정 행동을 유도하는 랜섬웨어이다.\n가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식으로 작동한다.\n\n[보기]\n\nㄱ. 컴포넌트 웨어\n\nㄴ. 유즈웨어\n\nㄷ. 셔블웨어\n\nㄹ. 스캐어 웨어\n\nㅁ. 안티 스파이 웨어\n\nㅂ. 네트웨어\n\nㅅ. 그룹웨어\n\nㅇ. 애드웨어", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "스캐어웨어(Scareware)는 사용자를 속여 돈을 지불하거나 소프트웨어를 구매하도록 조작하는 악성 소프트웨어입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발\"\n- 스캐어웨어는 사용자의 두려움(scare)을 이용합니다.\n- 가짜 경고나 위협적인 메시지를 보여줘서 사용자가 당황하게 만듭니다.\n- 사용자가 긴급하게 대응해야 한다고 느끼도록 조작합니다.\n\n2. \"'겁을 주다'라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불하거나 특정 행동을 유도하는 랜섬웨어\"\n- \"Scare\"는 \"겁을 주다, 놀라게 하다\"라는 의미입니다.\n- 공포 마케팅 전략을 사용합니다.\n- 랜섬웨어와 유사하지만, 실제로 데이터를 암호화하지 않고 가짜 경고를 보여줍니다.\n\n3. \"가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식\"\n- 가짜 안티바이러스 경고를 표시합니다.\n- \"시스템이 감염되었습니다\", \"바로 지금 처리하세요\" 등의 메시지를 보여줍니다.\n- 사용자로 하여금 가짜 안티바이러스 소프트웨어를 구매하거나 설치하도록 유도합니다.\n\n[보기 분석]\n- ㄱ. 컴포넌트 웨어: 컴포넌트 기반 소프트웨어\n- ㄴ. 유즈웨어: 사용자가 만든 소프트웨어\n- ㄷ. 셔블웨어: 평가판 소프트웨어\n- ㄹ. 스캐어 웨어: 공포를 이용한 악성 소프트웨어 ✓\n- ㅁ. 안티 스파이 웨어: 스파이웨어 방지 소프트웨어\n- ㅂ. 네트웨어: 네트워크 기반 소프트웨어\n- ㅅ. 그룹웨어: 그룹 협업 소프트웨어\n- ㅇ. 애드웨어: 광고 소프트웨어\n\n[답] 문제에서 설명한 모든 특징(공포 유발, 가짜 경고, 속임수)이 스캐어웨어와 정확히 일치하므로 답은 \"ㄹ\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.036449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["출력1출력5"], "raw_text": "출력1출력5"}, "explanation": "이 Java 코드는 예외 처리 메커니즘(try-catch-finally)을 이해하는 문제입니다.\n\n[코드 분석]\n\n```java int a = 5, b = 0;\ntry {\nSystem.out.print(a/b); // 5 / 0 → ArithmeticException 발생!\n} catch(ArithmeticException e) {\nSystem.out.print(\"출력1\");\n} catch(ArrayIndexOutOfBoundsException e) {\nSystem.out.print(\"출력2\");\n} catch(NumberFormatException e) {\nSystem.out.print(\"출력3\");\n} catch(Exception e) {\nSystem.out.print(\"출력4\");\n} finally {\nSystem.out.print(\"출력5\");\n}\n```\n\n[실행 과정]\n\n1. [try 블록 실행]\n- `a = 5`, `b = 0`\n- `System.out.print(5 / 0)` 실행 시도\n- 0으로 나누기 연산 → `ArithmeticException` 발생\n\n2. [예외 처리]\n- Java는 발생한 예외 타입을 찾기 위해 catch 블록들을 순서대로 확인합니다.\n- 첫 번째 catch: `catch(ArithmeticException e)` → **일치!**\n- 따라서 \"출력1\"을 출력합니다.\n\n3. [finally 블록 실행]\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- \"출력5\"를 출력합니다.\n\n4. [최종 출력]\n- \"출력1\" + \"출력5\" = **\"출력1출력5\"[핵심 포인트]\n- Java의 예외 처리 순서: try → catch(일치하는 예외 타입) → finally\n- 여러 catch 블록이 있을 때 첫 번째로 일치하는 catch 블록이 실행됩니다.\n- finally 블록은 예외 발생 여부와 관계없이 반드시 실행됩니다.\n\n[답] \"출력1출력5\"", "table_refs": [], "image_refs": ["images/2025_round1/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.036449"}, "code_blocks": [{"language": "java", "code": "public class Main {\n  public static void main(String[] args) {\n    int a=5,b=0;\n    try{\n      System.out.print(a/b);\n    }catch(ArithmeticException e){\n      System.out.print(\"출력1\");\n    }catch(ArrayIndexOutOfBoundsException e) {\n      System.out.print(\"출력2\");\n    }catch(NumberFormatException e) {\n      System.out.print(\"출력3\");\n    }catch(Exception e){\n      System.out.print(\"출력4\");\n    }finally{\n      System.out.print(\"출력5\");\n    }\n  }\n}", "line_numbers": [1, 18], "file": "data/codes/2025_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 내용은 ARP/RARP에 대한 설명이다. 각 설명에 해당하는 것을 작성하시오.\n\n(1) 은/는 네트워크상에서 IP 주소를 MAC 주소로 변환하는 프로토콜이고,\n( 2 ) 은/는 MAC 주소를 IP 주소로 변환하는 프로토콜이다.", "choices": [], "answer": {"keys": ["(1) ARP", "(2) RARP"], "raw_text": "(1) ARP\n(2) RARP"}, "explanation": "ARP(Address Resolution Protocol)와 RARP(Reverse Address Resolution Protocol)는 네트워크에서 주소 변환을 담당하는 프로토콜입니다.\n\n[문제 분석]\n\n[(1) IP 주소를 MAC 주소로 변환하는 프로토콜]\n- ARP(Address Resolution Protocol)는 IP 주소를 물리적 주소인 MAC 주소로 변환합니다.\n- 예를 들어, 컴퓨터가 네트워크상의 다른 컴퓨터와 통신하려면 IP 주소는 알고 있지만, 실제로 데이터를 전송하려면 MAC 주소가 필요합니다.\n- ARP는 브로드캐스트를 통해 \"이 IP 주소를 가진 컴퓨터의 MAC 주소를 알려주세요\"라고 요청하고, 해당 컴퓨터가 자신의 MAC 주소를 응답합니다.\n\n[(2) MAC 주소를 IP 주소로 변환하는 프로토콜]\n- RARP(Reverse Address Resolution Protocol)는 ARP의 반대 개념입니다.\n- MAC 주소를 알고 있지만 IP 주소를 모를 때 사용합니다.\n- 주로 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아오는 데 사용됩니다.\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용되고 있습니다.\n\n[ARP와 RARP의 관계]\n- ARP: IP 주소 → MAC 주소 변환\n- RARP: MAC 주소 → IP 주소 변환 (역방향)\n\n[답] (1) ARP, (2) RARP", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.037448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 SQL 문제이다.\n아래 두 테이블을 참고하여\n\n보기에 쿼리 실행 결과를 작성하시오.\nSELECT name, incentive FROM emp, sal WHERE emp.id = sal.id and incentives >= 500", "choices": [], "answer": {"keys": ["이순신", "1000"], "raw_text": "이순신 1000"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n[SQL 쿼리 실행 순서와 분석]\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 이순신, 1000입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q007.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.037448"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래는 데이터베이스에 관련된 설명이다.\n알맞는 용어를 보기에서 골라 괄호를 작성하시오.\n\n1. 릴레이션에서 속성의 개수를 의미 : ( 1 )\n\n2. 릴레이션에서 튜플의 개수를 의미 : ( 2 )\n\n3. 한 릴레이션의 속상이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미 : ( 3 )\n\n4. 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준 : ( 4 )\n\n[보기]\n\nㄱ. domain\n\nㄴ. primary\n\nㄷ. degree\n\nㄹ. candidate\n\nㅁ. cardinality\n\nㅂ. attribute\n\nㅅ. foreign", "choices": [], "answer": {"keys": ["(1) ㄷ", "(2) ㅁ", "(3) ㅅ", "(4) ㄱ"], "raw_text": "(1) ㄷ\n(2) ㅁ\n(3) ㅅ\n(4) ㄱ"}, "explanation": "이 문제는 **데이터베이스 릴레이션의 기본 용어**를 구분하는 문제입니다.\n\n[각 용어의 정의]\n\n1. [(1) Degree (차수) - ㄷ]\n   - **정의**: 릴레이션에서 **속성(Attribute)의 개수**를 의미합니다.\n   - 릴레이션의 열(Column) 수를 나타냅니다.\n   - 예: 학생 테이블에 학번, 이름, 나이, 학과 4개 속성이 있으면 Degree = 4\n\n2. [(2) Cardinality (카디널리티) - ㅁ]\n   - **정의**: 릴레이션에서 **튜플(Tuple)의 개수**를 의미합니다.\n   - 릴레이션의 행(Row) 수를 나타냅니다.\n   - 예: 학생 테이블에 100명의 학생이 있으면 Cardinality = 100\n\n3. [(3) Foreign Key (외래키) - ㅅ]\n   - **정의**: 한 릴레이션의 속성이 **다른 릴레이션의 기본 키를 참조**할 때, 참조하는 속성을 의미합니다.\n   - 참조 무결성(Referential Integrity)을 보장합니다.\n   - 예: 학생 테이블의 `학과코드`가 학과 테이블의 기본 키 `학과코드`를 참조\n\n4. [(4) Domain (도메인) - ㄱ]\n   - **정의**: 특정 속성에 대해 **입력될 수 있는 값의 유형이나 범위**를 의미하고 무결성을 보장하는 기준입니다.\n   - 데이터 타입, 길이, 범위 등을 정의합니다.\n   - 예: 나이 속성의 도메인은 0 이상 150 이하의 정수\n\n[요약]\n- **Degree**: 속성(열)의 개수\n- **Cardinality**: 튜플(행)의 개수\n- **Foreign Key**: 다른 테이블의 기본 키를 참조하는 속성\n- **Domain**: 속성 값의 유형이나 범위\n\n[답]\n- (1) ㄷ (degree)\n- (2) ㅁ (cardinality)\n- (3) ㅅ (foreign)\n- (4) ㄱ (domain)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.037448"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["프로그래밍"], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "IP 주소가 192.168.35.10, 서브넷 255.255.252.0인 PC에서 브로드캐스팅으로 다른 IP로 정보를 전달한다고 할 때 수신할 수 있는 알맞는 IP를 보기에서 골라 모두 작성하시오.\n\n[보기]\n\nㄱ. 192.168.34.1\n\nㄴ. 192.168.32.19\n\nㄷ. 192.168.35.200\n\nㄹ. 192.168.33.138\n\nㅁ. 192.168.35.50", "choices": [], "answer": {"keys": ["ㄱ,ㄴ,ㄷ,ㄹ,ㅁ"], "raw_text": "ㄱ,ㄴ,ㄷ,ㄹ,ㅁ"}, "explanation": "이 문제는 서브넷 마스크와 브로드캐스트 주소 범위를 이해하는 문제입니다.\n\n[주어진 정보]\n- IP 주소: 192.168.35.10\n- 서브넷 마스크: 255.255.252.0\n\n[서브넷 마스크 분석]\n- 255.255.252.0을 이진수로 변환: 11111111.11111111.11111100.00000000\n- 서브넷 비트 수: 22개 (앞의 22개 1)\n- 호스트 비트 수: 10개 (뒤의 10개 0)\n\n[네트워크 주소 계산]\nIP 주소와 서브넷 마스크를 AND 연산:\n- IP: 192.168.35.10 = 11000000.10101000.00100011.00001010\n- 마스크: 255.255.252.0 = 11111111.11111111.11111100.00000000\n- AND 결과: 192.168.32.0\n\n[브로드캐스트 범위]\n- 네트워크 주소: 192.168.32.0\n- 브로드캐스트 주소: 192.168.35.255 (네트워크 주소 + 호스트 비트 모두 1)\n- 사용 가능한 IP 범위: 192.168.32.1 ~ 192.168.35.254\n\n[보기 분석]\n- ㄱ. 192.168.34.1 → 32~35 범위 내 ✓\n- ㄴ. 192.168.32.19 → 32~35 범위 내 ✓\n- ㄷ. 192.168.35.200 → 32~35 범위 내 ✓\n- ㄹ. 192.168.33.138 → 32~35 범위 내 ✓\n- ㅁ. 192.168.35.50 → 32~35 범위 내 ✓\n\n모든 보기가 같은 네트워크(서브넷)에 속하므로 브로드캐스트로 모두 수신 가능합니다.\n\n[답] \"ㄱ,ㄴ,ㄷ,ㄹ,ㅁ\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.037448"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["4", "BACDE"], "raw_text": "4 BACDE"}, "explanation": "이 C언어 코드는 문자 배열에 문자를 삽입하는 알고리즘을 구현한 문제입니다.\n\n[코드 실행 단계]\n\n1. [초기 상태]\n```c char Data[5] = {'B', 'A', 'D', 'E'};\nchar c = 'C';\n```\n- 배열: `Data[0]='B', Data[1]='A', Data[2]='D', Data[3]='E', Data[4]='\u0000'`\n- 삽입할 문자: `c = 'C'`\n\n2. [첫 번째 출력]\n```c printf(\"%d\n\", Data[3]-Data[1]);\n```\n- `Data[3] = 'E'` (ASCII 69)\n- `Data[1] = 'A'` (ASCII 65)\n- `69 - 65 = 4` → **출력: \"4\"**\n\n3. [삽입 위치 찾기]\n```c for(i=0; i<5; ++i) {\nif(Data[i] > c) // 'C'보다 큰 값 찾기 break;\n}\n```\n- i=0: 'B' < 'C' → 계속\n- i=1: 'A' < 'C' → 계속\n- i=2: 'D' > 'C' → **break!** (i=2)\n\n4. [문자 삽입 (오른쪽으로 시프트)]\n```c temp = Data[2]; // temp = 'D'\nData[2] = 'C'; // 삽입 i = 3;\n\n// 나머지 원소들을 오른쪽으로 한 칸씩 이동 for(; i<5; ++i) {\ntemp2 = Data[i];\nData[i] = temp;\ntemp = temp2;\n}\n```\n- i=3: Data[3]='E'를 temp2에 저장 → Data[3]='D', temp='E'\n- i=4: Data[4]='\u0000'를 temp2에 저장 → Data[4]='E', temp='\u0000'\n- 최종 배열: `{'B', 'A', 'C', 'D', 'E'}`\n\n5. [최종 출력]\n```c for(i=0; i<5; i++)\nprintf(\"%c\", Data[i]);\n```\n- **출력: \"BACDE\"[답] \"4 BACDE\"", "table_refs": [], "image_refs": ["images/2025_round1/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.037448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nchar Data[5] = {'B', 'A', 'D', 'E'};\nchar c;\nint main(){\n    int i, temp, temp2;\n    c = 'C';\n    printf(\"%d\\n\", Data[3]-Data[1]);\n    for(i=0;i<5;++i){\n        if(Data[i]>c)\n            break;\n    }\n    temp = Data[i];\n    Data[i] = c;\n    i++;\n    for(;i<5;++i){\n        temp2 = Data[i];\n        Data[i] = temp;\n        temp = temp2;\n    }\n    for(i=0;i<5;i++){\n        printf(\"%c\", Data[i]);\n    }\n}", "line_numbers": [1, 23], "file": "data/codes/2025_round1/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["13"], "raw_text": "13"}, "explanation": "이 C언어 코드는 2차원 배열을 동적으로 할당하고 데이터를 배치한 후 합을 계산하는 문제입니다.\n\n[코드 실행 단계]\n\n1. [2차원 배열 동적 할당]\n```c int rows = 3, cols = 3;\nint data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};\n```\n- 3×3 배열을 동적으로 할당합니다.\n- data 배열: {5, 2, 7, 4, 1, 8, 3, 6, 9}\n\n2. [set() 함수 분석]\n```c void set(int** arr, int* data, int rows, int cols) {\nfor (int i = 0; i < rows * cols; ++i) {\narr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n}\n}\n```\n- i=0: arr[(1/3)%3][1%3] = arr[0][1] = data[0] = 5\n- i=1: arr[(2/3)%3][2%3] = arr[0][2] = data[1] = 2\n- i=2: arr[(3/3)%3][3%3] = arr[1][0] = data[2] = 7\n- i=3: arr[(4/3)%3][4%3] = arr[1][1] = data[3] = 4\n- i=4: arr[(5/3)%3][5%3] = arr[1][2] = data[4] = 1\n- i=5: arr[(6/3)%3][6%3] = arr[2][0] = data[5] = 8\n- i=6: arr[(7/3)%3][7%3] = arr[2][1] = data[6] = 3\n- i=7: arr[(8/3)%3][8%3] = arr[2][2] = data[7] = 6\n- i=8: arr[(9/3)%3][9%3] = arr[0][0] = data[8] = 9\n\n[배열 상태]\n```\n[9][5][2]\n[7][4][1]\n[8][3][6]\n```\n\n3. [합 계산]\n```c for (int i = 0; i < rows * cols; i++) {\nsum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n}\n```\n- i가 짝수면 +, 홀수면 - 부호를 적용합니다.\n- i=0: arr[0][0]=9 × 1 = 9\n- i=1: arr[0][1]=5 × (-1) = -5\n- i=2: arr[0][2]=2 × 1 = 2\n- i=3: arr[1][0]=7 × (-1) = -7\n- i=4: arr[1][1]=4 × 1 = 4\n- i=5: arr[1][2]=1 × (-1) = -1\n- i=6: arr[2][0]=8 × 1 = 8\n- i=7: arr[2][1]=3 × (-1) = -3\n- i=8: arr[2][2]=6 × 1 = 6\n\n[합] 9 - 5 + 2 - 7 + 4 - 1 + 8 - 3 + 6 = **13[답] 13", "table_refs": [], "image_refs": ["images/2025_round1/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.037448"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nvoid set(int** arr, int* data, int rows, int cols) {\n    for (int i = 0; i < rows * cols; ++i) {\n        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n    }\n}\nint main() {\n    int rows = 3, cols = 3, sum = 0;\n    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}; \n    int** arr;\n    arr = (int**) malloc(sizeof(int*) * rows);\n    for (int i = 0; i < cols; i++) {\n        arr[i] = (int*) malloc(sizeof(int) * cols);\n    }\n    set(arr, data, rows, cols);\n    for (int i = 0; i < rows * cols; i++) {\n        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n    }\n    for(int i=0; i<rows; i++) {\n        free(arr[i]);\n    }\n    free(arr);\n    printf(\"%d\", sum);\n}", "line_numbers": [1, 25], "file": "data/codes/2025_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 결합도와 관련된 내용이다.\n보기에 알맞는 답을 골라 작성하시오.\n\n(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우의 결합도\n(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\nㄱ. 자료 결합도\n\nㄴ. 스탬프 결합도\n\nㄷ. 제어 결합도\n\nㄹ. 공통 결합도\n\nㅁ. 내용 결합도\n\nㅂ. 외부 결합도", "choices": [], "answer": {"keys": ["(1) ㅁ", "(2) ㄴ", "(3) ㄹ"], "raw_text": "(1) ㅁ\n(2) ㄴ\n(3) ㄹ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 결합도(Coupling) 개념에 관한 문제입니다.\n\n[문제에서 설명하는 각 결합도]\n\n[(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우]\n- 내용 결합도(Content Coupling)는 가장 강한 결합도입니다.\n- 한 모듈이 다른 모듈의 내부 구현(변수, 함수 등)을 직접 접근하는 경우입니다.\n- 모듈 간의 독립성이 매우 낮아 한 모듈의 변경이 다른 모듈에 직접적인 영향을 미칩니다.\n- 예: 모듈 A가 모듈 B의 전역 변수나 내부 함수를 직접 호출\n\n[(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우]\n- 스탬프 결합도(Stamp Coupling)는 구조체나 배열 등의 복합 자료구조가 전달되는 경우입니다.\n- 모듈 간에 필요한 데이터만 전달하지 않고 전체 구조를 전달하므로 불필요한 의존성이 생깁니다.\n- 예: 모듈 A가 모듈 B에 전체 구조체를 전달\n\n[(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용]\n- 공통 결합도(Common Coupling)는 여러 모듈이 공통으로 사용하는 전역 변수나 공유 메모리를 사용하는 경우입니다.\n- 전역 변수를 통해 모듈 간에 상호작용하므로 모듈의 독립성이 떨어집니다.\n- 예: 여러 모듈이 같은 전역 변수를 읽고 쓰는 경우\n\n[결합도 순서 (강함 → 약함)]\n1. 내용 결합도 (가장 강함)\n2. 공통 결합도 3. 외부 결합도 4. 제어 결합도 5. 스탬프 결합도 6. 자료 결합도 (가장 약함, 이상적)\n\n[답] (1) ㅁ (내용 결합도), (2) ㄴ (스탬프 결합도), (3) ㄹ (공통 결합도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["54"], "raw_text": "54"}, "explanation": "이 문제는 Java 상속, 정적 변수, 메서드 오버라이딩, 생성자 호출 순서를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java\nnew Child();\nSystem.out.println(Parent.total);\n\nclass Parent {\n    static int total = 0;  // 정적 변수 (클래스 변수)\n    int v = 1;             // 인스턴스 변수\n    public Parent() {\n        total += (++v);    // v를 1 증가시킨 후 total에 더함\n        show();            // 메서드 호출\n    }\n    public void show() {\n        total += total;    // total을 2배로 만듦\n    }\n}\n\nclass Child extends Parent {\n    int v = 10;            // 필드 숨김 (Parent의 v와 별개)\n    public Child() {\n        v += 2;            // Child의 v를 12로 만듦\n        total += v++;      // total에 v(12)를 더하고 v를 13으로 증가\n        show();            // 오버라이딩된 메서드 호출\n    }\n    @Override\n    public void show() {\n        total += total * 2; // total을 3배로 만듦 (total + total*2)\n    }\n}\n```\n\n[실행 과정]\n\n[핵심 개념]\n- Java에서 메서드 오버라이딩은 **객체의 실제 타입**에 따라 결정됩니다.\n- 부모 생성자에서 오버라이딩된 메서드를 호출하면, **자식 클래스의 메서드가 호출**됩니다.\n\n1. [`new Child()` 호출]\n   - 자식 클래스 생성자는 부모 클래스 생성자를 먼저 호출합니다.\n   - [`Parent()` 생성자 실행]\n     - `total = 0` (초기값)\n     - `++v` → Parent의 `v`가 1에서 2로 증가\n     - `total += 2` → `total = 2`\n     - `show()` 호출 → Child의 오버라이딩된 `show()` 메서드 실행 (실제 객체가 Child이므로)\n       - `total += total * 2` → `total = 2 + 2*2 = 2 + 4 = 6`\n     - **현재: `total = 6`**\n\n2. [`Child()` 생성자 실행]\n   - `v += 2` → Child의 `v`가 10에서 12로 증가 (Parent의 v와 별개)\n   - `total += v++` → `total += 12`, 그 다음 `v = 13`\n     - `total = 6 + 12 = 18`\n   - `show()` 호출 → Child의 `show()` 메서드 실행\n     - `total += total * 2` → `total = 18 + 18*2 = 18 + 36 = 54`\n     - **현재: `total = 54`**\n\n[최종 출력]\n- `System.out.println(Parent.total)` → **출력: 54**\n\n[정리]\n- Parent 생성자에서 `show()` 호출 시, 실제 객체가 `Child`이므로 Child의 `show()`가 호출됩니다.\n- 이는 Java의 동적 메서드 디스패치(Dynamic Method Dispatch) 때문입니다.\n\n[답] \"54\"", "table_refs": [], "image_refs": ["images/2025_round1/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void main(String[] args) {\n        new Child();\n        System.out.println(Parent.total);\n    }\n}\nclass Parent {\n    static int total = 0;\n    int v = 1;\n    public Parent() {\n        total += (++v);\n        show();    \n    }\n    public void show() {\n        total += total;\n    }\n}\nclass Child extends Parent {\n    int v = 10;\n    public Child() {\n        v += 2;\n        total += v++;\n        show();\n    }\n    @Override\n    public void show() {\n        total += total * 2;\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2025_round1/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래는 디자인 패턴에 대한 설명이다.\n알맞는 답을 보기에 골라 작성하시오.\n서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다.\n기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다.\n기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다.", "choices": [], "answer": {"keys": ["Adapter"], "raw_text": "Adapter"}, "explanation": "Adapter(어댑터) 패턴은 기존 클래스를 수정하지 않고 다른 인터페이스로 변환하여 사용할 수 있게 해주는 디자인 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다\"\n- 어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스들을 연결합니다.\n- 예를 들어, 클래스 A는 `charge()` 메서드를 가지고 있지만, 클라이언트는 `plugIn()` 메서드를 기대하는 경우, 어댑터가 `plugIn()`을 `charge()`로 변환합니다.\n\n2. \"기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다\"\n- Adaptee: 변환이 필요한 기존 클래스\n- Target: 클라이언트가 원하는 인터페이스\n- Adapter: Adaptee를 Target 인터페이스로 변환하는 중간 클래스\n- 어댑터가 Target 인터페이스를 구현하고, 내부적으로 Adaptee를 호출합니다.\n\n3. \"기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다\"\n- 어댑터는 기존 클래스를 감싸는 래퍼(Wrapper) 역할을 합니다.\n- 기존 클래스의 기능은 그대로 사용하되, 인터페이스만 변환합니다.\n- 객체 어댑터 방식: 객체 합성을 사용하여 Adaptee를 포함\n- 클래스 어댑터 방식: 다중 상속을 사용하여 Target과 Adaptee를 상속\n\n[어댑터 패턴의 활용 예시]\n- 전기 콘센트 어댑터: 110V 플러그를 220V 콘센트에 사용\n- 레거시 시스템과 새 시스템 연동\n- 서로 다른 API를 통합\n\n[답] 문제에서 설명한 모든 특징(인터페이스 변환, 어댑터 클래스, 래퍼 역할)이 Adapter 패턴과 정확히 일치하므로 답은 \"Adapter\"입니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "문장(Statement) 커버리지 테스트를 수행하려고 한다. 코드를 아래의 제어 흐름도 빈칸에 연결되도록 작성하고 문장 커버리지 순서대로 작성하시오.", "choices": [], "answer": {"keys": ["(1) int a = 0", "(2) a < m || b[a] < x", "(3) b[a] < 0", "(4) b[a] = -b[a];", "(5) a++;", "(6) return 1;", "(7) ③ → ④ → ⑤ → ② → ⑥"], "raw_text": "(1) int a = 0\n(2) a < m || b[a] < x\n(3) b[a] < 0\n(4) b[a] = -b[a];\n(5) a++;\n(6) return 1;\n(7) ③ → ④ → ⑤ → ② → ⑥"}, "explanation": "이 문제는 문장 커버리지(Statement Coverage) 테스트를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c\nint Main(int b[], int m, int x) {\n    int a = 0;                    // ①\n    while (a < m || b[a] < x) {   // ②\n        if (b[a] < 0)             // ③\n            b[a] = -b[a];         // ④\n        a++;                      // ⑤\n    }\n    return 1;                    // ⑥\n}\n```\n\n[문장 커버리지란]\n- 프로그램의 모든 실행 가능한 문장을 최소한 한 번씩 실행했는지를 측정합니다.\n- 각 문장이 실행되었는지 확인하는 것이 목표입니다.\n\n[제어 흐름도 분석]\n\n1. **① `int a = 0`**: 변수 초기화\n   - 시작 노드에서 실행되는 첫 번째 문장\n\n2. ② `a < m || b[a] < x`: while 루프 조건\n   - 반복문 진입 조건\n   - `||` 논리 연산자로, 둘 중 하나라도 참이면 루프 진입\n\n3. **③ `b[a] < 0`**: if 조건문\n   - 조건이 참이면 ④ 실행, 거짓이면 ⑤로 이동\n\n4. **④ `b[a] = -b[a];`**: 음수 값을 양수로 변환\n   - 조건부 실행 문장 (③이 참일 때만 실행)\n\n5. **⑤ `a++;`**: 변수 증가\n   - while 루프 내부에서 항상 실행\n   - 실행 후 ②로 돌아가서 조건 다시 확인\n\n6. **⑥ `return 1;`**: 함수 종료\n   - while 루프가 종료되면 실행\n\n[문장 커버리지 순서]\n\n모든 문장을 한 번씩 실행하려면:\n- ① → ② (루프 진입) → ③ (조건 참) → ④ → ⑤ → ② (조건 확인 후 종료) → ⑥\n\n[실행 경로]\n- ①: `a = 0` 초기화\n- ②: `a < m || b[a] < x` 조건 확인 (진입 조건 충족)\n- ③: `b[a] < 0` 조건 확인 (참이라고 가정)\n- ④: `b[a] = -b[a]` 실행 (음수를 양수로 변환)\n- ⑤: `a++` 실행 (a 증가)\n- ②: 다시 조건 확인 (이번에는 거짓으로 가정하여 루프 종료)\n- ⑥: `return 1` 실행\n\n[답]\n- (1) int a = 0\n- (2) a < m || b[a] < x\n- (3) b[a] < 0\n- (4) b[a] = -b[a];\n- (5) a++;\n- (6) return 1;\n- (7) ③ → ④ → ⑤ → ② → ⑥", "table_refs": [], "image_refs": ["images/2025_round1/Q015_1.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [{"language": "unknown", "code": "int Main(int b[], int m, int x) {\n    int a = 0;\n    while (a < m || b[a] < x) {\n        if (b[a] < 0)\n            b[a] = -b[a];\n        a++;\n    }\n    return 1;\n}", "line_numbers": [1, 9], "file": "data/codes/2025_round1/Q015_code.txt"}], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["unknown"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "(\n\n①    )\n\n2. (    ②    )\n\n3. (    ③    )\n\n4. (    ④    )    5. (    ⑤    )  6. (    ⑥    )\n문장 커버리지 순서 1 → 2\n→ (          ⑦           )", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n[세션 하이재킹의 정의와 개념]\n\n1. **기본 정의**: 세션 하이재킹은 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.\n\n2. **세션이란**: 세션은 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.\n\n[TCP 세션 하이재킹]\n\n1. **3-way 핸드셰이크**: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.\n- 클라이언트가 서버에 SYN 패킷 전송\n- 서버가 SYN-ACK 패킷 응답\n- 클라이언트가 ACK 패킷 전송 이 과정이 완료되면 정상적인 통신이 시작됩니다.\n\n2. **공격 과정**:\n- 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.\n- TCP 시퀀스 번호를 예측하거나 조작합니다.\n- 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.\n- 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.\n\n**문제 해석**: 문제에서 '세션을 가로채다', 'TCP 3-way 핸드셰이크', '시퀀스 번호 조작', '인증 없이 통신 탈취' 등의 키워드가 언급되어 있으므로 답은 \"세션 하이재킹\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 문제는 **Java 재귀 함수와 분할 정복**을 이해하는 문제입니다.\n\n[코드 분석]\n\n```java\nint[] data = {3, 5, 8, 12, 17};\nSystem.out.println(func(data, 0, data.length - 1));\n\nstatic int func(int[] a, int st, int end) {\n    if (st >= end) return 0;\n    int mid = (st + end) / 2;\n    return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n}\n```\n\n[재귀 호출 추적]\n\n[func(data, 0, 4) 호출]\n- `st = 0`, `end = 4`\n- `mid = (0 + 4) / 2 = 2`\n- `a[2] = 8`\n- `return 8 + Math.max(func(data, 0, 2), func(data, 3, 4))`\n\n[왼쪽 재귀: func(data, 0, 2)]\n- `st = 0`, `end = 2`\n- `mid = 1`\n- `a[1] = 5`\n- `return 5 + Math.max(func(data, 0, 1), func(data, 2, 2))`\n\n  - [func(data, 0, 1)]\n    - `st = 0`, `end = 1`\n    - `mid = 0`\n    - `a[0] = 3`\n    - `return 3 + Math.max(func(data, 0, 0), func(data, 1, 1))`\n      - `func(data, 0, 0)`: `st >= end` → **0 반환**\n      - `func(data, 1, 1)`: `st >= end` → **0 반환**\n    - `return 3 + Math.max(0, 0) = 3`\n\n  - [func(data, 2, 2)]\n    - `st >= end` → **0 반환**\n\n  - `return 5 + Math.max(3, 0) = 5 + 3 = 8`\n\n[오른쪽 재귀: func(data, 3, 4)]\n- `st = 3`, `end = 4`\n- `mid = 3`\n- `a[3] = 12`\n- `return 12 + Math.max(func(data, 3, 3), func(data, 4, 4))`\n  - `func(data, 3, 3)`: `st >= end` → **0 반환**\n  - `func(data, 4, 4)`: `st >= end` → **0 반환**\n- `return 12 + Math.max(0, 0) = 12`\n\n[최종 계산]\n- `func(data, 0, 4) = 8 + Math.max(8, 12) = 8 + 12 = 20`\n\n[답] \"20\"", "table_refs": [], "image_refs": ["images/2025_round1/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void main(String[] args) {\n        int[] data = {3, 5, 8, 12, 17};\n        System.out.println(func(data, 0, data.length - 1));\n    }\n    static int func(int[] a, int st, int end) {\n        if (st >= end) return 0;\n        int mid = (st + end) / 2;\n        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n    } \n}", "line_numbers": [1, 11], "file": "data/codes/2025_round1/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["13"], "raw_text": "13"}, "explanation": "이미지의 Python 코드는 이진 트리를 구성하고 홀수 레벨의 노드 값만 합산하는 문제입니다.\n\n[코드 실행 단계]\n\n1. [트리 구성]\n```python\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\n```\n- `tree()` 함수는 리스트를 이진 트리로 변환합니다.\n- `nodes[(i - 1) // 2].children.append(nodes[i])`: 부모 인덱스 계산\n- i=1: 부모=(1-1)//2=0 → nodes[0].children에 nodes[1] 추가\n- i=2: 부모=(2-1)//2=0 → nodes[0].children에 nodes[2] 추가\n- i=3: 부모=(3-1)//2=1 → nodes[1].children에 nodes[3] 추가\n- i=4: 부모=(4-1)//2=1 → nodes[1].children에 nodes[4] 추가\n- i=5: 부모=(5-1)//2=2 → nodes[2].children에 nodes[5] 추가\n- i=6: 부모=(6-1)//2=2 → nodes[2].children에 nodes[6] 추가\n\n[트리 구조]\n```\n       3 (level 0)\n      / \\\n     5   8 (level 1)\n    / \\ / \\\n  12 15 18 21 (level 2)\n```\n\n2. [calc() 함수 실행]\n```python\ndef calc(node, level=0):\n    if node is None:\n        return 0\n    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\n```\n- [핵심] `level % 2 == 1`일 때만 노드 값을 더합니다.\n- level이 홀수(1, 3, 5...)일 때만 노드 값을 합산\n- level이 짝수(0, 2, 4...)일 때는 0을 더합니다.\n\n[계산 과정]\n- [level 0 (루트)] 노드 3 → level % 2 == 0 → **0 추가**\n- [level 1] 노드 5, 8 → level % 2 == 1 → **5 + 8 = 13 추가**\n- [level 2] 노드 12, 15, 18, 21 → level % 2 == 0 → **0 추가**\n\n[최종 결과] 0 + 13 + 0 = **13**\n\n[답] 13", "table_refs": [], "image_refs": ["images/2025_round1/Q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [{"language": "python", "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\ndef tree(li):\n    nodes = [Node(i) for i in li]\n    for i in range(1, len(li)):\n        nodes[(i - 1) // 2].children.append(nodes[i])\n    return nodes[0]\ndef calc(node, level=0):\n    if node is None:\n        return 0\n    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\nprint(calc(root))", "line_numbers": [1, 16], "file": "data/codes/2025_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.\n19.다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["35421"], "raw_text": "35421"}, "explanation": "이 C언어 코드는 연결 리스트에 노드를 삽입하고 특정 값을 가진 노드를 맨 앞으로 이동시키는 문제입니다.\n\n[코드 실행 단계]\n\n1. [insert() 함수로 리스트 생성]\n```c for (int i = 1; i <= 5; i++)\nhead = insert(head, i);\n```\n- `insert()`는 새 노드를 리스트의 맨 앞에 추가합니다 (역순으로 저장됨).\n- i=1: head = 1 → NULL\n- i=2: head = 2 → 1 → NULL\n- i=3: head = 3 → 2 → 1 → NULL\n- i=4: head = 4 → 3 → 2 → 1 → NULL\n- i=5: head = 5 → 4 → 3 → 2 → 1 → NULL\n\n[최종 리스트] 5 → 4 → 3 → 2 → 1 → NULL\n\n2. [reconnect() 함수 실행]\n```c head = reconnect(head, 3);\n```\n- `reconnect()`는 값이 3인 노드를 찾아서 리스트의 맨 앞으로 이동시킵니다.\n- 현재 리스트: 5 → 4 → 3 → 2 → 1 → NULL\n- 값 3인 노드를 찾고, 그 노드를 제거한 후 맨 앞에 다시 삽입합니다.\n\n[reconnect 과정]\n- curr가 3인 노드를 찾음\n- prev(4)의 next를 curr(3)의 next(2)로 연결\n- curr(3)의 next를 현재 head(5)로 설정\n- head를 curr(3)으로 변경\n\n[결과 리스트] 3 → 5 → 4 → 2 → 1 → NULL\n\n3. [출력]\n```c for (curr = head; curr != NULL; curr = curr->next)\nprintf(\"%d\", curr->value);\n```\n- 순서대로: 3, 5, 4, 2, 1\n- **출력: \"35421\"[답] \"35421\"", "table_refs": [], "image_refs": ["images/2025_round1/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>   \n#include <stdlib.h>  \ntypedef struct Data {\n    int value;\n    struct Data *next;\n} Data;\nData* insert(Data* head, int value) {\n    Data* new_node = (Data*)malloc(sizeof(Data));\n    new_node->value = value;\n    new_node->next = head;\n    return new_node;\n}\nData* reconnect(Data* head, int value) {\n    if (head == NULL || head->value == value) return head;\n    Data *prev = NULL, *curr = head;\n    while (curr != NULL && curr->value != value) {\n        prev = curr;\n        curr = curr->next;\n    }\n    if (curr != NULL && prev != NULL) {\n        prev->next = curr->next;\n        curr->next = head;\n        head = curr;\n    }\n    return head;\n}\nint main() {\n    Data *head = NULL, *curr;\n    for (int i = 1; i <= 5; i++)\n        head = insert(head, i);\n    head = reconnect(head, 3);\n    for (curr = head; curr != NULL; curr = curr->next)\n        printf(\"%d\", curr->value);\n    return 0; \n}", "line_numbers": [1, 35], "file": "data/codes/2025_round1/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이미지의 Java 코드는 메서드 오버로딩과 재귀 함수를 결합한 문제입니다.\n\n[코드 분석]\n\n```java\npublic static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n}\n\nstatic int calc(int value) {\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 2);\n}\n\nstatic int calc(String str) {\n    int value = Integer.valueOf(str);\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 3);\n}\n```\n\n[핵심 개념]\n\n1. [메서드 오버로딩]\n   - `calc(int value)`: 파라미터가 int형\n   - `calc(String str)`: 파라미터가 String형\n   - 같은 이름이지만 파라미터 타입이 다른 두 메서드\n\n2. [메서드 호출 과정]\n   - `calc(\"5\")` → String 타입이므로 `calc(String str)` 호출\n   - 내부에서 `calc(int value)` 호출 가능\n\n[실행 과정]\n\n1. [`calc(\"5\")` 호출] (String 버전)\n   - `value = Integer.valueOf(\"5\") = 5`\n   - `value > 1`이므로 재귀 호출\n   - `return calc(5-1) + calc(5-3)` = `calc(4) + calc(2)`\n   - 여기서 int 타입으로 호출되므로 `calc(int)` 버전 실행\n\n2. [`calc(4)` 계산] (int 버전 - 피보나치 패턴)\n   - `return calc(3) + calc(2)`\n   \n   [calc(3)]\n   - `return calc(2) + calc(1)`\n   - calc(2): `return calc(1) + calc(0)` = 1 + 0 = **1**\n   - calc(1): `return 1`\n   - calc(3) = 1 + 1 = **2**\n   \n   [calc(2)]\n   - `return calc(1) + calc(0)` = 1 + 0 = **1**\n   \n   **calc(4) = 2 + 1 = 3**\n\n3. [`calc(2)` 계산] (int 버전)\n   - `return calc(1) + calc(0)` = 1 + 0 = **1**\n\n4. [최종 결과]\n   - `calc(4) + calc(2)` = 3 + 1 = **4**\n\n[정리]\n- String 버전: `calc(value - 1) + calc(value - 3)` (간격이 1과 3)\n- int 버전: `calc(value - 1) + calc(value - 2)` (피보나치, 간격이 1과 2)\n- 메서드 오버로딩으로 서로 다른 재귀 패턴 사용\n\n[답] 4", "table_refs": [], "image_refs": ["images/2025_round1/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:27:19.038526"}, "code_blocks": [{"language": "java", "code": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n  }\n}\n\nstatic int calc(int value) {\n  if (value <= 1) return value;\n  return calc(value - 1) + calc(value - 2);\n}\n\nstatic int calc(String str) {\n  int value = Integer.valueOf(str);\n  if (value <= 1) return value;\n  return calc(value - 1) + calc(value - 3);\n}", "line_numbers": [1, 16], "file": "data/codes/2025_round1/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 파일 구조와 관련된 설명이다.\n설명을 읽고 괄호 안에 들어갈 가장 알맞은 용어를 작성하시오\n.\n데이터베이스의 물리 설계 시\n,\n레코드에 접근하는 방법은 순차 접근 방법\n, [\n]\n방법\n,\n해싱 방법 등이 있다\n.\n이 중\n[\n]\n방법은 레코드의 키 값과 포인터를 쌍으로 묶어 저장하며 검색 시 키 값을 기준으로 빠르게 탐색할 수 있도록 설계되어 있다\n.\n이 방식은 검색 속도가 빠르며\n<\n키 값\n,\n포인터\n>\n쌍으로 구성된 자료 구조를 사용하여 해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다\n.", "choices": [], "answer": {"keys": ["인덱스"], "raw_text": "인덱스"}, "explanation": "인덱스(Index)는 데이터베이스의 물리적 저장 구조에서 레코드를 빠르게 검색하기 위한 방법입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. [\"레코드에 접근하는 방법\"]\n- 데이터베이스 물리 설계 시 레코드에 접근하는 방법에는 순차 접근 방법, 인덱스 방법, 해싱 방법 등이 있습니다.\n- 인덱스 방법은 이 중 하나로, 빠른 검색을 위해 사용됩니다.\n\n2. [\"레코드의 키 값과 포인터를 쌍으로 묶어 저장\"]\n- 인덱스는 각 레코드의 키 값(예: 학번, 사원번호 등)과 해당 레코드가 실제로 저장된 주소(포인터)를 쌍으로 저장합니다.\n- 예를 들어, 키 값이 \"2024001\"이면 해당 레코드가 저장된 메모리 주소를 함께 저장합니다.\n\n3. [\"검색 시 키 값을 기준으로 빠르게 탐색\"]\n- 순차 접근 방법은 처음부터 끝까지 모든 레코드를 확인해야 하지만, 인덱스를 사용하면 키 값만으로 바로 해당 레코드의 위치를 찾을 수 있습니다.\n- 인덱스는 보통 정렬되어 저장되므로 이진 탐색 등의 효율적인 알고리즘을 사용할 수 있습니다.\n\n4. [\"<키 값, 포인터> 쌍으로 구성된 자료 구조\"]\n- 인덱스는 각 항목을 <키 값, 포인터> 쌍의 형태로 저장합니다.\n- 이 자료 구조를 통해 키 값만 알면 바로 해당 레코드의 위치를 찾을 수 있습니다.\n\n5. [\"해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다\"]\n- 인덱스에서 키 값을 찾으면, 그에 대응하는 포인터(주소)를 얻을 수 있습니다.\n- 이 포인터를 사용하여 데이터베이스에서 해당 레코드를 직접 접근할 수 있습니다.\n\n[왜 인덱스인가]\n- 문제에서 설명하는 모든 특징(키 값과 포인터 쌍, 빠른 검색, 직접 접근)이 인덱스의 정의와 정확히 일치합니다.\n- 순차 접근 방법은 처음부터 순서대로 찾아가는 방식이고, 해싱 방법은 해시 함수를 사용하는 방식이므로 문제 설명과 일치하지 않습니다.\n\n[답] 문제에서 설명하는 모든 특징이 인덱스 방법과 정확히 일치하므로 답은 \"인덱스\"입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.224251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["데이터베이스"], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 데이터베이스 릴레이션의 구성 요소 중 하나에 대한 설명이다.\n설명을 읽고 보기에서 알맞은 기호를 골라 작성하시오\n.\n릴레이션\n(Relation)\n에서 열\n(Column)\n을 의미하며 데이터 항목의 속성\n(Attribute)\n또는 특성을 나타낸다\n.\n각 열은 고유한 이름을 가지며 특정 도메인\n(Domain)\n에서 정의된 값을 갖는다\n.\n예를 들어\n\"\n학생\n\"\n릴레이션에서 학번\n,\n이름\n,\n전공 등은 각각 하나의 열이며 이 열들은 학생의 고유한 속성을 나타낸다\n.\n이 개념은 파일 구조에서의 필드\n(Field)\n에 해당하며 릴레이션에서 행\n(Row, Tuple)\n의 구성 요소가 된다\n.\nㄱ\n. Cardinality\nㄷ\n. Attribute", "choices": [], "answer": {"keys": ["ㄷ"], "raw_text": "ㄷ"}, "explanation": "이 문제는 데이터베이스 릴레이션의 구성 요소 중 Attribute(속성)를 설명하는 문제입니다.\n\n[문제에서 설명하는 각 특징을 하나씩 분석]\n\n1. \"릴레이션에서 열(Column)을 의미\"\n- 릴레이션은 관계형 데이터베이스에서 테이블을 의미합니다.\n- 열(Column)은 테이블의 세로 방향 구조로, 데이터의 한 가지 특성을 나타냅니다.\n- Attribute는 이 열(Column)과 동일한 개념입니다.\n\n2. \"데이터 항목의 속성(Attribute) 또는 특성을 나타낸다\"\n- 각 Attribute는 데이터 항목이 가지고 있는 특성을 정의합니다.\n- 예를 들어, 사람에 대한 속성으로는 이름, 나이, 주소 등이 있습니다.\n\n3. \"각 열은 고유한 이름을 가지며 특정 도메인(Domain)에서 정의된 값을 갖는다\"\n- 각 Attribute는 유일한 이름(예: 학번, 이름, 전공)을 가집니다.\n- 도메인(Domain)은 그 Attribute에 입력될 수 있는 값의 범위를 의미합니다.\n- 예를 들어, 나이 Attribute는 0 이상의 정수만 입력 가능한 도메인을 가질 수 있습니다.\n\n4. 예시: \"학생\" 릴레이션에서 학번, 이름, 전공 등은 각각 하나의 열\n- 학번 열: 학생의 고유 번호를 나타내는 Attribute\n- 이름 열: 학생의 이름을 나타내는 Attribute\n- 전공 열: 학생의 전공 분야를 나타내는 Attribute\n- 이들은 모두 학생이라는 엔티티의 서로 다른 속성을 나타냅니다.\n\n5. \"파일 구조에서의 필드(Field)에 해당\"\n- 파일 구조에서 필드는 데이터의 한 단위를 의미합니다.\n- 데이터베이스의 Attribute는 파일 구조의 필드와 동일한 역할을 합니다.\n- 둘 다 데이터의 특성을 저장하는 단위입니다.\n\n6. \"릴레이션에서 행(Row, Tuple)의 구성 요소\"\n- 한 행(튜플)은 여러 Attribute 값들로 구성됩니다.\n- 예를 들어, 한 학생의 행은 (학번: 2024001, 이름: \"홍길동\", 전공: \"컴퓨터공학\") 형태입니다.\n- 여기서 각 값(2024001, \"홍길동\", \"컴퓨터공학\")은 해당 Attribute의 실제 값입니다.\n\n[보기 분석]\n- ㄱ. Cardinality(카디널리티): 릴레이션에서 튜플(행)의 개수를 의미합니다. 문제에서 설명하는 \"열\"과는 반대로 \"행의 개수\"를 의미하므로 문제 설명과 일치하지 않습니다.\n- ㄷ. Attribute(속성): 문제에서 설명하는 모든 특징(열, 속성, 고유한 이름, 도메인, 필드에 해당, 행의 구성 요소)이 Attribute의 정의와 정확히 일치합니다.\n\n[결론] 문제에서 설명하는 모든 특징이 Attribute의 정의와 완전히 일치하므로 답은 \"ㄷ\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 정보보안 관련 문제이다.\n아래 내용을 보고\n\n알맞는 단어를 작성하시오.\n원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공하는 보안 접속용 프로토콜이다\n.\n공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원한다\n.\n주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는 22 번이다\n.\nTelnet 의 보안 취약점을 보완한 대안으로 널리 사용된다\n.", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "SSH(Secure Shell)는 원격 접속을 위한 보안 프로토콜입니다.\n\n[문제에서 설명한 특징과 정확히 매칭]\n\n1. \"원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공\"\n- SSH는 네트워크를 통해 원격 컴퓨터에 안전하게 접속하기 위해 사용됩니다.\n- 모든 통신 데이터를 암호화하여 전송하므로 네트워크상에서 가로채더라도 내용을 알 수 없습니다.\n- 이는 평문으로 통신하는 Telnet의 보안 취약점을 해결한 것입니다.\n\n2. \"공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원\"\n- SSH는 공개키 암호화 방식을 사용하여 사용자를 인증합니다.\n- 공개키-개인키 쌍을 사용하므로 비밀번호보다 더 안전한 인증이 가능합니다.\n- 모든 데이터가 암호화되어 전송되므로 기밀성이 보장됩니다.\n\n3. \"주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는 22번\"\n- SSH는 주로 서버 관리자가 원격으로 서버에 접속하여 명령을 실행할 때 사용됩니다.\n- SSH의 표준 포트 번호는 22번입니다. 이는 SSH를 식별하는 중요한 특징 중 하나입니다.\n- 포트 번호 22번은 IANA(Internet Assigned Numbers Authority)에서 SSH에 할당한 공식 포트입니다.\n\n4. \"Telnet의 보안 취약점을 보완한 대안으로 널리 사용된다\"\n- Telnet은 모든 데이터를 평문으로 전송하므로 네트워크상에서 비밀번호 등 중요한 정보가 노출될 위험이 있습니다.\n- SSH는 이러한 보안 취약점을 해결하기 위해 개발되었으며, 현재 원격 접속의 표준 프로토콜로 널리 사용됩니다.\n\n[답] 문제에서 설명한 모든 특징(원격 접속, 암호화된 통신, 공개키 인증, 포트 22번, Telnet의 대안)이 SSH와 정확히 일치하므로 답은 \"SSH\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "스케줄링 알고리즘에 관한 다음 설명을 읽고\n\n(1)\n과\n(2)\n에 알맞은 스케줄링 알고리즘의 명칭을 각각 쓰시오\n.\n\n(1) CPU burst 시간이 짧은 프로세스를 우선적으로 처리하는 스케줄링 방식이다\n.\n\"Shortest Next CPU Burst\"\n라고도 불리며 선점형 또는 비선점형으로 구현될 수 있다\n.\n(2)\n위의 스케줄링 방식을 선점형으로 구현한 형태로 실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU 를 선점한다\n.", "choices": [], "answer": {"keys": ["(1) SJF", "(2) SRT"], "raw_text": "(1) SJF\n(2) SRT"}, "explanation": "이 문제는 운영체제의 CPU 스케줄링 알고리즘인 SJF(Shortest Job First)와 SRT(Shortest Remaining Time)에 관한 문제입니다.\n\n[문제 분석]\n\n[(1)에 해당하는 스케줄링 알고리즘]\n- \"CPU burst 시간이 짧은 프로세스를 우선적으로 처리\": CPU를 사용하는 시간이 짧은 프로세스를 먼저 실행합니다.\n- \"Shortest Next CPU Burst라고도 불림\": 다음에 실행될 CPU burst 시간이 가장 짧은 프로세스를 선택합니다.\n- \"선점형 또는 비선점형으로 구현될 수 있다\": 프로세스를 중간에 중단시킬 수 있는 선점형으로도, 그렇지 않은 비선점형으로도 구현 가능합니다.\n\n이 특징들은 SJF(Shortest Job First, 최단 작업 우선)와 정확히 일치합니다.\n\n[(2)에 해당하는 스케줄링 알고리즘]\n- \"위의 스케줄링 방식을 선점형으로 구현한 형태\": SJF를 선점형으로 구현한 것입니다.\n- \"실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU를 선점\": 현재 실행 중인 프로세스가 5ms가 남았는데, 2ms만 필요한 새로운 프로세스가 도착하면 기존 프로세스를 중단하고 새로운 프로세스를 실행합니다.\n\n이 특징은 SRT(Shortest Remaining Time, 최단 잔여 시간 우선)와 정확히 일치합니다.\n\n[SJF와 SRT의 차이]\n- SJF는 비선점형이 기본이지만 선점형으로도 구현 가능합니다.\n- SRT는 SJF의 선점형 버전으로, 실행 중인 프로세스의 남은 시간을 고려하여 더 짧은 작업이 도착하면 즉시 선점합니다.\n\n[답] (1) SJF, (2) SRT", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 Java의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["BB"], "raw_text": "BB"}, "explanation": "이미지의 Java 코드는 배열 참조 전달과 String 파라미터 전달의 차이를 보여주는 문제입니다.\n\n[코드 분석]\n\n```java\nString data[] = { \"A\" };\nString s = \"B\";\nchange(data, s);\nSystem.out.print(data[0] + s);\n\npublic static void change(String[] data, String s) {\n    data[0] = s;\n    s = \"Z\";\n}\n```\n\n[핵심 개념]\n- Java는 참조 타입(reference type)과 기본 타입(primitive type)을 다르게 처리합니다.\n- 배열은 참조 타입이므로, 배열 참조가 전달되면 같은 배열 객체를 가리킵니다.\n- String도 참조 타입이지만, 메서드 내부에서 파라미터에 새로운 값을 할당하면 원본 변수에는 영향이 없습니다.\n\n[실행 과정]\n\n1. [초기 상태]\n   - `data[] = { \"A\" }` (배열 참조)\n   - `s = \"B\"` (String 참조)\n\n2. [`change(data, s)` 호출]\n   - `data` 파라미터: 배열 참조가 전달됨 (같은 배열 객체를 가리킴)\n   - `s` 파라미터: String 참조 \"B\"가 전달됨\n\n3. [메서드 내부 실행]\n   - `data[0] = s;` → `data[0] = \"B\"` (배열의 첫 번째 요소가 \"B\"로 변경됨)\n     - **원본 배열이 변경됨** (참조 타입이므로)\n   - `s = \"Z\";` → 메서드 내부의 파라미터 `s`만 \"Z\"로 변경됨\n     - **원본 변수 `s`는 변경되지 않음** (새로운 참조를 할당했을 뿐)\n\n4. [메서드 종료 후]\n   - `data[0] = \"B\"` (메서드에서 변경된 값 유지)\n   - `s = \"B\"` (원본 변수는 변경되지 않음)\n\n5. [출력]\n   - `data[0] + s = \"B\" + \"B\" = \"BB\"`\n\n[정리]\n- 배열은 참조 타입이므로 메서드에서 배열 요소를 수정하면 원본 배열이 변경됩니다.\n- String도 참조 타입이지만, 메서드 내부에서 파라미터에 새로운 값을 할당하면 그 값은 메서드 내부에서만 유효하고 원본 변수에는 영향이 없습니다.\n\n[답] \"BB\"", "table_refs": [{"id": "table1", "json": "data/tables/2025_round2/Q005_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2025_round2/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void change(String[] data, String s){\n        data[0] = s;\n        s = \"Z\";\n    }\n    public static void main(String[] args) {\n        String data[] = { \"A\" };\n        String s = \"B\";\n        change(data, s);\n        System.out.print(data[0] + s);\n    }\n}", "line_numbers": [1, 12], "file": "data/codes/2025_round2/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 IP 주소와 서브넷 마스크에 관한 문제이다.\n주어진 정보를 참고하여\n\n괄호 안에 들어갈 알맞은 값을 쓰시오\n.\n호스트의 IP 주소가 223.13.234.132 이고 서브넷 마스크가 255.255.255.192 일 때 다음 물음에 답하시오\n.\n이 호스트가 속한 네트워크 주소는 223.13.234.(\n\n①\n)\n이다\n.\n이 네트워크에서 사용 가능한 호스트 수는\n(\n②\n)\n개이다\n.\n(\n단\n,\n네트워크 주소와 브로드캐스트 주소는 제외한다\n.)", "choices": [], "answer": {"keys": ["① 128", "② 62"], "raw_text": "① 128\n② 62"}, "explanation": "이 문제는 IP 주소와 서브넷 마스크를 사용하여 네트워크 주소와 사용 가능한 호스트 수를 계산하는 문제입니다.\n\n[주어진 정보]\n- 호스트 IP 주소: 223.13.234.132\n- 서브넷 마스크: 255.255.255.192\n\n[① 네트워크 주소 계산]\n\n서브넷 마스크 255.255.255.192를 이진수로 변환하면:\n- 255.255.255.192 = 11111111.11111111.11111111.11000000\n\n마지막 옥텟(8비트)에서:\n- 192 = 11000000 (2진수)\n- 서브넷 비트 수: 2개 (앞의 두 개 1)\n- 호스트 비트 수: 6개 (뒤의 여섯 개 0)\n\n네트워크 주소를 계산하려면 IP 주소와 서브넷 마스크를 AND 연산:\n- IP: 223.13.234.132 = 11011111.00001101.11101010.10000100\n- 마스크: 255.255.255.192 = 11111111.11111111.11111111.11000000\n- AND 결과: 223.13.234.128\n\n따라서 네트워크 주소는 223.13.234.**128**입니다.\n\n[② 사용 가능한 호스트 수 계산]\n\n호스트 비트 수가 6개이므로:\n- 사용 가능한 주소: 2^6 = 64개\n- 하지만 네트워크 주소와 브로드캐스트 주소는 사용할 수 없으므로:\n- 실제 사용 가능한 호스트 수: 64 - 2 = **62개[답] ① 128, ② 62", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 디자인 패턴에 관한 문제이다.\n아래 내용을 보고\n\n알맞는 단어를 작성하시오.\n어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용하는 방식의 디자인 패턴이다\n.\n실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시켜 메모리와 자원을 절약할 수 있 다\n.\n또한\n,\n실제 객체를 감추어 정보은닉을 강화할 수 있다는 장점이 있다\n.", "choices": [], "answer": {"keys": ["Proxy"], "raw_text": "Proxy"}, "explanation": "Proxy(프록시) 패턴은 객체지향 디자인 패턴 중 하나로, 실제 객체에 대한 접근을 제어하는 패턴입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용\"\n- 프록시는 실제 객체를 직접 접근하지 않고, 프록시 객체를 통해 간접적으로 접근합니다.\n- 프록시는 실제 객체의 대리인 역할을 하며, 클라이언트는 프록시를 실제 객체처럼 사용합니다.\n\n2. \"실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시킬 수 있다\"\n- 프록시는 실제 객체를 생성하기 전에 필요한 사전 작업(인증, 로깅 등)을 수행할 수 있습니다.\n- 실제 객체는 필요할 때까지 생성하지 않고 지연시키므로(Lazy Loading) 메모리와 자원을 절약할 수 있습니다.\n- 예를 들어, 이미지나 대용량 파일을 실제로 사용할 때까지 로드하지 않아 메모리를 절약합니다.\n\n3. \"실제 객체를 감추어 정보은닉을 강화할 수 있다\"\n- 클라이언트는 실제 객체를 직접 접근하지 않고 프록시를 통해서만 접근하므로, 실제 객체의 내부 구조를 숨길 수 있습니다.\n- 이를 통해 보안을 강화하고, 실제 객체의 구현 세부사항을 감출 수 있습니다.\n\n[프록시 패턴의 활용 예시]\n- 가상 프록시(Virtual Proxy): 무거운 객체를 지연 로딩\n- 원격 프록시(Remote Proxy): 네트워크를 통해 원격 객체에 접근\n- 보호 프록시(Protection Proxy): 접근 권한 제어\n\n[답] 문제에서 설명한 모든 특징(접근 제어, 대리 객체, 지연 생성, 정보은닉)이 Proxy 패턴과 정확히 일치하므로 답은 \"Proxy\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.042458"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음은 웹 데이터 교환 방식에 관한 문제이다.\n아래 설명을 읽고 괄호 안에 들어갈 알맞은 용어를 작성하시오\n.\n(\n)\n은\n/\n는 웹 페이지 전체를 다시 불러오지 않고 JavaScript 와 XML(\n또는 JSON)\n을 이용하여 일부 콘텐츠만 비동기적으로 갱신할 수 있는 기술이다\n.\n(\n)\n은\n/\n는 HTML 만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법이다\n.", "choices": [], "answer": {"keys": ["AJAX"], "raw_text": "AJAX"}, "explanation": "AJAX(Asynchronous JavaScript and XML)는 웹 페이지를 새로고침하지 않고 비동기적으로 데이터를 교환하는 웹 개발 기법입니다.\n\n[문제에서 설명하는 각 특징]\n\n1. \"웹 페이지 전체를 다시 불러오지 않고 JavaScript와 XML(또는 JSON)을 이용하여 일부 콘텐츠만 비동기적으로 갱신\"\n- 전통적인 웹 페이지는 사용자가 링크를 클릭하면 전체 페이지를 다시 서버에서 가져와서 화면을 다시 그려야 합니다.\n- AJAX를 사용하면 페이지의 일부 영역만 JavaScript를 통해 서버에서 데이터를 가져와서 업데이트할 수 있습니다.\n- 이 과정은 비동기적으로 이루어지므로, 사용자는 페이지를 기다리는 동안 다른 작업을 계속할 수 있습니다.\n- 데이터 형식으로는 XML이나 JSON을 주로 사용합니다.\n\n2. \"HTML만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법\"\n- HTML만으로는 정적인 페이지만 만들 수 있습니다.\n- AJAX는 JavaScript, XMLHttpRequest(또는 Fetch API) 등을 활용하여 동적인 상호작용을 가능하게 합니다.\n- 예를 들어, 검색어를 입력하면 자동완성 목록이 나타나거나, 댓글을 작성하면 새로고침 없이 바로 화면에 추가되는 등의 기능이 가능합니다.\n\n[AJAX의 장점]\n- 사용자 경험 향상: 페이지 전체 새로고침 없이 필요한 부분만 업데이트\n- 서버 부하 감소: 필요한 데이터만 요청하여 네트워크 트래픽 감소\n- 빠른 응답: 비동기 처리를 통해 사용자 인터페이스가 블로킹되지 않음\n\n[답] 문제에서 설명한 모든 특징(비동기 갱신, JavaScript와 XML/JSON 사용, 동적 기능, 상호작용)이 AJAX와 정확히 일치하므로 답은 \"AJAX\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["프로그래밍"], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["19"], "raw_text": "19"}, "explanation": "이미지의 Java 코드는 람다 표현식으로 함수형 인터페이스를 구현하고 예외 처리하는 문제입니다.\n\n[코드 분석]\n\n```java\nstatic interface F {\n    int apply(int x) throws Exception;\n}\n\npublic static int run(F f) {\n    try {\n        return f.apply(3);\n    } catch (Exception e) {\n        return 7;\n    }\n}\n\nF f = (x) -> {\n    if (x > 2) {\n        throw new Exception();\n    }\n    return x * 2;\n};\n\nSystem.out.print(run(f) + run((int n) -> n + 9));\n```\n\n[핵심 개념]\n- `F` 인터페이스는 `apply(int x)` 메서드를 정의하며, 예외를 던질 수 있습니다.\n- `run` 메서드는 `F` 타입의 함수를 받아 실행하고, 예외가 발생하면 7을 반환합니다.\n- 람다 표현식 `(x) -> { ... }`는 함수형 인터페이스 `F`를 구현합니다.\n\n[실행 과정]\n\n1. [`F f` 람다 함수 정의]\n   - `f = (x) -> { if (x > 2) throw new Exception(); return x * 2; }`\n   - x가 2보다 크면 예외를 발생시키고, 그렇지 않으면 `x * 2`를 반환합니다.\n\n2. [첫 번째 `run(f)` 호출]\n   - `run` 메서드 내부에서 `f.apply(3)` 실행\n   - `x = 3`이므로 `x > 2` 조건이 **참**입니다.\n   - `throw new Exception()`이 실행되어 예외가 발생합니다.\n   - `run` 메서드의 `catch (Exception e)` 블록이 예외를 잡아서 **7을 반환**합니다.\n   - **결과: `run(f) = 7`**\n\n3. [두 번째 `run((int n) -> n + 9)` 호출]\n   - 새로운 람다 함수 `(int n) -> n + 9`가 전달됩니다.\n   - 이 함수는 예외를 발생시키지 않는 일반적인 함수입니다.\n   - `run` 메서드 내부에서 `f.apply(3)` 실행 (여기서 `f`는 전달된 람다 함수)\n   - `n = 3`이므로 `3 + 9 = 12`를 반환합니다.\n   - 예외가 발생하지 않으므로 `try` 블록이 정상적으로 실행됩니다.\n   - 결과: `run((int n) -> n + 9) = 12`\n\n4. [최종 출력]\n   - `run(f) + run((int n) -> n + 9) = 7 + 12 = 19`\n   - `System.out.print(19)` 실행\n\n[정리]\n- 람다 표현식에서 조건에 따라 예외를 발생시킬 수 있습니다.\n- `run` 메서드는 try-catch 블록으로 예외를 처리하고, 예외 발생 시 7을 반환합니다.\n- 두 개의 서로 다른 람다 함수가 각각 다른 결과를 반환합니다.\n\n[답] 19", "table_refs": [], "image_refs": ["images/2025_round2/Q009.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    static interface F {\n        int apply(int x) throws Exception;\n    }\n    public static int run(F f) {\n        try {\n            return f.apply(3);\n        } catch (Exception e) {\n            return 7;\n        }\n    }\n    public static void main(String[] args) {\n        F f = (x) -> {\n            if (x > 2) {\n                throw new Exception();\n            }\n            return x * 2;\n        };\n        System.out.print(run(f) + run((int n) -> n + 9));\n    }\n}", "line_numbers": [1, 21], "file": "data/codes/2025_round2/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5P"], "raw_text": "5P"}, "explanation": "이 문제는 Java 메서드 오버라이딩, 오버로딩, 정적 메서드를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java\nParent ref = new Child();\nSystem.out.println(ref.x(2) + ref.id());\n\nclass Parent {\n    public int x(int i) { return i + 2; }        // 인스턴스 메서드\n    public static String id() { return \"P\"; }   // 정적 메서드\n}\n\nclass Child extends Parent {\n    public int x(int i) { return i + 3; }        // 오버라이딩\n    public String x(String s) { return s + \"R\"; } // 오버로딩\n    public static String id() { return \"C\"; }   // 정적 메서드 숨김\n}\n```\n\n[핵심 개념]\n\n1. [메서드 오버라이딩 (Method Overriding)]\n   - `Parent.x(int)`와 `Child.x(int)`는 오버라이딩 관계입니다.\n   - **실제 객체 타입**에 따라 메서드가 호출됩니다.\n   - `ref`는 `Child` 객체이므로 `Child.x(int)`가 호출됩니다.\n\n2. [정적 메서드 (Static Method)]\n   - `Parent.id()`와 `Child.id()`는 정적 메서드입니다.\n   - 정적 메서드는 **참조 변수의 타입**에 따라 호출됩니다 (오버라이딩되지 않음).\n   - `ref`의 타입이 `Parent`이므로 `Parent.id()`가 호출됩니다.\n\n[실행 과정]\n\n1. [`ref.x(2)` 호출]\n   - `ref`의 실제 타입은 `Child`이므로 `Child.x(int)` 메서드가 호출됩니다.\n   - `Child.x(2) = 2 + 3 = 5`\n   - 반환값: **5**\n\n2. [`ref.id()` 호출]\n   - `ref`의 선언 타입은 `Parent`이므로 `Parent.id()` 정적 메서드가 호출됩니다.\n   - 정적 메서드는 오버라이딩되지 않고, 참조 변수의 타입에 따라 결정됩니다.\n   - 반환값: **\"P\"**\n\n3. [출력]\n   - `5 + \"P\" = \"5P\"`\n\n[정리]\n- 인스턴스 메서드는 **실제 객체 타입**에 따라 호출됩니다 (동적 바인딩).\n- 정적 메서드는 **참조 변수의 타입**에 따라 호출됩니다 (정적 바인딩).\n\n[답] \"5P\"", "table_refs": [], "image_refs": ["images/2025_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [{"language": "java", "code": "public class Main{\n    public static class Parent {\n        public int x(int i) { return i + 2; }\n        public static String id() { return \"P\";}\n    }\n    public static class Child extends Parent {\n        public int x(int i) { return i + 3; }\n        public String x(String s) { return s + \"R\"; }\n        public static String id() { return \"C\"; }\n    }\n    public static void main(String[] args) {\n        Parent ref = new Child();\n        System.out.println(ref.x(2) + ref.id());\n    }\n}", "line_numbers": [1, 15], "file": "data/codes/2025_round2/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.", "choices": [], "answer": {"keys": ["1234561", "124567"], "raw_text": "1234561 124567"}, "explanation": "분기 커버리지(Branch Coverage)는 모든 분기(조건문의 각 경로)를 최소 한 번씩 실행하는 테스트 커버리지 기준입니다.\n\n[문제 이해]\n제어 흐름 그래프의 모든 분기(조건문의 True/False 경로)를 최소 한 번씩 실행하는 테스트 경로를 찾아야 합니다.\n\n[해결 방법]\n1. 그래프의 각 노드(1, 2, 3, 4, 5, 6, 7)를 식별합니다.\n2. 각 분기(조건문의 참/거짓 경로)를 모두 커버하는 경로를 찾습니다.\n3. 가능한 모든 분기를 포함하는 테스트 케이스 경로를 작성합니다.\n\n[답] 1234561, 124567\n- 첫 번째 경로(1234561): 노드 1→2→3→4→5→6→1로 돌아가는 경로와 루프를 포함\n- 두 번째 경로(124567): 노드 1→2→4→5→6→7 경로를 포함\n- 이 두 경로를 통해 그래프의 모든 분기를 커버할 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2 그리고 3"], "raw_text": "2 그리고 3"}, "explanation": "이 C언어 코드는 원형 큐(Circular Queue) 자료구조를 구현하고 사용하는 문제입니다.\n\n[코드 실행 단계]\n\n1. [초기 상태]\n```c Queue q = {{0}, 0, 0};\n```\n- 큐 구조체를 초기화: 배열 `a[] = {0, 0, 0}`, `front = 0`, `rear = 0`\n\n2. [`enq(&q, 1)` 실행]\n- `q->a[0] = 1` → 배열[0]에 1 저장\n- `q->rear = (0 + 1) % 3 = 1` → rear를 1로 이동\n- 상태: `a = {1, 0, 0}`, `front = 0`, `rear = 1`\n\n3. [`enq(&q, 2)` 실행]\n- `q->a[1] = 2` → 배열[1]에 2 저장\n- `q->rear = (1 + 1) % 3 = 2` → rear를 2로 이동\n- 상태: `a = {1, 2, 0}`, `front = 0`, `rear = 2`\n\n4. [`deq(&q)` 실행]\n- `val = q->a[0] = 1` → 배열[0]의 값 1을 가져옴\n- `q->front = (0 + 1) % 3 = 1` → front를 1로 이동\n- 상태: `a = {1, 2, 0}`, `front = 1`, `rear = 2`\n\n5. [`enq(&q, 3)` 실행]\n- `q->a[2] = 3` → 배열[2]에 3 저장\n- `q->rear = (2 + 1) % 3 = 0` → rear를 0으로 이동 (원형 큐 특성)\n- 상태: `a = {1, 2, 3}`, `front = 1`, `rear = 0`\n\n6. [`first = deq(&q)` 실행]\n- `val = q->a[1] = 2` → front 위치의 값 2를 가져옴\n- `q->front = (1 + 1) % 3 = 2` → front를 2로 이동\n- `first = 2`\n\n7. [`second = deq(&q)` 실행]\n- `val = q->a[2] = 3` → front 위치의 값 3을 가져옴\n- `q->front = (2 + 1) % 3 = 0` → front를 0으로 이동\n- `second = 3`\n\n[최종 출력] \"2 그리고 3\"\n\n[핵심 포인트]\n- 원형 큐는 배열의 마지막 인덱스 다음에 처음 인덱스로 돌아가는 구조입니다.\n- `% SIZE` 연산을 통해 원형 구조를 구현합니다.\n- front는 데이터를 꺼내는 위치, rear는 데이터를 넣는 위치입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#define SIZE 3\ntypedef struct {\n    int a[SIZE];\n    int front;\n    int rear;\n} Queue;\nvoid enq(Queue* q, int val){\n    q->a[q->rear] = val; \n    q->rear = (q->rear + 1) % SIZE;\n}\nint deq(Queue* q) {\n    int val = q->a[q->front];\n    q->front = (q->front + 1) % SIZE;\n    return val;\n}\nint main() {\n    Queue q = {{0}, 0, 0};\n    enq(&q,1); enq(&q,2); deq(&q); enq(&q, 3);\n    int first = deq(&q);\n    int second = deq(&q);\n    printf(\"%d 그리고 %d\", first, second);\n    return 0;\n}", "line_numbers": [1, 24], "file": "data/codes/2025_round2/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "라운드로빈(RR) 방식을 이용하고 아래 내용을 참고하여\n\n평균대기시간을 구하시오.\n운영체제에서 라운드로빈\n(Round Robin, RR)\n스케줄링은 각 프로세스에 동일한 시간 할당량\n(\n타임 퀀텀\n)\n을 순차적으로 부여하며 CPU 를 할당하는 방식이다\n.\n다음은 4 개의 프로세스가 서로 다른 시간에 도착하며 각기 다른 실행 시간을 가지는 상황이다.\n이때 시간 할당량은 4ms 이고 컨텍스트 스위칭 시간은 무시한다고 가정한다\n.\n아래 정보를 바탕으로 라운드로빈\n(RR)\n방식으로 CPU 스케줄링을 수행할 경우 모든 프로세스의 평균 대기시간\n(Average Waiting Time)\n은 얼마인가\n?", "choices": [], "answer": {"keys": ["11.75"], "raw_text": "11.75"}, "explanation": "라운드로빈(Round Robin, RR) 스케줄링은 각 프로세스에 동일한 시간 할당량(타임 퀀텀)을 순차적으로 부여하는 CPU 스케줄링 방식입니다.\n\n[주어진 정보]\n- 타임 퀀텀: 4ms\n- 컨텍스트 스위칭 시간: 무시\n- 프로세스 정보: 표 참조\n\n[라운드로빈 스케줄링 동작 원리]\n1. 각 프로세스는 타임 퀀텀(4ms)만큼 CPU를 할당받습니다.\n2. 타임 퀀텀이 지나면 현재 프로세스는 중단되고 다음 프로세스로 전환됩니다.\n3. 중단된 프로세스는 대기 큐의 맨 뒤에 추가되어 다시 기회를 얻습니다.\n4. 모든 프로세스가 완료될 때까지 반복합니다.\n\n[평균 대기시간 계산]\n각 프로세스가 준비 큐에서 대기한 시간의 총합을 프로세스 수로 나눈 값입니다.\n\n1. 각 프로세스의 대기시간을 계산:\n- 프로세스가 처음 실행되기 전까지의 시간\n- 이후 실행 중단 후 재실행 전까지의 시간들의 합\n\n2. 모든 프로세스의 대기시간을 더한 후 프로세스 수로 나눕니다.\n\n[답] 문제에서 주어진 프로세스 정보와 타임 퀀텀 4ms를 바탕으로 계산하면 평균 대기시간은 11.75입니다.", "table_refs": [{"id": "table1", "json": "data/tables/2025_round2/Q013_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2025_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5 그리고 6"], "raw_text": "5 그리고 6"}, "explanation": "이 C언어 코드는 포인터의 포인터(이중 포인터)와 구조체 배열을 다루는 문제입니다.\n\n[코드 실행 단계]\n\n1. [초기 상태]\n```c struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n```\n- 구조체 배열 `a`를 초기화: `a[0] = {1, 2}`, `a[1] = {3, 4}`, `a[2] = {5, 6}`\n\n2. [포인터 설정]\n```c struct dat* ptr = a; // ptr은 배열 a의 첫 번째 요소를 가리킴 struct dat** pptr = &ptr; // pptr은 ptr 변수의 주소를 가리킴 (이중 포인터)\n```\n\n3. [중요한 연산]\n```c\n(*pptr)[1] = (*pptr)[2];\n```\n- `*pptr`은 `ptr`을 의미합니다 (pptr이 가리키는 값이 ptr)\n- `(*pptr)[1]`은 `ptr[1]` 즉 `a[1]`을 의미합니다\n- `(*pptr)[2]`는 `ptr[2]` 즉 `a[2]`를 의미합니다\n- 따라서 `a[1] = a[2]`가 실행됩니다\n- 결과: `a[1] = {5, 6}` (a[2]의 값이 a[1]에 복사됨)\n\n4. [출력]\n```c printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n```\n- `a[1].x = 5`, `a[1].y = 6`\n- 출력: \"5 그리고 6\"\n\n[핵심 포인트]\n- 이중 포인터 `**pptr`은 포인터를 가리키는 포인터입니다.\n- `(*pptr)[1]`은 `ptr[1]`과 동일하며, 이는 `a[1]`을 의미합니다.\n- 구조체 배열의 요소는 구조체 전체가 복사됩니다.\n\n[답] \"5 그리고 6\"", "table_refs": [], "image_refs": ["images/2025_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct dat {\n    int x;\n    int y;\n};\nint main() {\n    struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n    struct dat* ptr = a;\n    struct dat** pptr = &ptr;\n    (*pptr)[1] = (*pptr)[2];\n    printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n    return 0;\n}", "line_numbers": [1, 13], "file": "data/codes/2025_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1a3b3"], "raw_text": "1a3b3"}, "explanation": "이 문제는 **Java 객체 배열과 참조**를 이해하는 문제입니다.\n\n[코드 분석]\n\n```java\nBO a = new BO(1);  // a.v = 1\nBO b = new BO(2);  // b.v = 2\nBO c = new BO(3);  // c.v = 3\nBO[] arr = {a, b, c};  // arr[0] = a, arr[1] = b, arr[2] = c\nBO t = arr[0];         // t = a (참조 복사)\narr[0] = arr[2];      // arr[0] = c (이제 arr[0]은 c를 가리킴)\narr[2] = t;           // arr[2] = a (이제 arr[2]는 a를 가리킴)\narr[1].v = arr[0].v; // arr[1].v = arr[0].v = c.v = 3\nSystem.out.println(a.v + \"a\" + b.v + \"b\" + c.v);\n```\n\n[핵심 개념]\n- Java에서 객체 배열은 **참조 배열**입니다.\n- 배열 요소는 객체를 참조하는 포인터입니다.\n- 배열 요소를 교환해도 원본 객체(`a`, `b`, `c`)는 변경되지 않습니다.\n- 하지만 배열 요소를 통해 객체의 필드를 수정하면 원본 객체가 변경됩니다.\n\n[실행 과정]\n\n1. [초기 상태]\n   - `a.v = 1`, `b.v = 2`, `c.v = 3`\n   - `arr = {a, b, c}` → `arr[0] = a`, `arr[1] = b`, `arr[2] = c`\n\n2. **`BO t = arr[0];`**\n   - `t = a` (참조 복사)\n\n3. **`arr[0] = arr[2];`**\n   - `arr[0] = c` (이제 `arr[0]`은 `c`를 가리킴)\n   - **원본 객체 `a`는 변경되지 않음** (여전히 `a.v = 1`)\n\n4. **`arr[2] = t;`**\n   - `arr[2] = a` (이제 `arr[2]`는 `a`를 가리킴)\n   - **원본 객체 `c`는 변경되지 않음** (여전히 `c.v = 3`)\n\n5. `arr[1].v = arr[0].v;`\n   - `arr[1] = b`이므로 `b.v = arr[0].v`\n   - `arr[0] = c`이므로 `arr[0].v = c.v = 3`\n   - 따라서 `b.v = 3` (원본 객체 `b`의 필드가 변경됨)\n\n6. [최종 상태]\n   - `a.v = 1` (변경 없음)\n   - `b.v = 3` (변경됨)\n   - `c.v = 3` (변경 없음)\n   - `arr = {c, b, a}` (배열 요소만 재배치됨)\n\n7. [출력]\n   - `a.v + \"a\" + b.v + \"b\" + c.v = 1 + \"a\" + 3 + \"b\" + 3 = \"1a3b3\"`\n\n[정리]\n- 배열 요소 교환은 참조만 바꾸므로 원본 객체는 변경되지 않습니다.\n- 배열 요소를 통해 객체의 필드를 수정하면 원본 객체가 변경됩니다.\n\n[답] \"1a3b3\"", "table_refs": [], "image_refs": ["images/2025_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.043456"}, "code_blocks": [{"language": "java", "code": "public class Main{\n    public static class BO {\n        public int v;\n        public BO(int v) {\n            this.v = v;\n        }\n    }\n    public static void main(String[] args) {\n        BO a = new BO(1);\n        BO b = new BO(2);\n        BO c = new BO(3);\n        BO[] arr = {a, b, c};\n        BO t = arr[0];\n        arr[0] = arr[2];\n        arr[2] = t;\n        arr[1].v = arr[0].v;\n        System.out.println(a.v + \"a\" + b.v + \"b\" + c.v);\n    }\n}", "line_numbers": [1, 19], "file": "data/codes/2025_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["3 1 2"], "raw_text": "3 1 2"}, "explanation": "이 C언어 코드는 연결 리스트(Linked List)의 포인터 연결을 추적하는 문제입니다.\n\n[코드 실행 단계]\n\n1. [노드 생성 및 초기화]\n```c struct node a = {1, NULL};\nstruct node b = {2, NULL};\nstruct node c = {3, NULL};\n```\n- 세 개의 노드 생성: `a.p = 1`, `b.p = 2`, `c.p = 3`, 모두 다음 노드 포인터는 NULL\n\n2. [첫 번째 연결]\n```c a.n = &b; // a의 다음 노드는 b.n = &c; // b의 다음 노드는 c.n = NULL;\n```\n- 연결: a → b → c → NULL\n\n3. [두 번째 연결 (덮어쓰기)]\n```c.n = &a; // c의 다음 노드를 a로 변경 a.n = &b; // a의 다음 노드는 여전히 b.n = NULL; // b의 다음 노드를 NULL로 변경\n```\n- 최종 연결: `c → a → b → NULL` (c가 a를 가리키고, a가 b를 가리키고, b는 NULL)\n\n4. [출력]\n```c struct node* head = &c; // head는 c를 가리킴 printf(\"%d\", head->p, head->n->p, head->n->n->p);\n```\n- `head->p` = `c.p` = **3**\n- `head->n->p` = `a.p` = **1** (head->n은 a를 가리킴)\n- `head->n->n->p` = `b.p` = **2** (head->n->n은 b를 가리킴)\n\n[최종 출력] \"3 1 2\"\n\n[핵심 포인트]\n- 포인터 할당 순서에 따라 연결 리스트의 구조가 달라집니다.\n- 마지막에 할당한 값이 이전 값을 덮어씁니다.\n- `head` 포인터를 따라가면서 각 노드의 값을 출력합니다.", "table_refs": [], "image_refs": ["images/2025_round2/q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.044456"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int p;\n    struct node* n;\n};\nint main() {\n    struct node a = {1, NULL};\n    struct node b = {2, NULL};\n    struct node c = {3, NULL};\n    a.n = &b; b.n = &c; c.n = NULL;\n    c.n = &a; a.n = &b; b.n = NULL;\n    struct node* head = &c;\n    printf(\"%d %d %d\", head->p, head->n->p, head->n->n->p);\n    return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2025_round2/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Pyhon언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 파이썬 코드는 딕셔너리, 집합(set) 생성과 연산을 이해하는 문제입니다.\n\n[코드 실행 단계]\n\n1. [딕셔너리 생성]\n```python lst = [1, 2, 3]\ndst = {i : i * 2 for i in lst}\n```\n- 딕셔너리 컴프리헨션: `dst = {1: 2, 2: 4, 3: 6}`\n- 키는 리스트의 각 요소, 값은 그 요소의 2배\n\n2. [집합 생성]\n```python s = set(dst.values())\n```\n- 딕셔너리의 값들로 집합 생성: `s = {2, 4, 6}`\n\n3. [리스트 수정]\n```python lst[0] = 99\n```\n- `lst = [99, 2, 3]`으로 변경\n- [주의] 딕셔너리는 이미 생성되었으므로 `dst`는 변경되지 않습니다!\n- `dst`는 여전히 `{1: 2, 2: 4, 3: 6}`입니다.\n\n4. [딕셔너리 값 수정]\n```python dst[2] = 7\n```\n- 키 2의 값을 7로 변경: `dst = {1: 2, 2: 7, 3: 6}`\n\n5. [집합에 요소 추가]\n```python s.add(99)\n```\n- 집합 s에 99 추가: `s = {2, 4, 6, 99}`\n\n6. [집합 교집합 계산]\n```python print(len(s & set(dst.values())))\n```\n- `s = {2, 4, 6, 99}`\n- `set(dst.values()) = {2, 7, 6}` (dst의 현재 값들)\n- 교집합: `{2, 4, 6, 99} & {2, 7, 6} = {2, 6}`\n- 교집합의 길이: **2[핵심 포인트]\n- 딕셔너리 컴프리헨션은 생성 시점의 리스트 값으로 딕셔너리를 만듭니다.\n- 이후 리스트를 수정해도 이미 생성된 딕셔너리는 영향받지 않습니다.\n- 집합의 교집합 연산(`&`)은 두 집합에 공통으로 있는 요소만 반환합니다.\n\n[답] 2", "table_refs": [], "image_refs": ["images/2025_round2/q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.044456"}, "code_blocks": [{"language": "python", "code": "lst = [1,2,3]\ndst = {i : i* 2 for i in lst}\ns = set(dst.values())\nlst[0] = 99 \ndst[2]=7\ns.add(99)\nprint(len(s & set(dst.values())))", "line_numbers": [1, 7], "file": "data/codes/2025_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["TSEB"], "raw_text": "TSEB"}, "explanation": "이 C언어 코드는 연결 리스트를 역순으로 생성하고 출력하는 문제입니다.\n\n[코드 실행 단계]\n\n1. [`func(\"BEST\")` 호출]\n- 문자열 \"BEST\"를 받아서 연결 리스트를 생성합니다.\n- 연결 리스트는 **역순**으로 구성됩니다 (새 노드가 맨 앞에 추가됨).\n\n```c while(*s) { // 문자열의 각 문자를 처리 n = malloc(sizeof(struct node));\nn->c = *s++; // 현재 문자를 노드에 저장 n->p = h; // 새 노드의 다음 노드를 이전 head로 설정 h = n; // head를 새 노드로 변경\n}\n```\n\n- 첫 번째 반복: 'B' → head = B 노드\n- 두 번째 반복: 'E' → E 노드가 B 노드 앞에 추가, head = E → B\n- 세 번째 반복: 'S' → S 노드가 E 노드 앞에 추가, head = S → E → B\n- 네 번째 반복: 'T' → T 노드가 S 노드 앞에 추가, head = T → S → E → B\n\n[최종 연결 리스트] T → S → E → B → NULL\n\n2. [`main()` 함수에서 출력]\n```c struct node* n = func(\"BEST\"); // n은 T 노드를 가리킴 while(n) {\nputchar(n->c); // 현재 노드의 문자 출력 struct node* t = n; // 임시 변수에 현재 노드 저장 n = n->p; // 다음 노드로 이동 free(t); // 현재 노드 메모리 해제\n}\n```\n\n- 첫 번째 반복: `n->c = 'T'` 출력, `n = n->p` → S 노드로 이동\n- 두 번째 반복: `n->c = 'S'` 출력, `n = n->p` → E 노드로 이동\n- 세 번째 반복: `n->c = 'E'` 출력, `n = n->p` → B 노드로 이동\n- 네 번째 반복: `n->c = 'B'` 출력, `n = n->p` → NULL\n\n[최종 출력] \"TSEB\"\n\n[핵심 포인트]\n- 연결 리스트에 노드를 추가할 때 새 노드를 head 앞에 추가하면 역순으로 저장됩니다.\n- 입력 \"BEST\"가 역순으로 저장되어 T → S → E → B 순서로 출력됩니다.\n- 각 노드를 출력한 후 메모리를 해제하여 메모리 누수를 방지합니다.\n\n[답] \"TSEB\"", "table_refs": [], "image_refs": ["images/2025_round2/q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.044456"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    char c;\n    struct node* p;\n};\nstruct node* func(char* s) {\n    struct node* h = NULL, *n;\n    while(*s) {\n        n = malloc(sizeof(struct node));\n        n->c = *s++;\n        n->p = h;\n        h = n;\n    }\n    return h;\n}\nint main() {\n    struct node* n = func(\"BEST\");\n    while(n) {\n        putchar(n->c);\n        struct node* t = n;\n        n = n->p;\n        free(t);\n    }\n    return 0;\n}", "line_numbers": [1, 26], "file": "data/codes/2025_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 TCP 통신 과정에서 발생할 수 있는 보안 취약점에 대한 설명이다.\n이를 이용한 공격 기법으로 옳은 것은\n?\nTCP 는 연결을 수립하기 위해 클라이언트가 서버에 SYN 패킷을 보내고 서버는 SYN-ACK 패킷으로 응답한 후 클라이언트가 다시 ACK 패킷을 보내는 3-way-handshake 과정을 거친다\n.\n이때 공격자는 클라이언트 역할로 수많은 SYN 패킷을 서버에 전송한 뒤 마지막 ACK 를 고의로 보내지 않아 서버가 연결 대기 상태를 계속 유지하게 만든다\n.\n이로 인해 서버의 연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못하게 되어 서비스 거부 상태가 발생한다\n.", "choices": [], "answer": {"keys": ["SYN Flooding"], "raw_text": "SYN Flooding"}, "explanation": "SYN Flooding은 TCP 연결 과정에서 발생하는 서비스 거부 공격(DoS) 기법입니다.\n\n[TCP 3-way-handshake 과정]\n1. 클라이언트가 서버에 **SYN** 패킷 전송 2. 서버가 **SYN-ACK** 패킷으로 응답 3. 클라이언트가 **ACK** 패킷을 전송하여 연결 완료\n\n[SYN Flooding 공격 원리]\n\n1. [공격자의 행동]\n- 공격자가 클라이언트 역할로 수많은 **SYN 패킷**을 서버에 전송\n- 하지만 마지막 **ACK 패킷을 고의로 보내지 않음**\n\n2. [서버의 상태]\n- 서버는 SYN 패킷을 받으면 SYN-ACK 패킷을 전송하고 연결을 위한 리소스를 할당\n- 클라이언트의 ACK 패킷을 기다리는 **SYN_RECEIVED** 상태로 대기\n- 연결 대기 큐에 연결 요청이 계속 쌓임\n\n3. [결과]\n- 서버의 연결 대기 큐가 가득 차게 됨\n- 정상적인 클라이언트의 접속 요청을 처리할 수 없게 됨\n- 서비스 거부(Denial of Service, DoS) 상태 발생\n\n[문제에서 설명한 특징과 정확히 일치]\n- \"클라이언트 역할로 수많은 SYN 패킷 전송\" ✓\n- \"마지막 ACK를 고의로 보내지 않음\" ✓\n- \"서버가 연결 대기 상태를 계속 유지\" ✓\n- \"연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못함\" ✓\n- \"서비스 거부 상태 발생\" ✓\n\n[답] 문제에서 설명한 모든 특징이 SYN Flooding 공격과 정확히 일치하므로 답은 \"SYN Flooding\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.044456"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["TCP/IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]", "choices": [], "answer": {"keys": ["TTL", "부장", "대리", "과장", "차장"], "raw_text": "TTL 부장 대리 과장 차장"}, "explanation": "이 문제는 관계대수(Relational Algebra)의 Projection(π) 연산을 이해하는 문제입니다.\n\n[Projection(π) 연산이란]\n- 릴레이션에서 **특정 속성(열)만 선택**하여 새로운 릴레이션을 만드는 연산입니다.\n- 수학 기호: π속성명(릴레이션명)\n- SQL의 `SELECT 속성명 FROM 릴레이션`과 동일합니다.\n\n[문제 분석]\n- `πTTL(employee)`는 `employee` 릴레이션에서 **TTL 속성(열)만 선택**하는 연산입니다.\n- 결과는 TTL 열의 모든 값들을 중복 없이 반환합니다.\n\n[연산 과정]\n\n1. [employee 테이블에서 TTL 열만 선택]\n   - TTL 열의 모든 값을 추출합니다.\n   - 중복 값은 제거됩니다 (릴레이션의 기본 특성).\n\n2. [결과]\n   - TTL 열의 고유한 값들: \"TTL\", \"부장\", \"대리\", \"과장\", \"차장\"\n   - 결과는 이 값들을 튜플(행)으로 반환합니다.\n\n[SQL로 표현하면]\n```sql\nSELECT DISTINCT TTL FROM employee;\n```\n\n[답] \"TTL 부장 대리 과장 차장\"\n\n[참고]\n- Projection 연산은 릴레이션의 차수(Degree)를 줄이는 연산입니다.\n- 결과 릴레이션의 튜플 수는 원본보다 같거나 작을 수 있습니다 (중복 제거).", "table_refs": [], "image_refs": ["images/2025_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:27:19.044456"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
