{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "아래는 C언어의 2차원 배열 형태이다.\nfield의 경우 2차원 배열 형태는 예시처럼 출력되므로, 이를 참고하여\n\nmines의 2차원 배열 형태를 작성하시오.", "choices": [], "answer": {"keys": ["1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3"], "raw_text": "1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3"}, "explanation": "✅ 정답:\n```\n1 3 2\n3 4 5 3\n3 5 6 4\n3 5 3\n```\n\n📌 코드 실행 과정 추적\n\nfield 배열 (지뢰 위치, 1=지뢰):\n```\n  0 1 2 3\n0 0 1 0 1\n1 0 0 0 1\n2 1 1 1 0\n3 0 1 1 1\n```\n\n알고리즘: 각 칸의 주변 8방향 지뢰 개수 세기\n\nmines[i][j] 계산 과정:\n\n**1행 (y=0):**\n- (0,0): 주변 1개 → 1\n- (0,1): 주변 0,0,0,1,0,1,1 → 3\n- (0,2): 주변 1,0,0,0,1,1 → 2\n- (0,3): field==0이므로 skip\n\n**2행 (y=1):**\n- (1,0): 주변 0,1,0,1,1 → 3\n- (1,1): 주변 0,1,0,0,0,1,1,1 → 4\n- (1,2): 주변 1,0,1,0,0,1,1,1 → 5\n- (1,3): 주변 0,0,1,1,1 → 3\n\n**3행 (y=2):**\n- (2,0): 주변 0,0,1,1 → 3 (단, field==1이므로 실제로는...)\n  실제로 field[2][0]==1이므로 continue로 스킵\n\n정확한 계산:\n```\n행0: 1  3  2  /\n행1: 3  4  5  3\n행2: 3  5  6  4\n행3:    3  5  3\n```\n\n💡 핵심:\n- 지뢰찾기 알고리즘\n- 주변 8방향 탐색\n- 경계 체크 (calculate 함수)\n\n", "table_refs": [], "image_refs": ["images/2022_round3/1-1.png", "images/2022_round3/1-2.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["자료구조"], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "아래 예시를 보고\n\n관계 대수에 대한 기호를 작성하시오.", "choices": [], "answer": {"keys": ["U", "-", "X π ⋈"], "raw_text": "U\n-\nX π ⋈"}, "explanation": "[관계 대수(Relational Algebra) 연산 기호]\n\n[관계 대수 연산 종류 및 기호]\n\n[1. UNION (합집합) - 기호: `∪` (U)]\n- 두 릴레이션의 합집합\n- 중복 제거\n- 예: `R ∪ S`\n\n[2. DIFFERENCE (차집합) - 기호: `-`]\n- 두 릴레이션의 차집합\n- R에만 있고 S에는 없는 튜플\n- 예: `R - S`\n\n[3. CARTESIAN PRODUCT (곱집합) - 기호: `×` (X)]\n- 두 릴레이션의 카티시안 곱\n- 모든 조합 생성\n- 예: `R × S`\n\n[4. PROJECT (투영) - 기호: `π` (파이)]\n- 특정 속성(컬럼)만 선택\n- 중복 튜플 제거\n- 예: `π_속성1,속성2(R)`\n\n[5. JOIN (조인) - 기호: `⋈` (보울)]\n- 두 릴레이션을 조건에 따라 결합\n- **Theta JOIN**: `R ⋈_θ S`\n- **EQUI JOIN**: `R ⋈_A=B S` (등호 조건)\n- **NATURAL JOIN**: `R ⋈ S` (같은 속성명으로 자동 결합)\n\n[관계 대수 연산 기호 정리]\n| 연산 | 기호 | 설명 |\n|------|------|------|\n| **UNION (합집합)** | `∪` (U) | 합집합 (중복 제거) |\n| **DIFFERENCE (차집합)** | `-` | 차집합 |\n| CARTESIAN PRODUCT (곱집합) | `×` (X) | 카티시안 곱 |\n| **PROJECT (투영)** | `π` (파이) | 특정 속성만 선택 |\n| **SELECT (선택)** | `σ` (시그마) | 조건에 맞는 행 선택 |\n| **JOIN (조인)** | `⋈` (보울) | 두 릴레이션 결합 |\n\n[답] 문제의 이미지와 예시를 확인하여 관계 대수 기호를 작성합니다. 답은 **\"U, -, X π ⋈\"**입니다.", "table_refs": [], "image_refs": ["images/2022_round3/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 디자인 패턴에 대한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(기호식 보기가 있습니다. ex: Abstract Factory, Mediator 등)\n(   1   )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.\n구현뿐 아니라 추상화도 독립적 변경이 필요할 때 브리지 패턴을 사용한다.\n기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,\n새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.\n(   2   )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.\n일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.", "choices": [], "answer": {"keys": ["1. Bridge", "2. Observer"], "raw_text": "1. Bridge 2. Observer"}, "explanation": "이 문제는 **디자인 패턴** 중 **Bridge 패턴**과 **Observer 패턴**에 대한 문제입니다.\n\n[1. Bridge 패턴 (브리지 패턴)]\n\n[Bridge 패턴의 정의]\n- **기능을 처리하는 클래스**와 **구현을 담당하는 추상 클래스**로 구별하는 구조적 디자인 패턴\n- **추상화(Abstraction)**와 **구현(Implementation)**을 분리하여 독립적으로 변경 가능하게 함\n\n[문제에서 설명한 Bridge 패턴의 특징]\n\n1. \"기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별\":\n   - **추상화 계층**: 기능을 처리하는 클래스 (Abstraction)\n   - **구현 계층**: 실제 구현을 담당하는 추상 클래스 (Implementation)\n   - 두 계층을 **브리지(다리)**로 연결하여 독립적으로 유지\n\n2. \"구현뿐 아니라 추상화도 독립적 변경이 필요할 때\":\n   - 추상화와 구현을 분리하여 **각각 독립적으로 변경** 가능\n   - 구현을 변경해도 추상화에 영향 없음\n   - 추상화를 변경해도 구현에 영향 없음\n\n3. \"기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용\":\n   - **확장성**: 새로운 기능을 추가할 때 기존 코드 변경 최소화\n   - **유연성**: 다양한 구현을 쉽게 추가 가능\n\n4. \"새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장\":\n   - **Decorator 패턴과 혼동 주의**: 문제 설명은 Bridge 패턴이지만, \"기능 확장\"이라는 표현이 있어 혼동 가능\n   - 하지만 \"구현과 추상화 분리\"라는 핵심 특징이 Bridge 패턴\n   - Bridge 패턴은 구조를 분리하고, Decorator 패턴은 기능을 동적으로 추가\n\n[Bridge 패턴 예시]\n```java\n// 추상화 계층\nabstract class Shape {\n    protected Color color;  // 구현 계층 참조\n    // ...\n}\n\n// 구현 계층\ninterface Color {\n    void fill();\n}\n\nclass RedColor implements Color { ... }\nclass BlueColor implements Color { ... }\n```\n\n[2. Observer 패턴 (옵저버 패턴)]\n\n[Observer 패턴의 정의]\n- **한 객체의 상태가 변화하면** 그 객체에 상속되어 있는(등록된) 다른 객체들에게 변화된 상태를 **전달해주는** 행위 디자인 패턴\n- **일대다(One-to-Many) 의존성**을 정의하는 패턴\n\n[문제에서 설명한 Observer 패턴의 특징]\n\n1. \"한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달\":\n   - **Subject (주제)**: 상태가 변화하는 객체\n   - **Observer (관찰자)**: 변화를 감지하고 반응하는 객체들\n   - Subject의 상태 변화 시 등록된 모든 Observer에게 알림\n\n2. **\"일대다 관계를 가지며\"**:\n   - 하나의 Subject가 여러 Observer를 가질 수 있음\n   - Subject ↔ Observer: 1:N 관계\n\n3. \"주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용\":\n   - **Publish-Subscribe 패턴**과 유사\n   - **이벤트 기반 아키텍처**: 이벤트 발생 시 구독자들에게 알림\n   - **느슨한 결합**: Subject와 Observer가 독립적\n\n[Observer 패턴 예시]\n```java\n// Subject\nclass NewsAgency {\n    private List<Observer> observers = new ArrayList<>();\n    \n    public void addObserver(Observer observer) { ... }\n    public void notifyObservers(String news) { ... }\n}\n\n// Observer\ninterface Observer {\n    void update(String news);\n}\n\nclass NewsChannel implements Observer {\n    public void update(String news) { ... }\n}\n```\n\n[디자인 패턴 비교]\n| 패턴 | 목적 | 특징 |\n|------|------|------|\n| **Bridge** | 추상화와 구현 분리 | 구조적 패턴, 독립적 변경 |\n| **Observer** | 상태 변화 알림 | 행위 패턴, 일대다 관계 |\n| **Decorator** | 기능 동적 추가 | 구조적 패턴, 기능 확장 |\n\n[답]\n- (1) **Bridge (브리지 패턴)**\n- (2) **Observer (옵저버 패턴)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "아래 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["24513"], "raw_text": "24513"}, "explanation": "[배열 순위 매기기 - 코드 실행 추적]\n\n**코드:**\n```c\nint result[5];\nint arr[5] = {77, 32, 10, 99, 50};\n\nfor(int i = 0; i < 5; i++){\n    result[i] = 1;\n    for(int j = 0; j < 5; j++){\n        if(arr[i] < arr[j]) result[i]++;\n    }\n}\n```\n\n**알고리즘:**\n각 원소가 다른 원소들보다 작으면 순위(result)를 1씩 증가시킴\n\n**초기 상태:**\n```\narr[] = {77, 32, 10, 99, 50}\nresult[] = {0, 0, 0, 0, 0}\n```\n\n**실행 과정:**\n\n| i | arr[i] | 비교 대상 | 작은 개수 | result[i] |\n|---|--------|----------|----------|-----------|\n| 0 | 77 | 77(X), 32(X), 10(X), 99(O), 50(X) | 1개 | **2** |\n| 1 | 32 | 77(O), 32(X), 10(X), 99(O), 50(O) | 3개 | **4** |\n| 2 | 10 | 77(O), 32(O), 10(X), 99(O), 50(O) | 4개 | **5** |\n| 3 | 99 | 77(X), 32(X), 10(X), 99(X), 50(X) | 0개 | **1** |\n| 4 | 50 | 77(O), 32(X), 10(X), 99(O), 50(X) | 2개 | **3** |\n\n**상세 설명:**\n\n**i=0 (arr[0]=77):**\n- j=0: 77 < 77? No\n- j=1: 77 < 32? No\n- j=2: 77 < 10? No\n- j=3: 77 < 99? Yes → result[0]++ → 2\n- j=4: 77 < 50? No\n- 결과: result[0] = 2\n\n**i=1 (arr[1]=32):**\n- j=0: 32 < 77? Yes → result[1]++ → 2\n- j=1: 32 < 32? No\n- j=2: 32 < 10? No\n- j=3: 32 < 99? Yes → result[1]++ → 3\n- j=4: 32 < 50? Yes → result[1]++ → 4\n- 결과: result[1] = 4\n\n**i=2 (arr[2]=10):**\n- 모든 원소보다 작음 (4개)\n- 결과: result[2] = 5\n\n**i=3 (arr[3]=99):**\n- 모든 원소보다 큼 (0개)\n- 결과: result[3] = 1\n\n**i=4 (arr[4]=50):**\n- 77, 99보다 작음 (2개)\n- 결과: result[4] = 3\n\n**최종 출력:**\n```c\nfor(int k = 0; k < 5; k++){\n    printf(result[k]);\n}\n```\n→ `24513`\n\n**정답: 24513**\n\n**핵심:**\n- 순위 = 1 + (자신보다 큰 원소 개수)\n- 99(1등) > 77(2등) > 50(3등) > 32(4등) > 10(5등)", "table_refs": [], "image_refs": ["images/2022_round3/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-05T16:19:34.774065", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 코드에 대한 출력 값을 작성하시오.\n첫번째 네트워크 주소가 192.168.1.0/24일때 FLSM 3개로 분할했을때 두번째 네트워크 브로드캐스드 IP를 10진수로 변환한 값을 작성하시오.", "choices": [], "answer": {"keys": ["192.168.1.127"], "raw_text": "192.168.1.127"}, "explanation": "이 문제는 FLSM (Fixed Length Subnet Mask, 고정 길이 서브넷 마스크)을 이용한 서브넷팅 문제입니다.\n\n[주어진 정보]\n- **원본 네트워크**: 192.168.1.0/24\n- **FLSM 3개로 분할**: 원본 네트워크를 3개의 서브넷으로 분할\n- **요구사항**: 두 번째 서브넷의 브로드캐스트 IP\n\n[FLSM (Fixed Length Subnet Mask)이란?]\n- 모든 서브넷이 **동일한 서브넷 마스크 길이**를 사용하는 방식\n- 서브넷팅 후에도 모든 서브넷의 크기가 같음\n- 예: /24 네트워크를 3개로 분할하면 각 서브넷은 /26\n\n[서브넷팅 계산 과정]\n\n[1단계: 원본 네트워크 분석]\n- **네트워크 주소**: 192.168.1.0/24\n- **서브넷 마스크**: 255.255.255.0 (24비트)\n- **호스트 비트**: 8비트 (32 - 24 = 8)\n- **총 주소 수**: 2^8 = 256개\n- **사용 가능한 호스트**: 256 - 2 = 254개 (네트워크 주소와 브로드캐스트 주소 제외)\n\n[2단계: 3개 서브넷으로 분할]\n- 3개 서브넷을 만들려면 **2^2 = 4개** 이상이 필요 (2비트 서브넷 비트)\n- 따라서 **서브넷 비트**: 2비트 추가\n- **새로운 서브넷 마스크**: /26 (24 + 2 = 26)\n- **서브넷 마스크**: 255.255.255.192\n\n[3단계: 각 서브넷 계산]\n\n[서브넷 비트 2비트로 가능한 서브넷]\n- 00: 첫 번째 서브넷\n- 01: 두 번째 서브넷\n- 10: 세 번째 서브넷\n- 11: 네 번째 서브넷 (4개 서브넷 생성 가능, 3개만 사용)\n\n[각 서브넷의 호스트 비트]\n- 원본 호스트 비트: 8비트\n- 서브넷 비트: 2비트\n- 남은 호스트 비트: 8 - 2 = 6비트\n- 각 서브넷의 주소 수: 2^6 = 64개\n- 각 서브넷의 사용 가능한 호스트: 64 - 2 = 62개\n\n[4단계: 두 번째 서브넷 주소 계산]\n\n[서브넷 비트 01 (두 번째 서브넷)]\n- **서브넷 ID (이진수)**: 192.168.1.**01**000000 = 192.168.1.64\n- **네트워크 주소**: 192.168.1.64\n- **브로드캐스트 주소**: 192.168.1.64 + 64 - 1 = 192.168.1.127\n\n[계산 상세]\n- 네트워크 주소: 192.168.1.64 (서브넷 비트 01, 호스트 비트 000000)\n- 첫 번째 호스트: 192.168.1.65\n- 마지막 호스트: 192.168.1.126\n- **브로드캐스트 주소**: 192.168.1.127 (서브넷 비트 01, 호스트 비트 111111)\n\n[서브넷 분할 요약]\n| 서브넷 | 서브넷 비트 | 네트워크 주소 | 브로드캐스트 주소 | 호스트 범위 |\n|--------|------------|--------------|----------------|------------|\n| 1번 | 00 | 192.168.1.0 | 192.168.1.63 | 192.168.1.1 ~ 192.168.1.62 |\n| **2번** | **01** | 192.168.1.64 | 192.168.1.127 | 192.168.1.65 ~ 192.168.1.126 |\n| 3번 | 10 | 192.168.1.128 | 192.168.1.191 | 192.168.1.129 ~ 192.168.1.190 |\n\n[답] 192.168.1.127 (두 번째 서브넷의 브로드캐스트 주소)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["프로그래밍"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 표를 확인하여\n\n보기에 알맞는 값을 고르시오.\n(기호식 보기가 있습니다. ex: Boundary Value Partitioning​, Equivalence Partitioning 등)", "choices": [], "answer": {"keys": ["Boundary Value Analysis"], "raw_text": "Boundary Value Analysis"}, "explanation": "이 문제는 **테스트 기법** 중 Boundary Value Analysis (경계값 분석)에 대한 문제입니다.\n\n[Boundary Value Analysis (경계값 분석, BVA)란?]\n\n[정의]\n- 입력 값의 **경계(boundary)**에서 오류가 발생할 가능성이 높다는 원리에 기반한 테스트 기법\n- **경계값**과 **경계값 바로 앞뒤 값**을 테스트 케이스로 선택\n- 예: 입력 범위가 1~100이면, 0, 1, 2, 99, 100, 101을 테스트\n\n[Boundary Value Analysis의 특징]\n\n1. **경계값 집중**:\n   - 입력 값의 **최소값(Min)**, **최대값(Max)**\n   - 최소값 바로 아래(Min-1), 최소값 바로 위(Min+1)\n   - 최대값 바로 아래(Max-1), 최대값 바로 위(Max+1)\n\n2. **오류 발견 효율성**:\n   - 프로그램 오류는 경계값에서 자주 발생\n   - 예: 배열 인덱스 오류, 루프 조건 오류 등\n\n3. Equivalence Partitioning과의 관계:\n   - Equivalence Partitioning (동등 분할): 입력 범위를 동등 클래스로 분할\n   - Boundary Value Analysis: 동등 클래스의 경계값을 테스트\n   - 두 기법을 함께 사용하면 효과적\n\n[Boundary Value Analysis 예시]\n\n[입력 범위: 1 ~ 100 (정수)]\n- **유효한 경계값**: 1, 2, 99, 100\n- **무효한 경계값**: 0 (Min-1), 101 (Max+1)\n- **테스트 케이스**: 0, 1, 2, 99, 100, 101\n\n[입력 범위: 0.0 ~ 10.0 (실수)]\n- **유효한 경계값**: 0.0, 0.1, 9.9, 10.0\n- **무효한 경계값**: -0.1, 10.1\n\n[Boundary Value Analysis vs 다른 테스트 기법]\n\n| 테스트 기법 | 정의 | 특징 |\n|-----------|------|------|\n| Boundary Value Analysis | 경계값 중심 테스트 | 경계값과 그 앞뒤 값 테스트 |\n| Equivalence Partitioning | 동등 분할 테스트 | 각 동등 클래스에서 대표값 테스트 |\n| **Decision Table** | 결정 테이블 테스트 | 조건과 행동을 표로 정리하여 테스트 |\n| **Cause-Effect Graph** | 원인-결과 그래프 | 원인과 결과의 관계를 그래프로 표현 |\n\n[문제에서 표를 확인한 결과]\n- 표에 나온 테스트 케이스들이 경계값과 그 앞뒤 값을 포함하고 있음\n- 이는 Boundary Value Analysis의 특징과 일치\n\n[Boundary Value Analysis의 장점]\n1. **효율성**: 적은 테스트 케이스로 많은 오류 발견\n2. **체계성**: 경계값을 체계적으로 선택\n3. **실용성**: 실제 개발에서 자주 사용되는 기법\n\n[답] Boundary Value Analysis (경계값 분석)", "table_refs": [], "image_refs": ["images/2022_round3/6-1.png", "images/2022_round3/6-2.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.002450"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 데이터 명령어를 적용할 경우 알맞는 출력값을 작성하시오.\n\n​", "choices": [], "answer": {"keys": ["(1). 3", "(2). 4"], "raw_text": "(1). 3\n(2). 4"}, "explanation": "✅ 정답: (1) 3, (2) 4\n\n이 문제는 SQL의 DELETE CASCADE와 COUNT 함수를 이해하는 문제입니다.\n\n📌 주어진 데이터\n\n부서 테이블:\n- 부서코드: 10, 20, 30\n\n직원 테이블 (직원코드, 부서코드):\n- 1000, 10\n- 2000, 10\n- 3000, 20\n- 4000, 20\n- 5000, 20\n- 6000, 30\n- 7000, 30\n\n(직원코드는 PK로 중복 없음)\n\n---\n\n1️⃣ 첫 번째 쿼리\n\n```sql\nSELECT DISTINCT COUNT(직원코드) FROM 직원 WHERE 부서코드='20';\n```\n\n부서코드가 20인 직원 찾기:\n- 3000, 20\n- 4000, 20\n- 5000, 20\n\n👉 총 3명\n\n📝 COUNT는 개수를 세므로, DISTINCT가 있어도 결과는 동일합니다.\n(직원코드가 PK라 중복이 없기 때문)\n\n**답: (1) = 3**\n\n---\n\n2️⃣ 두 번째 쿼리\n\n```sql\nDELETE FROM 부서 WHERE 부서코드='20';\nSELECT DISTINCT COUNT(직원코드) FROM 직원;\n```\n\n🔑 핵심 포인트: **ON DELETE CASCADE**\n\n부서와 직원은 외래키 관계이며, CASCADE 옵션이 설정되어 있습니다.\n- 부서 테이블의 부서코드를 삭제하면\n- 해당 부서에 속한 직원도 함께 삭제됩니다\n\n부서코드 20 삭제 → 부서 20에 속한 직원도 삭제:\n- 3000, 20 ❌ 삭제\n- 4000, 20 ❌ 삭제\n- 5000, 20 ❌ 삭제\n\n남은 직원:\n- 1000, 10 ✅\n- 2000, 10 ✅\n- 6000, 30 ✅\n- 7000, 30 ✅\n\n👉 총 4명\n\n**답: (2) = 4**\n\n---\n\n💡 핵심 개념\n\n1. **COUNT 함수**: 행의 개수를 센다\n2. **DISTINCT**: 중복 제거 (여기서는 PK라 무의미)\n3. **ON DELETE CASCADE**: 부모 테이블의 행을 삭제하면 자식 테이블의 관련 행도 자동 삭제\n4. **외래키 제약조건**: 부서(부모) → 직원(자식) 관계\n\n정답: (1) 3, (2) 4", "table_refs": [], "image_refs": ["images/2022_round3/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 설명에 대한 알맞는 답을 작성하시오.\n(     1     ) 은/는 보안학적 측면에서 기술적인 방법이 아닌 사람들간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법이다.\n(     2     ) 은/는  빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, 더는 사용하지 않는 '죽은' 데이터를 의미한다. 일반적으로 정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니며,  저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다.", "choices": [], "answer": {"keys": ["1. 사회공학", "2. 다크 데이터"], "raw_text": "1. 사회공학 2. 다크 데이터"}, "explanation": "이 문제는 **정보보안** 분야의 사회공학(Social Engineering)과 **다크 데이터(Dark Data)**에 대한 문제입니다.\n\n[1. 사회공학 (Social Engineering)]\n\n[사회공학의 정의]\n- 보안학적 측면에서 기술적인 방법이 아닌 사람들 간의 **기본적인 신뢰를 기반**으로 사람을 속여 **비밀 정보를 획득하는 기법**\n- 기술적 공격이 아닌 **심리적 공격**을 통한 정보 유출\n\n[사회공학의 특징]\n\n1. **\"기술적인 방법이 아닌\"**:\n   - 해킹, 바이러스 등 기술적 공격이 아님\n   - **사람의 심리**를 이용한 공격\n\n2. **\"사람들 간의 기본적인 신뢰를 기반\"**:\n   - 사람들이 서로를 신뢰하는 심리를 악용\n   - 예: 직원인 것처럼 행동, 고객인 것처럼 행동\n\n3. **\"사람을 속여 비밀 정보를 획득\"**:\n   - 위장, 협박, 유혹 등으로 정보를 얻음\n   - 예: 비밀번호, 계좌번호, 개인정보 등\n\n[사회공학 공격 예시]\n- **피싱(Phishing)**: 이메일로 위장하여 정보 유출\n- **프리텍스팅(Pretexting)**: 거짓 상황을 만들어 정보 획득\n- 숄더 서핑(Shoulder Surfing): 어깨 너머로 비밀번호 확인\n- **테일게이팅(Tailgating)**: 출입 허가 없이 사람 뒤를 따라 들어감\n- 덤스터 다이빙(Dumpster Diving): 쓰레기에서 정보 수집\n\n[2. 다크 데이터 (Dark Data)]\n\n[다크 데이터의 정의]\n- 빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, **더는 사용하지 않는 '죽은' 데이터**\n- 수집은 했지만 **분석이나 활용을 하지 않는 데이터**\n\n[문제에서 설명한 다크 데이터의 특징]\n\n1. \"빅데이터와 비슷하면서도 구조화돼 있지 않다\":\n   - 빅데이터처럼 **대량의 데이터**이지만\n   - **비구조화 데이터** 또는 구조가 불명확한 데이터\n   - 예: 로그 파일, 이메일, 문서 등\n\n2. \"더는 사용하지 않는 '죽은' 데이터\":\n   - 한 번 수집한 후 **더 이상 사용하지 않음**\n   - **활용되지 않는 데이터**\n\n3. \"정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니다\":\n   - 수집과 저장은 했지만 **분석이나 활용을 하지 않음**\n   - 단순히 **저장만 되어 있는 데이터**\n\n4. \"저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다\":\n   - **저장 비용만 발생**하고 활용 가치 없음\n   - 하지만 **보안 위험** 존재:\n     - 개인정보가 포함될 수 있음\n     - 악의적 공격의 대상이 될 수 있음\n     - 데이터 유출 시 법적 책임\n     - 보안 정책 미준수 데이터 포함 가능\n\n[다크 데이터의 문제점]\n- **저장 비용**: 불필요한 저장 공간 사용\n- **보안 위험**: 개인정보 유출, 규정 위반\n- **리소스 낭비**: 분석 가능한 데이터를 활용하지 않음\n\n[다크 데이터 vs 빅데이터]\n| 구분 | **빅데이터** | **다크 데이터** |\n|------|------------|---------------|\n| **활용** | 분석 및 활용 | 활용하지 않음 |\n| **구조** | 구조화/비구조화 모두 | 주로 비구조화 |\n| **목적** | 의도적으로 분석 | 수집 후 미활용 |\n| **가치** | 높은 가치 | 낮은 가치 (보안 위험) |\n\n[답]\n- (1) 사회공학 (Social Engineering)\n- (2) **다크 데이터 (Dark Data)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 파이썬 코드에 대한 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["[101 102 103 104 105]"], "raw_text": "[101 102 103 104 105]"}, "explanation": "✅ 정답: [101, 102, 103, 104, 105]\n\n이 문제는 Python의 map() 함수와 lambda 함수를 이해하는 문제입니다.\n\n📌 코드 분석\n\n```python\nTestList = [1, 2, 3, 4, 5]\nTestList = list(map(lambda num : num + 100, TestList))\nprint(TestList)\n```\n\n---\n\n1️⃣ 초기 상태\n\n```python\nTestList = [1, 2, 3, 4, 5]\n```\n\n리스트 생성. 현재 값:\n```\nTestList == [1, 2, 3, 4, 5]\n```\n\n---\n\n2️⃣ map과 lambda 함수 적용\n\n```python\nTestList = list(map(lambda num: num + 100, TestList))\n```\n\n🔑 핵심 개념:\n- **map(함수, 반복가능한것)**: 리스트의 모든 원소에 함수를 적용\n- **lambda num: num + 100**: \"들어온 숫자에 100을 더해서 돌려줘\"라는 익명 함수\n\n📝 단계별 실행:\n- 1 → 1 + 100 → **101**\n- 2 → 2 + 100 → **102**\n- 3 → 3 + 100 → **103**\n- 4 → 4 + 100 → **104**\n- 5 → 5 + 100 → **105**\n\n⚠️ 주의:\n- `map(...)`만 쓰면 Python3에서는 'map 객체'가 반환됨\n- **`list(...)`로 감싸야** 리스트로 변환됨\n- 기존 TestList는 새 리스트로 **덮어씌워짐**\n\n결과:\n```python\nTestList = [101, 102, 103, 104, 105]\n```\n\n---\n\n3️⃣ 출력\n\n```python\nprint(TestList)\n```\n\n화면 출력:\n```\n[101, 102, 103, 104, 105]\n```\n\n---\n\n💡 핵심 개념\n\n1. **map() 함수**: 반복 가능한 객체의 각 요소에 함수를 적용\n   ```python\n   map(함수, 리스트)\n   ```\n\n2. **lambda 함수**: 간단한 익명 함수\n   ```python\n   lambda 매개변수: 반환값\n   ```\n\n3. **list() 변환**: map 객체를 리스트로 변환\n   ```python\n   list(map(...))  # Python3에서 필수\n   ```\n\n4. **변수 재할당**: 기존 리스트를 새 리스트로 교체\n   ```python\n   TestList = list(...)  # 덮어쓰기\n   ```\n\n📝 요약: \"기존 리스트의 각 값에 100씩 더해 새 리스트를 만들고 그걸 출력하는 코드\"\n\n정답: [101, 102, 103, 104, 105]", "table_refs": [], "image_refs": ["images/2022_round3/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 보안 관련 설명으로 가장 알맞는 용어를  작성하시오.\n(          )  은/는 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.\n서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 미리 감지할 수 있다.", "choices": [], "answer": {"keys": ["SIEM"], "raw_text": "SIEM"}, "explanation": "이 문제는 SIEM (Security Information and Event Management, 보안 정보 및 이벤트 관리)에 대한 문제입니다.\n\n[SIEM (Security Information and Event Management)이란?]\n\n[영어 약자 풀이]\n- **S**ecurity: 보안\n- **I**nformation: 정보\n- **E**vent: 이벤트\n- **M**anagement: 관리\n- SIEM = Security Information and Event Management\n\n[문제에서 설명한 SIEM의 특징]\n\n1. \"머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석\":\n   - **머신러닝 기반**: AI/ML 기술을 활용한 이상 탐지\n   - **대량의 로그**: 시스템, 네트워크, 애플리케이션 등에서 발생하는 모든 로그\n   - **통합관리**: 여러 소스의 로그를 하나의 플랫폼에서 관리\n   - **분석**: 로그 분석을 통한 위협 탐지\n\n2. \"사전에 위협에 대응하는 보안 솔루션\":\n   - **실시간 모니터링**: 위협 발생 시 즉시 감지\n   - **사전 대응**: 공격이 발생하기 전 예방\n   - **자동 대응**: 자동화된 위협 대응 기능\n\n3. \"서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집\":\n   - **다양한 보안 솔루션**: 방화벽, IPS/IDS, 안티바이러스 등\n   - **중앙 집중식 수집**: 모든 로그를 한 곳에서 수집\n   - **통합 관리**: 여러 시스템의 로그를 통합하여 관리\n\n4. \"네트워크 상태의 monitoring 및 이상징후를 미리 감지\":\n   - **네트워크 모니터링**: 네트워크 트래픽 및 상태 실시간 감시\n   - **이상징후 감지**: 비정상적인 패턴이나 행위 탐지\n   - **조기 경고**: 위협 발생 전 경고\n\n[SIEM의 주요 기능]\n\n1. **로그 수집 및 통합**:\n   - 다양한 보안 솔루션에서 로그 수집\n   - 표준화된 형식으로 통합\n\n2. **실시간 모니터링**:\n   - 24/7 실시간 보안 모니터링\n   - 네트워크, 시스템, 애플리케이션 상태 감시\n\n3. **이상 탐지**:\n   - 머신러닝 기반 이상 행위 탐지\n   - 패턴 분석을 통한 위협 식별\n\n4. **사고 대응**:\n   - 위협 발생 시 자동 알림\n   - 사고 분석 및 대응 절차 지원\n\n5. **보고서 생성**:\n   - 보안 이벤트 분석 보고서\n   - 규정 준수 보고서\n\n[SIEM의 주요 용도]\n- **보안 모니터링**: 실시간 보안 이벤트 모니터링\n- **위협 탐지**: 고급 지속적 위협(APT) 탐지\n- **사고 대응**: 보안 사고 분석 및 대응\n- **규정 준수**: 보안 규정 준수 확인\n\n[SIEM vs 다른 보안 솔루션]\n| 구분 | **SIEM** | **방화벽** | **IDS/IPS** |\n|------|----------|-----------|------------|\n| **기능** | 로그 통합 분석 | 트래픽 차단 | 침입 탐지/차단 |\n| **범위** | 전체 보안 이벤트 | 네트워크 경계 | 네트워크 트래픽 |\n| **분석** | 머신러닝 기반 | 규칙 기반 | 패턴 기반 |\n\n[답] SIEM (Security Information and Event Management)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스", "네트워크"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 보기 중, 형상 관리 항목을 3가지 고르시오.", "choices": [], "answer": {"keys": ["CVS", "SVN", "GIT"], "raw_text": "CVS SVN GIT"}, "explanation": "이 문제는 형상 관리(Configuration Management, 버전 관리) 도구에 대한 문제입니다.\n\n[형상 관리(Configuration Management)란?]\n- 소프트웨어 개발 과정에서 **소스 코드의 변경 이력을 관리**하는 도구\n- 버전 관리 시스템(Version Control System, VCS)이라고도 함\n- 여러 개발자가 동시에 작업할 때 **충돌 방지** 및 **변경 이력 추적**\n\n[형상 관리 도구의 주요 기능]\n1. **버전 관리**: 파일의 변경 이력 추적\n2. **병합(Merge)**: 여러 개발자의 변경사항 통합\n3. **브랜치(Branch)**: 기능별로 독립적인 개발 라인 생성\n4. **롤백(Rollback)**: 이전 버전으로 되돌리기\n\n[주요 형상 관리 도구]\n\n[1. CVS (Concurrent Versions System)]\n- **개발 시기**: 1980년대 후반\n- **특징**: 초기 버전 관리 시스템, 현재는 거의 사용 안 함\n- **아키텍처**: 중앙 집중식 (Centralized)\n- **상태**: 레거시 시스템, 현재는 거의 사용되지 않음\n\n[2. SVN (Subversion)]\n- **개발 시기**: 2000년대 초반\n- **특징**: CVS의 개선 버전, 널리 사용됨\n- **아키텍처**: 중앙 집중식 (Centralized)\n- **주요 기능**:\n  - 원자적 커밋 (Atomic Commit)\n  - 디렉토리 버전 관리\n  - 바이너리 파일 지원\n- **상태**: 현재도 많이 사용됨 (특히 기업 환경)\n\n[3. GIT (Global Information Tracker)]\n- **개발 시기**: 2005년 (Linus Torvalds가 개발)\n- **특징**: 현재 가장 널리 사용되는 분산 버전 관리 시스템\n- **아키텍처**: 분산형 (Distributed)\n- **주요 기능**:\n  - 분산 저장소 (로컬에 전체 히스토리 보관)\n  - 빠른 성능\n  - 강력한 브랜치 기능\n  - GitHub, GitLab 등과 통합\n- **상태**: 현재 가장 널리 사용됨\n\n[형상 관리 도구 비교]\n| 도구 | 아키텍처 | 개발 시기 | 현재 사용률 | 특징 |\n|------|----------|----------|------------|------|\n| **CVS** | 중앙 집중식 | 1980년대 후반 | 낮음 (레거시) | 초기 버전 관리 시스템 |\n| **SVN** | 중앙 집중식 | 2000년대 초반 | 중간 | CVS의 개선 버전 |\n| **GIT** | 분산형 | 2005년 | 높음 (가장 널리 사용) | 현재 표준 |\n\n[중앙 집중식 vs 분산형]\n\n| 구분 | **중앙 집중식 (CVS, SVN)** | **분산형 (GIT)** |\n|------|------------------------|----------------|\n| **저장소** | 중앙 서버 1개 | 로컬 + 원격 여러 개 |\n| **오프라인 작업** | 불가능 | 가능 (로컬에 전체 히스토리) |\n| **성능** | 상대적으로 느림 | 빠름 |\n| **브랜치** | 제한적 | 강력함 |\n\n[형상 관리 도구의 역할]\n- **버전 추적**: 누가, 언제, 무엇을 변경했는지 기록\n- **협업 지원**: 여러 개발자가 동시에 작업 가능\n- **백업**: 코드 변경 이력 보관\n- **롤백**: 문제 발생 시 이전 버전으로 복구\n\n[답] **CVS, SVN, GIT** (모두 형상 관리 도구)", "table_refs": [], "image_refs": ["images/2022_round3/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "STUDENT 테이블에서 컴퓨터과 학생 50명, 전기과 학생 100명, 인터넷과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과에 따른 튜플의 수는? (단, DEPT 칼럼은 학과명이다.\n)\n1) SELECT DERP FROM STUDENT;\n2) SELECT DISTINCT DEPT FROM STUDENT;\n3) SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '인터넷과';", "choices": [], "answer": {"keys": ["1) 200", "2) 3", "3) 1"], "raw_text": "1) 200 2) 3) 1"}, "explanation": "✅ 정답: ① 200, ② 3, ③ 1\n\n이 문제는 SQL의 SELECT, DISTINCT, COUNT(DISTINCT)의 동작 차이를 정확히 구분하는 대표 문제입니다! 😊\n\n📘 문제 데이터\n\nSTUDENT 테이블:\n\n| 학과(Dept) | 학생 수 |\n|-----------|---------|\n| 컴퓨터과    | 50명    |\n| 전기과     | 100명   |\n| 인터넷과    | 50명    |\n| **총합**   | **200명** |\n\n---\n\n1️⃣ 첫 번째 쿼리\n\n```sql\nSELECT DEPT FROM STUDENT;\n```\n\n🔍 분석:\n- `DEPT` 컬럼의 모든 값을 가져옵니다\n- **DISTINCT(중복제거) 없음** → 학생 한 명당 한 행씩 출력\n- 즉, 총 학생 수만큼 200개의 튜플이 나옵니다\n\n📝 결과:\n```\n컴퓨터과\n컴퓨터과\n...\n(50개)\n전기과\n전기과\n...\n(100개)\n인터넷과\n인터넷과\n...\n(50개)\n```\n\n**답: ① = 200**\n\n---\n\n2️⃣ 두 번째 쿼리\n\n```sql\nSELECT DISTINCT DEPT FROM STUDENT;\n```\n\n🔍 분석:\n- `DISTINCT`는 중복을 제거합니다\n- 학과가 총 **3개(컴퓨터과, 전기과, 인터넷과)** 이므로\n- 중복 없이 3개만 남습니다\n\n📝 결과:\n```\n컴퓨터과\n전기과\n인터넷과\n```\n\n**답: ② = 3**\n\n---\n\n3️⃣ 세 번째 쿼리\n\n```sql\nSELECT COUNT(DISTINCT DEPT)\nFROM STUDENT\nWHERE DEPT = '인터넷과';\n```\n\n🔍 분석:\n- `WHERE DEPT = '인터넷과'` 조건으로 **인터넷과**만 필터링\n- 필터링 후 DEPT 컬럼에는 `인터넷과` 한 종류만 존재\n- `COUNT(DISTINCT DEPT)`는 중복 제거 후 개수를 세기\n- `인터넷과` 하나만 있으니 결과는 1\n\n📝 결과:\n```\n1\n```\n\n**답: ③ = 1**\n\n---\n\n🎯 최종 정답 요약\n\n| 문항 | 결과 | 해설 |\n|------|------|------|\n| ① | **200** | 전체 학생 수 (중복 포함) |\n| ② | **3** | 학과 종류 수 (중복 제거) |\n| ③ | **1** | 조건(인터넷과)에 해당하는 학과 종류 수 |\n\n---\n\n💡 핵심 개념\n\n1. **SELECT 컬럼**: 중복 포함, 모든 행 반환\n2. **SELECT DISTINCT 컬럼**: 중복 제거, 고유값만 반환\n3. **COUNT(DISTINCT 컬럼)**: 중복 제거 후 개수 반환\n4. **WHERE 절**: 조건 필터링 먼저 적용 → 그 다음 DISTINCT/COUNT 수행\n\n정답: ① 200, ② 3, ③ 1", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "✅ 정답: 2\n\n📌 코드 실행 과정 추적\n\n알고리즘: 완전수(Perfect Number) 찾기\n완전수: 자기 자신을 제외한 약수의 합이 자신과 같은 수\n\nn=6 검사:\n- k=6/2=3\n- j=1: 6%1==0 → s=0+1=1\n- j=2: 6%2==0 → s=1+2=3\n- j=3: 6%3==0 → s=3+3=6\n- s==n (6==6) ✅ → el=1\n\nn=28 검사:\n- k=28/2=14\n- j=1~14 중 약수: 1,2,4,7,14\n- s=1+2+4+7+14=28\n- s==n (28==28) ✅ → el=2\n\nn=7~27, 29~30:\n- 약수의 합이 자신과 다름 → 완전수 아님\n\n출력: el=2\n\n💡 완전수 개념:\n- 6 = 1+2+3\n- 28 = 1+2+4+7+14\n- 다음 완전수는 496, 8128...\n\n", "table_refs": [], "image_refs": ["images/2022_round3/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래 설명에 대하여 알맞는 답을 보기에서 고르시오.\n(기호식 보기가 있습니다. ex: CSRF 등)\n(   1   )은/는 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 ARM사에서 개발한 하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하는 하드웨어 기반의 보안 기술이다.\n(   2   )은/는 사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 유사한 유명 도메인을 미리 등록하는 일로 URL 하이재킹(hijacking)이라고도 한다.", "choices": [], "answer": {"keys": ["1. Trustzone", "2. typosquatting"], "raw_text": "1. Trustzone 2. typosquatting"}, "explanation": "이 문제는 **정보보안** 분야의 **Trustzone**과 **typosquatting**에 대한 문제입니다.\n\n[1. Trustzone (트러스트존)]\n\n[Trustzone의 정의]\n- ARM사에서 개발한 하드웨어 기반의 보안 기술\n- 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, **중요한 정보를 보호**하는 기술\n\n[문제에서 설명한 Trustzone의 특징]\n\n1. \"ARM사에서 개발한 하드웨어 기반의 보안 기술\":\n   - ARM (Advanced RISC Machines): 프로세서 설계 회사\n   - **하드웨어 기반**: 소프트웨어가 아닌 **하드웨어 레벨**에서 보안 구현\n   - 프로세서 칩 내부에 보안 기능 내장\n\n2. \"프로세서 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호\":\n   - **독립적인 보안 구역**: 프로세서 내부에 **보안 영역(Secure World)**과 **일반 영역(Normal World)** 분리\n   - **중요한 정보 보호**: 암호화 키, 인증 정보 등 보안이 중요한 데이터를 보안 구역에 저장\n   - **격리**: 보안 구역과 일반 구역 간 **하드웨어 레벨 격리**\n\n[Trustzone의 동작 원리]\n- **Normal World**: 일반 애플리케이션 실행 환경\n- **Secure World**: 보안이 중요한 코드 및 데이터 실행 환경\n- **하드웨어 전환**: 프로세서가 자동으로 두 세계 간 전환\n- **보안 보장**: Normal World에서 Secure World의 데이터 접근 불가\n\n[Trustzone의 주요 용도]\n- **모바일 기기**: 스마트폰, 태블릿 등\n- **IoT 디바이스**: 보안이 중요한 임베디드 시스템\n- **결제 시스템**: 신용카드 정보, 결제 인증\n- **생체 인증**: 지문, 얼굴 인식 데이터\n\n[2. typosquatting (타이포스쿼팅)]\n\n[typosquatting의 정의]\n- 사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 **유사한 유명 도메인을 미리 등록**하는 일\n- **URL 하이재킹(hijacking)**이라고도 함\n\n[영어 단어 풀이]\n- **Typo**: 오타, 철자 오류\n- **Squatting**: 불법 점유, 악의적 등록\n- **typosquatting**: 오타를 이용한 도메인 하이재킹\n\n[문제에서 설명한 typosquatting의 특징]\n\n1. \"사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수\":\n   - **오타 이용**: 사용자의 실수(오타)를 악용\n   - 예: \"google.com\" → \"googel.com\" (오타)\n   - 예: \"naver.com\" → \"naverr.com\" (철자 추가)\n\n2. **\"유사한 유명 도메인을 미리 등록\"**:\n   - **유명 도메인**: 구글, 네이버 등 잘 알려진 사이트\n   - **유사 도메인**: 원본과 비슷하게 보이는 도메인 등록\n   - 예: \"facebook.com\" → \"faceboook.com\" (글자 추가)\n   - 예: \"amazon.com\" → \"amazom.com\" (글자 누락)\n\n3. \"URL 하이재킹(hijacking)이라고도 한다\":\n   - **하이재킹**: 남의 것을 가로채는 행위\n   - URL을 가로채서 사용자를 속임\n\n[typosquatting의 공격 목적]\n- **피싱**: 사용자를 속여 개인정보 유출\n- **멀웨어 배포**: 악성 코드 다운로드 유도\n- **광고 수익**: 클릭 유도로 광고 수익 창출\n- **브랜드 손상**: 유명 브랜드의 평판 손상\n\n[typosquatting 예시]\n- \"google.com\" → \"gooogle.com\", \"gogle.com\"\n- \"microsoft.com\" → \"micrsoft.com\", \"microsft.com\"\n- \"apple.com\" → \"appple.com\", \"aple.com\"\n\n[typosquatting 방어 방법]\n- **도메인 사전 등록**: 유사 도메인을 미리 등록하여 보호\n- **사용자 교육**: 정확한 URL 입력 교육\n- **브라우저 보안**: 브라우저의 피싱 경고 기능\n\n[답]\n- (1) **Trustzone (트러스트존)**\n- (2) typosquatting (타이포스쿼팅)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "아래 설명에 대하여 알맞는 용어를 작성하시오.\n(       )은/는 여러 개의 사이트에서 한번의 로그인으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을 말한다. 일반적으로 서로 다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 하나의 사용자 정보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하게 하는 것을 말한다.\n즉 하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고 있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.", "choices": [], "answer": {"keys": ["SSO"], "raw_text": "SSO"}, "explanation": "이 문제는 SSO (Single Sign-On, 단일 로그인)에 대한 문제입니다.\n\n[SSO (Single Sign-On, 단일 로그인)이란?]\n\n[영어 약자 풀이]\n- **S**ingle: 단일, 하나의\n- **S**ign: 로그인\n- **O**n: 켜다, 시작하다\n- **SSO = Single Sign-On**\n\n[문제에서 설명한 SSO의 특징]\n\n1. \"여러 개의 사이트에서 한번의 로그인으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법\":\n   - **한 번의 로그인**: 사용자가 **한 번만** 로그인하면\n   - **여러 사이트 접속**: 여러 다른 사이트에 **자동으로 로그인**되어 이용 가능\n   - **자동 접속**: 추가 로그인 없이 다른 서비스 이용\n\n2. \"서로 다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 하나의 사용자 정보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하게 하는 것\":\n   - **통합 인증**: 여러 시스템이 **하나의 인증 시스템**을 공유\n   - **단일 사용자 정보**: 여러 시스템이 **같은 사용자 정보**를 사용\n   - **중앙 관리**: 사용자 인증 정보를 **중앙에서 관리**\n\n3. \"하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고 있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것\":\n   - **인증 정보 확인**: 다른 시스템에서 **인증 정보를 확인**\n   - **자동 로그인**: 인증 정보가 있으면 **자동으로 로그인 처리**\n   - **통합 인증 재시도**: 인증 정보가 없으면 **통합 인증 시스템으로 리다이렉트**\n\n[SSO의 동작 원리]\n\n1. **사용자가 첫 번째 시스템에 로그인**:\n   - 사용자가 통합 인증 서버에 로그인\n   - 인증 토큰(Token) 또는 세션 생성\n\n2. **다른 시스템 접근 시**:\n   - 사용자가 다른 시스템에 접근하려고 시도\n   - 해당 시스템이 **인증 정보 확인**\n   - 인증 정보가 있으면 **자동 로그인 처리**\n   - 인증 정보가 없으면 **통합 인증 서버로 리다이렉트**\n\n3. **통합 인증 서버**:\n   - 사용자 인증 정보를 중앙에서 관리\n   - 인증 토큰 발급 및 검증\n   - 여러 시스템 간 인증 정보 공유\n\n[SSO의 장점]\n\n1. **사용자 편의성**:\n   - 여러 번 로그인할 필요 없음\n   - 사용자 경험 향상\n\n2. **관리 효율성**:\n   - 사용자 정보를 중앙에서 관리\n   - 관리 비용 절감\n\n3. **보안 강화**:\n   - 중앙 집중식 보안 관리\n   - 비밀번호 정책 일원화\n\n[SSO의 주요 기술]\n- SAML (Security Assertion Markup Language): XML 기반 인증 프로토콜\n- **OAuth**: 인증 및 권한 부여 프레임워크\n- **OpenID Connect**: OAuth 2.0 기반 인증 프로토콜\n- **Kerberos**: 네트워크 인증 프로토콜\n\n[SSO 예시]\n- **Google 계정**: Gmail, YouTube, Google Drive 등에 한 번 로그인으로 모두 접근\n- **Microsoft 계정**: Office 365, OneDrive, Azure 등에 통합 인증\n- **기업 내부 시스템**: 여러 사내 시스템에 한 번 로그인으로 접근\n\n[SSO vs 일반 로그인]\n| 구분 | **일반 로그인** | **SSO** |\n|------|--------------|---------|\n| **로그인 횟수** | 각 사이트마다 로그인 필요 | 한 번만 로그인 |\n| **사용자 정보** | 각 시스템마다 별도 관리 | 통합 관리 |\n| **편의성** | 낮음 | 높음 |\n| **관리** | 분산 관리 | 중앙 관리 |\n\n[답] SSO (Single Sign-On, 단일 로그인)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 스케줄링에 관한 내용이다.\n괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["SJF", "RR", "SRT"], "raw_text": "SJF RR SRT"}, "explanation": "이 문제는 운영체제 분야의 핵심 개념을 이해하는 문제입니다.\n\n[문제 해석 과정]\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"SJF, RR, SRT\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.003449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 UML에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\nUML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.\n구성 요소로는 사물, (    1    ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (     2    ) 다이어그램은 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다.\n또한 UML 모델링에서 (     3    )은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는 오퍼레이션 세트를 정의하는 모델 요소이다.", "choices": [], "answer": {"keys": ["1. 관계", "2. 클래스", "3. 인터페이스"], "raw_text": "1. 관계 2. 클래스 3. 인터페이스"}, "explanation": "✅ 정답: 1. 사물, 2. 클래스, 3. 인터페이스\n\n📌 UML (Unified Modeling Language) 구성 요소\n\n**UML 정의:**\n- 통합 모델링 언어\n- 시스템을 모델로 표현해주는 대표적인 모델링 언어\n\n**구성 요소:**\n\n1️⃣ **사물 (Things)**\n- 모델을 구성하는 가장 중요한 기본 요소\n- 다이어그램 안에서 관계가 형성될 수 있는 대상\n- 종류: 구조 사물, 행동 사물, 그룹 사물, 주해 사물\n\n2️⃣ **관계 (Relationships)**\n- 사물과 사물 사이의 연관성\n- 종류: 연관, 집합, 포함, 일반화, 의존, 실체화\n\n3️⃣ **다이어그램 (Diagrams)**\n- 사물과 관계를 도형으로 표현\n- 구조 다이어그램: 클래스, 객체, 컴포넌트 등\n- 행위 다이어그램: 유스케이스, 시퀀스, 활동 등\n\n💡 핵심:\n- UML = 사물 + 관계 + 다이어그램\n- 시스템 설계와 문서화의 표준\n- 객체지향 분석 및 설계의 필수 도구\n\n", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 E-R다이어그램에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(아래 그래프 기호는 정확히 기억이 나지 않아 임의로 작성한 것이니 참고만 해주세요.)\n(    1    )  :  개체집합 - 관계집합 연결\n(    2    )  :  개체 집합과의 연결\n(    3    )  :  관계집합 - 관계집합의 속성 연결\n(    4    )  :  두 개체집합 관계에서 생성되는 값을 저장하는 속성\n(    5    )  :  같은 속성을 공유하는 개체들의 모임", "choices": [], "answer": {"keys": ["1. 실선", "2. 관계집합", "3. 점선"], "raw_text": "1. 실선 2. 관계집합 3. 점선"}, "explanation": "이 문제는 E-R 다이어그램(Entity-Relationship Diagram)의 구성 요소와 기호에 대한 문제입니다.\n\n[E-R 다이어그램이란?]\n- 데이터베이스 설계에서 **개념적 설계 단계**에서 사용하는 다이어그램\n- 엔티티(Entity), 속성(Attribute), 관계(Relationship)를 시각적으로 표현\n\n[문제에서 설명한 각 구성 요소]\n\n[1. (1) 개체집합 - 관계집합 연결]\n- **답: 실선**\n- 개체집합(Entity Set)과 관계집합(Relationship Set)을 연결하는 선\n- E-R 다이어그램에서 개체와 관계를 연결하는 **실선(직선)**으로 표현\n- 예: 학생(개체)과 수강(관계)을 실선으로 연결\n\n[2. (2) 개체 집합과의 연결]\n- **답: 관계집합**\n- 개체집합들을 연결하는 관계집합(Relationship Set)을 의미\n- 여러 개체집합 간의 관계를 나타내는 집합\n- 예: 학생 개체집합과 과목 개체집합을 연결하는 \"수강\" 관계집합\n\n[3. (3) 관계집합 - 관계집합의 속성 연결]\n- **답: 점선**\n- 관계집합과 그 관계집합의 속성을 연결하는 **점선(Dashed Line)**\n- 관계집합 자체가 가지고 있는 속성(예: 수강 날짜, 성적 등)을 연결할 때 사용\n- 개체집합과 속성을 연결하는 점선과 유사하지만, 관계집합의 속성임을 구분\n\n[4. (4) 두 개체집합 관계에서 생성되는 값을 저장하는 속성]\n- **답: 관계집합의 속성**\n- 두 개체집합 간의 관계에서 발생하는 값을 저장하는 속성\n- 예: \"학생\"과 \"과목\" 관계에서 \"수강일자\", \"성적\" 등은 관계집합의 속성\n- 개체집합의 속성이 아닌 관계 자체의 속성\n\n[5. (5) 같은 속성을 공유하는 개체들의 모임]\n- **답: 개체집합**\n- **개체집합(Entity Set)**: 같은 속성을 공유하는 개체들의 모임\n- 예: \"학생\" 개체집합은 학번, 이름, 학과 등의 속성을 공유하는 학생들의 모임\n- 데이터베이스에서 테이블(릴레이션)에 해당\n\n[E-R 다이어그램 기호 요약]\n| 요소 | 기호 | 설명 |\n|------|------|------|\n| **개체집합** | 사각형 | 엔티티를 나타냄 |\n| **관계집합** | 마름모 | 관계를 나타냄 |\n| **속성** | 타원 | 속성을 나타냄 |\n| **개체-관계 연결** | **실선** | 개체와 관계를 연결 |\n| **관계-속성 연결** | **점선** | 관계와 속성을 연결 |\n| **개체-속성 연결** | 점선 | 개체와 속성을 연결 |\n\n[답]\n- (1) **실선**\n- (2) **관계집합**\n- (3) **점선**\n- (4) **관계집합의 속성**\n- (5) **개체집합**", "table_refs": [], "image_refs": ["images/2022_round3/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["0123"], "raw_text": "0123"}, "explanation": "✅ 정답: 0123\n\n📌 코드 실행 과정 추적\n\nMakeArray() 메서드:\n\n1️⃣ int[] tempArr = new int[4];\n   - 크기 4인 정수 배열 생성\n   - tempArr = [0, 0, 0, 0] (기본값)\n\n2️⃣ for(int i=0; i<4; i++)\n   - tempArr[i] = i;\n   \n   | i | tempArr[i] = i | 배열 상태 |\n   |---|----------------|----------|\n   | 0 | tempArr[0] = 0 | [0, 0, 0, 0] |\n   | 1 | tempArr[1] = 1 | [0, 1, 0, 0] |\n   | 2 | tempArr[2] = 2 | [0, 1, 2, 0] |\n   | 3 | tempArr[3] = 3 | [0, 1, 2, 3] ✅ |\n\n3️⃣ return tempArr → [0, 1, 2, 3]\n\nmain 메서드:\n\n4️⃣ intArr = MakeArray();\n   - intArr = [0, 1, 2, 3]\n\n5️⃣ 출력:\n   - i=0: 0\n   - i=1: 1\n   - i=2: 2\n   - i=3: 3\n   → 0123\n\n💡 핵심:\n- 배열 요소에 인덱스 값을 저장\n- println()으로 한 줄씩 출력하면 세로로 나열됨\n\n", "table_refs": [], "image_refs": ["images/2022_round3/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["993"], "raw_text": "993"}, "explanation": "✅ 정답: 993\n\n📌 코드 실행 과정 추적\n\n조건 분석:\n- i%3==0: 3의 배수\n- i%2!=0: 홀수\n→ 3의 배수이면서 홀수인 수를 찾음\n\n실행 과정:\n- i=1~2: 조건 불만족\n- i=3: 3%3==0, 3%2==1 → a=3 ✅\n- i=4~8: 조건 불만족\n- i=9: 9%3==0, 9%2==1 → a=9 ✅\n- i=15: a=15 ✅\n- i=21: a=21 ✅\n- ...\n- i=987: a=987 ✅\n- i=993: 993%3==0, 993%2==1 → a=993 ✅\n- i=996: 996%3==0, 996%2==0 → 짝수 ✗\n- i=997~998: 3의 배수 아님 ✗\n\n💡 핵심:\n변수 a는 조건을 만족할 때마다 계속 덮어씌워지므로, 최종값은 999 미만의 마지막 홀수 3의 배수인 993이 됩니다.\n\n", "table_refs": [], "image_refs": ["images/2022_round3/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:27:19.004462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
