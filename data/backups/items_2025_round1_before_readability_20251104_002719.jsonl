{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 네트워크 보완에 관련된 문제이다.\n괄호 안에 알맞는 용어를 작성하시오.\n(   )은/는 '세션을 가로채다.' 라는 의미로 다른 사람의 세션 상태를 훔치거나 도용하여 액세스하는 해킹 기법이다.\nTCP (   )은/는 TCP의 3-way 핸드셰이크가 완료된 후에 공격자가 시퀀스 번호 등을 조작하여 정상적인 세션을 가로채고 인증 없이 통신을 탈취하는 공격 공격이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의와 개념:**\n\n1. **기본 정의**: 세션 하이재킹은 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.\n\n2. **세션이란**: 세션은 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.\n\n**TCP 세션 하이재킹:**\n\n1. **3-way 핸드셰이크**: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.\n- 클라이언트가 서버에 SYN 패킷 전송\n- 서버가 SYN-ACK 패킷 응답\n- 클라이언트가 ACK 패킷 전송 이 과정이 완료되면 정상적인 통신이 시작됩니다.\n\n2. **공격 과정**:\n- 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.\n- TCP 시퀀스 번호를 예측하거나 조작합니다.\n- 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.\n- 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.\n\n**문제 해석**: 문제에서 '세션을 가로채다', 'TCP 3-way 핸드셰이크', '시퀀스 번호 조작', '인증 없이 통신 탈취' 등의 키워드가 언급되어 있으므로 답은 \"세션 하이재킹\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.900403", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.895109"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 제약조건과 관련된 문제이다.\n괄호 안에 알맞는 용어를 보기에 골라 작성하시오.\n개체, 참조, 도메인", "choices": [], "answer": {"keys": ["ㄱ. 도메인", "ㄴ. 개체", "ㄷ. 참조"], "raw_text": "ㄱ. 도메인\nㄴ. 개체\nㄷ. 참조"}, "explanation": "이 문제는 데이터베이스의 제약조건 개념인 도메인(Domain), 개체 무결성(Entity Integrity), 참조 무결성(Referential Integrity)에 관한 문제입니다.\n\n**데이터베이스 제약조건 이해:**\n\n1. **도메인(Domain) 제약조건:**\n- 도메인은 특정 속성(컬럼)에 입력될 수 있는 값의 유형이나 범위를 정의합니다.\n- 예를 들어, 나이 속성의 도메인은 0 이상의 정수일 수 있습니다.\n- 도메인 제약조건은 데이터의 타입, 길이, 범위 등을 제한하여 데이터 무결성을 보장합니다.\n- 문제에서 \"특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준\"이라고 설명한 것이 도메인 제약조건입니다.\n\n2. **개체 무결성(Entity Integrity):**\n- 개체 무결성은 릴레이션(테이블)의 기본 키(Primary Key)가 NULL이 될 수 없고, 중복될 수 없다는 규칙입니다.\n- 기본 키는 각 튜플(행)을 고유하게 식별하는 역할을 하므로 반드시 값이 있어야 합니다.\n- 문제의 이미지나 설명에서 개체 무결성과 관련된 내용이 있을 것입니다.\n\n3. **참조 무결성(Referential Integrity):**\n- 참조 무결성은 한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조되는 값이 반드시 존재해야 한다는 규칙입니다.\n- 외래 키(Foreign Key)는 다른 릴레이션의 기본 키를 참조하는 속성입니다.\n- 문제에서 \"한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미\"라고 설명한 것이 외래 키(참조 무결성)입니다.\n\n**답:** 보기에서:\n- ㄱ. domain: 도메인 제약조건 (4번 문제)\n- ㄴ. 개체: 개체 무결성 관련\n- ㄷ. 참조: 참조 무결성, 외래 키 (3번 문제)\n\n문제의 실제 설명과 이미지를 바탕으로 정확히 매칭하면 \"ㄱ. 도메인, ㄴ. 개체, ㄷ. 참조\"입니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.895109"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "아래의 내용에서 설명 글의 괄호안의 용어를 영문 약자로 작성하시오.\n(        ) 은/는 3글자의 영어 약자로 이루어진 오류 기법으로 데이터를 전송하거나 저장할 때 데이터의 오류를 감지하는 데 사용되는 오류 검출 코드이다.\n(        ) 은/는 데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인하는 기법이다.\n(        ) 은/는 데이터 전송의 안정성을 높이는 데 중요한 역할을 한다.\n데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고나머지를 (       ) 값으로 삼는다.", "choices": [], "answer": {"keys": ["CRC"], "raw_text": "CRC"}, "explanation": "CRC(Cyclic Redundancy Check)는 데이터 전송 시 오류를 검출하는 코드입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"3글자의 영어 약자로 이루어진 오류 기법\"**\n- CRC는 Cyclic Redundancy Check의 약자로 정확히 3글자입니다.\n- 데이터 전송이나 저장 시 오류를 감지하는 데 사용됩니다.\n\n2. **\"데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인\"**\n- CRC는 데이터에 체크섬(나머지 값)을 추가하여 전송합니다.\n- 수신 측에서 같은 방법으로 체크섬을 다시 계산하여 두 값이 일치하면 오류가 없는 것으로, 다르면 오류가 발생한 것으로 판단합니다.\n\n3. **\"데이터 전송의 안정성을 높이는 데 중요한 역할\"**\n- CRC는 통신이나 저장 매체에서 발생할 수 있는 데이터 손상을 감지하여 신뢰성을 높입니다.\n\n4. **\"데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고 나머지를 ( ) 값으로 삼는다\"**\n- CRC는 생성 다항식(Generator Polynomial)을 사용하여 계산합니다.\n- 예시로 주어진 \"x³ + x + 1\"은 다항식을 이진수로 표현하면 \"1011\"이 됩니다.\n- 데이터를 이 다항식으로 나눗셈 연산을 수행하고 나머지를 CRC 값으로 사용합니다.\n\n**CRC 계산 과정:**\n1. 데이터에 0을 추가 (다항식 차수만큼)\n2. 생성 다항식으로 XOR 연산 (2진수 나눗셈)\n3. 나머지를 CRC 값으로 사용\n\n**답:** 문제에서 설명한 모든 특징(3글자 약자, 체크섬 추가, 이진수 다항식 나눗셈)이 CRC와 정확히 일치하므로 답은 \"CRC\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.895109"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 악성코드 관련된 문제이다.\n아래 내용을 확인하여\n\n보기에 골라 작성하시오.\n사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.\n‘겁을 주다’라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불 하거나 특정 행동을 유도하는 랜섬웨어이다.\n가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식으로 작동한다.\n\n[보기]\n\nㄱ. 컴포넌트 웨어\n\nㄴ. 유즈웨어\n\nㄷ. 셔블웨어\n\nㄹ. 스캐어 웨어\n\nㅁ. 안티 스파이 웨어\n\nㅂ. 네트웨어\n\nㅅ. 그룹웨어\n\nㅇ. 애드웨어", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "스캐어웨어(Scareware)는 사용자를 속여 돈을 지불하거나 소프트웨어를 구매하도록 조작하는 악성 소프트웨어입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발\"**\n- 스캐어웨어는 사용자의 두려움(scare)을 이용합니다.\n- 가짜 경고나 위협적인 메시지를 보여줘서 사용자가 당황하게 만듭니다.\n- 사용자가 긴급하게 대응해야 한다고 느끼도록 조작합니다.\n\n2. **\"'겁을 주다'라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불하거나 특정 행동을 유도하는 랜섬웨어\"**\n- \"Scare\"는 \"겁을 주다, 놀라게 하다\"라는 의미입니다.\n- 공포 마케팅 전략을 사용합니다.\n- 랜섬웨어와 유사하지만, 실제로 데이터를 암호화하지 않고 가짜 경고를 보여줍니다.\n\n3. **\"가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식\"**\n- 가짜 안티바이러스 경고를 표시합니다.\n- \"시스템이 감염되었습니다\", \"바로 지금 처리하세요\" 등의 메시지를 보여줍니다.\n- 사용자로 하여금 가짜 안티바이러스 소프트웨어를 구매하거나 설치하도록 유도합니다.\n\n**보기 분석:**\n- ㄱ. 컴포넌트 웨어: 컴포넌트 기반 소프트웨어\n- ㄴ. 유즈웨어: 사용자가 만든 소프트웨어\n- ㄷ. 셔블웨어: 평가판 소프트웨어\n- **ㄹ. 스캐어 웨어: 공포를 이용한 악성 소프트웨어** ✓\n- ㅁ. 안티 스파이 웨어: 스파이웨어 방지 소프트웨어\n- ㅂ. 네트웨어: 네트워크 기반 소프트웨어\n- ㅅ. 그룹웨어: 그룹 협업 소프트웨어\n- ㅇ. 애드웨어: 광고 소프트웨어\n\n**답:** 문제에서 설명한 모든 특징(공포 유발, 가짜 경고, 속임수)이 스캐어웨어와 정확히 일치하므로 답은 \"ㄹ\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["출력1출력5"], "raw_text": "출력1출력5"}, "explanation": "이 Java 코드는 예외 처리 메커니즘(try-catch-finally)을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java int a = 5, b = 0;\ntry {\nSystem.out.print(a/b); // 5 / 0 → ArithmeticException 발생!\n} catch(ArithmeticException e) {\nSystem.out.print(\"출력1\");\n} catch(ArrayIndexOutOfBoundsException e) {\nSystem.out.print(\"출력2\");\n} catch(NumberFormatException e) {\nSystem.out.print(\"출력3\");\n} catch(Exception e) {\nSystem.out.print(\"출력4\");\n} finally {\nSystem.out.print(\"출력5\");\n}\n```\n\n**실행 과정:**\n\n1. **try 블록 실행:**\n- `a = 5`, `b = 0`\n- `System.out.print(5 / 0)` 실행 시도\n- **0으로 나누기 연산 → `ArithmeticException` 발생**\n\n2. **예외 처리:**\n- Java는 발생한 예외 타입을 찾기 위해 catch 블록들을 순서대로 확인합니다.\n- 첫 번째 catch: `catch(ArithmeticException e)` → **일치!**\n- 따라서 \"출력1\"을 출력합니다.\n\n3. **finally 블록 실행:**\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- \"출력5\"를 출력합니다.\n\n4. **최종 출력:**\n- \"출력1\" + \"출력5\" = **\"출력1출력5\"**핵심 포인트:**\n- Java의 예외 처리 순서: try → catch(일치하는 예외 타입) → finally\n- 여러 catch 블록이 있을 때 첫 번째로 일치하는 catch 블록이 실행됩니다.\n- finally 블록은 예외 발생 여부와 관계없이 반드시 실행됩니다.\n\n**답:** \"출력1출력5\"", "table_refs": [], "image_refs": ["images/2025_round1/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [{"language": "java", "code": "public class Main {\n  public static void main(String[] args) {\n    int a=5,b=0;\n    try{\n      System.out.print(a/b);\n    }catch(ArithmeticException e){\n      System.out.print(\"출력1\");\n    }catch(ArrayIndexOutOfBoundsException e) {\n      System.out.print(\"출력2\");\n    }catch(NumberFormatException e) {\n      System.out.print(\"출력3\");\n    }catch(Exception e){\n      System.out.print(\"출력4\");\n    }finally{\n      System.out.print(\"출력5\");\n    }\n  }\n}", "line_numbers": [1, 18], "file": "data/codes/2025_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 내용은 ARP/RARP에 대한 설명이다. 각 설명에 해당하는 것을 작성하시오.\n\n(1) 은/는 네트워크상에서 IP 주소를 MAC 주소로 변환하는 프로토콜이고,\n( 2 ) 은/는 MAC 주소를 IP 주소로 변환하는 프로토콜이다.", "choices": [], "answer": {"keys": ["(1) ARP", "(2) RARP"], "raw_text": "(1) ARP\n(2) RARP"}, "explanation": "ARP(Address Resolution Protocol)와 RARP(Reverse Address Resolution Protocol)는 네트워크에서 주소 변환을 담당하는 프로토콜입니다.\n\n**문제 분석:**\n\n**(1) IP 주소를 MAC 주소로 변환하는 프로토콜:**\n- **ARP(Address Resolution Protocol)**는 IP 주소를 물리적 주소인 MAC 주소로 변환합니다.\n- 예를 들어, 컴퓨터가 네트워크상의 다른 컴퓨터와 통신하려면 IP 주소는 알고 있지만, 실제로 데이터를 전송하려면 MAC 주소가 필요합니다.\n- ARP는 브로드캐스트를 통해 \"이 IP 주소를 가진 컴퓨터의 MAC 주소를 알려주세요\"라고 요청하고, 해당 컴퓨터가 자신의 MAC 주소를 응답합니다.\n\n**(2) MAC 주소를 IP 주소로 변환하는 프로토콜:**\n- **RARP(Reverse Address Resolution Protocol)**는 ARP의 반대 개념입니다.\n- MAC 주소를 알고 있지만 IP 주소를 모를 때 사용합니다.\n- 주로 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아오는 데 사용됩니다.\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용되고 있습니다.\n\n**ARP와 RARP의 관계:**\n- ARP: IP 주소 → MAC 주소 변환\n- RARP: MAC 주소 → IP 주소 변환 (역방향)\n\n**답:** (1) ARP, (2) RARP", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 SQL 문제이다.\n아래 두 테이블을 참고하여\n\n보기에 쿼리 실행 결과를 작성하시오.\nSELECT name, incentive FROM emp, sal WHERE emp.id = sal.id and incentives >= 500", "choices": [], "answer": {"keys": ["이순신", "1000"], "raw_text": "이순신 1000"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 이순신, 1000입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q007.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래는 데이터베이스에 관련된 설명이다.\n알맞는 용어를 보기에서 골라 괄호를 작성하시오.\n\n1. 릴레이션에서 속성의 개수를 의미 : ( 1 )\n\n2. 릴레이션에서 튜플의 개수를 의미 : ( 2 )\n\n3. 한 릴레이션의 속상이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미 : ( 3 )\n\n4. 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준 : ( 4 )\n\n[보기]\n\nㄱ. domain\n\nㄴ. primary\n\nㄷ. degree\n\nㄹ. candidate\n\nㅁ. cardinality\n\nㅂ. attribute\n\nㅅ. foreign", "choices": [], "answer": {"keys": ["(1) ㄷ", "(2) ㅁ", "(3) ㅅ", "(4) ㄱ"], "raw_text": "(1) ㄷ\n(2) ㅁ\n(3) ㅅ\n(4) ㄱ"}, "explanation": "데이터베이스의 핵심 개념을 이해하는 문제입니다.\n\n1. 개념 이해: 문제에서 설명하는 데이터베이스 용어나 개념의 정의를 확인합니다.\n2. 관계 파악: 테이블 간의 관계, 속성 간의 종속 관계 등을 이해합니다.\n3. 제약조건: 무결성 제약조건, 키 제약조건 등을 확인합니다.\n4. 정규화: 정규형에 대한 이해가 필요한 경우 각 정규형의 특징을 확인합니다.\n\n문제의 설명과 보기, 이미지 등을 종합적으로 고려하면 답은 (1) ㄷ, (2) ㅁ, (3) ㅅ입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["프로그래밍"], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "IP 주소가 192.168.35.10, 서브넷 255.255.252.0인 PC에서 브로드캐스팅으로 다른 IP로 정보를 전달한다고 할 때 수신할 수 있는 알맞는 IP를 보기에서 골라 모두 작성하시오.\n\n[보기]\n\nㄱ. 192.168.34.1\n\nㄴ. 192.168.32.19\n\nㄷ. 192.168.35.200\n\nㄹ. 192.168.33.138\n\nㅁ. 192.168.35.50", "choices": [], "answer": {"keys": ["ㄱ,ㄴ,ㄷ,ㄹ,ㅁ"], "raw_text": "ㄱ,ㄴ,ㄷ,ㄹ,ㅁ"}, "explanation": "이 문제는 서브넷 마스크와 브로드캐스트 주소 범위를 이해하는 문제입니다.\n\n**주어진 정보:**\n- IP 주소: 192.168.35.10\n- 서브넷 마스크: 255.255.252.0\n\n**서브넷 마스크 분석:**\n- 255.255.252.0을 이진수로 변환: 11111111.11111111.11111100.00000000\n- 서브넷 비트 수: 22개 (앞의 22개 1)\n- 호스트 비트 수: 10개 (뒤의 10개 0)\n\n**네트워크 주소 계산:**\nIP 주소와 서브넷 마스크를 AND 연산:\n- IP: 192.168.35.10 = 11000000.10101000.00100011.00001010\n- 마스크: 255.255.252.0 = 11111111.11111111.11111100.00000000\n- AND 결과: 192.168.32.0\n\n**브로드캐스트 범위:**\n- 네트워크 주소: 192.168.32.0\n- 브로드캐스트 주소: 192.168.35.255 (네트워크 주소 + 호스트 비트 모두 1)\n- 사용 가능한 IP 범위: 192.168.32.1 ~ 192.168.35.254\n\n**보기 분석:**\n- ㄱ. 192.168.34.1 → 32~35 범위 내 ✓\n- ㄴ. 192.168.32.19 → 32~35 범위 내 ✓\n- ㄷ. 192.168.35.200 → 32~35 범위 내 ✓\n- ㄹ. 192.168.33.138 → 32~35 범위 내 ✓\n- ㅁ. 192.168.35.50 → 32~35 범위 내 ✓\n\n모든 보기가 같은 네트워크(서브넷)에 속하므로 브로드캐스트로 모두 수신 가능합니다.\n\n**답:** \"ㄱ,ㄴ,ㄷ,ㄹ,ㅁ\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["4", "BACDE"], "raw_text": "4 BACDE"}, "explanation": "이 C언어 코드는 문자 배열에 문자를 삽입하는 알고리즘을 구현한 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c char Data[5] = {'B', 'A', 'D', 'E'};\nchar c = 'C';\n```\n- 배열: `Data[0]='B', Data[1]='A', Data[2]='D', Data[3]='E', Data[4]='\u0000'`\n- 삽입할 문자: `c = 'C'`\n\n2. **첫 번째 출력:**\n```c printf(\"%d\n\", Data[3]-Data[1]);\n```\n- `Data[3] = 'E'` (ASCII 69)\n- `Data[1] = 'A'` (ASCII 65)\n- `69 - 65 = 4` → **출력: \"4\"**\n\n3. **삽입 위치 찾기:**\n```c for(i=0; i<5; ++i) {\nif(Data[i] > c) // 'C'보다 큰 값 찾기 break;\n}\n```\n- i=0: 'B' < 'C' → 계속\n- i=1: 'A' < 'C' → 계속\n- i=2: 'D' > 'C' → **break!** (i=2)\n\n4. **문자 삽입 (오른쪽으로 시프트):**\n```c temp = Data[2]; // temp = 'D'\nData[2] = 'C'; // 삽입 i = 3;\n\n// 나머지 원소들을 오른쪽으로 한 칸씩 이동 for(; i<5; ++i) {\ntemp2 = Data[i];\nData[i] = temp;\ntemp = temp2;\n}\n```\n- i=3: Data[3]='E'를 temp2에 저장 → Data[3]='D', temp='E'\n- i=4: Data[4]='\u0000'를 temp2에 저장 → Data[4]='E', temp='\u0000'\n- 최종 배열: `{'B', 'A', 'C', 'D', 'E'}`\n\n5. **최종 출력:**\n```c for(i=0; i<5; i++)\nprintf(\"%c\", Data[i]);\n```\n- **출력: \"BACDE\"**답:** \"4 BACDE\"", "table_refs": [], "image_refs": ["images/2025_round1/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nchar Data[5] = {'B', 'A', 'D', 'E'};\nchar c;\nint main(){\n    int i, temp, temp2;\n    c = 'C';\n    printf(\"%d\\n\", Data[3]-Data[1]);\n    for(i=0;i<5;++i){\n        if(Data[i]>c)\n            break;\n    }\n    temp = Data[i];\n    Data[i] = c;\n    i++;\n    for(;i<5;++i){\n        temp2 = Data[i];\n        Data[i] = temp;\n        temp = temp2;\n    }\n    for(i=0;i<5;i++){\n        printf(\"%c\", Data[i]);\n    }\n}", "line_numbers": [1, 23], "file": "data/codes/2025_round1/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["13"], "raw_text": "13"}, "explanation": "이 C언어 코드는 2차원 배열을 동적으로 할당하고 데이터를 배치한 후 합을 계산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **2차원 배열 동적 할당:**\n```c int rows = 3, cols = 3;\nint data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};\n```\n- 3×3 배열을 동적으로 할당합니다.\n- data 배열: {5, 2, 7, 4, 1, 8, 3, 6, 9}\n\n2. **set() 함수 분석:**\n```c void set(int** arr, int* data, int rows, int cols) {\nfor (int i = 0; i < rows * cols; ++i) {\narr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n}\n}\n```\n- i=0: arr[(1/3)%3][1%3] = arr[0][1] = data[0] = 5\n- i=1: arr[(2/3)%3][2%3] = arr[0][2] = data[1] = 2\n- i=2: arr[(3/3)%3][3%3] = arr[1][0] = data[2] = 7\n- i=3: arr[(4/3)%3][4%3] = arr[1][1] = data[3] = 4\n- i=4: arr[(5/3)%3][5%3] = arr[1][2] = data[4] = 1\n- i=5: arr[(6/3)%3][6%3] = arr[2][0] = data[5] = 8\n- i=6: arr[(7/3)%3][7%3] = arr[2][1] = data[6] = 3\n- i=7: arr[(8/3)%3][8%3] = arr[2][2] = data[7] = 6\n- i=8: arr[(9/3)%3][9%3] = arr[0][0] = data[8] = 9\n\n**배열 상태:**\n```\n[9][5][2]\n[7][4][1]\n[8][3][6]\n```\n\n3. **합 계산:**\n```c for (int i = 0; i < rows * cols; i++) {\nsum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n}\n```\n- i가 짝수면 +, 홀수면 - 부호를 적용합니다.\n- i=0: arr[0][0]=9 × 1 = 9\n- i=1: arr[0][1]=5 × (-1) = -5\n- i=2: arr[0][2]=2 × 1 = 2\n- i=3: arr[1][0]=7 × (-1) = -7\n- i=4: arr[1][1]=4 × 1 = 4\n- i=5: arr[1][2]=1 × (-1) = -1\n- i=6: arr[2][0]=8 × 1 = 8\n- i=7: arr[2][1]=3 × (-1) = -3\n- i=8: arr[2][2]=6 × 1 = 6\n\n**합:** 9 - 5 + 2 - 7 + 4 - 1 + 8 - 3 + 6 = **13**답:** 13", "table_refs": [], "image_refs": ["images/2025_round1/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nvoid set(int** arr, int* data, int rows, int cols) {\n    for (int i = 0; i < rows * cols; ++i) {\n        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n    }\n}\nint main() {\n    int rows = 3, cols = 3, sum = 0;\n    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}; \n    int** arr;\n    arr = (int**) malloc(sizeof(int*) * rows);\n    for (int i = 0; i < cols; i++) {\n        arr[i] = (int*) malloc(sizeof(int) * cols);\n    }\n    set(arr, data, rows, cols);\n    for (int i = 0; i < rows * cols; i++) {\n        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n    }\n    for(int i=0; i<rows; i++) {\n        free(arr[i]);\n    }\n    free(arr);\n    printf(\"%d\", sum);\n}", "line_numbers": [1, 25], "file": "data/codes/2025_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 결합도와 관련된 내용이다.\n보기에 알맞는 답을 골라 작성하시오.\n\n(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우의 결합도\n(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\nㄱ. 자료 결합도\n\nㄴ. 스탬프 결합도\n\nㄷ. 제어 결합도\n\nㄹ. 공통 결합도\n\nㅁ. 내용 결합도\n\nㅂ. 외부 결합도", "choices": [], "answer": {"keys": ["(1) ㅁ", "(2) ㄴ", "(3) ㄹ"], "raw_text": "(1) ㅁ\n(2) ㄴ\n(3) ㄹ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 결합도(Coupling) 개념에 관한 문제입니다.\n\n**문제에서 설명하는 각 결합도:**\n\n**(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우:**\n- **내용 결합도(Content Coupling)**는 가장 강한 결합도입니다.\n- 한 모듈이 다른 모듈의 내부 구현(변수, 함수 등)을 직접 접근하는 경우입니다.\n- 모듈 간의 독립성이 매우 낮아 한 모듈의 변경이 다른 모듈에 직접적인 영향을 미칩니다.\n- 예: 모듈 A가 모듈 B의 전역 변수나 내부 함수를 직접 호출\n\n**(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우:**\n- **스탬프 결합도(Stamp Coupling)**는 구조체나 배열 등의 복합 자료구조가 전달되는 경우입니다.\n- 모듈 간에 필요한 데이터만 전달하지 않고 전체 구조를 전달하므로 불필요한 의존성이 생깁니다.\n- 예: 모듈 A가 모듈 B에 전체 구조체를 전달\n\n**(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용:**\n- **공통 결합도(Common Coupling)**는 여러 모듈이 공통으로 사용하는 전역 변수나 공유 메모리를 사용하는 경우입니다.\n- 전역 변수를 통해 모듈 간에 상호작용하므로 모듈의 독립성이 떨어집니다.\n- 예: 여러 모듈이 같은 전역 변수를 읽고 쓰는 경우\n\n**결합도 순서 (강함 → 약함):**\n1. 내용 결합도 (가장 강함)\n2. 공통 결합도 3. 외부 결합도 4. 제어 결합도 5. 스탬프 결합도 6. 자료 결합도 (가장 약함, 이상적)\n\n**답:** (1) ㅁ (내용 결합도), (2) ㄴ (스탬프 결합도), (3) ㄹ (공통 결합도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["54"], "raw_text": "54"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 54을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void main(String[] args) {\n        new Child();\n        System.out.println(Parent.total);\n    }\n}\nclass Parent {\n    static int total = 0;\n    int v = 1;\n    public Parent() {\n        total += (++v);\n        show();    \n    }\n    public void show() {\n        total += total;\n    }\n}\nclass Child extends Parent {\n    int v = 10;\n    public Child() {\n        v += 2;\n        total += v++;\n        show();\n    }\n    @Override\n    public void show() {\n        total += total * 2;\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2025_round1/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래는 디자인 패턴에 대한 설명이다.\n알맞는 답을 보기에 골라 작성하시오.\n서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다.\n기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다.\n기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다.", "choices": [], "answer": {"keys": ["Adapter"], "raw_text": "Adapter"}, "explanation": "Adapter(어댑터) 패턴은 기존 클래스를 수정하지 않고 다른 인터페이스로 변환하여 사용할 수 있게 해주는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다\"**\n- 어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스들을 연결합니다.\n- 예를 들어, 클래스 A는 `charge()` 메서드를 가지고 있지만, 클라이언트는 `plugIn()` 메서드를 기대하는 경우, 어댑터가 `plugIn()`을 `charge()`로 변환합니다.\n\n2. **\"기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다\"**\n- Adaptee: 변환이 필요한 기존 클래스\n- Target: 클라이언트가 원하는 인터페이스\n- Adapter: Adaptee를 Target 인터페이스로 변환하는 중간 클래스\n- 어댑터가 Target 인터페이스를 구현하고, 내부적으로 Adaptee를 호출합니다.\n\n3. **\"기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다\"**\n- 어댑터는 기존 클래스를 감싸는 래퍼(Wrapper) 역할을 합니다.\n- 기존 클래스의 기능은 그대로 사용하되, 인터페이스만 변환합니다.\n- 객체 어댑터 방식: 객체 합성을 사용하여 Adaptee를 포함\n- 클래스 어댑터 방식: 다중 상속을 사용하여 Target과 Adaptee를 상속\n\n**어댑터 패턴의 활용 예시:**\n- 전기 콘센트 어댑터: 110V 플러그를 220V 콘센트에 사용\n- 레거시 시스템과 새 시스템 연동\n- 서로 다른 API를 통합\n\n**답:** 문제에서 설명한 모든 특징(인터페이스 변환, 어댑터 클래스, 래퍼 역할)이 Adapter 패턴과 정확히 일치하므로 답은 \"Adapter\"입니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "문장(Statement) 커버리지 테스트를 수행하려고 한다. 코드를 아래의 제어 흐름도 빈칸에 연결되도록 작성하고 문장 커버리지 순서대로 작성하시오.", "choices": [], "answer": {"keys": ["(1) int a = 0", "(2) a < m || b[a] < x", "(3) b[a] < 0", "(4) b[a] = -b[a];", "(5) a++;", "(6) return 1;", "(7) ③ → ④ → ⑤ → ② → ⑥"], "raw_text": "(1) int a = 0\n(2) a < m || b[a] < x\n(3) b[a] < 0\n(4) b[a] = -b[a];\n(5) a++;\n(6) return 1;\n(7) ③ → ④ → ⑤ → ② → ⑥"}, "explanation": "unknown 코드를 단계별로 실행하면서 변수의 초기값과 변화를 추적합니다.\n조건문, 반복문, 함수 호출 등을 순서대로 따라가며 각 단계의 결과를 확인합니다.\n최종 출력값 (1) int a = 0, (2) a < m || b[a] < x, (3) b[a] < 0, (4) b[a] = -b[a];, (5) a++;, (6) return 1;, (7) ③ → ④ → ⑤ → ② → ⑥을 도출하는 과정을 이해합니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q015_1.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "unknown", "code": "int Main(int b[], int m, int x) {\n    int a = 0;\n    while (a < m || b[a] < x) {\n        if (b[a] < 0)\n            b[a] = -b[a];\n        a++;\n    }\n    return 1;\n}", "line_numbers": [1, 9], "file": "data/codes/2025_round1/Q015_code.txt"}], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["unknown"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "(\n\n①    )\n\n2. (    ②    )\n\n3. (    ③    )\n\n4. (    ④    )    5. (    ⑤    )  6. (    ⑥    )\n문장 커버리지 순서 1 → 2\n→ (          ⑦           )", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의와 개념:**\n\n1. **기본 정의**: 세션 하이재킹은 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.\n\n2. **세션이란**: 세션은 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.\n\n**TCP 세션 하이재킹:**\n\n1. **3-way 핸드셰이크**: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.\n- 클라이언트가 서버에 SYN 패킷 전송\n- 서버가 SYN-ACK 패킷 응답\n- 클라이언트가 ACK 패킷 전송 이 과정이 완료되면 정상적인 통신이 시작됩니다.\n\n2. **공격 과정**:\n- 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.\n- TCP 시퀀스 번호를 예측하거나 조작합니다.\n- 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.\n- 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.\n\n**문제 해석**: 문제에서 '세션을 가로채다', 'TCP 3-way 핸드셰이크', '시퀀스 번호 조작', '인증 없이 통신 탈취' 등의 키워드가 언급되어 있으므로 답은 \"세션 하이재킹\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 20을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void main(String[] args) {\n        int[] data = {3, 5, 8, 12, 17};\n        System.out.println(func(data, 0, data.length - 1));\n    }\n    static int func(int[] a, int st, int end) {\n        if (st >= end) return 0;\n        int mid = (st + end) / 2;\n        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n    } \n}", "line_numbers": [1, 11], "file": "data/codes/2025_round1/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["13"], "raw_text": "13"}, "explanation": "이 파이썬 코드는 이진 트리를 구성하고 레벨별로 값을 계산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **트리 구성:**\n```python li = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\n```\n- `tree()` 함수는 리스트를 이진 트리로 변환합니다.\n- `nodes[(i - 1) // 2].children.append(nodes[i])`: 부모 인덱스 계산\n- i=1: 부모=(1-1)//2=0 → nodes[0].children에 nodes[1] 추가\n- i=2: 부모=(2-1)//2=0 → nodes[0].children에 nodes[2] 추가\n- i=3: 부모=(3-1)//2=1 → nodes[1].children에 nodes[3] 추가\n- i=4: 부모=(4-1)//2=1 → nodes[1].children에 nodes[4] 추가\n- i=5: 부모=(5-1)//2=2 → nodes[2].children에 nodes[5] 추가\n- i=6: 부모=(6-1)//2=2 → nodes[2].children에 nodes[6] 추가\n\n**트리 구조:**\n```\n3 (level 0)\n/ \\\n5 8 (level 1)\n/ \\ / \\\n12 15 18 21 (level 2)\n```\n\n2. **calc() 함수 실행:**\n```python def calc(node, level=0):\nif node is None:\nreturn 0 return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\n```\n- level이 홀수(1, 3, 5...)일 때만 노드 값을 더합니다.\n- level이 짝수(0, 2, 4...)일 때는 0을 더합니다.\n\n**계산 과정:**\n- level 0 (루트): 3 값 무시 (level % 2 == 0) → 0\n- level 1: 5 + 8 = 13 (level % 2 == 1) → **13**\n- level 2: 12, 15, 18, 21 값 무시 (level % 2 == 0) → 0\n\n**최종 결과:** 0 + 13 + 0 = **13**답:** 13", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.898106"}, "code_blocks": [{"language": "python", "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\ndef tree(li):\n    nodes = [Node(i) for i in li]\n    for i in range(1, len(li)):\n        nodes[(i - 1) // 2].children.append(nodes[i])\n    return nodes[0]\ndef calc(node, level=0):\n    if node is None:\n        return 0\n    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\nprint(calc(root))", "line_numbers": [1, 16], "file": "data/codes/2025_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.\n19.다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["35421"], "raw_text": "35421"}, "explanation": "이 C언어 코드는 연결 리스트에 노드를 삽입하고 특정 값을 가진 노드를 맨 앞으로 이동시키는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **insert() 함수로 리스트 생성:**\n```c for (int i = 1; i <= 5; i++)\nhead = insert(head, i);\n```\n- `insert()`는 새 노드를 리스트의 맨 앞에 추가합니다 (역순으로 저장됨).\n- i=1: head = 1 → NULL\n- i=2: head = 2 → 1 → NULL\n- i=3: head = 3 → 2 → 1 → NULL\n- i=4: head = 4 → 3 → 2 → 1 → NULL\n- i=5: head = 5 → 4 → 3 → 2 → 1 → NULL\n\n**최종 리스트:** 5 → 4 → 3 → 2 → 1 → NULL\n\n2. **reconnect() 함수 실행:**\n```c head = reconnect(head, 3);\n```\n- `reconnect()`는 값이 3인 노드를 찾아서 리스트의 맨 앞으로 이동시킵니다.\n- 현재 리스트: 5 → 4 → 3 → 2 → 1 → NULL\n- 값 3인 노드를 찾고, 그 노드를 제거한 후 맨 앞에 다시 삽입합니다.\n\n**reconnect 과정:**\n- curr가 3인 노드를 찾음\n- prev(4)의 next를 curr(3)의 next(2)로 연결\n- curr(3)의 next를 현재 head(5)로 설정\n- head를 curr(3)으로 변경\n\n**결과 리스트:** 3 → 5 → 4 → 2 → 1 → NULL\n\n3. **출력:**\n```c for (curr = head; curr != NULL; curr = curr->next)\nprintf(\"%d\", curr->value);\n```\n- 순서대로: 3, 5, 4, 2, 1\n- **출력: \"35421\"**답:** \"35421\"", "table_refs": [], "image_refs": ["images/2025_round1/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.898106"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>   \n#include <stdlib.h>  \ntypedef struct Data {\n    int value;\n    struct Data *next;\n} Data;\nData* insert(Data* head, int value) {\n    Data* new_node = (Data*)malloc(sizeof(Data));\n    new_node->value = value;\n    new_node->next = head;\n    return new_node;\n}\nData* reconnect(Data* head, int value) {\n    if (head == NULL || head->value == value) return head;\n    Data *prev = NULL, *curr = head;\n    while (curr != NULL && curr->value != value) {\n        prev = curr;\n        curr = curr->next;\n    }\n    if (curr != NULL && prev != NULL) {\n        prev->next = curr->next;\n        curr->next = head;\n        head = curr;\n    }\n    return head;\n}\nint main() {\n    Data *head = NULL, *curr;\n    for (int i = 1; i <= 5; i++)\n        head = insert(head, i);\n    head = reconnect(head, 3);\n    for (curr = head; curr != NULL; curr = curr->next)\n        printf(\"%d\", curr->value);\n    return 0; \n}", "line_numbers": [1, 35], "file": "data/codes/2025_round1/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 4을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.898106"}, "code_blocks": [{"language": "java", "code": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n  }\n  static int calc(int value) {\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 2);\n  }\n  static int calc(String str) {\n    int value = Integer.valueOf(str);\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 3);\n  }\n}", "line_numbers": [1, 14], "file": "data/codes/2025_round1/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
