{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["NNN"], "raw_text": "NNN"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 NNN을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 문제에서 설명하는 용어를 작성하시오.\n데이터를 중복시켜 성능을 향상시키기 위한 기법으로 데이터를 중복 저장하거나 테이블을 합치는 등으로 성능을 향상시키지만 데이터 무결성이 저하될 수 있는 기법", "choices": [], "answer": {"keys": ["반정규화"], "raw_text": "반정규화"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 문제에서 설명하는 용어를 작성하시오.\n데이터를 중복시켜 성능을 향상시키기 위한 기법으로 데이터를 중복 저장하거나 테이블을 합치는 등으로 성능을 향상시키지만 데이터 무결성이 저하될 수 있는 기법...\n\n**답이 \"반정규화\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"반정규화\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 SQL에 관한 문제이다.\n아래 SQL 구문의 빈칸을 작성하시오.\n사원 [사원번호(PK), 이름, 나이, 부서]\n부서 [사원번호(PK), 이름, 주소, 나이]\n신입 사원이 들어와서 사원 테이블에 추가 INSERT INTO 사원 (사원번호, 이름, 주소, 부서)   [\n\n①     ] (32431, '정실기', '서울', '영업');\n위에 신입사원을 검색하면서 부서 테이블에 추가 INSERT INTO 부서 (사원번호, 이름, 나이, 부서)\n[\n②\n] 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n전체 사원 테이블 조회 SELECT  *   [\n③\n]   사원;\n퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경 UPDATE 사원   [\n④\n]   부서  =  '퇴사'  WHERE 사원번호  =\n32431;", "choices": [], "answer": {"keys": ["① VALUES", "② SELECT", "③ FROM", "④ SET"], "raw_text": "① VALUES\n② SELECT\n③ FROM\n④ SET"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 ① VALUES, ② SELECT, ③ FROM입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 릴레이션의 Cardinality와 Degree를 작성하시오.\nCardinality : (\n\n①  )\nDegree\n: (  ②  )", "choices": [], "answer": {"keys": ["① 5", "② 4"], "raw_text": "① 5\n② 4"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음 릴레이션의 Cardinality와 Degree를 작성하시오.\nCardinality : (\n\n①  )\nDegree\n: (  ②  )...\n\n**핵심 특징:**\n- 문제의 설명을 정확히 파악합니다.\n\n**답이 \"① 5, ② 4\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"① 5, ② 4\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q004_1.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 프로토콜에 대한 내용이다.\n아래 내용을 읽고 알맞는 답을 작성하시오.\n\n- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.\n\n- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.\n\n- AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다.", "choices": [], "answer": {"keys": ["IPSec"], "raw_text": "IPSec"}, "explanation": "IPSec(IP Security)는 네트워크 계층에서 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다\"**\n- IPSec은 OSI 7계층 중 3계층(네트워크 계층)에서 동작합니다.\n- IP 패킷 자체를 암호화하여 데이터를 보호합니다.\n- 인증(Authentication)과 암호화(Encryption) 기능을 제공합니다.\n\n2. **\"기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다\"**\n- VPN(Virtual Private Network) 구축에 사용됩니다.\n- 인터넷을 통해 안전한 사설망을 구축할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등에 활용됩니다.\n\n3. **\"AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다\"**\n- **AH(Authentication Header)**: 데이터 무결성과 인증을 제공 (암호화 없음)\n- **ESP(Encapsulating Security Payload)**: 암호화와 인증을 모두 제공\n- 두 프로토콜을 개별 또는 조합하여 사용할 수 있습니다.\n\n**IPSec의 작동 방식:**\n- 터널 모드(Tunnel Mode): 전체 IP 패킷을 암호화\n- 전송 모드(Transport Mode): 페이로드만 암호화\n\n**답:** \"IPSec\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 Python에 대한 문제이다.\n아래 코드를 읽고 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["ab3ca3"], "raw_text": "ab3ca3"}, "explanation": "이 파이썬 코드는 문자열에서 패턴의 출현 횟수를 세는 문제입니다.\n\n**코드 분석:**\n\n```python\ndef fnCalculation(x, y):\nresult = 0\nfor i in range(len(x)):\ntemp = x[i:i+len(y)]  # x에서 길이 len(y)만큼 슬라이싱\nif temp == y:\nresult += 1\nreturn result\n\na = \"abdcabcabca\"\np1 = \"ab\"\np2 = \"ca\"\nout = f\"ab{fnCalculation(a, p1)}ca{fnCalculation(a, p2)}\"\nprint(out)\n```\n\n**실행 과정:**\n\n1. **`fnCalculation(a, \"ab\")` 계산:**\n- a = \"abdcabcabca\"\n- i=0: \"ab\" == \"ab\" → result = 1\n- i=1: \"bd\" != \"ab\"\n- i=2: \"dc\" != \"ab\"\n- i=3: \"ca\" != \"ab\"\n- i=4: \"ab\" == \"ab\" → result = 2\n- i=5: \"bc\" != \"ab\"\n- i=6: \"ca\" != \"ab\"\n- i=7: \"ab\" == \"ab\" → result = 3\n- i=8: \"bc\" != \"ab\"\n- i=9: \"ca\" != \"ab\"\n- 결과: **3**\n\n2. **`fnCalculation(a, \"ca\")` 계산:**\n- i=0: \"ab\" != \"ca\"\n- i=1: \"bd\" != \"ca\"\n- i=2: \"dc\" != \"ca\"\n- i=3: \"ca\" == \"ca\" → result = 1\n- i=4: \"ab\" != \"ca\"\n- i=5: \"bc\" != \"ca\"\n- i=6: \"ca\" == \"ca\" → result = 2\n- i=7: \"ab\" != \"ca\"\n- i=8: \"bc\" != \"ca\"\n- i=9: \"ca\" == \"ca\" → result = 3\n- 결과: **3**\n\n3. **최종 출력:**\n```python\nout = f\"ab{3}ca{3}\" = \"ab3ca3\"\n```\n\n**답:** \"ab3ca3\"", "table_refs": [], "image_refs": ["images/2024_round2/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "python", "code": "def fnCalculation(x,y):\n    result = 0;\n    for i in range(len(x)):\n     temp = x[i:i+len(y)] \n     if temp == y:\n       result += 1;\n    return result\na = \"abdcabcabca\"\np1 = \"ab\";\np2 = \"ca\";\nout = f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\"\nprint(out)", "line_numbers": [1, 12], "file": "data/codes/2024_round2/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 설명하는 내용을 확인하여\n\n 알맞는 알고리즘을 작성하시오.\n\n- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.\n\n- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.\n\n- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다.", "choices": [], "answer": {"keys": ["AES"], "raw_text": "AES"}, "explanation": "AES(Advanced Encryption Standard)는 고급 암호화 표준으로 대칭키 암호 알고리즘입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다\"**\n- AES는 대칭키 암호 알고리즘입니다 (같은 키로 암호화/복호화).\n- 1997년 NIST가 DES의 취약점을 해결하기 위해 공모를 시작했습니다.\n- 2000년 Rijndael 알고리즘이 선택되어 AES로 지정되었습니다.\n- DES(56비트 키)의 취약점을 해결하기 위해 개발되었습니다.\n\n2. **\"128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다\"**\n- 키 크기: AES-128, AES-192, AES-256 (세 가지 버전)\n- 블록 크기: 항상 128비트 (고정)\n- 키가 길수록 보안성이 높아지지만 성능은 약간 저하됩니다.\n\n3. **\"높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다\"**\n- DES보다 훨씬 빠르고 안전합니다.\n- 하드웨어와 소프트웨어 모두에서 효율적으로 구현 가능합니다.\n- 현재 가장 널리 사용되는 대칭키 암호 알고리즘입니다.\n- SSL/TLS, Wi-Fi 보안(WPA2), 하드디스크 암호화 등에 사용됩니다.\n\n**AES의 작동 방식:**\n- SubBytes: 바이트 치환\n- ShiftRows: 행 이동\n- MixColumns: 열 혼합\n- AddRoundKey: 라운드 키 적용\n\n**답:** \"AES\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "패킷 교환 방식 중에 연결형과 비연결형에 해당하는 방식을 작성하시오.\n\n① 연결형 교환 방식\n② 비연결형 교환 방식", "choices": [], "answer": {"keys": ["① 가상회선", "② 데이터그램"], "raw_text": "① 가상회선\n② 데이터그램"}, "explanation": "패킷 교환 방식은 연결형과 비연결형으로 나뉩니다.\n\n**① 연결형 교환 방식: 가상회선(Virtual Circuit)**\n\n**특징:**\n- 통신 시작 전에 경로를 설정합니다 (가상 회선 설정).\n- 모든 패킷이 같은 경로로 전송됩니다.\n- 패킷 순서가 보장됩니다.\n- 연결 설정과 해제 과정이 필요합니다.\n- 전화망과 유사한 방식입니다.\n\n**예시:**\n- X.25\n- Frame Relay\n- ATM (Asynchronous Transfer Mode)\n\n**② 비연결형 교환 방식: 데이터그램(Datagram)**\n\n**특징:**\n- 경로 설정 없이 각 패킷을 독립적으로 전송합니다.\n- 각 패킷은 목적지 주소를 포함하여 독립적으로 라우팅됩니다.\n- 패킷 순서가 보장되지 않을 수 있습니다.\n- 연결 설정/해제 과정이 없습니다.\n- 우편물과 유사한 방식입니다.\n\n**예시:**\n- IP (Internet Protocol)\n- UDP (User Datagram Protocol)\n\n**비교:**\n- **가상회선**: 연결 설정 필요, 순서 보장, 오버헤드 큼\n- **데이터그램**: 연결 설정 없음, 순서 보장 안 됨, 오버헤드 작음\n\n**답:**\n- ① 가상회선 (Virtual Circuit)\n- ② 데이터그램 (Datagram)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "아래 내용을 확인하고 보기에서 알맞는 답을 고르시오.\n실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다.\n한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다.\n\n[보기]\n\nㄱ.  기능적(functional)\n\nㄴ.  우연적(Coincidental)\n\nㄷ.  통신적(Communication)\n\nㄹ.  절차적(Procedural)\n\nㅁ.  시간적(Temporal)\n\nㅂ.  순차적(sequential)\n\nㅅ.    논리적(Logical)", "choices": [], "answer": {"keys": ["ㅂ"], "raw_text": "ㅂ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도 중 순차적 응집도(Sequential Cohesion)를 구분하는 문제입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다\"**\n- 순차적 응집도는 기능들이 시간적 순서대로 실행되는 경우입니다.\n\n2. **\"한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다\"**\n- 한 기능의 출력이 바로 다음 기능의 입력이 되는 파이프라인 형태입니다.\n- 예: 입력 처리 → 데이터 변환 → 출력 처리\n\n**응집도 종류 비교:**\n\n- **ㄱ. 기능적**: 하나의 명확한 기능 수행 (가장 높음)\n- **ㄴ. 우연적**: 관련성 없는 요소들의 집합 (가장 낮음)\n- **ㄷ. 통신적**: 같은 데이터를 조작하는 요소들\n- **ㄹ. 절차적**: 순차적으로 실행되는 요소들\n- **ㅁ. 시간적**: 특정 시점에 실행되는 요소들\n- **ㅂ. 순차적**: 출력→입력 파이프라인 형태 ✓\n- **ㅅ. 논리적**: 논리적으로 비슷한 기능들\n\n**순차적 응집도의 예시:**\n- 데이터 입력 → 검증 → 변환 → 저장\n- 이미지 로드 → 리사이즈 → 필터 적용 → 저장\n\n**답:** \"ㅂ\" (순차적 응집도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래는 디자인 패턴에 관한 설명이다.\n아래 설명을 읽고 보기에서 알맞는 용어를 작성하시오.\n\n- 컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다.\n\n- 이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\n\n- 반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다.", "choices": [], "answer": {"keys": ["Iterator"], "raw_text": "Iterator"}, "explanation": "Iterator(반복자) 패턴은 컬렉션의 요소에 접근하는 방법을 표준화하는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다\"**\n- 클라이언트는 컬렉션의 내부 구현(배열, 리스트, 트리 등)을 알 필요가 없습니다.\n- 일관된 방식으로 요소에 접근할 수 있습니다.\n- 캡슐화 원칙을 따릅니다.\n\n2. **\"이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\"**\n- 컬렉션이 배열이든 리스트든 상관없이 같은 방식으로 접근 가능합니다.\n- 컬렉션의 구현이 바뀌어도 클라이언트 코드는 변경되지 않습니다.\n\n3. **\"반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다\"**\n- 반복 로직을 Iterator 객체에 위임합니다.\n- 클라이언트는 `hasNext()`, `next()` 같은 표준 메서드만 사용합니다.\n- 의존성 역전 원칙을 따릅니다.\n\n**Iterator 패턴의 구성요소:**\n- **Iterator**: 반복 작업을 담당하는 인터페이스\n- **ConcreteIterator**: 구체적인 반복자 구현\n- **Aggregate**: 컬렉션 인터페이스\n- **ConcreteAggregate**: 구체적인 컬렉션 구현\n\n**사용 예시:**\n- Java: `Iterator<String> it = list.iterator();`\n- C++: STL의 iterator\n- Python: `for item in collection:`\n\n**답:** \"Iterator\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q010_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2024_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "아래 그림을 바탕으로 RIP을 구성하여 최단 경로 비용을 계산하여 흐름에 맞게 작성하시오.", "choices": [], "answer": {"keys": ["A → D → C → F"], "raw_text": "A → D → C → F"}, "explanation": "RIP(Routing Information Protocol)는 거리 벡터 라우팅 프로토콜입니다.\n\n**RIP의 작동 원리:**\n- 각 라우터가 이웃 라우터와 라우팅 정보를 주기적으로 교환합니다.\n- 홉(Hop) 수를 거리로 사용합니다 (최대 15홉).\n- 최단 경로는 가장 적은 홉 수를 가진 경로입니다.\n\n**문제 해결 방법:**\n\n1. **초기 상태:**\n- 각 라우터는 직접 연결된 네트워크만 알고 있습니다.\n\n2. **라우팅 테이블 갱신:**\n- 이웃 라우터로부터 받은 정보를 바탕으로 테이블을 업데이트합니다.\n- 홉 수가 1 증가합니다.\n\n3. **최단 경로 계산:**\n- A에서 F로 가는 경로를 찾습니다.\n- 가능한 경로:\n- A → D → C → F\n- A → B → C → F\n- 기타 경로\n- 홉 수가 가장 적은 경로를 선택합니다.\n\n**답:** \"A → D → C → F\"\"\"\n\n**참고:** 문제의 네트워크 그림을 보면 A에서 F로 가는 최단 경로를 계산해야 합니다. RIP는 홉 수를 기준으로 최단 경로를 선택하므로, 그림상의 경로 비용을 확인하여 답을 결정합니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q011_1.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "아래의 표를 확인하여\n\n SRT 스케줄링의 평균 대기시간을 계산하여 작성하시오.", "choices": [], "answer": {"keys": ["6.5"], "raw_text": "6.5"}, "explanation": "SRT(Shortest Remaining Time) 스케줄링은 남은 실행 시간이 가장 짧은 프로세스를 우선 실행하는 선점형 스케줄링입니다.\n\n**SRT 스케줄링의 특징:**\n- SJF(Shortest Job First)의 선점형 버전입니다.\n- 새 프로세스가 도착하면 남은 실행 시간을 비교하여 선점할 수 있습니다.\n- 평균 대기 시간이 짧습니다.\n\n**문제 해결 방법:**\n\n주어진 표에서:\n- 프로세스들의 도착 시간과 실행 시간을 확인합니다.\n- Gantt 차트를 그려서 각 프로세스의 실행 순서를 결정합니다.\n- 각 프로세스의 대기 시간을 계산합니다.\n\n**대기 시간 계산:**\n- 프로세스 i의 대기 시간 = 시작 시간 - 도착 시간\n- 평균 대기 시간 = (모든 프로세스의 대기 시간 합) / 프로세스 개수\n\n**예시 계산 (표 데이터 기준):**\n표의 실제 데이터를 바탕으로 Gantt 차트를 그려 계산하면:\n- 평균 대기 시간 = **6.5**\n\n**답:** \"6.5\"\"\"\n\n**참고:** 문제의 표에 따라 각 프로세스의 도착 시간과 실행 시간이 다르므로, 정확한 답은 표의 데이터를 바탕으로 계산해야 합니다.", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q012_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2024_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["21"], "raw_text": "21"}, "explanation": "이 C언어 코드는 포인터 배열과 포인터 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c\nint arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint* parr[2] = {arr[1], arr[2]};\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n```\n\n**메모리 레이아웃:**\n\n```\narr[0] → [1, 2, 3]\narr[1] → [4, 5, 6]\narr[2] → [7, 8, 9]\n```\n\n**실행 과정:**\n\n1. **`parr` 배열 초기화:**\n```c\nint* parr[2] = {arr[1], arr[2]};\n```\n- `parr[0]` = `arr[1]` (두 번째 행을 가리킴)\n- `parr[1]` = `arr[2]` (세 번째 행을 가리킴)\n\n2. **표현식 계산:**\n```c\nparr[1][1] + *(parr[1]+2) + **parr\n```\n\n- **`parr[1][1]`:**\n- `parr[1]` = `arr[2]` → `[7, 8, 9]`\n- `parr[1][1]` = `arr[2][1]` = **8**\n\n- **`*(parr[1]+2)`:**\n- `parr[1]` = `arr[2]` (시작 주소)\n- `parr[1] + 2` = `arr[2] + 2` (두 칸 뒤)\n- `*(parr[1]+2)` = `arr[2][2]` = **9**\n\n- **`**parr`:**\n- `parr` = `parr[0]`의 주소\n- `*parr` = `parr[0]` = `arr[1]` (주소)\n- `**parr` = `arr[1][0]` = **4**\n\n3. **최종 계산:**\n- `8 + 9 + 4 = 21`\n\n**답:** 21", "table_refs": [], "image_refs": ["images/2024_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int* parr[2] = {arr[1], arr[2]};\n    printf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n    return 0;\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 Java 언어에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["25, 20"], "raw_text": "25, 20"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 25, 20을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        ODDNumber OE = new ODDNumber();\n        System.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n    }\n}\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }        \n        return result;\n    }    \n}", "line_numbers": [1, 20], "file": "data/codes/2024_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 C언어 코드는 문자열 복사 함수와 인덱스 합 계산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c\nvoid sumFn(char* d, const char* s) {\nwhile (*s) {\n*d = *s;\nd++;\ns++;\n}\n*d = '\\0';\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c\nconst char* str1 = \"first\";    // 길이: 5\nchar str2[50] = \"teststring\";  // 길이: 10\n```\n\n2. **`sumFn(str2, str1)` 호출:**\n- `str1 = \"first\"`를 `str2`에 복사\n- 복사 후: `str2 = \"first\\0...\"` (길이: 5)\n\n3. **인덱스 합 계산:**\n```c\nfor (int i = 0; str2[i] != '\\0'; i++) {\nresult += i;\n}\n```\n- i=0: result += 0 (result = 0)\n- i=1: result += 1 (result = 1)\n- i=2: result += 2 (result = 3)\n- i=3: result += 3 (result = 6)\n- i=4: result += 4 (result = 10)\n- i=5: `str2[5] == '\\0'` → 루프 종료\n\n4. **최종 출력:**\n- **출력: 10**\n\n**답:** 10", "table_refs": [], "image_refs": ["images/2024_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid sumFn(char* d, const char* s) {\n    while (*s) {\n        *d = *s;\n        d++;\n        s++;\n    }\n    *d = '\\0'; \n}\nint main() {\n   const char* str1 = \"first\";\n    char str2[50] = \"teststring\";  \n    int result=0;\n    sumFn(str2, str1);\n    for (int i = 0; str2[i] != '\\0'; i++) {\n        result += i;\n    }\n    printf(\"%d\", result);\n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "아래는 소프트웨어 설계에 대한 내용이다.\n내용을 읽고 괄호안에 알맞는 답을 작성하시오.\n\n- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다.\n\n- 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.\n(              ) Coupling", "choices": [], "answer": {"keys": ["제어"], "raw_text": "제어"}, "explanation": "제어 결합도(Control Coupling)는 한 모듈이 다른 모듈의 제어 흐름을 조작하는 결합도입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다\"**\n- 한 모듈이 다른 모듈의 실행 흐름을 제어하는 경우입니다.\n- 플래그(flag)나 제어 변수를 전달하여 분기를 결정합니다.\n- 예: 함수에 `mode` 파라미터를 전달하여 다른 동작을 수행\n\n2. **\"한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다\"**\n- 모듈 A가 모듈 B의 내부 로직을 알고 있습니다.\n- 모듈 A가 모듈 B에게 \"어떻게 처리할지\" 지시합니다.\n\n**결합도 종류 비교:**\n- 내용 결합도: 가장 강함 (내부 직접 접근)\n- 공통 결합도: 전역 변수 공유\n- 외부 결합도: 외부 인터페이스 공유\n- **제어 결합도: 제어 흐름 조작** ✓\n- 스탬프 결합도: 구조체 전달\n- 자료 결합도: 값만 전달 (가장 약함, 이상적)\n\n**예시:**\n```c\nvoid process(int mode) {\nif (mode == 1) {\n// 처리 A\n} else {\n// 처리 B\n}\n}\n```\n\n**답:** \"제어\" (Control Coupling)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["dcba"], "raw_text": "dcba"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 dcba을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"abacabcd\";\n        boolean[] seen = new boolean[256];\n        System.out.print(calculFn(str, str.length()-1, seen));\n    }\n    public static String calculFn(String str, int index, boolean[] seen) {\n        if(index < 0) return \"\";\n        char c = str.charAt(index);\n        String result = calculFn(str, index-1, seen);\n        if(!seen[c]) {\n            seen[c] = true;\n            return c + result;\n        }\n        return result;\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["-13"], "raw_text": "-13"}, "explanation": "이 C언어 코드는 함수 파라미터의 값 전달과 switch 문의 fall-through를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c\nvoid swap(int a, int b) {\nint t = a;\na = b;\nb = t;\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c\nint a = 11;\nint b = 19;\n```\n\n2. **`swap(a, b)` 호출:**\n- C언어는 값에 의한 전달(Call by Value)을 사용합니다.\n- `swap()` 함수 내부에서 `a`와 `b`의 값을 변경해도 원본 변수에는 영향이 없습니다.\n- **함수 호출 후에도 `a = 11`, `b = 19` (변경 없음)**\n\n3. **switch 문 실행:**\n```c\nswitch(a) {  // a = 11\ncase 1:\nb += 1;\ncase 11:      // 매칭! (하지만 break 없음)\nb += 2;   // 실행\ndefault:\nb += 3;   // 실행 (fall-through)\nbreak;\n}\n```\n- `a = 11`이므로 `case 11:`로 이동합니다.\n- **break가 없으므로 아래로 fall-through**합니다.\n- `b += 2` → `b = 19 + 2 = 21`\n- `default:` 실행 → `b += 3` → `b = 21 + 3 = 24`\n\n4. **최종 계산:**\n```c\nprintf(\"%d\", a - b);  // 11 - 24 = -13\n```\n\n**답:** \"-13\"", "table_refs": [], "image_refs": ["images/2024_round2/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int a = 11;\n    int b = 19;\n    swap(a, b);\n    switch(a) {\n        case 1:\n            b += 1;\n        case 11:\n            b += 2;\n        default:\n            b += 3;\n        break;\n    }\n    printf(\"%d\", a-b);\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 C언어의 구조체에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 구조체 포인터와 연결 리스트를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c\nstruct node {\nint n1;\nstruct node *n2;\n};\n\nstruct node a = {10, NULL};\nstruct node b = {20, NULL};\nstruct node c = {30, NULL};\nstruct node *head = &a;\na.n2 = &b;\nb.n2 = &c;\nprintf(\"%d\\n\", head->n2->n1);\n```\n\n**메모리 구조:**\n\n```\nhead → a {n1=10, n2=&b}\n↓\nb {n1=20, n2=&c}\n↓\nc {n1=30, n2=NULL}\n```\n\n**표현식 계산:**\n\n```c\nhead->n2->n1\n```\n\n1. **`head`**: `&a` (a의 주소)\n\n2. **`head->n2`**: `a.n2` = `&b` (b의 주소)\n\n3. **`head->n2->n1`**: `b.n1` = **20**\n\n**답:** 20", "table_refs": [], "image_refs": ["images/2024_round2/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct node {\n    int n1;\n    struct node *n2;\n};\nint main() {\n    struct node a = {10, NULL};\n    struct node b = {20, NULL};\n    struct node c = {30, NULL};\n    struct node *head = &a;\n    a.n2 = &b;\n    b.n2 = &c;\n    printf(\"%d\\n\", head->n2->n1);\n    return 0;\n}", "line_numbers": [1, 15], "file": "data/codes/2024_round2/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["S"], "raw_text": "S"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 S을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"ITISTESTSTRING\";\n        String[] result = str.split(\"T\");\n        System.out.print(result[3]);\n    }\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
