{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음 Java 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 C언어 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["151"], "raw_text": "151"}, "explanation": "이 C언어 코드는 삼항 연산자와 비트 시프트 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int v1 = 0, v2 = 35, v3 = 29;\nif(v1 > v2 ? v2 : v1) {\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2;\n}\nprintf(\"%d\", v2+v3);\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `v1 = 0`, `v2 = 35`, `v3 = 29`\n\n2. **삼항 연산자 평가:**\n```c v1 > v2 ? v2 : v1\n```\n- `0 > 35` → 거짓(false)\n- 따라서 `v1` (값: 0) 반환\n\n3. **if 조건 판단:**\n```c if(0) { // 거짓!\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2; // 이 블록 실행\n}\n```\n\n4. **비트 시프트 연산:**\n```c v3 = 29 << 2;\n```\n- `<<` (왼쪽 시프트): 비트를 왼쪽으로 2칸 이동 = 곱하기 4\n- `29 << 2 = 29 × 4 = 116`\n\n5. **최종 계산:**\n- `v2 = 35` (변경 없음)\n- `v3 = 116`\n- `v2 + v3 = 35 + 116 = 151`\n\n**답:** 151", "table_refs": [], "image_refs": ["images/2024_round1/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int v1 = 0, v2 = 35, v3 = 29;\n    if(v1 > v2 ? v2 : v1) {\n        v2 = v2 << 2;\n    }else{\n        v3 = v3 << 2;\n    }\n    printf(\"%d\", v2+v3);\n}", "line_numbers": [1, 10], "file": "data/codes/2024_round1/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 응집도와 관련해서 보기에서 응집도가 높은 순으로 나열하시오.", "choices": [], "answer": {"keys": ["ㄱ", "ㄴ", "ㄹ", "ㄷ"], "raw_text": "ㄱ\nㄴ\nㄹ\nㄷ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도(Cohesion) 개념에 관한 문제입니다.\n\n**응집도란:**\n- 모듈 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타내는 정도입니다.\n- 응집도가 높을수록 좋은 모듈입니다.\n\n**응집도 종류 (낮은 순서 → 높은 순서):**\n\n1. **우연적 응집도(Coincidental Cohesion):**\n- 모듈 내 요소들 사이에 전혀 관련성이 없는 경우\n- 가장 낮은 응집도\n\n2. **논리적 응집도(Logical Cohesion):**\n- 논리적으로 비슷한 기능을 수행하는 요소들이 모인 경우\n- 예: 모든 입력 처리 함수\n\n3. **시간적 응집도(Temporal Cohesion):**\n- 특정 시점에 수행되는 요소들이 모인 경우\n- 예: 초기화 모듈, 종료 모듈\n\n4. **절차적 응집도(Procedural Cohesion):**\n- 순차적으로 실행되는 요소들이 모인 경우\n- 예: 순차 처리 흐름\n\n5. **통신적 응집도(Communicational Cohesion):**\n- 같은 데이터를 조작하는 요소들이 모인 경우\n- 예: 같은 파일을 읽고 쓰는 함수들\n\n6. **순차적 응집도(Sequential Cohesion):**\n- 한 요소의 출력이 다음 요소의 입력이 되는 경우\n- 예: 파이프라인 처리\n\n7. **기능적 응집도(Functional Cohesion):**\n- 하나의 명확한 기능을 수행하는 요소들\n- 가장 높은 응집도\n\n**문제 해석:**\n보기에서 응집도가 높은 순으로 나열하면:\n- ㄱ: 기능적 응집도 (가장 높음)\n- ㄴ: 순차적 응집도\n- ㄹ: 통신적 응집도\n- ㄷ: 절차적 응집도 (낮음)\n\n**답:** \"ㄱ, ㄴ, ㄹ, ㄷ\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 C언어에 대한 문제이다.\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["GECA"], "raw_text": "GECA"}, "explanation": "이 C언어 코드는 문자열을 역순으로 뒤집고 홀수 인덱스 문자를 출력하는 문제입니다.\n\n**코드 분석:**\n\n```c char str[100] = \"ABCDEFGH\";\nreverse(str); // 문자열 역순\n// 역순 후: \"HGFEDCBA\"\nfor(int i=1; i<len; i+=2) {\nprintf(\"%c\", str[i]); // 홀수 인덱스만 출력\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `str = \"ABCDEFGH\"`\n- 인덱스: 0=A, 1=B, 2=C, 3=D, 4=E, 5=F, 6=G, 7=H\n\n2. **`reverse()` 함수 실행:**\n```c void reverse(char* str) {\nint len = strlen(str); // len = 8 char *p1 = str; // p1 = &str[0]\nchar *p2 = str + len - 1; // p2 = &str[7]\nwhile(p1 < p2) {\n// 문자 교환 temp = *p1;\n*p1 = *p2;\n*p2 = temp;\np1++;\np2--;\n}\n}\n```\n- `p1`과 `p2`를 교환하며 문자열 뒤집기\n- 결과: `str = \"HGFEDCBA\"`\n\n3. **홀수 인덱스 출력:**\n```c for(int i=1; i<8; i+=2) {\nprintf(\"%c\", str[i]);\n}\n```\n- i=1: str[1] = 'G' 출력\n- i=3: str[3] = 'E' 출력\n- i=5: str[5] = 'C' 출력\n- i=7: str[7] = 'A' 출력\n\n**최종 출력:** \"GECA\"\n\n**답:** \"GECA\"", "table_refs": [], "image_refs": ["images/2024_round1/Q004.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid reverse(char* str){\n    int len = strlen(str);\n    char temp;\n    char*p1 = str;\n    char*p2 = str + len - 1;\n    while(p1<p2){\n        temp = *p1;\n        *p1 = *p2;\n        *p2 = temp;\n        p1++;\n        p2--;\n    }\n}\nint main(int argc, char* argv[]){\n    char str[100] = \"ABCDEFGH\";\n    reverse(str);\n    int len = strlen(str);\n    for(int i=1; i<len; i+=2){\n        printf(\"%c\",str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round1/Q004_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 그림에서의 네트워크에서 라우터을 통한 할당 가능한 2번, 4번, 5번의 IP를 작성하시오.\n1) 192.168.35.3/24 3) 129.200.10.16/22 6) 192.168.36.24/24 192.168.35.0 192.168.35.72 192.168.36.0 192.168.36.249 129.200.8.0 129.200.8.249", "choices": [], "answer": {"keys": ["192.168.35.72", "129.200.8.249", "192.168.36.249"], "raw_text": "192.168.35.72 129.200.8.249 192.168.36.249"}, "explanation": "이 문제는 서브넷 마스크를 이용하여 네트워크 범위를 계산하고, 주어진 IP 주소 중 할당 가능한 IP를 찾는 문제입니다.\n\n**주어진 정보:**\n- 1번: 192.168.35.3/24\n- 3번: 129.200.10.16/22\n- 6번: 192.168.36.24/24\n\n**서브넷 마스크 분석:**\n\n1. **192.168.35.3/24:**\n- 서브넷 마스크: 255.255.255.0 (24비트)\n- 네트워크 주소: 192.168.35.0\n- 사용 가능 범위: 192.168.35.1 ~ 192.168.35.254\n- **2번 IP: 192.168.35.72** → 범위 내 ✓\n\n2. **129.200.10.16/22:**\n- 서브넷 마스크: 255.255.252.0 (22비트)\n- 네트워크 주소 계산:\n- 10을 이진수: 00001010\n- 마스크 252(11111100)와 AND: 00001000 = 8\n- 네트워크 주소: 129.200.8.0\n- 사용 가능 범위: 129.200.8.1 ~ 129.200.11.254\n- **4번 IP: 129.200.8.249** → 범위 내 ✓\n\n3. **192.168.36.24/24:**\n- 서브넷 마스크: 255.255.255.0 (24비트)\n- 네트워크 주소: 192.168.36.0\n- 사용 가능 범위: 192.168.36.1 ~ 192.168.36.254\n- **5번 IP: 192.168.36.249** → 범위 내 ✓\n\n**답:**\n- 2번: 192.168.35.72\n- 4번: 129.200.8.249\n- 5번: 192.168.36.249", "table_refs": [], "image_refs": ["images/2024_round1/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 표에서 나타나고 있는 정규형을 작성하시오.", "choices": [], "answer": {"keys": ["제 3정규형"], "raw_text": "제 3정규형"}, "explanation": "이 문제는 데이터베이스 정규화의 제3정규형(3NF)을 판별하는 문제입니다.\n\n**정규형 판별 기준:**제1정규형(1NF):**\n- 모든 속성이 원자값(더 이상 분할할 수 없는 값)이어야 합니다.\n- 중복되는 튜플이 없어야 합니다.\n\n**제2정규형(2NF):**\n- 제1정규형을 만족\n- 모든 비주요 속성이 주요 속성에 완전 함수 종속되어야 합니다.\n- 부분 함수 종속이 없어야 합니다.\n\n**제3정규형(3NF):**\n- 제2정규형을 만족\n- 모든 비주요 속성이 주요 속성에 직접 종속되어야 합니다.\n- 이행 함수 종속(Transitive Dependency)이 없어야 합니다.\n- 예: A → B, B → C일 때, A → C는 이행 종속입니다.\n\n**문제의 표 분석:**\n표를 보면:\n- 주요 키(기본키)가 있고\n- 비주요 속성들이 주요 속성에 직접 종속되어 있으며\n- 이행 종속이 없는 것으로 보입니다.\n\n따라서 제3정규형까지 만족하는 것으로 판단됩니다.\n\n**답:** \"제 3정규형\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round1/Q006_table1.json", "rows": 6, "cols": 3}], "image_refs": ["images/2024_round1/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래의 내용에서 설명하는 네트워크 용어를 영문 약자로 작성하시오.", "choices": [], "answer": {"keys": ["OSPF"], "raw_text": "OSPF"}, "explanation": "OSPF(Open Shortest Path First)는 링크 상태 라우팅 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다\"**\n- OSPF는 링크 상태 라우팅 프로토콜입니다.\n- 거리 벡터 프로토콜(RIP)과 달리, 각 라우터가 네트워크 전체의 토폴로지를 알고 있습니다.\n- 링크 상태 정보(Link State Advertisement, LSA)를 주기적으로 교환하여 네트워크 상태를 감시합니다.\n\n2. **\"단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다\"**\n- OSPF는 IGP(Interior Gateway Protocol)입니다.\n- 자율 시스템(AS) 내부에서 사용되며, AS 간 통신에는 사용되지 않습니다.\n- BGP(Border Gateway Protocol)는 EGP(Exterior Gateway Protocol)입니다.\n\n3. **\"모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다\"**\n- OSPF는 Dijkstra 알고리즘(최단 경로 우선 알고리즘)을 사용합니다.\n- 각 라우터가 네트워크 그래프를 구성하고, Dijkstra 알고리즘으로 최단 경로 트리를 계산합니다.\n- 비용(Cost)을 기준으로 최적 경로를 선택합니다.\n\n**답:** \"OSPF\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.\n\n2. 단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.\n\n3. 모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅", "java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 내용의 각각의 설명에 대한 답을 작성하시오.\n\n(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.\n(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다.\n(3) (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.", "choices": [], "answer": {"keys": ["(1) 세타 조인", "(2) 동등 조인", "(3) 자연 조인"], "raw_text": "(1) 세타 조인\n(2) 동등 조인\n(3) 자연 조인"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n아래 내용의 각각의 설명에 대한 답을 작성하시오.\n\n(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.\n(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다.\n(3) (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다....\n\n**핵심 특징:**\n- 문제의 설명을 정확히 파악합니다.\n\n**답이 \"(1) 세타 조인, (2) 동등 조인, (3) 자연 조인\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"(1) 세타 조인, (2) 동등 조인, (3) 자연 조인\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n(1) LRU :\n(2) LFU :", "choices": [], "answer": {"keys": ["(1) 6", "(2) 6"], "raw_text": "(1) 6\n(2) 6"}, "explanation": "이 문제는 운영체제의 페이지 교체 알고리즘인 LRU와 LFU를 이해하는 문제입니다.\n\n**주어진 정보:**\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n**LRU (Least Recently Used) - 가장 최근에 사용되지 않은 페이지 교체:**초기 상태:** [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 1 | [1, 빈, 빈] | ✓ |\n| 2 | [1, 2, 빈] | ✓ |\n| 3 | [1, 2, 3] | ✓ |\n| 1 | [1, 2, 3] | (히트) |\n| 2 | [1, 2, 3] | (히트) |\n| 4 | [2, 3, 4] | ✓ (1 제거) |\n| 1 | [3, 4, 1] | ✓ (2 제거) |\n| 2 | [4, 1, 2] | ✓ (3 제거) |\n| 5 | [1, 2, 5] | ✓ (4 제거) |\n| 7 | [2, 5, 7] | ✓ (1 제거) |\n\n**페이지 부재 횟수: 6**LFU (Least Frequently Used) - 가장 적게 사용된 페이지 교체:**초기 상태:** [빈, 빈, 빈], 빈도: {}\n\n| 참조 | 프레임 상태 | 빈도 | 페이지 부재 |\n|------|------------|------|-----------|\n| 1 | [1, 빈, 빈] | {1:1} | ✓ |\n| 2 | [1, 2, 빈] | {1:1, 2:1} | ✓ |\n| 3 | [1, 2, 3] | {1:1, 2:1, 3:1} | ✓ |\n| 1 | [1, 2, 3] | {1:2, 2:1, 3:1} | (히트) |\n| 2 | [1, 2, 3] | {1:2, 2:2, 3:1} | (히트) |\n| 4 | [1, 2, 4] | {1:2, 2:2, 4:1} | ✓ (3 제거, 빈도 최소) |\n| 1 | [1, 2, 4] | {1:3, 2:2, 4:1} | (히트) |\n| 2 | [1, 2, 4] | {1:3, 2:3, 4:1} | (히트) |\n| 5 | [1, 2, 5] | {1:3, 2:3, 5:1} | ✓ (4 제거, 빈도 최소) |\n| 7 | [1, 2, 7] | {1:3, 2:3, 7:1} | ✓ (5 제거, 빈도 최소) |\n\n**페이지 부재 횟수: 6**답:**\n- (1) LRU: 6\n- (2) LFU: 6", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래 JAVA언어 코드의 실행 순서를 중복 번호없이 작성하시오.\n실행 순서 : 5 → ( ) → ( ) → ( ) → ( ) → ( )", "choices": [], "answer": {"keys": ["6", "3", "1", "7", "2"], "raw_text": "6 3\n1 7\n2"}, "explanation": "이 Java 코드는 상속에서 생성자 호출 순서와 메서드 오버라이딩을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Parent {\nParent(int x, int y) { ①\nthis.x = x;\nthis.y = y;\n}\nint getT() { ②\nreturn x * y;\n}\n}\nclass Child extends Parent {\nChild(int i) { ③\nsuper(i+1, i); // Parent 생성자 호출 this.x = i;\n}\nint getT(int n) { ④\nreturn super.getT() + n;\n}\n}\npublic class Main {\npublic static void main(String[] args) { ⑤\nParent parent = new Child(3); ⑥\nSystem.out.println(parent.getT()); ⑦\n}\n}\n```\n\n**실행 순서:**\n\n1. **⑤ `main()` 호출**\n\n2. **⑥ `new Child(3)` 실행:**\n- Child 생성자 호출 전에 **Parent 생성자(①)를 먼저 호출**해야 함\n- `super(i+1, i)` = `super(4, 3)` 호출\n- **① Parent(int 4, int 3) 실행** → x=4, y=3. **③ Child(int 3) 실행:**\n- `this.x = 3` (Child의 x = 3, Parent의 x는 그대로)\n\n4. **⑦ `parent.getT()` 호출:**\n- `parent`는 실제로 `Child` 객체이지만, 타입이 `Parent`입니다.\n- 하지만 `getT()`는 오버라이딩되지 않았으므로 **Parent의 getT()(②) 호출**\n- `x * y = 4 * 3 = 12` (Parent의 x, y 사용)\n\n**실행 순서:** 5 → **6** → **3** → **1** → **7** → **2**답:** \"6, 3, 1, 7, 2\"", "table_refs": [], "image_refs": ["images/2024_round1/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [{"language": "java", "code": "class Parent {\n    int x, y;\n    Parent(int x, int y) { ①\n        this.x=x;\n        this y=y;\n    }\n    int getT() { ②\n        return x*y;\n    }\n}\n​class Child extend Parent {\n    int x;\n    Child (int x) { ③\n        super(x+1, x);\n        this.x=x;\n    }\n    int getT(int n){ ④\n        return super.getT()+n;\n    }\n}\nclass Main {\n    public static void main(String[] args) { ⑤\n        Parent parent = new Child(3); ⑥\n        System.out.println(parent.getT()); ⑦\n    }\n}", "line_numbers": [1, 26], "file": "data/codes/2024_round1/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 C언어의 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["9981 and 2795.10"], "raw_text": "9981 and 2795.10"}, "explanation": "이 C언어 코드는 구조체와 함수 호출을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c typedef struct {\nint accNum;\ndouble bal;\n} BankAcc;\n\nvoid initAcc(BankAcc *acc, int x, double y) {\nacc->accNum = x;\nacc->bal = y;\n}\n\nvoid xxx(BankAcc *acc, double *en) {\nif (*en > 0 && *en < acc->bal) {\nacc->bal = acc->bal - *en; // 출금\n} else {\nacc->bal = acc->bal + *en; // 입금\n}\n}\n\nvoid yyy(BankAcc *acc) {\nacc->bal = acc->bal * sim_pow((1+0.1), 3);\n// 이자 계산: bal * (1.1)^3\n}\n```\n\n**실행 과정:**\n\n1. **초기화:**\n```c initAcc(&myAcc, 9981, 2200.0);\n```\n- `accNum = 9981`\n- `bal = 2200.0`\n\n2. **xxx() 호출:**\n```c double amount = 100.0;\nxxx(&myAcc, &amount);\n```\n- `*en = 100.0 > 0` ✓\n- `*en = 100.0 < 2200.0` ✓\n- 조건 만족 → 출금\n- `bal = 2200.0 - 100.0 = 2100.0`\n\n3. **yyy() 호출:**\n```c yyy(&myAcc);\n```\n- `sim_pow(1.1, 3) = 1.1 × 1.1 × 1.1 = 1.331`\n- `bal = 2100.0 × 1.331 = 2795.1`\n\n4. **출력:**\n```c printf(\"%d and %.2f\", myAcc.accNum, myAcc.bal);\n```\n- **출력: \"9981 and 2795.10\"**답:** \"9981 and 2795.10\"", "table_refs": [], "image_refs": ["images/2024_round1/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\ntypedef struct{\n    int accNum;\n    double bal;\n}BankAcc;\ndouble sim_pow(double base, int year){\n    int i;\n    double r = 1.0;\n    for(i=0; i<year; i++){\n        r = r*base;\n    }\n    return r;\n} \nvoid initAcc(BankAcc *acc, int x, double y){\n    acc -> accNum = x;\n    acc -> bal = y;\n}\nvoid xxx(BankAcc *acc, double *en){\n    if (*en > 0 && *en < acc -> bal) {\n        acc -> bal = acc -> bal-*en;\n    }else{\n        acc -> bal = acc -> bal+*en;\n    }\n}\nvoid yyy(BankAcc *acc){\n    acc -> bal = acc -> bal * sim_pow((1+0.1),3);\n}\nint main(){\n    BankAcc myAcc;\n    initAcc(&myAcc, 9981, 2200.0);\n    double amount = 100.0;\n    xxx(&myAcc, &amount);\n    yyy(&myAcc);\n    printf(\"%d and %.2f\", myAcc.accNum, myAcc.bal);\n    return 0;\n}", "line_numbers": [1, 36], "file": "data/codes/2024_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 파이썬 코드에 대한 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Seynaau"], "raw_text": "Seynaau"}, "explanation": "이 파이썬 코드는 문자열 리스트에서 각 문자열의 두 번째 문자를 추출하여 연결하는 문제입니다.\n\n**코드 분석:**\n\n```python a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"]\nstr = \"S\"\nfor i in a:\nstr = str + i[1] # 각 문자열의 인덱스 1(두 번째 문자) 추출 print(str)\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `str = \"S\"`\n\n2. **반복문 실행:**\n- i = \"Seoul\": `str = \"S\" + \"e\" = \"Se\"`\n- i = \"Kyeonggi\": `str = \"Se\" + \"y\" = \"Sey\"`\n- i = \"Incheon\": `str = \"Sey\" + \"n\" = \"Seyn\"`\n- i = \"Daejun\": `str = \"Seyn\" + \"a\" = \"Seyna\"`\n- i = \"Daegu\": `str = \"Seyna\" + \"a\" = \"Seynaa\"`\n- i = \"Pusan\": `str = \"Seynaa\" + \"u\" = \"Seynaau\"`\n\n**최종 출력:** \"Seynaau\"\n\n**답:** \"Seynaau\"", "table_refs": [], "image_refs": ["images/2024_round1/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "python", "code": "a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"] \nstr = \"S\"\nfor i in a:\n    str = str + i[1]\nprint(str)", "line_numbers": [1, 5], "file": "data/codes/2024_round1/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "아래 보기의 SQL 문장과 테이블을 참고하여\n\n출력 값을 표로 작성하시오.", "choices": [], "answer": {"keys": ["a", "b"], "raw_text": "a b"}, "explanation": "이 코드 실행 문제는 프로그램의 실행 흐름을 따라가며 결과를 도출하는 문제입니다.\n\n**코드 실행 과정:**\n\n1. **초기화**: 변수와 자료구조의 초기 상태를 확인합니다. 각 변수의 초기값을 정확히 파악합니다.\n\n2. **연산 수행**: 각 연산의 결과를 단계별로 계산합니다. 연산자 우선순위와 결합 방향을 고려합니다.\n\n3. **반복 처리**: 반복문이 있을 경우 각 반복에서의 값 변화를 추적합니다. 반복 횟수와 종료 조건을 확인합니다.\n\n4. **조건 분기**: 조건문에 따라 실행 경로가 달라지므로 각 분기를 확인합니다. 중첩된 조건문의 경우 모든 경우를 고려합니다.\n\n5. **최종 출력**: 모든 과정을 거쳐 최종 출력값 a, b을 계산합니다.\n\n**핵심 포인트**: 변수의 값 변화를 단계별로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round1/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "unknown", "code": "SELECT\n    B\nFROM\n    R1\nWHERE\n    C IN (SELECT C FROM R2 WHERE D=\"k\");", "line_numbers": [1, 6], "file": "data/codes/2024_round1/Q013_code.txt"}], "primary_category": "SQL", "secondary_categories": ["데이터베이스"], "tags": ["unknown"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래는 애플리케이션 테스트 관리에 대한 내용이다.\n설명하는 답을 보기에서 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "이 문제는 소프트웨어 테스트의 커버리지 종류를 이해하는 문제입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다\"**\n- 모든 가능한 조건 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n\n2. **\"특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다\"**\n- 조건의 독립적 영향력을 테스트합니다.\n\n3. **\"각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다\"**\n- 각 조건이 결과에 영향을 미치는지 확인합니다.\n\n**변경 조건/결정 커버리지(MC/DC - Modified Condition/Decision Coverage):**\n- 조건들의 독립적인 영향력을 테스트합니다.\n- 각 조건이 결정(결과)에 독립적으로 영향을 미치는지 확인합니다.\n- 모든 가능한 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n- 항공기 소프트웨어 등 고신뢰성 시스템에서 요구되는 커버리지입니다.\n\n**다른 커버리지와의 차이:**\n- 다중 조건 커버리지: 모든 조건 조합을 테스트 (2^n 개)\n- 조건/결정 커버리지: 각 조건과 결정을 개별적으로 테스트\n- **변경 조건/결정 커버리지: 각 조건이 결정에 독립적으로 영향을 미치는지 테스트** ✓\n\n**답:** \"ㄹ\" (변경 조건/결정 커버리지)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다.\n\n2. 특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다.\n\n3. 각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 결정 커버리지\n\nㄷ. 조건 커버리지\n\nㄹ. 변경 조건/결정 커버리지\n\nㅁ.다중 조건 커버리지\n\nㅂ.경로 커버리지\n\nㅅ.조건/결정 커버리지", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.\n인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다.\n해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다.\n일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다.", "choices": [], "answer": {"keys": ["ㅅ"], "raw_text": "ㅅ"}, "explanation": "루트킷(Rootkit)은 해커가 시스템에 침투한 후 자신의 존재를 숨기고 지속적인 접근 권한을 유지하는 악성 프로그램입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다\"**\n- 루트킷은 해커의 활동을 숨깁니다.\n- 관리자 권한(root 권한)을 획득하여 시스템을 완전히 제어합니다.\n\n2. **\"해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다\"**\n- 탐지를 피하기 위해 자신의 파일, 프로세스, 네트워크 연결 등을 숨깁니다.\n- 시스템 로그를 조작하여 침입 흔적을 지웁니다.\n\n3. **\"일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다\"**\n- 커널 레벨 루트킷: 운영체제 커널에 침투\n- 시스템콜 후킹: 운영체제 함수를 가로채서 탐지를 우회\n- 안티바이러스가 탐지하지 못하도록 합니다.\n\n**보기 분석:**\n- ㄱ. 트로이 목마: 정상 프로그램으로 위장한 악성 코드\n- ㄴ. 웜: 자기 복제를 통해 네트워크로 확산\n- ㄷ. 백도어: 비밀 통로를 만들어 접근\n- ㄹ. 악성코드: 일반적인 악성 소프트웨어\n- ㅁ. 바이러스: 다른 파일에 감염되는 악성 코드\n- ㅂ. 스파이웨어: 사용자 정보를 수집\n- **ㅅ. 루트킷: 존재를 숨기고 지속적 접근 유지** ✓\n\n**답:** \"ㅅ\" (루트킷)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 Java 코드를 보고\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["9"], "raw_text": "9"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 9을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round1/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "java", "code": "class classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() {\n        System.out.println(a + b);\n    }\n}\nclass classTwo extends classOne {\n    int po = 3;\n    public classTwo(int i) {\n        super(i, i+1);\n    }\n    public void print() {\n        System.out.println(po*po);\n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round1/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㅅ"], "raw_text": "ㅅ"}, "explanation": "이 문제는 기타 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n문제의 실제 내용에 따라 구체적인 해설을 작성해야 합니다. 문제의 설명과 보기를 종합적으로 분석하여 정확한 답을 찾습니다.\n\n**답:** 문제의 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다.\n\n2. 시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다.\n\n3. 한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다.\n\n4. 일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "정보보안", "secondary_categories": [], "tags": ["java", "해킹"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "아래의 SQL 코드와 테이블을 참고하여\n\n결과 값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 코드 실행 문제는 프로그램의 실행 흐름을 따라가며 결과를 도출하는 문제입니다.\n\n**코드 실행 과정:**\n\n1. **초기화**: 변수와 자료구조의 초기 상태를 확인합니다. 각 변수의 초기값을 정확히 파악합니다.\n\n2. **연산 수행**: 각 연산의 결과를 단계별로 계산합니다. 연산자 우선순위와 결합 방향을 고려합니다.\n\n3. **반복 처리**: 반복문이 있을 경우 각 반복에서의 값 변화를 추적합니다. 반복 횟수와 종료 조건을 확인합니다.\n\n4. **조건 분기**: 조건문에 따라 실행 경로가 달라지므로 각 분기를 확인합니다. 중첩된 조건문의 경우 모든 경우를 고려합니다.\n\n5. **최종 출력**: 모든 과정을 거쳐 최종 출력값 1을 계산합니다.\n\n**핵심 포인트**: 변수의 값 변화를 단계별로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round1/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.881115"}, "code_blocks": [{"language": "unknown", "code": "SELECT \n    COUNT(*) \nFROM \n    TABLE \nWHERE \n    EMPNO > 100 \nAND \n    SAL >= 3000 OR EMPNO = 200", "line_numbers": [1, 8], "file": "data/codes/2024_round1/Q018_code.txt"}], "primary_category": "SQL", "secondary_categories": ["프로그래밍", "데이터베이스"], "tags": ["unknown"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 C언어 코드의 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Nd sc 1"], "raw_text": "Nd sc 1"}, "explanation": "이 C언어 코드는 문자를 대문자, 소문자, 숫자로 구분하여 각각 다른 방식으로 변환하는 문제입니다.\n\n**코드 분석:**\n\n```c char *p = \"It is 8\";\nfor(i=0; p[i]!='\\0'; i++) {\nif(isupper(p[i]))\nresult[i] = (p[i]-'A'+5) % 25 + 'A';\nelse if(islower(p[i]))\nresult[i] = (p[i]-'a'+10) % 26 + 'a';\nelse if(isdigit(p[i]))\nresult[i] = (p[i]-'0'+3) % 10 + '0';\nelse result[i] = p[i]; // 공백, 특수문자 등 그대로\n}\n```\n\n**실행 과정 (p = \"It is 8\"):**\n\n1. **i=0, p[0]='I' (대문자):**\n- `('I'-'A'+5) % 25 + 'A' = (8+5) % 25 + 'A' = 13 + 'A' = 'N'`\n\n2. **i=1, p[1]='t' (소문자):**\n- `('t'-'a'+10) % 26 + 'a' = (19+10) % 26 + 'a' = 3 + 'a' = 'd'`\n\n3. **i=2, p[2]=' ' (공백):**\n- 그대로 복사: `result[2] = ' '`\n\n4. **i=3, p[3]='i' (소문자):**\n- `('i'-'a'+10) % 26 + 'a' = (8+10) % 26 + 'a' = 18 + 'a' = 's'`\n\n5. **i=4, p[4]='s' (소문자):**\n- `('s'-'a'+10) % 26 + 'a' = (18+10) % 26 + 'a' = 2 + 'a' = 'c'`\n\n6. **i=5, p[5]=' ' (공백):**\n- 그대로 복사: `result[5] = ' '`\n\n7. **i=6, p[6]='8' (숫자):**\n- `('8'-'0'+3) % 10 + '0' = (8+3) % 10 + '0' = 1 + '0' = '1'`\n\n**최종 출력:** \"Nd sc 1\"\n\n**답:** \"Nd sc 1\"", "table_refs": [], "image_refs": ["images/2024_round1/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.881115"}, "code_blocks": [{"language": "c", "code": "#include<stdio.h>\n#include<ctype.h>\nint main(){\n    char*p = \"It is 8\";\n    char result[100];\n    int i;\n    for(i=0; p[i]!='\\0'; i++){\n        if(isupper(p[i]))\n            result[i] = (p[i]-'A'+5)% 25 + 'A';\n        else if(islower(p[i]))\n            result[i] = (p[i]-'a'+10)% 26 + 'a';\n        else if(isdigit(p[i]))\n            result[i] = (p[i]-'0'+3)% 10 + '0';\n        else if(!(isupper(p[i]) || islower(p[i]) || isdigit(p[i])))    \n            result[i] = p[i];\n    }\n    result[i] = '\\0';\n    printf(\"%s\\n\",result);\n    return 0;\n}", "line_numbers": [1, 20], "file": "data/codes/2024_round1/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 아래의 내용을 보고\n\n알맞는 용어를 작성하시오.\n구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다.\n연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다 관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다.\nkit라고도 불린다.", "choices": [], "answer": {"keys": ["Abstract Factory"], "raw_text": "Abstract Factory"}, "explanation": "Abstract Factory(추상 팩토리) 패턴은 관련된 객체들의 집합을 생성하는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다\"**\n- 클라이언트는 구체적인 클래스를 알 필요 없이 추상 인터페이스를 통해 객체를 생성합니다.\n- 의존성 역전 원칙(Dependency Inversion Principle)을 따릅니다.\n\n2. **\"연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다\"**\n- 관련된 객체들을 하나의 제품군(Product Family)으로 그룹화합니다.\n- 예: Windows 스타일의 버튼, 메뉴, 다이얼로그 vs Mac 스타일의 버튼, 메뉴, 다이얼로그\n- 팩토리 객체가 적절한 제품군을 선택하여 생성합니다.\n\n3. **\"관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다\"**\n- 여러 관련 객체를 함께 생성할 때 사용됩니다.\n- 일관성 있는 객체 집합을 보장합니다.\n\n4. **\"kit라고도 불린다\"**\n- Abstract Factory는 \"Kit\" 패턴이라고도 합니다.\n- 객체 키트를 제공하는 개념입니다.\n\n**Factory Method와의 차이:**\n- Factory Method: 하나의 제품 객체 생성\n- **Abstract Factory: 관련된 여러 제품 객체들을 함께 생성**답:** \"Abstract Factory\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.938824", "readability_improved": "2025-11-04T00:26:37.881115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
