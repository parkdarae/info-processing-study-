{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["RARP (Reverse Address Resolution Protocol)"], "raw_text": "RARP (Reverse Address Resolution Protocol)"}, "explanation": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. **사용 목적:**\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. **동작 방식:**\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n**답:** RARP (Reverse Address Resolution Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 DB 설계 절차에 관한 설명이다.\n다음 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- (1)은/는 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.\n\n- (2)은/는 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다.\n\n- (3)은/는 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.\n\n[보기]\n\n: 구현 / 개념적 설계 / 논리적 설계 / 요구사항 분석 / 물리적 설계", "choices": [], "answer": {"keys": ["1. 물리적 설계", "2. 개념적 설계", "3. 논리적 설계"], "raw_text": "1. 물리적 설계 2. 개념적 설계 3. 논리적 설계"}, "explanation": "이 문제는 **데이터베이스 설계 절차**를 이해하는 문제입니다.\n\n**데이터베이스 설계 절차:**\n\n1. **요구사항 분석:**\n- 사용자 요구사항을 파악하고 분석\n- 시스템이 처리해야 할 데이터와 기능 정의\n\n2. **개념적 설계:**\n- 현실 세계에 대한 인식을 추상적, 개념적으로 표현\n- 개념적 구조를 도출하는 과정\n- 주요 산출물: E-R 다이어그램\n- 엔티티와 속성, 관계를 정의\n\n3. **논리적 설계:**\n- 목표 DBMS에 맞는 스키마 설계\n- 트랜잭션 인터페이스 설계\n- 정규화 과정 수행\n- 관계형 데이터 모델로 변환\n\n4. **물리적 설계:**\n- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환\n- 인덱스 설계, 저장 공간 할당\n- 결과 산출물: 테이블 정의서 등\n\n5. **구현:**\n- 실제 데이터베이스 생성 및 응용 프로그램 개발\n\n**문제에서 요구하는 답:**\n- (1) 물리적 설계: 테이블 정의서 등 명세서 생성\n- (2) 개념적 설계: E-R 다이어그램 등 개념적 구조 도출\n- (3) 논리적 설계: 정규화 과정 수행\n\n**답:** 1. 물리적 설계, 2. 개념적 설계, 3. 논리적 설계", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 요구사항의 분류에 대한 설명이다.\n괄호 (   ) 안에 들어갈 요구사항의 유형에 대해서 쓰시오.\n\n- (1) 요구사항은 시스템이 제공하는 기능, 서비스에 대한 요구사항이다.\n\n- (2) 요구사항은 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항이다.", "choices": [], "answer": {"keys": ["1. 기능적", "2. 비기능적"], "raw_text": "1. 기능적 2. 비기능적"}, "explanation": "요구사항이란 시스템 개발 분야에서 어떤 과제를 수행하기 위해, 필요한 조건이나 능력을 말합니다. - 기능적 요구사항 : 사용자 요구사항, 시스템 요구사항 - 비 기능적 요구사항 : 제품 요구사항, 조직 요구사항, 외부 요구사항", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구성된 언어를 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["WSDL"], "raw_text": "WSDL"}, "explanation": "WSDL(Web Services Description Language의 약자)은 웹 서비스 기술언어 또는 기술된 정의 파일의 총칭으로 XML로 기술됩니다. 웹 서비스의 구체적 내용이 기술되어 있으며 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술됩니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 파이썬 코드이다.\n출력 결과를 쓰시오.", "choices": [], "answer": {"keys": ["skiddp"], "raw_text": "skiddp"}, "explanation": "이 파이썬 코드는 **문자열 리스트의 각 요소에서 첫 번째 문자를 추출**하는 문제입니다.\n\n**코드 분석:**\n```python class good :\nli = [\"seoul\", \"kyeonggi\", \"inchon\", \"daejeon\", \"daegu\", \"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\nstr01 = str01 + i[0]\nprint(str01)\n```\n\n**실행 과정:**\n\n1. **클래스 정의 및 인스턴스 생성:**\n- `good` 클래스의 클래스 변수 `li`에 도시명 리스트 저장\n- `g = good()`로 인스턴스 생성\n\n2. **반복문 실행:**\n- `for i in g.li`: 리스트의 각 요소를 순회\n- 각 도시명 문자열에서 첫 번째 문자(`i[0]`) 추출\n\n3. **문자 추출 과정:**\n- `i = \"seoul\"` → `i[0] = 's'` → `str01 = 's'`\n- `i = \"kyeonggi\"` → `i[0] = 'k'` → `str01 = 'sk'`\n- `i = \"inchon\"` → `i[0] = 'i'` → `str01 = 'ski'`\n- `i = \"daejeon\"` → `i[0] = 'd'` → `str01 = 'skid'`\n- `i = \"daegu\"` → `i[0] = 'd'` → `str01 = 'skidd'`\n- `i = \"pusan\"` → `i[0] = 'p'` → `str01 = 'skiddp'`\n\n**최종 출력:** `skiddp`\n\n**핵심 포인트:**\n- 문자열 인덱싱: `문자열[0]`은 첫 번째 문자를 반환합니다.\n- 문자열 연결: `str01 = str01 + i[0]`는 기존 문자열에 새 문자를 추가합니다.\n\n**답:**skiddp**", "table_refs": [], "image_refs": ["images/2021_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [{"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}, {"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 SQL 실행 결과를 숫자만 쓰시오.\nSELECT COUNT(*) FROM 급여 WHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 SQL 쿼리는 WHERE 절의 조건을 분석하는 문제입니다.\n\n**쿼리 분석:**\n```sql SELECT COUNT(*) FROM 급여\nWHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;\n```\n\n**WHERE 절 조건 (연산자 우선순위 고려):**\n- `AND`가 `OR`보다 우선순위가 높으므로:\n- `(EMPNO > 100 AND SAL >= 3000) OR EMPNO = 200`\n\n**테이블 데이터 확인 (Q006_table1.json):**\n- 행1: EMPNO=100, SAL=1000\n- 행2: EMPNO=200, SAL=3000\n- 행3: EMPNO=300, SAL=1500\n\n**조건 검사:**\n\n1. 행1 (EMPNO=100, SAL=1000):\n- `(100 > 100 AND 1000 >= 3000) OR 100 = 200`\n- `(FALSE AND FALSE) OR FALSE` = FALSE\n\n2. 행2 (EMPNO=200, SAL=3000):\n- `(200 > 100 AND 3000 >= 3000) OR 200 = 200`\n- `(TRUE AND TRUE) OR TRUE` = TRUE ✓\n\n3. 행3 (EMPNO=300, SAL=1500):\n- `(300 > 100 AND 1500 >= 3000) OR 300 = 200`\n- `(TRUE AND FALSE) OR FALSE` = FALSE\n\n**결과:** 조건을 만족하는 행은 1개\n\n**답:** 1", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q006_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2021_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 Java 프로그램 결과를 쓰시오.", "choices": [], "answer": {"keys": ["3 1 45 50 89"], "raw_text": "3 1 45 50 89"}, "explanation": "이 Java 코드는 **2차원 배열의 구조와 접근 방법**을 이해하는 문제입니다.\n\n**코드 분석:**\n```java int[][]arr = new int[][]{{45,50,75},{89}};\nSystem.out.println(arr[0].length); // 첫 번째 행의 길이 System.out.println(arr[1].length); // 두 번째 행의 길이 System.out.println(arr[0][0]); // 첫 번째 행, 첫 번째 요소 System.out.println(arr[0][1]); // 첫 번째 행, 두 번째 요소 System.out.println(arr[1][0]); // 두 번째 행, 첫 번째 요소\n```\n\n**2차원 배열 구조:**\n- `arr[0] = {45, 50, 75}` → 길이 3\n- `arr[1] = {89}` → 길이 1\n\n**실행 순서:**\n\n1. `arr[0].length`: 첫 번째 행의 길이 → **3**\n2. `arr[1].length`: 두 번째 행의 길이 → **1**\n3. `arr[0][0]`: 첫 번째 행의 첫 번째 요소 → **45**\n4. `arr[0][1]`: 첫 번째 행의 두 번째 요소 → **50**\n5. `arr[1][0]`: 두 번째 행의 첫 번째 요소 → **89**출력:** `3 1 45 50 89`\n\n**핵심 포인트:**\n- Java에서 2차원 배열은 행마다 길이가 다를 수 있습니다(가변 배열).\n- `arr[i].length`는 i번째 행의 길이를 반환합니다.\n- `arr[i][j]`는 i번째 행의 j번째 요소에 접근합니다.\n\n**답:**3 1 45 50 89**", "table_refs": [], "image_refs": ["images/2021_round1/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [{"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}, {"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["비정규화 (반정규화/역정규화)"], "raw_text": "비정규화 (반정규화/역정규화)"}, "explanation": "이 문제는 **비정규화(반정규화/역정규화)**에 대한 문제입니다.\n\n**비정규화란?**\n- 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법\n- 정규화의 반대 개념으로, 성능을 위해 의도적으로 정규화 원칙을 완화\n\n**비정규화 방법:**\n\n1. **테이블 통합:**\n- 관련된 여러 테이블을 하나로 통합\n- 조인 연산 감소로 성능 향상\n\n2. **테이블 분할:**\n- 하나의 테이블을 여러 테이블로 분할\n- 수직 분할: 컬럼 단위 분할\n- 수평 분할: 행 단위 분할\n\n3. **중복 테이블 추가:**\n- 조회 성능 향상을 위해 중복 테이블 생성\n- 집계 테이블, 통계 테이블 등\n\n4. **중복 속성 추가:**\n- 조인 없이 접근하기 위해 중복 컬럼 추가\n- 계산된 값 저장\n\n**비정규화의 목적:**\n- 조회 성능 향상\n- 개발 및 운영 단순화\n- 응답 시간 단축\n\n**주의사항:**\n- 데이터 일관성 관리 필요\n- 저장 공간 증가\n- 데이터 중복으로 인한 업데이트 비용 증가\n\n**답:**비정규화 (반정규화/역정규화)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["ERD", "정규화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 블랙박스 기법에 대한 예제이다.\n블랙박스 기법 두 가지를 쓰시오.", "choices": [], "answer": {"keys": ["1. 경곗값 분석", "2. 동등분할 테스트"], "raw_text": "1. 경곗값 분석 2. 동등분할 테스트"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 이해하는 문제입니다.\n\n**블랙박스 테스트란?**\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n**블랙박스 테스트 종류:**\n\n1. **동치 분할 검사(동등분할 테스트, Equivalence Partitioning):**\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 동일한 결과를 낼 것으로 예상되는 입력값들을 하나의 그룹으로 묶음\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. **경계값 분석(Boundary Value Analysis):**\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 경계와 그 근처 값을 테스트\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. **원인-효과 그래프 검사(Cause-Effect Graphing):**\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. **오류 예측 검사(Error Guessing):**\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. **비교 검사(Comparison Testing):**\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n**문제에서 요구하는 기법:**\n- 블랙박스 기법 두 가지: **경계값 분석**, **동등분할 테스트**답:** 1. 경계값 분석, 2. 동등분할 테스트", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "0 <= x <= 10이면 -1 0 10 11 검사", "choices": [], "answer": {"keys": ["RARP (Reverse Address Resolution Protocol)"], "raw_text": "RARP (Reverse Address Resolution Protocol)"}, "explanation": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. **사용 목적:**\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. **동작 방식:**\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n**답:** RARP (Reverse Address Resolution Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "입력 데이터의 영역을 유사한 도메인별로 유횻값 / 무횻값을 그룹핑하여 나누어서 검사", "choices": [], "answer": {"keys": ["1. 물리적 설계", "2. 개념적 설계", "3. 논리적 설계"], "raw_text": "1. 물리적 설계 2. 개념적 설계 3. 논리적 설계"}, "explanation": "이 문제는 **데이터베이스 설계 절차**를 이해하는 문제입니다.\n\n**데이터베이스 설계 절차:**\n\n1. **요구사항 분석:**\n- 사용자 요구사항을 파악하고 분석\n- 시스템이 처리해야 할 데이터와 기능 정의\n\n2. **개념적 설계:**\n- 현실 세계에 대한 인식을 추상적, 개념적으로 표현\n- 개념적 구조를 도출하는 과정\n- 주요 산출물: E-R 다이어그램\n- 엔티티와 속성, 관계를 정의\n\n3. **논리적 설계:**\n- 목표 DBMS에 맞는 스키마 설계\n- 트랜잭션 인터페이스 설계\n- 정규화 과정 수행\n- 관계형 데이터 모델로 변환\n\n4. **물리적 설계:**\n- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환\n- 인덱스 설계, 저장 공간 할당\n- 결과 산출물: 테이블 정의서 등\n\n5. **구현:**\n- 실제 데이터베이스 생성 및 응용 프로그램 개발\n\n**문제에서 요구하는 답:**\n- (1) 물리적 설계: 테이블 정의서 등 명세서 생성\n- (2) 개념적 설계: E-R 다이어그램 등 개념적 구조 도출\n- (3) 논리적 설계: 정규화 과정 수행\n\n**답:** 1. 물리적 설계, 2. 개념적 설계, 3. 논리적 설계", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 테스트 종류에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n\n- (2) 은/는 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n\n[보기]\n\n: 시스템 테스트 / 인수 테스트 / 알파 테스트 / 단위 테스트 / 통합 테스트 / 회귀 테스트", "choices": [], "answer": {"keys": ["1. 단위 테스트", "2. 통합 테스트"], "raw_text": "1. 단위 테스트 2. 통합 테스트"}, "explanation": "이 문제는 **테스트 종류**를 이해하는 문제입니다.\n\n**각 테스트 레벨의 정의:**\n\n1. **단위 테스트(Unit Test):**\n- 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n- 가장 작은 단위(함수, 메서드)를 독립적으로 테스트\n- 화이트박스 테스트 기법 사용\n- 개발자가 수행\n\n2. **통합 테스트(Integration Test):**\n- 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n- 여러 모듈을 결합하여 테스트\n- 모듈 간 인터페이스와 상호작용 검증\n\n**다른 테스트 레벨:**\n\n3. **시스템 테스트(System Test):**\n- 구현된 시스템이 정해진 요건에 적합한지 여부를 평가\n- 실제 운용과 같은 환경에서 시스템 전체에 대해 수행\n- 기능적 요구사항과 비기능적 요구사항 검증\n\n4. **인수 테스트(Acceptance Test):**\n- 사용자나 고객이 수행하는 최종 테스트\n- 시스템이 사용자의 요구사항을 만족하는지 확인\n\n**테스트 순서:**\n단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트\n\n**답:**\n- (1) **단위 테스트**: 개별 모듈 확인\n- (2) **통합 테스트**: 인터페이스 간 시스템 확인", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- IPv6는 (1.)  비트 길이를 가진다.\n\n- IPv4는 길이 32bit이며, (2.) 비트씩 네 부분으로 나눈다.", "choices": [], "answer": {"keys": ["1. 128", "2. 8"], "raw_text": "1. 128 2. 8"}, "explanation": "이 문제는 **IPv6와 IPv4의 주소 체계**를 이해하는 문제입니다.\n\n**IPv6 주소:**\n- **128비트 길이**를 가집니다.\n- IPv4의 주소 고갈 문제를 해결하기 위해 개발\n- 16진수로 표현하며 8그룹으로 나눔 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)\n\n**IPv4 주소:**\n- **32비트 길이**를 가집니다.\n- **8비트씩 네 부분**으로 나누어 표현\n- 각 부분을 10진수로 표현 (예: 192.168.0.1)\n- 총 32비트 = 8비트 × 4개 부분\n\n**비교:**\n| 항목 | IPv4 | IPv6 |\n|------|------|------|\n| 주소 길이 | 32비트 | 128비트 |\n| 표현 방식 | 10진수, 4개 부분 | 16진수, 8개 부분 |\n| 예시 | 192.168.0.1 | 2001:0db8::1 |\n\n**답:**\n- (1) **128** (IPv6는 128비트)\n- (2) **8** (IPv4는 8비트씩 네 부분)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "공유메모리, 소켓, 세마포어, 메세지 큐 등 프로세스 간 통신하는 기술을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["IPC (Inter Process Communication)"], "raw_text": "IPC (Inter Process Communication)"}, "explanation": "IPC(Inter Process Communication, 프로세스 간 통신)는 운영체제에서 **서로 다른 프로세스가 데이터를 주고받는 기술**을 의미합니다.\n\n**IPC의 종류:**\n\n1. **공유 메모리(Shared Memory):**\n- 여러 프로세스가 같은 메모리 영역을 공유\n- 가장 빠른 통신 방법\n- 동기화 필요 (세마포어, 뮤텍스 등)\n\n2. **소켓(Socket):**\n- 네트워크를 통한 프로세스 간 통신\n- 로컬 또는 원격 프로세스와 통신 가능\n- TCP/UDP 프로토콜 사용\n\n3. **세마포어(Semaphore):**\n- 공유 자원에 대한 접근을 제어하는 동기화 메커니즘\n- 정수값을 사용하여 사용 가능한 자원의 개수를 나타냄\n- P 연산(대기), V 연산(신호) 제공\n\n4. **메시지 큐(Message Queue):**\n- 프로세스 간 메시지를 큐 형태로 전송\n- 비동기 통신 지원\n- 시스템이 관리하는 큐를 통해 메시지 전달\n\n**IPC의 필요성:**\n- 프로세스는 독립적인 메모리 공간을 가지므로 직접 데이터 공유 불가\n- 프로세스 간 데이터 교환 및 동기화를 위해 IPC 사용\n\n**답:**IPC (Inter Process Communication)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "시스템 통합에 사용되는 솔루션으로 구축 유형에는 Point to Point, Hub & Spoke, Message Bus가 있다. 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 , 통합이 가능하도록 해주는 솔루션을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["EAI (Enterprise Application Integration)"], "raw_text": "EAI (Enterprise Application Integration)"}, "explanation": "EAI 구축 유형 : 포인트 투 포인트 - 가장 기초적인 애플리케이션 통합 방법 (1:1 단순 통합 방법) / 허브 앤 스포크 - 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중적 방식 / 메세지 버스 - 애플리케이션 사이 미들웨어를 두어 연계하는 통합 방식 / 하이브리드 - 그룹 내는 허브 앤 스포크 방식, 그룹 간에는 메세지 버스 방식 사용", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "주어진 테이블의 Cardinality / Degree를 구하시오.", "choices": [], "answer": {"keys": ["Cardinality : 5", "Degree : 4"], "raw_text": "Cardinality : 5 Degree : 4"}, "explanation": "이 문제는 데이터베이스의 **Cardinality와 Degree**를 구하는 문제입니다.\n\n**Cardinality (카디널리티):**\n- 릴레이션(테이블)에서 **튜플(행)의 개수**\n- 데이터의 행 수\n- 예: 테이블에 5개의 행이 있으면 Cardinality = 5\n\n**Degree (차수):**\n- 릴레이션(테이블)에서 **속성(컬럼)의 개수**\n- 테이블의 컬럼 수\n- 예: 테이블에 4개의 컬럼이 있으면 Degree = 4\n\n**문제에서 요구하는 답:**\n주어진 테이블을 확인하면:\n- 행(Row)의 개수: 5개 → **Cardinality = 5**\n- 컬럼(Column)의 개수: 4개 → **Degree = 4**기억하기:**\n- Cardinality = 데이터 행 수 (카운트)\n- Degree = 속성 컬럼 수 (도메인)\n\n**답:**\n- **Cardinality : 5**\n- **Degree : 4**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q014_table1.json", "rows": 5, "cols": 4}], "image_refs": ["images/2021_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["Lee 38"], "raw_text": "Lee 38"}, "explanation": "이 C언어 코드는 **구조체 배열과 포인터**를 이해하는 문제입니다.\n\n**코드 분석:**\n```c struct good {\nchar name[10];\nint age;\n};\nvoid main(){\nstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\nstruct good *p;\np = s;\np++;\nprintf(\"%s\\n\", p->name);\nprintf(\"%d\\n\", p->age);\n}\n```\n\n**실행 과정:**\n\n1. **구조체 배열 초기화:**\n- `s[0] = {\"Kim\", 28}`\n- `s[1] = {\"Lee\", 38}`\n- `s[2] = {\"Seo\", 50}`\n- `s[3] = {\"Park\", 35}`\n\n2. **포인터 설정:**\n- `p = s` → `p`는 배열의 첫 번째 요소(`s[0]`)를 가리킴\n\n3. **포인터 증가:**\n- `p++` → 포인터가 다음 구조체를 가리킴 (`s[1]`)\n- 구조체 포인터는 구조체 크기만큼 이동\n\n4. **출력:**\n- `p->name`: `s[1].name` = **\"Lee\"**\n- `p->age`: `s[1].age` = **38**핵심 포인트:**\n- 구조체 포인터의 `++` 연산은 구조체 크기만큼 증가합니다.\n- `p->` 연산자는 포인터가 가리키는 구조체의 멤버에 접근합니다.\n\n**답:**Lee 38**", "table_refs": [], "image_refs": ["images/2021_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}, {"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "데이터 모델 구성요소 3가지를 쓰시오.\n\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.\n\n- 개체 데이터 모델에서는 (1.) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 (2.) 을/를 어떻게 나타낼 것인지 표현한다.\n\n- (3) 은/는 데이터 무결성 유지를 위한 db의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.", "choices": [], "answer": {"keys": ["1. 연산", "2. 구조", "3. 제약조건"], "raw_text": "1. 연산 2. 구조 3. 제약조건"}, "explanation": "데이터 모델은 데이터베이스 설계의 기초가 되는 개념적 틀입니다. 데이터 모델의 구성요소는 다음과 같습니다.\n\n**데이터 모델 구성요소 3가지:**\n\n1. **연산(Operation):**\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세\n- 데이터베이스를 조작하는 기본 도구\n- 예: SELECT, INSERT, UPDATE, DELETE 등의 연산\n\n2. **구조(Structure):**\n- 개체 데이터 모델에서는 연산을 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타냄\n- 논리 데이터 모델에서는 구조를 어떻게 나타낼 것인지 표현\n- 데이터의 논리적 구조와 물리적 구조를 정의\n- 예: 릴레이션 구조, 스키마 구조 등\n\n3. **제약조건(Constraint):**\n- 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법\n- 릴레이션의 특정 칼럼에 설정하는 제약\n- 개체 무결성: 기본 키가 NULL이 될 수 없고 중복될 수 없음\n- 참조 무결성: 외래 키가 참조하는 기본 키 값이 반드시 존재해야 함\n\n**데이터 모델의 역할:**\n- 현실 세계의 정보를 데이터베이스에 표현하기 위한 구조와 규칙 제공\n- 데이터의 일관성과 무결성 보장\n\n**답:**\n- (1) **연산**\n- (2) **구조**\n- (3) **제약조건**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["15"], "raw_text": "15"}, "explanation": "이 Java 코드는 **반복문을 이용한 누적 합계**를 계산하는 문제입니다.\n\n**코드 분석:**\n```java int i, j;\nfor(j=0, i=0; i<=5; i++){\nj += i;\nSystem.out.print(i);\nif(i==5){\nSystem.out.print(\"=\");\nSystem.out.print(j);\n}else{\nSystem.out.print(\"+\");\n}\n}\n```\n\n**실행 과정:**\n\n1. **초기화:**\n- `i = 0`, `j = 0`\n\n2. **반복문 실행 (i=0부터 i=5까지):**\n\n| 반복 | i 값 | j 값 | j += i 후 | 출력 |\n|------|------|------|----------|------|\n| 초기 | 0 | 0 | - | - |\n| 1회 | 0 | 0 | j = 0 + 0 = 0 | `0+` |\n| 2회 | 1 | 0 | j = 0 + 1 = 1 | `1+` |\n| 3회 | 2 | 1 | j = 1 + 2 = 3 | `2+` |\n| 4회 | 3 | 3 | j = 3 + 3 = 6 | `3+` |\n| 5회 | 4 | 6 | j = 6 + 4 = 10 | `4+` |\n| 6회 | 5 | 10 | j = 10 + 5 = 15 | `5=15` |\n\n3. **최종 출력:**\n- `0+1+2+3+4+5=15`\n- 하지만 문제에서 요구하는 것은 숫자만이므로: **15**핵심 포인트:**\n- `j += i`는 `j = j + i`와 같습니다 (누적 합계).\n- 반복문이 끝날 때 `j`는 0부터 5까지의 합인 15가 됩니다.\n\n**답:**15**", "table_refs": [], "image_refs": ["images/2021_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [{"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}, {"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법, 어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식은 ?", "choices": [], "answer": {"keys": ["임의적 접근 통제 (DAC)"], "raw_text": "임의적 접근 통제 (DAC)"}, "explanation": "접근 통제는 사람이나 프로세스가 시스템이나 파일에 접근 여부를 허가하거나 거부하는 기능을 말합니다. 임의적 접근 통제(DAC - Discretionary Access Control) : 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한하는 방법", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 결합도에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n\n- (2) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도\n\n- (3) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\n: 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도", "choices": [], "answer": {"keys": ["1. 내용 결합도", "2. 스탬프 결합도", "3. 공통 결합도"], "raw_text": "1. 내용 결합도 2. 스탬프 결합도 3. 공통 결합도"}, "explanation": "결합도와 품질(낮은 품질에서 좋은 품질 순) : 내용결합도 > 공통 결합도 > 외부 결합도 > 제어 결합도 > 스탬프 결합도 > 자료 결합도", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "괄호 안에 공통으로 들어갈 공격 기법을 적으시오.\n\n- (      ) 은/는 '세션을 가로채다' 라는 의미로 정상적 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결한다.\n\n- (      ) 은/는 세션 관리 취약점을 이용한 공격 기법이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의:**\n\n1. **기본 의미:**\n- '세션을 가로채다(Hijack)'라는 의미\n- 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법\n\n2. **공격 방식:**\n- 정상적인 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결\n- 세션 관리 취약점을 이용한 공격 기법\n\n**세션 하이재킹의 과정:**\n\n1. **세션 정보 획득:**\n- 네트워크 스니핑을 통해 세션 ID, 쿠키 등의 세션 정보 탈취\n- 또는 XSS 공격을 통해 세션 정보 유출\n\n2. **세션 가로채기:**\n- 획득한 세션 정보를 사용하여 정상 사용자인 것처럼 위장\n- 서버가 공격자를 정상 사용자로 인식\n\n3. **권한 획득:**\n- 정상 사용자의 권한으로 시스템 접근 및 조작\n\n**방어 방법:**\n- HTTPS 사용 (암호화 통신)\n- 세션 ID 암호화\n- 세션 타임아웃 설정\n- IP 주소 검증\n\n**답:**세션 하이재킹**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
