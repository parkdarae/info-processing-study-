{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["RARP (Reverse Address Resolution Protocol)"], "raw_text": "RARP (Reverse Address Resolution Protocol)"}, "explanation": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. **사용 목적:**\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. **동작 방식:**\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n**답:** RARP (Reverse Address Resolution Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 DB 설계 절차에 관한 설명이다.\n다음 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- (1)은/는 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.\n\n- (2)은/는 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다.\n\n- (3)은/는 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.\n\n[보기]\n\n: 구현 / 개념적 설계 / 논리적 설계 / 요구사항 분석 / 물리적 설계", "choices": [], "answer": {"keys": ["1. 물리적 설계", "2. 개념적 설계", "3. 논리적 설계"], "raw_text": "1. 물리적 설계 2. 개념적 설계 3. 논리적 설계"}, "explanation": "이 문제는 **데이터베이스 설계 절차**를 이해하는 문제입니다.\n\n**데이터베이스 설계 절차:**\n\n1. **요구사항 분석:**\n- 사용자 요구사항을 파악하고 분석\n- 시스템이 처리해야 할 데이터와 기능 정의\n\n2. **개념적 설계:**\n- 현실 세계에 대한 인식을 추상적, 개념적으로 표현\n- 개념적 구조를 도출하는 과정\n- 주요 산출물: E-R 다이어그램\n- 엔티티와 속성, 관계를 정의\n\n3. **논리적 설계:**\n- 목표 DBMS에 맞는 스키마 설계\n- 트랜잭션 인터페이스 설계\n- 정규화 과정 수행\n- 관계형 데이터 모델로 변환\n\n4. **물리적 설계:**\n- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환\n- 인덱스 설계, 저장 공간 할당\n- 결과 산출물: 테이블 정의서 등\n\n5. **구현:**\n- 실제 데이터베이스 생성 및 응용 프로그램 개발\n\n**문제에서 요구하는 답:**\n- (1) 물리적 설계: 테이블 정의서 등 명세서 생성\n- (2) 개념적 설계: E-R 다이어그램 등 개념적 구조 도출\n- (3) 논리적 설계: 정규화 과정 수행\n\n**답:** 1. 물리적 설계, 2. 개념적 설계, 3. 논리적 설계", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 요구사항의 분류에 대한 설명이다.\n괄호 (   ) 안에 들어갈 요구사항의 유형에 대해서 쓰시오.\n\n- (1) 요구사항은 시스템이 제공하는 기능, 서비스에 대한 요구사항이다.\n\n- (2) 요구사항은 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항이다.", "choices": [], "answer": {"keys": ["1. 기능적", "2. 비기능적"], "raw_text": "1. 기능적 2. 비기능적"}, "explanation": "요구사항이란 시스템 개발 분야에서 어떤 과제를 수행하기 위해, 필요한 조건이나 능력을 말합니다. - 기능적 요구사항 : 사용자 요구사항, 시스템 요구사항 - 비 기능적 요구사항 : 제품 요구사항, 조직 요구사항, 외부 요구사항", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구성된 언어를 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["WSDL"], "raw_text": "WSDL"}, "explanation": "WSDL(Web Services Description Language의 약자)은 웹 서비스 기술언어 또는 기술된 정의 파일의 총칭으로 XML로 기술됩니다. 웹 서비스의 구체적 내용이 기술되어 있으며 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술됩니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 파이썬 코드이다.\n출력 결과를 쓰시오.", "choices": [], "answer": {"keys": ["skiddp"], "raw_text": "skiddp"}, "explanation": "이 파이썬 코드는 **문자열 리스트의 각 요소에서 첫 번째 문자를 추출**하는 문제입니다.\n\n**코드 분석:**\n```python class good :\nli = [\"seoul\", \"kyeonggi\", \"inchon\", \"daejeon\", \"daegu\", \"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\nstr01 = str01 + i[0]\nprint(str01)\n```\n\n**실행 과정:**\n\n1. **클래스 정의 및 인스턴스 생성:**\n- `good` 클래스의 클래스 변수 `li`에 도시명 리스트 저장\n- `g = good()`로 인스턴스 생성\n\n2. **반복문 실행:**\n- `for i in g.li`: 리스트의 각 요소를 순회\n- 각 도시명 문자열에서 첫 번째 문자(`i[0]`) 추출\n\n3. **문자 추출 과정:**\n- `i = \"seoul\"` → `i[0] = 's'` → `str01 = 's'`\n- `i = \"kyeonggi\"` → `i[0] = 'k'` → `str01 = 'sk'`\n- `i = \"inchon\"` → `i[0] = 'i'` → `str01 = 'ski'`\n- `i = \"daejeon\"` → `i[0] = 'd'` → `str01 = 'skid'`\n- `i = \"daegu\"` → `i[0] = 'd'` → `str01 = 'skidd'`\n- `i = \"pusan\"` → `i[0] = 'p'` → `str01 = 'skiddp'`\n\n**최종 출력:** `skiddp`\n\n**핵심 포인트:**\n- 문자열 인덱싱: `문자열[0]`은 첫 번째 문자를 반환합니다.\n- 문자열 연결: `str01 = str01 + i[0]`는 기존 문자열에 새 문자를 추가합니다.\n\n**답:**skiddp**", "table_refs": [], "image_refs": ["images/2021_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [{"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}, {"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 SQL 실행 결과를 숫자만 쓰시오.\nSELECT COUNT(*) FROM 급여 WHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 SQL 쿼리는 WHERE 절의 조건을 분석하는 문제입니다.\n\n**쿼리 분석:**\n```sql SELECT COUNT(*) FROM 급여\nWHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;\n```\n\n**WHERE 절 조건 (연산자 우선순위 고려):**\n- `AND`가 `OR`보다 우선순위가 높으므로:\n- `(EMPNO > 100 AND SAL >= 3000) OR EMPNO = 200`\n\n**테이블 데이터 확인 (Q006_table1.json):**\n- 행1: EMPNO=100, SAL=1000\n- 행2: EMPNO=200, SAL=3000\n- 행3: EMPNO=300, SAL=1500\n\n**조건 검사:**\n\n1. 행1 (EMPNO=100, SAL=1000):\n- `(100 > 100 AND 1000 >= 3000) OR 100 = 200`\n- `(FALSE AND FALSE) OR FALSE` = FALSE\n\n2. 행2 (EMPNO=200, SAL=3000):\n- `(200 > 100 AND 3000 >= 3000) OR 200 = 200`\n- `(TRUE AND TRUE) OR TRUE` = TRUE ✓\n\n3. 행3 (EMPNO=300, SAL=1500):\n- `(300 > 100 AND 1500 >= 3000) OR 300 = 200`\n- `(TRUE AND FALSE) OR FALSE` = FALSE\n\n**결과:** 조건을 만족하는 행은 1개\n\n**답:** 1", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q006_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2021_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.836117"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 Java 프로그램 결과를 쓰시오.", "choices": [], "answer": {"keys": ["3 1 45 50 89"], "raw_text": "3 1 45 50 89"}, "explanation": "이 Java 코드는 **2차원 배열의 구조와 접근 방법**을 이해하는 문제입니다.\n\n**코드 분석:**\n```java int[][]arr = new int[][]{{45,50,75},{89}};\nSystem.out.println(arr[0].length); // 첫 번째 행의 길이 System.out.println(arr[1].length); // 두 번째 행의 길이 System.out.println(arr[0][0]); // 첫 번째 행, 첫 번째 요소 System.out.println(arr[0][1]); // 첫 번째 행, 두 번째 요소 System.out.println(arr[1][0]); // 두 번째 행, 첫 번째 요소\n```\n\n**2차원 배열 구조:**\n- `arr[0] = {45, 50, 75}` → 길이 3\n- `arr[1] = {89}` → 길이 1\n\n**실행 순서:**\n\n1. `arr[0].length`: 첫 번째 행의 길이 → **3**\n2. `arr[1].length`: 두 번째 행의 길이 → **1**\n3. `arr[0][0]`: 첫 번째 행의 첫 번째 요소 → **45**\n4. `arr[0][1]`: 첫 번째 행의 두 번째 요소 → **50**\n5. `arr[1][0]`: 두 번째 행의 첫 번째 요소 → **89**출력:** `3 1 45 50 89`\n\n**핵심 포인트:**\n- Java에서 2차원 배열은 행마다 길이가 다를 수 있습니다(가변 배열).\n- `arr[i].length`는 i번째 행의 길이를 반환합니다.\n- `arr[i][j]`는 i번째 행의 j번째 요소에 접근합니다.\n\n**답:**3 1 45 50 89**", "table_refs": [], "image_refs": ["images/2021_round1/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [{"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}, {"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["비정규화 (반정규화/역정규화)"], "raw_text": "비정규화 (반정규화/역정규화)"}, "explanation": "이 문제는 **비정규화(반정규화/역정규화)**에 대한 문제입니다.\n\n**비정규화란?**\n- 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법\n- 정규화의 반대 개념으로, 성능을 위해 의도적으로 정규화 원칙을 완화\n\n**비정규화 방법:**\n\n1. **테이블 통합:**\n- 관련된 여러 테이블을 하나로 통합\n- 조인 연산 감소로 성능 향상\n\n2. **테이블 분할:**\n- 하나의 테이블을 여러 테이블로 분할\n- 수직 분할: 컬럼 단위 분할\n- 수평 분할: 행 단위 분할\n\n3. **중복 테이블 추가:**\n- 조회 성능 향상을 위해 중복 테이블 생성\n- 집계 테이블, 통계 테이블 등\n\n4. **중복 속성 추가:**\n- 조인 없이 접근하기 위해 중복 컬럼 추가\n- 계산된 값 저장\n\n**비정규화의 목적:**\n- 조회 성능 향상\n- 개발 및 운영 단순화\n- 응답 시간 단축\n\n**주의사항:**\n- 데이터 일관성 관리 필요\n- 저장 공간 증가\n- 데이터 중복으로 인한 업데이트 비용 증가\n\n**답:**비정규화 (반정규화/역정규화)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["ERD", "정규화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 블랙박스 기법에 대한 예제이다.\n블랙박스 기법 두 가지를 쓰시오.", "choices": [], "answer": {"keys": ["1. 경곗값 분석", "2. 동등분할 테스트"], "raw_text": "1. 경곗값 분석 2. 동등분할 테스트"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 이해하는 문제입니다.\n\n**블랙박스 테스트란?**\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n**블랙박스 테스트 종류:**\n\n1. **동치 분할 검사(동등분할 테스트, Equivalence Partitioning):**\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 동일한 결과를 낼 것으로 예상되는 입력값들을 하나의 그룹으로 묶음\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. **경계값 분석(Boundary Value Analysis):**\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 경계와 그 근처 값을 테스트\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. **원인-효과 그래프 검사(Cause-Effect Graphing):**\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. **오류 예측 검사(Error Guessing):**\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. **비교 검사(Comparison Testing):**\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n**문제에서 요구하는 기법:**\n- 블랙박스 기법 두 가지: **경계값 분석**, **동등분할 테스트**답:** 1. 경계값 분석, 2. 동등분할 테스트", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "0 <= x <= 10이면 -1 0 10 11 검사", "choices": [], "answer": {"keys": ["RARP (Reverse Address Resolution Protocol)"], "raw_text": "RARP (Reverse Address Resolution Protocol)"}, "explanation": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. **사용 목적:**\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. **동작 방식:**\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n**답:** RARP (Reverse Address Resolution Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "입력 데이터의 영역을 유사한 도메인별로 유횻값 / 무횻값을 그룹핑하여 나누어서 검사", "choices": [], "answer": {"keys": ["1. 물리적 설계", "2. 개념적 설계", "3. 논리적 설계"], "raw_text": "1. 물리적 설계 2. 개념적 설계 3. 논리적 설계"}, "explanation": "이 문제는 **데이터베이스 설계 절차**를 이해하는 문제입니다.\n\n**데이터베이스 설계 절차:**\n\n1. **요구사항 분석:**\n- 사용자 요구사항을 파악하고 분석\n- 시스템이 처리해야 할 데이터와 기능 정의\n\n2. **개념적 설계:**\n- 현실 세계에 대한 인식을 추상적, 개념적으로 표현\n- 개념적 구조를 도출하는 과정\n- 주요 산출물: E-R 다이어그램\n- 엔티티와 속성, 관계를 정의\n\n3. **논리적 설계:**\n- 목표 DBMS에 맞는 스키마 설계\n- 트랜잭션 인터페이스 설계\n- 정규화 과정 수행\n- 관계형 데이터 모델로 변환\n\n4. **물리적 설계:**\n- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환\n- 인덱스 설계, 저장 공간 할당\n- 결과 산출물: 테이블 정의서 등\n\n5. **구현:**\n- 실제 데이터베이스 생성 및 응용 프로그램 개발\n\n**문제에서 요구하는 답:**\n- (1) 물리적 설계: 테이블 정의서 등 명세서 생성\n- (2) 개념적 설계: E-R 다이어그램 등 개념적 구조 도출\n- (3) 논리적 설계: 정규화 과정 수행\n\n**답:** 1. 물리적 설계, 2. 개념적 설계, 3. 논리적 설계", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 테스트 종류에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n\n- (2) 은/는 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n\n[보기]\n\n: 시스템 테스트 / 인수 테스트 / 알파 테스트 / 단위 테스트 / 통합 테스트 / 회귀 테스트", "choices": [], "answer": {"keys": ["1. 단위 테스트", "2. 통합 테스트"], "raw_text": "1. 단위 테스트 2. 통합 테스트"}, "explanation": "이 문제는 **테스트 종류**를 이해하는 문제입니다.\n\n**각 테스트 레벨의 정의:**\n\n1. **단위 테스트(Unit Test):**\n- 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n- 가장 작은 단위(함수, 메서드)를 독립적으로 테스트\n- 화이트박스 테스트 기법 사용\n- 개발자가 수행\n\n2. **통합 테스트(Integration Test):**\n- 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n- 여러 모듈을 결합하여 테스트\n- 모듈 간 인터페이스와 상호작용 검증\n\n**다른 테스트 레벨:**\n\n3. **시스템 테스트(System Test):**\n- 구현된 시스템이 정해진 요건에 적합한지 여부를 평가\n- 실제 운용과 같은 환경에서 시스템 전체에 대해 수행\n- 기능적 요구사항과 비기능적 요구사항 검증\n\n4. **인수 테스트(Acceptance Test):**\n- 사용자나 고객이 수행하는 최종 테스트\n- 시스템이 사용자의 요구사항을 만족하는지 확인\n\n**테스트 순서:**\n단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트\n\n**답:**\n- (1) **단위 테스트**: 개별 모듈 확인\n- (2) **통합 테스트**: 인터페이스 간 시스템 확인", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- IPv6는 (1.)  비트 길이를 가진다.\n\n- IPv4는 길이 32bit이며, (2.) 비트씩 네 부분으로 나눈다.", "choices": [], "answer": {"keys": ["1. 128", "2. 8"], "raw_text": "1. 128 2. 8"}, "explanation": "이 문제는 **IPv6와 IPv4의 주소 체계**를 이해하는 문제입니다.\n\n**IPv6 주소:**\n- **128비트 길이**를 가집니다.\n- IPv4의 주소 고갈 문제를 해결하기 위해 개발\n- 16진수로 표현하며 8그룹으로 나눔 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)\n\n**IPv4 주소:**\n- **32비트 길이**를 가집니다.\n- **8비트씩 네 부분**으로 나누어 표현\n- 각 부분을 10진수로 표현 (예: 192.168.0.1)\n- 총 32비트 = 8비트 × 4개 부분\n\n**비교:**\n| 항목 | IPv4 | IPv6 |\n|------|------|------|\n| 주소 길이 | 32비트 | 128비트 |\n| 표현 방식 | 10진수, 4개 부분 | 16진수, 8개 부분 |\n| 예시 | 192.168.0.1 | 2001:0db8::1 |\n\n**답:**\n- (1) **128** (IPv6는 128비트)\n- (2) **8** (IPv4는 8비트씩 네 부분)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "공유메모리, 소켓, 세마포어, 메세지 큐 등 프로세스 간 통신하는 기술을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["IPC (Inter Process Communication)"], "raw_text": "IPC (Inter Process Communication)"}, "explanation": "IPC(Inter Process Communication, 프로세스 간 통신)는 운영체제에서 **서로 다른 프로세스가 데이터를 주고받는 기술**을 의미합니다.\n\n**IPC의 종류:**\n\n1. **공유 메모리(Shared Memory):**\n- 여러 프로세스가 같은 메모리 영역을 공유\n- 가장 빠른 통신 방법\n- 동기화 필요 (세마포어, 뮤텍스 등)\n\n2. **소켓(Socket):**\n- 네트워크를 통한 프로세스 간 통신\n- 로컬 또는 원격 프로세스와 통신 가능\n- TCP/UDP 프로토콜 사용\n\n3. **세마포어(Semaphore):**\n- 공유 자원에 대한 접근을 제어하는 동기화 메커니즘\n- 정수값을 사용하여 사용 가능한 자원의 개수를 나타냄\n- P 연산(대기), V 연산(신호) 제공\n\n4. **메시지 큐(Message Queue):**\n- 프로세스 간 메시지를 큐 형태로 전송\n- 비동기 통신 지원\n- 시스템이 관리하는 큐를 통해 메시지 전달\n\n**IPC의 필요성:**\n- 프로세스는 독립적인 메모리 공간을 가지므로 직접 데이터 공유 불가\n- 프로세스 간 데이터 교환 및 동기화를 위해 IPC 사용\n\n**답:**IPC (Inter Process Communication)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "시스템 통합에 사용되는 솔루션으로 구축 유형에는 Point to Point, Hub & Spoke, Message Bus가 있다. 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 , 통합이 가능하도록 해주는 솔루션을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["EAI (Enterprise Application Integration)"], "raw_text": "EAI (Enterprise Application Integration)"}, "explanation": "EAI 구축 유형 : 포인트 투 포인트 - 가장 기초적인 애플리케이션 통합 방법 (1:1 단순 통합 방법) / 허브 앤 스포크 - 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중적 방식 / 메세지 버스 - 애플리케이션 사이 미들웨어를 두어 연계하는 통합 방식 / 하이브리드 - 그룹 내는 허브 앤 스포크 방식, 그룹 간에는 메세지 버스 방식 사용", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.837116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "주어진 테이블의 Cardinality / Degree를 구하시오.", "choices": [], "answer": {"keys": ["Cardinality : 5", "Degree : 4"], "raw_text": "Cardinality : 5 Degree : 4"}, "explanation": "이 문제는 데이터베이스의 **Cardinality와 Degree**를 구하는 문제입니다.\n\n**Cardinality (카디널리티):**\n- 릴레이션(테이블)에서 **튜플(행)의 개수**\n- 데이터의 행 수\n- 예: 테이블에 5개의 행이 있으면 Cardinality = 5\n\n**Degree (차수):**\n- 릴레이션(테이블)에서 **속성(컬럼)의 개수**\n- 테이블의 컬럼 수\n- 예: 테이블에 4개의 컬럼이 있으면 Degree = 4\n\n**문제에서 요구하는 답:**\n주어진 테이블을 확인하면:\n- 행(Row)의 개수: 5개 → **Cardinality = 5**\n- 컬럼(Column)의 개수: 4개 → **Degree = 4**기억하기:**\n- Cardinality = 데이터 행 수 (카운트)\n- Degree = 속성 컬럼 수 (도메인)\n\n**답:**\n- **Cardinality : 5**\n- **Degree : 4**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q014_table1.json", "rows": 5, "cols": 4}], "image_refs": ["images/2021_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["Lee 38"], "raw_text": "Lee 38"}, "explanation": "이 C언어 코드는 **구조체 배열과 포인터**를 이해하는 문제입니다.\n\n**코드 분석:**\n```c struct good {\nchar name[10];\nint age;\n};\nvoid main(){\nstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\nstruct good *p;\np = s;\np++;\nprintf(\"%s\\n\", p->name);\nprintf(\"%d\\n\", p->age);\n}\n```\n\n**실행 과정:**\n\n1. **구조체 배열 초기화:**\n- `s[0] = {\"Kim\", 28}`\n- `s[1] = {\"Lee\", 38}`\n- `s[2] = {\"Seo\", 50}`\n- `s[3] = {\"Park\", 35}`\n\n2. **포인터 설정:**\n- `p = s` → `p`는 배열의 첫 번째 요소(`s[0]`)를 가리킴\n\n3. **포인터 증가:**\n- `p++` → 포인터가 다음 구조체를 가리킴 (`s[1]`)\n- 구조체 포인터는 구조체 크기만큼 이동\n\n4. **출력:**\n- `p->name`: `s[1].name` = **\"Lee\"**\n- `p->age`: `s[1].age` = **38**핵심 포인트:**\n- 구조체 포인터의 `++` 연산은 구조체 크기만큼 증가합니다.\n- `p->` 연산자는 포인터가 가리키는 구조체의 멤버에 접근합니다.\n\n**답:**Lee 38**", "table_refs": [], "image_refs": ["images/2021_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}, {"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "데이터 모델 구성요소 3가지를 쓰시오.\n\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.\n\n- 개체 데이터 모델에서는 (1.) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 (2.) 을/를 어떻게 나타낼 것인지 표현한다.\n\n- (3) 은/는 데이터 무결성 유지를 위한 db의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.", "choices": [], "answer": {"keys": ["1. 연산", "2. 구조", "3. 제약조건"], "raw_text": "1. 연산 2. 구조 3. 제약조건"}, "explanation": "데이터 모델은 데이터베이스 설계의 기초가 되는 개념적 틀입니다. 데이터 모델의 구성요소는 다음과 같습니다.\n\n**데이터 모델 구성요소 3가지:**\n\n1. **연산(Operation):**\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세\n- 데이터베이스를 조작하는 기본 도구\n- 예: SELECT, INSERT, UPDATE, DELETE 등의 연산\n\n2. **구조(Structure):**\n- 개체 데이터 모델에서는 연산을 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타냄\n- 논리 데이터 모델에서는 구조를 어떻게 나타낼 것인지 표현\n- 데이터의 논리적 구조와 물리적 구조를 정의\n- 예: 릴레이션 구조, 스키마 구조 등\n\n3. **제약조건(Constraint):**\n- 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법\n- 릴레이션의 특정 칼럼에 설정하는 제약\n- 개체 무결성: 기본 키가 NULL이 될 수 없고 중복될 수 없음\n- 참조 무결성: 외래 키가 참조하는 기본 키 값이 반드시 존재해야 함\n\n**데이터 모델의 역할:**\n- 현실 세계의 정보를 데이터베이스에 표현하기 위한 구조와 규칙 제공\n- 데이터의 일관성과 무결성 보장\n\n**답:**\n- (1) **연산**\n- (2) **구조**\n- (3) **제약조건**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["15"], "raw_text": "15"}, "explanation": "이 Java 코드는 **반복문을 이용한 누적 합계**를 계산하는 문제입니다.\n\n**코드 분석:**\n```java int i, j;\nfor(j=0, i=0; i<=5; i++){\nj += i;\nSystem.out.print(i);\nif(i==5){\nSystem.out.print(\"=\");\nSystem.out.print(j);\n}else{\nSystem.out.print(\"+\");\n}\n}\n```\n\n**실행 과정:**\n\n1. **초기화:**\n- `i = 0`, `j = 0`\n\n2. **반복문 실행 (i=0부터 i=5까지):**\n\n| 반복 | i 값 | j 값 | j += i 후 | 출력 |\n|------|------|------|----------|------|\n| 초기 | 0 | 0 | - | - |\n| 1회 | 0 | 0 | j = 0 + 0 = 0 | `0+` |\n| 2회 | 1 | 0 | j = 0 + 1 = 1 | `1+` |\n| 3회 | 2 | 1 | j = 1 + 2 = 3 | `2+` |\n| 4회 | 3 | 3 | j = 3 + 3 = 6 | `3+` |\n| 5회 | 4 | 6 | j = 6 + 4 = 10 | `4+` |\n| 6회 | 5 | 10 | j = 10 + 5 = 15 | `5=15` |\n\n3. **최종 출력:**\n- `0+1+2+3+4+5=15`\n- 하지만 문제에서 요구하는 것은 숫자만이므로: **15**핵심 포인트:**\n- `j += i`는 `j = j + i`와 같습니다 (누적 합계).\n- 반복문이 끝날 때 `j`는 0부터 5까지의 합인 15가 됩니다.\n\n**답:**15**", "table_refs": [], "image_refs": ["images/2021_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [{"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}, {"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법, 어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식은 ?", "choices": [], "answer": {"keys": ["임의적 접근 통제 (DAC)"], "raw_text": "임의적 접근 통제 (DAC)"}, "explanation": "접근 통제는 사람이나 프로세스가 시스템이나 파일에 접근 여부를 허가하거나 거부하는 기능을 말합니다. 임의적 접근 통제(DAC - Discretionary Access Control) : 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한하는 방법", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 결합도에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n\n- (2) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도\n\n- (3) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\n: 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도", "choices": [], "answer": {"keys": ["1. 내용 결합도", "2. 스탬프 결합도", "3. 공통 결합도"], "raw_text": "1. 내용 결합도 2. 스탬프 결합도 3. 공통 결합도"}, "explanation": "결합도와 품질(낮은 품질에서 좋은 품질 순) : 내용결합도 > 공통 결합도 > 외부 결합도 > 제어 결합도 > 스탬프 결합도 > 자료 결합도", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "괄호 안에 공통으로 들어갈 공격 기법을 적으시오.\n\n- (      ) 은/는 '세션을 가로채다' 라는 의미로 정상적 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결한다.\n\n- (      ) 은/는 세션 관리 취약점을 이용한 공격 기법이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의:**\n\n1. **기본 의미:**\n- '세션을 가로채다(Hijack)'라는 의미\n- 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법\n\n2. **공격 방식:**\n- 정상적인 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결\n- 세션 관리 취약점을 이용한 공격 기법\n\n**세션 하이재킹의 과정:**\n\n1. **세션 정보 획득:**\n- 네트워크 스니핑을 통해 세션 ID, 쿠키 등의 세션 정보 탈취\n- 또는 XSS 공격을 통해 세션 정보 유출\n\n2. **세션 가로채기:**\n- 획득한 세션 정보를 사용하여 정상 사용자인 것처럼 위장\n- 서버가 공격자를 정상 사용자로 인식\n\n3. **권한 획득:**\n- 정상 사용자의 권한으로 시스템 접근 및 조작\n\n**방어 방법:**\n- HTTPS 사용 (암호화 통신)\n- 세션 ID 암호화\n- 세션 타임아웃 설정\n- IP 주소 검증\n\n**답:**세션 하이재킹**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:26:37.838115"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "아래 설명에 맞는 RAID 단계를 숫자로 작성하시오.\n\n- Striping(스트라이핑) 구현 방식\n\n- I/O 로드의 분산으로 매우 빠른 속도\n\n- 데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장", "choices": [], "answer": {"keys": ["RAID 0"], "raw_text": "RAID 0"}, "explanation": "이 문제는 **RAID 0 (스트라이핑)**에 대한 문제입니다.\n\n**RAID 0 (스트라이핑)의 특징:**\n\n1. **Striping (스트라이핑) 구현:**\n- 데이터를 여러 디스크에 분산 저장하는 방식\n- 데이터를 블록 단위로 분할하여 각 디스크에 저장\n\n2. **성능 향상:**\n- I/O 로드 분산으로 읽기/쓰기 속도가 매우 빠름\n- 여러 디스크에 동시에 접근하므로 병렬 처리 가능\n\n3. **데이터 저장 방식:**\n- 데이터를 블록으로 분할\n- 각 블록은 다른 디스크로 분산 저장\n\n**문제에서 설명하는 특징:**\n- \"스트라이핑 구현 방식\" → RAID 0\n- \"I/O 로드의 분산으로 매우 빠른 속도\" → RAID 0\n- \"데이터를 블럭으로 분할 저장하며, 각 블럭은 다른 디스크로 나뉘어 저장\" → RAID 0\n\n**답:**RAID 0**참고:** RAID 0은 패리티(검증 데이터)나 미러링 없이 순수하게 성능 향상만을 위한 방식입니다. 디스크 하나가 고장 나면 모든 데이터를 잃게 되므로 안정성은 낮습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.850116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["데이터베이스"], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 설명을 확인하여\n\n해당하는 항목을 보기에서 찾아 적으시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, rollback 등..))\n\n1. 오류가 발생하기 전까지의 사항을 로그(log)로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상\n\n2. 작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것", "choices": [], "answer": {"keys": ["watering hole (워터링홀)"], "raw_text": "watering hole (워터링홀)"}, "explanation": "이 문제는 데이터베이스 **트랜잭션의 복구 기법**에 대한 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n1. **오류가 발생하기 전까지의 사항을 로그로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상**\n- 이것은 **REDO (재실행)**입니다.\n- 트랜잭션이 커밋된 후 갱신 사항이 데이터베이스에 반영되지 못한 경우\n- 로그 파일의 기록을 이용하여 다시 실행하는 복구 방법\n\n2. **작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것**\n- 이것은 **UNDO (취소)**입니다.\n- 트랜잭션이 롤백될 때 변경 사항을 취소하는 복구 방법\n- 변경 전 값으로 복원\n\n**REDO와 UNDO의 차이:**\n\n| 구분 | UNDO | REDO |\n|------|------|------|\n| 목적 | 트랜잭션 취소 | 트랜잭션 재실행 |\n| 시점 | 롤백 시 | 커밋 후 미반영 시 |\n| 방향 | 과거로 되돌림 | 앞으로 진행 |\n| 로그 | Before Image 사용 | After Image 사용 |\n\n**답:**\n- 1) **redo** (재실행)\n- 2) **undo** (취소)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:26:37.850116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음 자바 문법에 알맞는 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["2000"], "raw_text": "2000"}, "explanation": "이 Java 코드는 **클래스 객체의 참조 전달**과 **메서드를 통한 값 변경**을 이해하는 문제입니다.\n\n**코드 분석:**\n```java class A {\nint a;\nint b;\n}\npublic class Main {\nstatic void func1(A m){\nm.a *= 10;\n}\nstatic void func2(A m){\nm.a += m.b;\n}\npublic static void main(String args[]){\nA m = new A();\nm.a = 100;\nfunc1(m);\nm.b = m.a;\nfunc2(m);\nSystem.out.printf(\"%d\", m.a);\n}\n}\n```\n\n**실행 과정:**\n\n1. **객체 생성 및 초기화:**\n- `A m = new A()` → `m.a = 0`, `m.b = 0` (기본값)\n- `m.a = 100` → `m.a = 100`, `m.b = 0`\n\n2. **func1(m) 호출:**\n- `m.a *= 10` → `m.a = 100 * 10 = 1000`\n- 현재 상태: `m.a = 1000`, `m.b = 0`\n\n3. **m.b 값 설정:**\n- `m.b = m.a` → `m.b = 1000`\n- 현재 상태: `m.a = 1000`, `m.b = 1000`\n\n4. **func2(m) 호출:**\n- `m.a += m.b` → `m.a = 1000 + 1000 = 2000`\n- 현재 상태: `m.a = 2000`, `m.b = 1000`\n\n5. **출력:**\n- `System.out.printf(\"%d\", m.a)` → **2000**핵심 포인트:**\n- Java에서 객체는 참조로 전달되므로, 메서드 내에서 객체의 필드를 변경하면 원본 객체도 변경됩니다.\n- `m.a *= 10`은 `m.a = m.a * 10`과 같습니다.\n\n**답:**2000**", "table_refs": [], "image_refs": ["images/2022_round1/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:26:37.850116"}, "code_blocks": [{"language": "java", "code": "class A {\n  int a;\n  int b;\n}\n  public class Main {\n  static void func1(A m){\n   m.a *= 10;\n  }\n  static void func2(A m){\n    m.a += m.b;\n  }\n  public static void main(String args[]){\n  A m = new A();\n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  System.out.printf(\"%d\", m.a);\n  }\n}", "line_numbers": [1, 20], "file": "data/codes/2022_round1/Q003_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 SQL 결과에 알맞는 쿼리을 작성하시오.\nSELECT name, score FROM 성적\n\n(1) BY ( 2 ) ( 3 )", "choices": [], "answer": {"keys": ["1) ORDER", "2) score", "3) DESC"], "raw_text": "1) ORDER 2) score 3) DESC"}, "explanation": "이 문제는 **SQL ORDER BY 절**을 작성하는 문제입니다.\n\n**쿼리 분석:**\n```sql SELECT name, score FROM 성적\n(1) BY (2) (3)\n```\n\n**문제에서 요구하는 것:**\n- 결과를 점수(score) 기준으로 내림차순 정렬\n- ORDER BY 절 작성\n\n**ORDER BY 절:**\n- `ORDER BY 컬럼명 [ASC|DESC]`\n- `ASC`: 오름차순 (기본값, 생략 가능)\n- `DESC`: 내림차순\n\n**정답:**\n```sql SELECT name, score FROM 성적 ORDER BY score DESC\n```\n\n**빈칸 채우기:**\n- (1) **ORDER**: ORDER BY 절 시작\n- (2) **score**: 정렬할 컬럼명\n- (3) **DESC**: 내림차순 정렬\n\n**실행 결과:**\n점수가 높은 순서대로 학생 이름과 점수가 출력됩니다.\n\n**답:**\n- 1) **ORDER**\n- 2) **score**\n- 3) **DESC**", "table_refs": [{"id": "table1", "json": "data/tables/2022_round1/Q004_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2022_round1/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "데이터베이스의 이상현상 중, 삭제 이상에 대해 서술하시오.", "choices": [], "answer": {"keys": ["삭제 이상"], "raw_text": "삭제 이상"}, "explanation": "이 문제는 데이터베이스의 **삭제 이상(Deletion Anomaly)**에 대한 문제입니다.\n\n**삭제 이상이란?**\n- 데이터를 삭제할 때 **의도치 않은 다른 데이터도 함께 삭제**되는 이상 현상\n- 정규화되지 않은 테이블에서 발생하는 문제점 중 하나\n\n**삭제 이상의 예시:**\n\n예를 들어, 학생-과목 테이블에서:\n| 학번 | 이름 | 과목코드 | 과목명 |\n|------|------|----------|--------|\n| 001 | 김철수 | C101 | 데이터베이스 |\n| 001 | 김철수 | C102 | 운영체제 |\n| 002 | 이영희 | C101 | 데이터베이스 |\n\n만약 이영희가 데이터베이스 과목을 취소(삭제)하면:\n- 이영희의 행이 삭제됨\n- **문제**: C101(데이터베이스) 과목 정보도 함께 사라질 수 있음\n- 만약 C101을 듣는 학생이 이영희뿐이었다면, 과목 정보 자체가 삭제됨\n\n**해결 방법:**\n- 정규화를 통해 테이블을 분리\n- 학생 테이블, 과목 테이블, 수강 테이블로 분리\n\n**다른 이상 현상:**\n- **삽입 이상**: 데이터 삽입 시 불필요한 데이터도 함께 삽입해야 함\n- **갱신 이상**: 데이터 수정 시 여러 곳을 수정해야 하거나 일관성 문제 발생\n\n**답:**삭제 이상**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 파이썬 코드에서 출력되는 a와 b의 값을 작성하시오.", "choices": [], "answer": {"keys": ["a= 20 b= 2"], "raw_text": "a= 20 b= 2"}, "explanation": "이 파이썬 코드는 **함수의 기본값 매개변수(Default Parameter)**를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```python def exam(num1, num2=2):\nprint('a=', num1, 'b=', num2)\n\nexam(20)\n```\n\n**실행 과정:**\n\n1. **함수 정의:**\n- `exam(num1, num2=2)`: `num1`은 필수 매개변수, `num2`는 기본값이 2로 설정된 선택적 매개변수입니다.\n\n2. **함수 호출:**\n- `exam(20)`: 첫 번째 인자 20만 전달\n- `num1 = 20` (전달된 값)\n- `num2 = 2` (기본값 사용, 인자 미전달)\n\n3. **출력:**\n- `print('a=', 20, 'b=', 2)`\n- **출력: \"a= 20 b= 2\"**핵심 포인트:**\n- 기본값이 설정된 매개변수는 함수 호출 시 인자를 생략하면 기본값이 사용됩니다.\n- 여기서는 `num2`에 값을 전달하지 않았으므로 기본값 2가 사용되었습니다.\n\n**답:**a= 20 b= 2**", "table_refs": [], "image_refs": ["images/2022_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [{"language": "python", "code": "def exam(num1, num2=2):\n  print('a=', num1, 'b=', num2)\nexam(20)", "line_numbers": [1, 3], "file": "data/codes/2022_round1/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 설명과 관련된 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, remove, sort 등..))\n\n1. 요소를 확장해준다는 의미를 가지고 있으며, 모든 항목을 하나의 요소로 추가\n\n2. 리스트 내부 요소를 꺼내주는 함수로써, 그 요소는 리스트 안에서 삭제하고 그 값을 반환\n\n3. 리스트 내부의 요소의 순서는 뒤집는 역할", "choices": [], "answer": {"keys": ["1) extend", "2) pop", "3) reverse"], "raw_text": "1) extend 2) pop 3) reverse"}, "explanation": "이 문제는 파이썬 **리스트 메서드**의 기능을 이해하는 문제입니다.\n\n**각 메서드의 기능:**\n\n1. **`extend(iterable)`:**\n- 요소를 확장해준다는 의미\n- 반복 가능한 객체(리스트, 튜플 등)의 모든 항목을 하나씩 추가\n- 예: `[1, 2].extend([3, 4])` → `[1, 2, 3, 4]`\n- `append()`와 차이: `append([3, 4])`는 `[1, 2, [3, 4]]`가 됨\n\n2. **`pop([index])`:**\n- 리스트 내부 요소를 꺼내주는 함수\n- 해당 요소는 리스트에서 삭제하고 그 값을 반환\n- 인덱스를 지정하지 않으면 마지막 요소를 반환\n- 예: `[1, 2, 3].pop()` → `3` 반환, 리스트는 `[1, 2]`가 됨\n\n3. **`reverse()`:**\n- 리스트 내부 요소의 순서를 뒤집는 역할\n- 원본 리스트를 직접 수정 (반환값 없음)\n- 예: `[1, 2, 3].reverse()` → 리스트가 `[3, 2, 1]`로 변경\n\n**답:**\n- (1) **extend**\n- (2) **pop**\n- (3) **reverse**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["알고리즘"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 아래 단어를 영어 약자로 작성하시오.\n임시 키 무결성 프로토콜", "choices": [], "answer": {"keys": ["TKIP"], "raw_text": "TKIP"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음 아래 단어를 영어 약자로 작성하시오.\n임시 키 무결성 프로토콜...\n\n**핵심 특징:**\n- 임시 키 무결성 프로토콜\n\n**답이 \"TKIP\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"TKIP\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["네트워크"], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 중, 설명에 대한 답을 영어 약자로 작성하시오.\n키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경", "choices": [], "answer": {"keys": ["NUI"], "raw_text": "NUI"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 중, 설명에 대한 답을 영어 약자로 작성하시오.\n키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경...\n\n**답이 \"NUI\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"NUI\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 분석도구에 대한 설명으로 보기에 알맞는 답을 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, running analysis 등..))\n\n1. 소스 코드의 실행 없이, 코드의 의미를 분석해 결함을 찾아내는 원시적 코드 분석 기법\n\n2. 소스 코드를 실행하여 프로그램 동작이나 반응을 추적하고 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석", "choices": [], "answer": {"keys": ["1) static", "2) dynamic"], "raw_text": "1) static 2) dynamic"}, "explanation": "이 문제는 소프트웨어 **코드 분석 도구**의 종류를 묻는 문제입니다.\n\n**정적 분석 (Static Analysis):**\n\n1. **특징:**\n- 소스 코드의 실행 없이 코드의 의미를 분석\n- 코드 자체를 읽어서 결함을 찾아내는 원시적 코드 분석 기법\n- 컴파일 타임에 수행\n\n2. **장점:**\n- 실행 환경이 필요 없음\n- 빠른 분석 가능\n- 모든 코드 경로 분석 가능\n\n3. **예시 도구:**\n- SonarQube, ESLint, Pylint 등\n\n**동적 분석 (Dynamic Analysis):**\n\n1. **특징:**\n- 소스 코드를 실행하여 프로그램 동작이나 반응을 추적\n- 실행 중에 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석\n- 런타임에 수행\n\n2. **장점:**\n- 실제 실행 환경에서 문제 발견 가능\n- 성능 문제, 메모리 누수 등 실제 동작 문제 발견\n\n3. **예시 도구:**\n- Valgrind, JProfiler, Chrome DevTools 등\n\n**답:**\n- (1) **static**\n- (2) **dynamic**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 Java 코드 중에서 밑줄에 들어갈 알맞는 코드를 작성하시오.", "choices": [], "answer": {"keys": ["Car"], "raw_text": "Car"}, "explanation": "이 Java 코드는 **Thread 클래스의 생성자**와 **Runnable 인터페이스 구현**을 이해하는 문제입니다.\n\n**코드 분석:**\n```java class Car implements Runnable{\nint a;\npublic void run(){\nsystem.out.println(\"message\")\n}\n}\npublic class Main{\npublic static void main(String args[]){\nThread t1 = new Thread(new ___());\nt1.start();\n}\n}\n```\n\n**문제 해결:**\n\n1. **Thread 생성자:**\n- `Thread(Runnable target)`: Runnable 인터페이스를 구현한 객체를 받음\n- `new Thread(new Car())` 형식으로 호출\n\n2. **Runnable 인터페이스:**\n- `Car` 클래스가 `implements Runnable`로 구현\n- `run()` 메서드를 구현하여 스레드가 실행할 작업 정의\n\n3. **빈칸에 들어갈 코드:**\n- `new Thread(new Car())` → 빈칸은 **Car**\n- `Car` 클래스의 인스턴스를 생성하여 Thread 생성자에 전달\n\n4. **실행 흐름:**\n- `t1.start()` 호출 → 새 스레드 시작\n- `Car` 클래스의 `run()` 메서드 실행\n- \"message\" 출력\n\n**핵심 포인트:**\n- Thread는 Runnable 인터페이스를 구현한 객체를 받아 실행합니다.\n- `start()` 메서드로 스레드를 시작하면 `run()` 메서드가 자동 실행됩니다.\n\n**답:**Car**", "table_refs": [], "image_refs": ["images/2022_round1/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [{"language": "java", "code": "class Car implements Runnable{\n  int a;\n  public void run(){\n     system.out.println(\"message\")\n  }\n}\npublic class Main{\n  public static void main(String args[]){\n    Thread t1 = new Thread(new ___());\n    t1.start();\n  }\n}", "line_numbers": [1, 12], "file": "data/codes/2022_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 설명에 대한 알맞는 단어를 작성하시오.\n자바 프로그래밍 언어를 이용한 xUnit의 테스트 기법으로써 숨겨진 단위 테스트를 끌어내어 정형화시켜 단위 테스트를 쉽게 해주는 테스트용 Framework이다.", "choices": [], "answer": {"keys": ["JUnit"], "raw_text": "JUnit"}, "explanation": "이 문제는 Java 테스트 프레임워크인 **JUnit**에 대한 문제입니다.\n\n**JUnit이란?**\n- Java 프로그래밍 언어를 이용한 xUnit 테스트 기법\n- 숨겨진 단위 테스트를 끌어내어 정형화시켜 단위 테스트를 쉽게 해주는 테스트용 Framework\n\n**JUnit의 특징:**\n1. **단위 테스트 자동화:**\n- 각 메서드나 클래스의 기능을 개별적으로 테스트\n- 테스트 케이스를 자동으로 실행하고 결과를 확인\n\n2. **정형화된 테스트:**\n- `@Test` 어노테이션으로 테스트 메서드 표시\n- `assertEquals()`, `assertTrue()` 등으로 검증\n\n3. **xUnit 패턴:**\n- 여러 언어로 포팅된 테스트 프레임워크 패턴\n- Java용은 JUnit, Python용은 PyUnit, C#용은 NUnit 등\n\n**예시:**\n```java\n@Test public void testAddition() {\nassertEquals(5, calculator.add(2, 3));\n}\n```\n\n**답:**JUnit**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.851115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["소프트웨어공학"], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 보기 중에서 블랙박스 테스트 기법을 3가지 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄷ", "ㄹ", "ㅂ"], "raw_text": "ㄷ\nㄹ\nㅂ"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 선택하는 문제입니다.\n\n**블랙박스 테스트란?**\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n**블랙박스 테스트 기법 종류:**\n\n1. **동치 분할 (Equivalence Partitioning):**\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. **경계값 분석 (Boundary Value Analysis):**\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. **원인-효과 그래프 (Cause-Effect Graphing):**\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. **오류 예측 (Error Guessing):**\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. **비교 검사 (Comparison Testing):**\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n**문제에서 요구하는 기법:**\n- 보기에서 블랙박스 테스트 기법 3가지를 선택해야 합니다.\n\n**답:**ㄷ, ㄹ, ㅂ** (보기에 나열된 블랙박스 테스트 기법 3개)", "table_refs": [], "image_refs": ["images/2022_round1/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 소스코드에서 입력값이 5가 들어왔을때 출력되는 값을 작성하시오.", "choices": [], "answer": {"keys": ["120"], "raw_text": "120"}, "explanation": "이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.\n\n**팩토리얼이란?**\n- n! = n × (n-1) × (n-2) × ... × 2 × 1\n- 예: 5! = 5 × 4 × 3 × 2 × 1 = 120\n\n**코드 실행 단계:**\n\n```c int func(int a) {\nif (a <= 1) return 1; // 기저 조건 return a * func(a - 1); // 재귀 호출\n}\n```\n\n**입력값이 5일 때:**\n\n1. **`func(5)` 호출:**\n- 5 <= 1? 아니오 → `return 5 * func(4)`\n\n2. **`func(4)` 호출:**\n- 4 <= 1? 아니오 → `return 4 * func(3)`\n\n3. **`func(3)` 호출:**\n- 3 <= 1? 아니오 → `return 3 * func(2)`\n\n4. **`func(2)` 호출:**\n- 2 <= 1? 아니오 → `return 2 * func(1)`\n\n5. **`func(1)` 호출:**\n- 1 <= 1? 예 → `return 1` (기저 조건)\n\n6. **값 반환 과정:**\n- `func(1)` = 1\n- `func(2)` = 2 × 1 = 2\n- `func(3)` = 3 × 2 = 6\n- `func(4)` = 4 × 6 = 24\n- `func(5)` = 5 × 24 = **120**최종 출력:**120**핵심 포인트:**\n- 재귀 함수는 자기 자신을 호출하여 문제를 해결합니다.\n- 기저 조건(`a <= 1`)에서 재귀가 종료됩니다.", "table_refs": [], "image_refs": ["images/2022_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint func(int a) {\n  if (a <= 1) return 1;\n  return a * func(a - 1);\n}\nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  printf(\"%d\", func(a));\n}", "line_numbers": [1, 10], "file": "data/codes/2022_round1/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 중, 괄호 ( ) 안에 들어갈 연산자를 써서 정수를 역순으로 출력하는 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1) >", "2) %", "3) /"], "raw_text": "1) >\n2) %\n3) /"}, "explanation": "이 C언어 코드는 **정수를 역순으로 출력**하는 문제입니다.\n\n**코드 분석:**\n\n```c int number = 1234;\nint div = 10;\nint result = 0;\nwhile (number (1) 0) {\nresult = result * div;\nresult = result + number (2) div;\nnumber = number (3) div;\n}\n```\n\n**목표:**\n- 입력: 1234\n- 출력: 4321\n\n**빈칸 분석:**\n\n1. **`while (number (1) 0)`:**\n- 반복 조건: `number`가 0보다 큰 동안 반복\n- `(1)` = **>** (크다)\n\n2. **`number (2) div`:**\n- 마지막 자릿수를 구하기 위해 나머지 연산 필요\n- `number % div` = 일의 자리 숫자\n- `(2)` = **%** (나머지)\n\n3. **`number = number (3) div`:**\n- 마지막 자릿수를 제거하기 위해 나누기 연산 필요\n- `number / div` = 마지막 자릿수 제거\n- `(3)` = **/** (나누기)\n\n**실행 과정 (number = 1234):**\n\n| 반복 | number | result | 설명 |\n|------|--------|--------|------|\n| 초기 | 1234 | 0 | - |\n| 1 | 123 | 4 | result = 0*10 + 1234%10 = 4, number = 1234/10 = 123 |\n| 2 | 12 | 43 | result = 4*10 + 123%10 = 43, number = 123/10 = 12 |\n| 3 | 1 | 432 | result = 43*10 + 12%10 = 432, number = 12/10 = 1 |\n| 4 | 0 | 4321 | result = 432*10 + 1%10 = 4321, number = 1/10 = 0 |\n\n**최종 출력:**4321**답:**\n- (1) **>**\n- (2) **%**\n- (3) **/**", "table_refs": [], "image_refs": ["images/2022_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n  int number = 1234;\n  int div = 10;\n  int result = 0;\n  while (number ( 1 ) 0) {\n    result = result * div;\n    result = result + number ( 2 ) div;\n    number = number ( 3 ) div;\n  }\n  printf(\"%d\", result);return 0;\n}", "line_numbers": [1, 12], "file": "data/codes/2022_round1/Q015_code.txt"}], "primary_category": "기타", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 설명에 대한 답을 영어 약자로 작성하시오.\n정보보호 관리체계의 영문 약자", "choices": [], "answer": {"keys": ["ISMS (Information Security Management System)"], "raw_text": "ISMS (Information Security Management System)"}, "explanation": "이 문제는 정보보안 관리체계인 **ISMS**에 대한 문제입니다.\n\n**ISMS란?**\n- **Information Security Management System**의 약자\n- 정보보안 관리체계\n\n**ISMS의 목적:**\n- 조직의 정보자산을 보호하기 위한 체계적인 관리 시스템\n- 정보보안 위험을 관리하고 통제\n\n**ISMS 인증:**\n- 한국인터넷진흥원(KISA)에서 시행하는 정보보안 관리체계 인증\n- ISO/IEC 27001 국제표준 기반\n\n**답:**ISMS (Information Security Management System)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 설명 중, 괄호 ( ) 안에 들어가는 알맞는 답을 보기에서 선택하여 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, 참조성, 무결성 등..))\n\n1. 슈퍼키는\n\n(1) 의 속성을 갖는다.", "choices": [], "answer": {"keys": ["1) 유일성", "2) 최소성"], "raw_text": "1) 유일성 2) 최소성"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 설명 중, 괄호 ( ) 안에 들어가는 알맞는 답을 보기에서 선택하여 작성하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, 참조성, 무결성 등..))\n\n1. 슈퍼키는\n\n(1) 의 속성을 갖는다....\n\n**답이 \"1) 유일성, 2) 최소성\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"1) 유일성, 2) 최소성\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "후보키는\n\n(1) 와/과 ( 2 ) 의 속성을 갖는다.", "choices": [], "answer": {"keys": ["watering hole (워터링홀)"], "raw_text": "watering hole (워터링홀)"}, "explanation": "이 문제는 데이터베이스 **트랜잭션의 복구 기법**에 대한 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n1. **오류가 발생하기 전까지의 사항을 로그로 기록해 놓고, 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 현상**\n- 이것은 **REDO (재실행)**입니다.\n- 트랜잭션이 커밋된 후 갱신 사항이 데이터베이스에 반영되지 못한 경우\n- 로그 파일의 기록을 이용하여 다시 실행하는 복구 방법\n\n2. **작업을 취소하여 트랜잭션을 이전 상태로 되돌리는 것**\n- 이것은 **UNDO (취소)**입니다.\n- 트랜잭션이 롤백될 때 변경 사항을 취소하는 복구 방법\n- 변경 전 값으로 복원\n\n**REDO와 UNDO의 차이:**\n\n| 구분 | UNDO | REDO |\n|------|------|------|\n| 목적 | 트랜잭션 취소 | 트랜잭션 재실행 |\n| 시점 | 롤백 시 | 커밋 후 미반영 시 |\n| 방향 | 과거로 되돌림 | 앞으로 진행 |\n| 로그 | Before Image 사용 | After Image 사용 |\n\n**답:**\n- 1) **redo** (재실행)\n- 2) **undo** (취소)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:24:50.874959", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음 설명과 관련된 답을 보기에 찾아서 작서하시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Pharming, Ransomware등..))\n이 공격은 APT 공격에서 주로 쓰이는 공격으로, 공격 대상이 방문할 가능성이 있는 합법적인 웹 사이트를 미리 감염시킨 뒤, 잠복하고 있다가 공격 대상이 방문하면 대상의 컴퓨터에 악성코드를 설치하는 방식", "choices": [], "answer": {"keys": ["29"], "raw_text": "29"}, "explanation": "이 문제는 **워터링홀(Watering Hole) 공격**에 대한 문제입니다.\n\n**워터링홀 공격이란?**\n- APT(Advanced Persistent Threat) 공격에서 주로 사용되는 공격 기법\n- 공격 대상이 방문할 가능성이 있는 합법적인 웹 사이트를 미리 감염시킴\n- 잠복하고 있다가 공격 대상이 방문하면 대상의 컴퓨터에 악성코드를 설치\n\n**워터링홀 공격의 특징:**\n\n1. **타겟팅:**\n- 특정 그룹이나 조직이 자주 방문하는 합법적인 웹사이트를 선택\n\n2. **감염:**\n- 선택한 웹사이트를 악성코드로 감염시킴\n\n3. **잠복:**\n- 공격 대상이 방문할 때까지 대기\n\n4. **자동 설치:**\n- 방문 시 드라이브바이 다운로드(Drive-by Download)로 악성코드 자동 설치\n\n**다른 공격과의 차이:**\n- 피싱: 이메일 등으로 직접 공격\n- 워터링홀: 합법적 사이트를 경유하여 간접 공격\n\n**답:**watering hole (워터링홀)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h> \nint isPrime(int number) { \n  int i; \n  for (i=2; i<number; i++) { \n    if (number % i == 0) return 0; \n  } \n  return 1; \n} \nint main(void) { \n  int number = 13195, max_div=0, i; \n  for (i=2; i<number; i++) \n  if (isPrime(i) == 1 && number % i == 0) max_div = i; \n  printf(\"%d\", max_div); \n  return 0; \n}", "line_numbers": [1, 15], "file": "data/codes/2022_round1/Q018_code.txt"}], "primary_category": "정보보안", "secondary_categories": ["프로그래밍"], "tags": ["c", "해킹"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 소스코드가 실행할 때의 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1) 단위 테스트", "2) 통합 테스트", "3) 시스템 테스트"], "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"}, "explanation": "4) 인수 테스트", "table_refs": [], "image_refs": ["images/2022_round1/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 V모델에서의 테스트 단계에 대한 설명으로 괄호 안에 들어갈 답을 작성하시오.", "choices": [], "answer": {"keys": ["1) 단위 테스트", "2) 통합 테스트", "3) 시스템 테스트"], "raw_text": "1) 단위 테스트 2) 통합 테스트 3) 시스템 테스트"}, "explanation": "(답안 제공되지 않음)", "table_refs": [], "image_refs": ["images/2022_round1/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/271", "crawled_at": "2025-11-03T00:05:11.186697", "last_improved": "2025-11-04T00:15:55.922491", "readability_improved": "2025-11-04T00:26:37.852120"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 관계 데이터 모델에 대한 설명이다.\n괄호 안에 들어가는 용어를 작성하시오.\n( )은 /는 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용한다.\n수학의 predicate calculus에 기반을 두고 있으며\n,\n관계 데이터 모델의 제안자인 codd가 수학에 가까운 기반을 두고 특별히 관계 데이터베이스를 위해 제안하여 탄생하였다.\n( ) /은/는 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 튜블 ( )와/과 도메인 ( ) 이/가 있다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "(문제19-1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 대칭 키 알고리즘에 대한 설명이다.\n해당 설명에 맞는 용어를 보기에 골라 작성하시오.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "(문제19-2)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "Xuejia Lai와 James Messey 가 만든 알고리즘으로 PES(Proposed Encryption Standard)에서 IPES(Improved PES)로 변경되었다가, 1991년에 제작된 블록 암호 알고리즘으로 현재 국제 데이터 암호화 알고리즘으로 사용되고 있다. 64비트 블록을 128비트의 key를 이용하여 8개의 라운드로 구성되어 있다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "(문제19-1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["네트워크"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "미국의 NSA에서 개발한 Clipper 칩에 내장되는 블록 알고리즘이다. 전화기와 같은 음성을 암호화 하는데 주로 사용되며 64비트 입출력에 80비트의 키 총 32라운드를 가진다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "(문제19-2)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["네트워크", "정보보안"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "H회사의 전체 제품 단가 보다 큰 제품 출력을 하고자 한다. 괄호 안에 들어갈 알맞는 용어를 작성하시오.\nSELECT 제조사, 제품명, 단가 FROM 제품 WHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사='H')", "choices": [], "answer": {"keys": ["HTML"], "raw_text": "HTML"}, "explanation": "(문제19-3)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 SQL 결과에 알맞는 답을 작성하시오.\nSELECT count(col2)\nFROM TABLE WHERE col1 in(2,3) or col2 in(3,5);", "choices": [], "answer": {"keys": ["BGP"], "raw_text": "BGP"}, "explanation": "(문제14-4)", "table_refs": [], "image_refs": ["images/2022_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 네트워크에 관련한 내용이다.\n괄호 안에 들어갈 알맞는 답을 작성하시오.\n( )은/는 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하며, 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.\n또한 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.", "choices": [], "answer": {"keys": ["VPN"], "raw_text": "VPN"}, "explanation": "이 문제는 네트워크 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"VPN\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 SOLID 원칙에 관한 내용이다.\n괄호 안에 알맞는 단어를 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nSRP\n,\nLSP 등..))\n( ) 은/는 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.\n( ) 은/는 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.\n예를 들어 하나의 복합기에 프린터와 복사기, 팩스 메서드가 있는데 이 세가지 메서드는 같은 파일에 존재하므로 프린터 로직만 바뀌어도 복사기와 팩스도 재컴파일을 해야한다.\n그러므로 ( ) 을/를 적용하여 로직이 바뀌어도 다른 메서드는 영향을 받지 않도록 해야한다.", "choices": [], "answer": {"keys": ["ISP"], "raw_text": "ISP"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"ISP\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 자바 코드에 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["-8"], "raw_text": "-8"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"-8\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round2/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 소스코드에 대한 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"2\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round2/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "IP 주소가 139.127.19.132이고 서브넷마스크 255.255.255.192일 때 아래의 답을 작성하시오.\n(10진수로 표기)\n\n(1) 괄호 안에 들어갈 네트워크 주소 : 139.127.19.( )\n(2) 해당 네트워크 주소와 브로드캐스트 주소를 제외한 호스트 개수", "choices": [], "answer": {"keys": ["1) 128", "2) 62"], "raw_text": "1) 128 2) 62"}, "explanation": "이 문제는 네트워크 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"1) 128, 2) 62\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.884249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 설명에 대한 괄호 안에 알맞는 단어를 작성하시오.", "choices": [], "answer": {"keys": ["1) 베타", "2) 알파"], "raw_text": "1) 베타 2) 알파"}, "explanation": "(문제10은 소문제 1-2로 분리됨)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "( ) 테스트는 하드웨어나 소프트웨어의 개발 단계에서 상용화하기 전에 실시하는 제품 검사 작업. 제품의 결함 여부, 제품으로서의 가치 등을 평가하기 위해 실시한다. 선발된 잠재 고객으로 하여금 일정 기간 무료로 사용하게 한 후에 나타난 여러 가지 오류를 수정, 보완한다. 공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업이다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "(문제19-1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.856111"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "( ) 테스트는 새로운 제품 개발 과정에서 이루어지는 첫 번째 테스트. 즉, 시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 초기 작동의 결과를 평가하는 수단이며 개발 회사 내부에서 이루어지는 테스트로서 단위 테스트, 구성 테스트, 시스템 테스트 등을 포함한다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "(문제19-2)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 설명에 알맞는 테스트 용어를 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Iterating등..))\n오류를 제거하거나 수정한 시스템이나 시스템 컴포넌트 또는 프로그램이 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지를 확인하는 일종의 반복 시험이다.\n반복적인 시험이 필요한 이유는 오류가 제거·수정되는 상당수의 시스템이 의도치 않았던 오동작이나 새로운 형태의 오류를 일으키기 때문이다.\n결국, 수정·변경된 시스템이나 시스템 컴포넌트 또는 프로그램이 명세된 요구 사항을 충족시키는지를 확인하는 시험의 한 형태이다.", "choices": [], "answer": {"keys": ["Regression"], "raw_text": "Regression"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 설명에 알맞는 테스트 용어를 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, Iterating등..))\n오류를 제거하거나 수정한 시스템이나 시스템 컴포넌트 또는 프로그램이 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지를 확인하는 일종의 반복 시험이다.\n반복적인 시험이 필요한 이유는 오류가 제거·수정되는 상당수의 시스템이 의도치 않았던 오동작이나 새로운 형태의 오류를 일으키기 때문이다.\n결국, 수정·변경된 시스템이나 시스템 컴포넌트 또는 프로그램이 명세된 요구 사항을 충족시키는지를 확...\n\n**답이 \"Regression\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"Regression\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]", "choices": [], "answer": {"keys": ["TTL", "부장", "대리"], "raw_text": "TTL 부장 대리"}, "explanation": "(해설: 과장 차장도 포함)", "table_refs": [], "image_refs": ["images/2022_round2/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 파이썬 코드이다.\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["REMEMBER AND STR"], "raw_text": "REMEMBER AND STR"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"REMEMBER AND STR\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round2/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 설명에 대해 보기에 주어진 답을 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ARP, RARP 등..))", "choices": [], "answer": {"keys": ["1. IGP / 2. EGP / 3. OSPF / 4. BGP"], "raw_text": "1. IGP / 2. EGP / 3. OSPF / 4. BGP"}, "explanation": "(문제14는 소문제 1-4로 분리됨)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다.\n같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "(문제19-1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜로써,\n다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "(문제19-2)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다.\n규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜로써 RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다.", "choices": [], "answer": {"keys": ["HTML"], "raw_text": "HTML"}, "explanation": "(문제19-3)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅", "TCP/IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환하는 데 사용되는 외부 게이트웨이 프로토콜(EGP)이다.\n각 목적지에 대한 전체 경로가 포함되며, 다른 시스템과 교환하는 네트워크 도달 가능성 정보의 데이터베이스를 유지한다.\n네트워크 도달 가능성 정보를 사용하여 AS 연결 그래프를 구성하며, 이를 통해 라우팅 루프를 제거하고 AS 수준에서 정책 결정을 실행할 수 있다.", "choices": [], "answer": {"keys": ["BGP"], "raw_text": "BGP"}, "explanation": "(문제14-4)", "table_refs": [], "image_refs": ["images/2022_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 C언어에서 출력에 대한 알맞은 답을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 C언어 코드 문제는 변수의 값 변화와 연산 과정을 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **변수 초기화**: C언어에서 변수는 선언 시 초기화되지 않으면 쓰레기 값을 가질 수 있습니다. 명시적 초기화를 확인합니다.\n\n2. **연산 수행**:\n- 산술 연산: +, -, *, /, % (나머지)\n- 비트 연산: << (왼쪽 시프트), >> (오른쪽 시프트), & (AND), | (OR), ^ (XOR)\n- 논리 연산: && (AND), || (OR), ! (NOT)\n- 각 연산의 결과를 단계별로 계산합니다.\n\n3. **반복문/조건문**: for, while, if 등의 실행 흐름을 따라가며 각 단계에서의 변수 값 변화를 확인합니다.\n\n4. **출력 형식**: printf 함수의 형식 지정자(%d: 정수, %c: 문자, %s: 문자열 등)를 확인하여 출력 형식을 이해합니다.\n\n5. **최종 결과**: 모든 연산을 완료한 후 최종 출력값 10을 계산합니다.\n\n**핵심 포인트**: C언어는 연산자 우선순위와 형 변환을 정확히 이해해야 하며, 변수 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2022_round2/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint len(char*p);\nint main(){\n  char* p1 = \"2022\";\n  char* p2 = \"202207\";  \n  int a = len(p1);\n  int b = len(p2);\n  printf(\"%d\", a + b);\n}\nint len(char* p){\n  int r = 0;\n  while(*p != '\\0'){\n    p++;\n    r++;\n }\n return r;\n}", "line_numbers": [1, 17], "file": "data/codes/2022_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 C언어 코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["22"], "raw_text": "22"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"22\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round2/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 자바코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["61"], "raw_text": "61"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"61\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round2/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 함수 종속성에 대한 설명이다.\n해당 문제에 대한 알맞는 답을 보기에서 골라 작성하시오.\n\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중,\nunion 등..))", "choices": [], "answer": {"keys": ["1. Full", "2. Partial", "3. Transitive"], "raw_text": "1. Full 2. Partial 3. Transitive"}, "explanation": "(문제18은 소문제 1-3으로 분리됨)", "table_refs": [], "image_refs": ["images/2022_round2/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": ["프로그래밍", "데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "성적은 {학생,학과}에 대해서 ( ) Functional Dependency이다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "(문제19-1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "성적은 학과만 알아도 식별이 가능하므로, 이 경우에는 성적 속성은 기본키에 ( ) Functional Dependency이다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "(문제19-2)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 경우", "choices": [], "answer": {"keys": ["HTML"], "raw_text": "HTML"}, "explanation": "(문제19-3)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.857111"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 설명에 대한 알맞는 답을 보기에서 고르시오.\n(실제 기출문제에서는 답의 보기가 주어집니다.(오답 중, ajax, 등..))", "choices": [], "answer": {"keys": ["1. HTTP", "2. Hypertext", "3. HTML"], "raw_text": "1. HTTP 2. Hypertext 3. HTML"}, "explanation": "(문제19는 소문제 1-3으로 분리됨)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.858107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "인터넷에서, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 규약을 말한다.\n인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다.\n이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.", "choices": [], "answer": {"keys": ["HTTP"], "raw_text": "HTTP"}, "explanation": "(문제19-1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.858107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결시켜, 제시된 순서에 관계없이 이용자가 관련된 정보를 검색할 수 있도록 하는 정보 제공 방법이다.\n즉, 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 클릭함으로써 원하는 정보에 쉽게 접근하는 방식을 말한다.", "choices": [], "answer": {"keys": ["Hypertext"], "raw_text": "Hypertext"}, "explanation": "(문제19-2)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.858107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "웹 페이지 표시를 위해 개발된 지배적인 마크업 언어다.\n또한, 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.", "choices": [], "answer": {"keys": ["HTML"], "raw_text": "HTML"}, "explanation": "(문제19-3)", "table_refs": [], "image_refs": ["images/2022_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.858107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 모듈 F에 대한 Fan-in과 Fan-out을 작성하시오.", "choices": [], "answer": {"keys": ["Fan-in : 3", "Fan-out : 2"], "raw_text": "Fan-in : 3 Fan-out : 2"}, "explanation": "이 문제는 기타 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"Fan-in : 3, Fan-out : 2\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round2/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/423", "crawled_at": "2025-11-02T23:28:04.885249", "last_improved": "2025-11-04T00:15:55.925490", "readability_improved": "2025-11-04T00:26:37.858107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "아래는 C언어의 2차원 배열 형태이다.\nfield의 경우 2차원 배열 형태는 예시처럼 출력되므로, 이를 참고하여\n\nmines의 2차원 배열 형태를 작성하시오.", "choices": [], "answer": {"keys": ["1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3"], "raw_text": "1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"1 3 2 / 3 4 5 3 / 3 5 6 4 / 3 5 3\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/1-1.png", "images/2022_round3/1-2.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["자료구조"], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "아래 예시를 보고\n\n관계 대수에 대한 기호를 작성하시오.", "choices": [], "answer": {"keys": ["U", "-", "X π ⋈"], "raw_text": "U\n-\nX π ⋈"}, "explanation": "이 문제는 기타 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"U, -, X π ⋈\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 디자인 패턴에 대한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(기호식 보기가 있습니다. ex: Abstract Factory, Mediator 등)\n(   1   )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.\n구현뿐 아니라 추상화도 독립적 변경이 필요할 때 브리지 패턴을 사용한다.\n기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,\n새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.\n(   2   )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.\n일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.", "choices": [], "answer": {"keys": ["1. Bridge", "2. Observer"], "raw_text": "1. Bridge 2. Observer"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"1. Bridge, 2. Observer\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "아래 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["24513"], "raw_text": "24513"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"24513\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 코드에 대한 출력 값을 작성하시오.\n첫번째 네트워크 주소가 192.168.1.0/24일때 FLSM 3개로 분할했을때 두번째 네트워크 브로드캐스드 IP를 10진수로 변환한 값을 작성하시오.", "choices": [], "answer": {"keys": ["192.168.1.127"], "raw_text": "192.168.1.127"}, "explanation": "이 문제는 네트워크 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"192.168.1.127\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["프로그래밍"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 표를 확인하여\n\n보기에 알맞는 값을 고르시오.\n(기호식 보기가 있습니다. ex: Boundary Value Partitioning​, Equivalence Partitioning 등)", "choices": [], "answer": {"keys": ["Boundary Value Analysis"], "raw_text": "Boundary Value Analysis"}, "explanation": "이 문제는 기타 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"Boundary Value Analysis\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/6-1.png", "images/2022_round3/6-2.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 데이터 명령어를 적용할 경우 알맞는 출력값을 작성하시오.\n\n​", "choices": [], "answer": {"keys": ["(1). 3", "(2). 4"], "raw_text": "(1). 3\n(2). 4"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"(1). 3, (2). 4\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 설명에 대한 알맞는 답을 작성하시오.\n(     1     ) 은/는 보안학적 측면에서 기술적인 방법이 아닌 사람들간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법이다.\n(     2     ) 은/는  빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, 더는 사용하지 않는 ‘죽은’ 데이터를 의미한다. 일반적으로 정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니며,  저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다.", "choices": [], "answer": {"keys": ["1. 사회공학", "2. 다크 데이터"], "raw_text": "1. 사회공학 2. 다크 데이터"}, "explanation": "이 문제는 정보보안 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"1. 사회공학, 2. 다크 데이터\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 파이썬 코드에 대한 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["[101 102 103 104 105]"], "raw_text": "[101 102 103 104 105]"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"[101 102 103 104 105]\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.861107"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 보안 관련 설명으로 가장 알맞는 용어를  작성하시오.\n(          )  은/는 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.\n서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 미리 감지할 수 있다.", "choices": [], "answer": {"keys": ["SIEM"], "raw_text": "SIEM"}, "explanation": "이 문제는 정보보안 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"SIEM\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.927811", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스", "네트워크"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 보기 중, 형상 관리 항목을 3가지 고르시오.", "choices": [], "answer": {"keys": ["CVS", "SVN", "GIT"], "raw_text": "CVS SVN GIT"}, "explanation": "이 문제는 기타 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"CVS, SVN, GIT\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "STUDENT 테이블에서 컴퓨터과 학생 50명, 전기과 학생 100명, 인터넷과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과에 따른 튜플의 수는? (단, DEPT 칼럼은 학과명이다.\n)\n1) SELECT DERP FROM STUDENT;\n2) SELECT DISTINCT DEPT FROM STUDENT;\n3) SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '인터넷과';", "choices": [], "answer": {"keys": ["1) 200", "2) 3", "3) 1"], "raw_text": "1) 200 2) 3) 1"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 1) 200, 2) 3, 3) 1입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"2\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래 설명에 대하여 알맞는 답을 보기에서 고르시오.\n(기호식 보기가 있습니다. ex: CSRF 등)\n(   1   )은/는 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 ARM사에서 개발한 하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하는 하드웨어 기반의 보안 기술이다.\n(   2   )은/는 사용자들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 유사한 유명 도메인을 미리 등록하는 일로 URL 하이재킹(hijacking)이라고도 한다.", "choices": [], "answer": {"keys": ["1. Trustzone", "2. typosquatting"], "raw_text": "1. Trustzone 2. typosquatting"}, "explanation": "이 문제는 정보보안 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"1. Trustzone, 2. typosquatting\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "아래 설명에 대하여 알맞는 용어를 작성하시오.\n(       )은/는 여러 개의 사이트에서 한번의 로그인으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을 말한다. 일반적으로 서로 다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 하나의 사용자 정보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하게 하는 것을 말한다.\n즉 하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고 있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.", "choices": [], "answer": {"keys": ["SSO"], "raw_text": "SSO"}, "explanation": "이 문제는 정보보안 분야의 핵심 개념을 이해하는 문제입니다.\n\n**개념 이해 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.\n\n2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.\n\n4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.\n\n**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 \"SSO\"입니다.\n\n**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 스케줄링에 관한 내용이다.\n괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["SJF", "RR", "SRT"], "raw_text": "SJF RR SRT"}, "explanation": "이 문제는 운영체제 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"SJF, RR, SRT\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 UML에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\nUML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.\n구성 요소로는 사물, (    1    ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (     2    ) 다이어그램은 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다.\n또한 UML 모델링에서 (     3    )은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는 오퍼레이션 세트를 정의하는 모델 요소이다.", "choices": [], "answer": {"keys": ["1. 관계", "2. 클래스", "3. 인터페이스"], "raw_text": "1. 관계 2. 클래스 3. 인터페이스"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"1. 관계, 2. 클래스, 3. 인터페이스\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.647126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 E-R다이어그램에 관한 설명이다.\n괄호 안에 알맞는 답을 작성하시오.\n(아래 그래프 기호는 정확히 기억이 나지 않아 임의로 작성한 것이니 참고만 해주세요.)\n(    1    )  :  개체집합 - 관계집합 연결\n(    2    )  :  개체 집합과의 연결\n(    3    )  :  관계집합 - 관계집합의 속성 연결\n(    4    )  :  두 개체집합 관계에서 생성되는 값을 저장하는 속성\n(    5    )  :  같은 속성을 공유하는 개체들의 모임", "choices": [], "answer": {"keys": ["1. 실선", "2. 관계집합", "3. 점선"], "raw_text": "1. 실선 2. 관계집합 3. 점선"}, "explanation": "4. 관계집합의 속성 5. 개체집합", "table_refs": [], "image_refs": ["images/2022_round3/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["0123"], "raw_text": "0123"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"0123\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2022_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["993"], "raw_text": "993"}, "explanation": "이 문제는 프로그래밍 분야의 핵심 개념을 이해하는 문제입니다.\n\n**문제 해석 과정:**\n\n1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다.\n\n2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.\n\n3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다.\n\n**문제 해석**: 문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 \"993\"입니다.\n\n**학습 포인트**: 이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다.", "table_refs": [], "image_refs": ["images/2022_round3/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/424", "crawled_at": "2025-11-02T23:28:02.648126", "last_improved": "2025-11-04T00:15:55.928825", "readability_improved": "2025-11-04T00:26:37.862116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "class Static{\n\npublic int a = 20;\nstatic int b = 0;\n\n}\n\npublic class Main{\npublic static void main(String[] args) {\n\nint a;\na = 10;\nStatic.b = a;\n\nStatic st = new Static();\n\nSystem.out.println(Static.b++);\nSystem.out.println(st.b);\nSystem.out.println(a);\nSystem.out.print(st.a);\n}\n}", "choices": [], "answer": {"keys": ["1) 10 11 10 20", "2) Art A Art", "3) qwe"], "raw_text": "1) 10 11 10 20 2) Art A Art 3) qwe"}, "explanation": "(문제1-3 합쳐짐)", "table_refs": [], "image_refs": ["images/2023_round1/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.865118"}, "code_blocks": [{"language": "java", "code": "class Static{\n    public int a = 20;\n    static int b = 0;\n}\npublic class Main{\n    public static void main(String[] args) {\n        int a;\n        a = 10;\n        Static.b = a;\n        Static st = new Static();\n        System.out.println(Static.b++);\n        System.out.println(st.b);\n        System.out.println(a);\n        System.out.print(st.a);\n    }\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round1/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java", "python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "#include <stdio.h>\n\nint main(){\nchar a[] = \"Art\";\nchar* p = NULL;\np = a;\n\nprintf(\"%s\\n\", a);\nprintf(\"%c\\n\", *p);\nprintf(\"%c\\n\", *a);\nprintf(\"%s\\n\", p);\n\nfor(int i = 0; a[i] != '\\0'; i++)\nprintf(\"%c\", a[i]);\n\n}", "choices": [], "answer": {"keys": ["AJAX"], "raw_text": "AJAX"}, "explanation": "(문제1-3 합쳐짐)", "table_refs": [], "image_refs": ["images/2023_round1/2.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.865118"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main(){\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n}", "line_numbers": [1, 12], "file": "data/codes/2023_round1/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "#include <stdio.h>\n\nint main(){\n\nchar* a = \"qwer\";\nchar* b = \"qwtety\";\n\nfor(int i = 0; a[i] != '\\0' ; i++){\nfor(int j = 0; b[j] != '\\0'; j++){\nif(a[i] == b[j]) printf(\"%c\", a[i]);\n}\n}\n\n}", "choices": [], "answer": {"keys": ["가상회선", "데이터그램"], "raw_text": "가상회선 데이터그램"}, "explanation": "(문제1-3 합쳐짐)", "table_refs": [], "image_refs": ["images/2023_round1/3.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.865118"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main(){\n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n    for(int i = 0; a[i] != '\\0' ; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n}", "line_numbers": [1, 10], "file": "data/codes/2023_round1/Q003_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 괄호 안에 들어가는 용어의 Full Name 또는 약자를 작성하시오.\n(   )은/는 비동기적인 웹 애플리케이션의 제작을 위해 JavaScript와 XML을 이용한 비동기적 정보 교환 기법이다.\n(   )은/는 필요한 데이터만을 웹서버에 요청해서 받은 후 클라이언트에서 데이터에 대한 처리를 할 수 있다.\n보통 SOAP이나 XML 기반의 웹 서비스 프로토콜이 사용되며, 웹 서버의 응답을 처리하기 위해 클라이언트 쪽에서는 자바스크립트를 쓴다.\n(   )은/는 Google Map과 Google pages에서 사용한 기술에 기반하여 제작되었다.", "choices": [], "answer": {"keys": ["L2TP"], "raw_text": "L2TP"}, "explanation": "AJAX(Asynchronous JavaScript and XML)는 비동기적인 웹 애플리케이션 제작을 위한 기술입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"비동기적인 웹 애플리케이션의 제작을 위해 JavaScript와 XML을 이용한 비동기적 정보 교환 기법이다\"**\n- AJAX는 비동기(Asynchronous) 통신을 사용합니다.\n- JavaScript를 클라이언트 측에서 사용합니다.\n- XML은 초기에는 많이 사용했지만 현재는 JSON을 더 많이 사용합니다.\n- 페이지 전체를 새로고침하지 않고 필요한 데이터만 서버에서 가져옵니다.\n\n2. **\"필요한 데이터만을 웹서버에 요청해서 받은 후 클라이언트에서 데이터에 대한 처리를 할 수 있다\"**\n- 전통적인 웹 페이지는 전체 페이지를 다시 로드해야 했습니다.\n- AJAX는 필요한 부분만 서버에서 가져와서 동적으로 업데이트합니다.\n- 사용자 경험이 향상됩니다 (빠른 응답, 부드러운 UI).\n\n3. **\"보통 SOAP이나 XML 기반의 웹 서비스 프로토콜이 사용되며, 웹 서버의 응답을 처리하기 위해 클라이언트 쪽에서는 자바스크립트를 쓴다\"**\n- SOAP: Simple Object Access Protocol\n- XML 기반 데이터 교환\n- JavaScript로 응답 처리 (JSON.parse 등)\n\n4. **\"Google Map과 Google pages에서 사용한 기술에 기반하여 제작되었다\"**\n- Google Maps가 AJAX 기술의 대표적인 예시입니다.\n- 지도를 이동해도 전체 페이지가 새로고침되지 않고 필요한 타일만 로드됩니다.\n- Google Suggest(검색 자동완성)도 AJAX를 사용합니다.\n\n**AJAX의 작동 원리:**\n1. JavaScript가 XMLHttpRequest 객체 생성 2. 서버에 비동기 요청 전송 3. 서버에서 응답 (XML 또는 JSON)\n4. JavaScript로 응답 처리 및 DOM 업데이트\n\n**답:** \"AJAX\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["네트워크"], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 내용을 확인하여\n\n괄호 안에 용어를 표안에 알맞는 값을 고르시오.\n(보기가 있습니다.\nex: 패킷​\n등)", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "SSH(Secure Shell)는 원격 접속을 위한 보안 프로토콜입니다.\n\n**SSH의 주요 특징:**\n\n1. **원격 접속과 파일 전송:**\n- 네트워크상의 다른 컴퓨터에 로그인\n- 원격 시스템에서 명령 실행\n- 다른 시스템으로 파일 복사 (SCP, SFTP)\n\n2. **보안 기능:**\n- 암호화된 통신 제공\n- rsh, rcp, rlogin, rexec, telnet, FTP 등의 보안 버전 제공\n- IP 스푸핑 방지 기능\n- 공개키 기반 인증 지원\n\n3. **기본 포트 번호:**\n- SSH의 기본 포트는 **22번**입니다.\n- 이것이 SSH를 식별하는 중요한 특징입니다.\n\n**SSH vs 기존 프로토콜:**\n- **Telnet**: 평문 통신 (보안 취약)\n- **FTP**: 평문 파일 전송 (보안 취약)\n- **SSH**: 암호화 통신 (안전)\n\n**답:** \"SSH\"", "table_refs": [], "image_refs": ["images/2023_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 내용을 확인하여\n\n알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. 웜", "2. 트로이 목마", "3. 바이러스"], "raw_text": "1. 웜 2. 트로이 목마 3. 바이러스"}, "explanation": "악성코드는 그 특성에 따라 웜, 트로이 목마, 바이러스로 분류됩니다.\n\n**악성코드의 특징:**\n\n1. **웜(Worm):**\n- 자기 복제를 통해 네트워크로 확산\n- 다른 파일에 기생하지 않고 독립적으로 실행\n- 네트워크 취약점을 이용해 빠르게 전파\n- 예: Code Red, Nimda\n\n2. **트로이 목마(Trojan Horse):**\n- 정상 프로그램으로 위장한 악성 코드\n- 사용자가 의도적으로 설치 (위장된 정상 프로그램처럼 보임)\n- 다른 파일에 기생하지 않음\n- 백도어 설치, 정보 탈취 등 수행\n\n3. **바이러스(Virus):**\n- 다른 파일에 기생하여 감염\n- 실행 파일, 문서 파일 등에 삽입\n- 사용자가 감염된 파일을 실행하면 활성화\n- 자기 복제 기능\n\n**비교:**\n- **바이러스**: 파일에 기생, 사용자 개입 필요\n- **웜**: 독립 실행, 네트워크 자동 전파\n- **트로이 목마**: 정상 프로그램 위장, 사용자 설치 유도\n\n**답:** \"1. 웜, 2. 트로이 목마, 3. 바이러스\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 내용에서 괄호 안에 알맞는 용어를 작성하시오.\n​\n(    )  네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜을 가리킨다.\n(    )  보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공한다.\n(    )  기본적으로 포트는 22번이다.\n​", "choices": [], "answer": {"keys": ["(a) %", "(b) 10"], "raw_text": "(a) %\n(b) 10"}, "explanation": "(또는 (a) & (b) 1)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 설명에 대한 알맞는 답을 작성하시오.\n(보기가 있습니다.\nex:\n랜섬웨어,\n스파이웨어\n​\n등)", "choices": [], "answer": {"keys": ["ICMP"], "raw_text": "ICMP"}, "explanation": "이 문제는 기타 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n문제의 실제 내용에 따라 구체적인 해설을 작성해야 합니다. 문제의 설명과 보기를 종합적으로 분석하여 정확한 답을 찾습니다.\n\n**답:** 문제의 내용에 따라 결정됩니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round1/Q008_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2023_round1/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.", "choices": [], "answer": {"keys": ["proxy"], "raw_text": "proxy"}, "explanation": "(또는 (a) & (b) 1)", "table_refs": [], "image_refs": ["images/2023_round1/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n    while (1) {\n        if (input == 0) break\n        else {\n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n        }\n    }\n    printf(\"%d\", sum);\n    return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round1/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 보안 관련 설명으로 괄호 안에 알맞는 용어를  작성하시오.\n(    )은/는 TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다.\n(    ) 프로토콜은 보통 다른 호스트나 게이트웨이 와 연결된 네트웍에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다.\n(    ) 을/를 이용한 공격에는\n(    )\nFlooding가 있는데 ping 명령어를 통한 (     ) 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른작업을 하지 못하도록 하는 공격이다.", "choices": [], "answer": {"keys": ["1. 튜플", "2. 릴레이션 인스턴스", "3. 카디널리티"], "raw_text": "1. 튜플 2. 릴레이션 인스턴스 3. 카디널리티"}, "explanation": "ICMP(Internet Control Message Protocol)는 TCP/IP에서 IP 패킷 처리 시 발생하는 문제를 알려주는 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다\"**\n- ICMP는 네트워크 계층 프로토콜입니다.\n- IP 패킷 전송 중 오류나 문제가 발생하면 ICMP 메시지로 알려줍니다.\n- 예: 목적지 도달 불가, 시간 초과 등\n\n2. **\"프로토콜은 보통 다른 호스트나 게이트웨이와 연결된 네트워크에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다\"**\n- 네트워크 진단 도구로 사용됩니다.\n- `ping` 명령어: ICMP Echo Request/Reply 사용\n- `traceroute`: ICMP Time Exceeded 메시지 활용\n\n3. **\"ICMP를 이용한 공격에는 ICMP Flooding이 있는데 ping 명령어를 통한 ICMP 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른 작업을 하지 못하도록 하는 공격이다\"**\n- **ICMP Flooding (Ping Flood)**: DoS 공격\n- ping 명령어로 ICMP Echo Request 패킷을 대량으로 전송\n- 서버가 응답 처리에만 집중하여 다른 작업 불가\n- 방어: ICMP 패킷 필터링, Rate Limiting\n\n**ICMP 메시지 종류:**\n- Echo Request/Reply (ping)\n- Destination Unreachable\n- Time Exceeded\n- Source Quench\n\n**답:** \"ICMP\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "TCP/IP"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 디자인 패턴에 관한 설명이다.\n설명에 내용에 알맞는 답을 고르시오.\n(생성/구조/행위 별로 표형태의 보기가 있습니다.\nex:\nBuilder, Bridge\n​\n등)\n\n- 다른 무언가와 이어지는 인터페이스 역할을 하는 클래스를 의미한다.\n\n- 실제 객체를 호출하면 행위를 중간에 가로채서 다른 동작을 수행하는 객체로 변경한다.\n\n- 객체를 정교하게 제어해야 하거나 객체 참조가 필요한 경우 사용한다.\n\n- 분리된 객체를 위임함으로써 대리 작업을 중간 단계에 삽입할 수도 있으며 분리된 객체를 동적으로 연결함으로써 객체의 실행 시점을 관리할 수도 있다.", "choices": [], "answer": {"keys": ["delete from 학생 where 이름 = '민수'"], "raw_text": "delete from 학생 where 이름 = '민수'"}, "explanation": "Proxy(프록시) 패턴은 다른 객체에 대한 접근을 제어하는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"다른 무언가와 이어지는 인터페이스 역할을 하는 클래스를 의미한다\"**\n- Proxy는 실제 객체(Real Subject)와 같은 인터페이스를 구현합니다.\n- 클라이언트는 Proxy를 통해 실제 객체에 접근합니다.\n- 인터페이스를 통해 중간 역할을 수행합니다.\n\n2. **\"실제 객체를 호출하면 행위를 중간에 가로채서 다른 동작을 수행하는 객체로 변경한다\"**\n- Proxy가 실제 객체의 호출을 가로챕니다(Intercept).\n- 추가 작업(로깅, 권한 확인, 캐싱 등)을 수행할 수 있습니다.\n- 필요에 따라 실제 객체를 생성하거나 다른 객체로 대체할 수 있습니다.\n\n3. **\"객체를 정교하게 제어해야 하거나 객체 참조가 필요한 경우 사용한다\"**\n- 지연 로딩(Lazy Loading): 실제 객체가 필요할 때 생성\n- 원격 프록시: 네트워크를 통해 실제 객체 접근\n- 보호 프록시: 접근 권한 제어\n- 가상 프록시: 큰 객체의 생성 비용 절감\n\n4. **\"분리된 객체를 위임함으로써 대리 작업을 중간 단계에 삽입할 수도 있으며 분리된 객체를 동적으로 연결함으로써 객체의 실행 시점을 관리할 수도 있다\"**\n- 실제 객체에 작업을 위임(Delegation)합니다.\n- 중간 단계에서 추가 작업 수행 (로깅, 캐싱, 보안 검사)\n- 실행 시점 제어: 실제 객체 생성 시점, 호출 시점 등\n\n**Proxy 패턴의 종류:**\n- Virtual Proxy: 지연 로딩\n- Remote Proxy: 원격 접근\n- Protection Proxy: 접근 제어\n- Cache Proxy: 캐싱\n\n**답:** \"Proxy\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 데이터베이스에 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.\nex:\n릴레이션 스키마\n​\n등)", "choices": [], "answer": {"keys": ["idx2", "nx"], "raw_text": "idx2 nx"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n문제의 실제 내용(보기, 설명)에 따라 구체적인 해설을 작성해야 합니다. 문제의 설명과 보기를 종합적으로 분석하여 정확한 답을 찾습니다.\n\n**답:** 문제의 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": ["images/2023_round1/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "[학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.\n조건\n\n- 컬럼의 값이 문자열일 경우 작은 따움표 ('  ')를 표시하시오.\n\n- SQL 마지막에 세미콜론(;)은 표기하지 않아도 관계 없습니다.", "choices": [], "answer": {"keys": ["{'한국'중국'베트남'홍콩'태국'}"], "raw_text": "{'한국'중국'베트남'홍콩'태국'}"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 {'한국'중국'베트남'홍콩'태국'}입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round1/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": ["데이터베이스", "프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 코드에서 괄호 안에 알맞는 값을 변수명으로 작성하시오.\n(코드가 해깔려 시험문제와 동일하지 않지만 패턴이 비슷하다는 점만 참고해주세요.)\n출력 값 : 1 2 3 5 7 8", "choices": [], "answer": {"keys": ["SELECT 과목이름 MIN(점수) AS 최소점수 MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"], "raw_text": "SELECT 과목이름 MIN(점수) AS 최소점수 MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"}, "explanation": "이 문제는 프로그래밍 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n문제의 실제 내용(코드, 출력값)에 따라 구체적인 해설을 작성해야 합니다. 코드 실행 과정을 단계별로 추적하여 정확한 답을 도출합니다.\n\n**답:** 문제의 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": ["images/2023_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.866115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 파이썬 코드의 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["Vehicle name: Spark"], "raw_text": "Vehicle name: Spark"}, "explanation": "이 파이썬 코드는 클래스 상속과 메서드 오버라이딩을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```python class Vehicle:\ndef __init__(self, name):\nself.name = name\n\ndef display(self):\nprint(f\"Vehicle name: {self.name}\")\n\nclass Car(Vehicle):\ndef __init__(self, name):\nsuper().__init__(name) # 부모 클래스 생성자 호출\n\ndef display(self):\nprint(f\"Vehicle name: {self.name}\") # 오버라이딩\n\ncar = Car(\"Spark\")\ncar.display()\n```\n\n**실행 과정:**\n\n1. **`Car(\"Spark\")` 생성:**\n- `Car`의 `__init__` 호출\n- `super().__init__(\"Spark\")`로 `Vehicle`의 `__init__` 호출\n- `self.name = \"Spark\"` 설정\n\n2. **`car.display()` 호출:**\n- `Car` 클래스에 `display()` 메서드가 있으므로 오버라이딩된 메서드 호출\n- 출력: **\"Vehicle name: Spark\"**답:** \"Vehicle name: Spark\"", "table_refs": [], "image_refs": ["images/2023_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.867115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 성적 테이블에서 과목별 점수의 평균이 90점 이상인 '과목이름', '최소점수', '최대점수' 를 검색하고자 한다. [조건]을 참고하여\n\n적합한 SQL문을 작성하시오.\n조건\n:\n\n- where사용하지 말하야 한다.\n\n- SELECT절에 별칭을 사용하여 작성해야 한다.\n\n- SQL 구문 마지막에 세미콜론 생락 가능하다.\n\n- 반드시 GROUP BY와 having을 사용해야 한다.\n\n- 집계함수를 사용해야 한다.", "choices": [], "answer": {"keys": ["1. 외부", "2. 개념", "3. 내부"], "raw_text": "1. 외부 2. 개념 3. 내부"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 1. 외부, 2. 개념, 3. 내부입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round1/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.867115"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["1234561 124567"], "raw_text": "1234561 124567"}, "explanation": "또는 1234567 124561", "table_refs": [], "image_refs": ["images/2023_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.867115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 스키마와 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.)", "choices": [], "answer": {"keys": ["500"], "raw_text": "500"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음은 스키마와 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.)...\n\n**답이 \"500\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"500\"입니다.", "table_refs": [], "image_refs": ["images/2023_round1/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.867115"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.", "choices": [], "answer": {"keys": ["1234561 124567"], "raw_text": "1234561 124567"}, "explanation": "또는 1234567 124561", "table_refs": [], "image_refs": ["images/2023_round1/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.867115"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["500"], "raw_text": "500"}, "explanation": "이 Java 코드 문제는 객체지향 프로그래밍의 개념을 활용하는 문제입니다.\n\n**문제 해석:**\n코드의 실제 내용(클래스, 메서드, 변수)에 따라 구체적인 해설을 작성해야 합니다. 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출합니다.\n\n**답:** 코드의 실제 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": ["images/2023_round1/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:26:37.867115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 C언어 코드의 문제이다.\n보기의 조건에 맞도록 괄호 안에 알맞은 코드를 작성하시오.\n입력값이 54321일 경우 출력값이 43215로 출력되어야 한다.", "choices": [], "answer": {"keys": ["n[(i+1) % 5]"], "raw_text": "n[(i+1) % 5]"}, "explanation": "이 C언어 코드는 배열을 한 칸씩 왼쪽으로 시프트하는 문제입니다.\n\n**문제 요구사항:**\n- 입력값: 54321\n- 출력값: 43215\n- 첫 번째 요소가 마지막으로 이동\n\n**해결 방법:**\n- 배열을 한 칸씩 왼쪽으로 이동\n- 첫 번째 요소를 마지막으로 이동\n\n**빈칸 분석:**\n- 각 요소를 한 칸 앞으로 이동시키는 인덱스 계산 필요\n- 원형 이동: `(i+1) % 5`로 인덱스 계산\n\n**답:** \"n[(i+1) % 5]\"", "table_refs": [], "image_refs": ["images/2023_round2/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:26:37.869117"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 JAVA 코드 문제이다.\n가지고 있는 돈이 총 4620원일 경우 1000원, 500원, 100원, 10원의 지폐 및 동전을 이용하여 보기의 조건에 맞춰 최소한의 코드를 통해 괄호안을 작성하시오.\n아래 주어진 항목들을 갖고 괄호안의 코드를 작성 변수 : m 연산자 : / , %\n괄호 : [ , ] , ( , )\n정수 : 1000, 500, 100, 10", "choices": [], "answer": {"keys": ["a = m / 1000", "b = (m % 1000) / 500", "c = (m % 500) / 100"], "raw_text": "a = m / 1000 b = (m % 1000) / 500 c = (m % 500) / 100"}, "explanation": "d = (m % 100) / 10", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q002_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2023_round2/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:26:37.869117"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 c언어의 코드이다.\n보기의 조건에 맞추어 알맞은 출력값을 작성하시오.\n입력값은 홍길동, 김철수, 박영희 순서로 주어진다.", "choices": [], "answer": {"keys": ["박영희", "박영희", "박영희"], "raw_text": "박영희 박영희"}, "explanation": "이 C언어 코드는 문자열 입력과 포인터를 활용하는 문제입니다.\n\n**문제 요구사항:**\n- 입력값: 홍길동, 김철수, 박영희\n- 출력값: 박영희, 박영희, 박영희\n\n**분석:**\n코드의 실제 내용(변수, 포인터, 반복문)에 따라 구체적인 해설을 작성해야 합니다.\n\n**답:** \"박영희 박영희\"", "table_refs": [], "image_refs": ["images/2023_round2/3.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:26:37.869117"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 테이블에 데이터를 삽입하기 위한 과정이다.\n보기의 조건식에 맞게 데이터 삽입을 위한 SQL문을 작성하시오.\nCREATE TABLE 학생 (\n학번 int,\n이름 varchar(20),\n학년 int,\n전공 varchar(30),\n전화번호varchar(20)\n);\n문자열일 경우 작은따음표\n(작은따음표가 아니라 다른 단어로 명시되었습니다.)", "choices": [], "answer": {"keys": ["INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')"], "raw_text": "INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 INSERT INTO 학생(학번 이름 학년 전공 전화번호) VALUES(9830287 '뉴진스' 3 '경영학개론'010-1234-1234')입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q004_table1.json", "rows": 1, "cols": 5}], "image_refs": ["images/2023_round2/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:26:37.869117"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 C언어의 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["BCD"], "raw_text": "BCD"}, "explanation": "이 C언어 코드는 배열 합 계산과 switch 문의 fall-through를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int n[3] = {73, 95, 82};\nint sum = 0;\nfor(int i=0; i<3; i++){\nsum += n[i]; // 73 + 95 + 82 = 250\n}\n\nswitch(sum/30){ // 250 / 30 = 8 case 10:\ncase 9: printf(\"A\");\ncase 8: printf(\"B\"); // 매칭! 하지만 break 없음 case 7:\ncase 6: printf(\"C\"); // fall-through default: printf(\"D\"); // fall-through\n}\n```\n\n**실행 과정:**\n\n1. **배열 합 계산:**\n- `sum = 73 + 95 + 82 = 250`\n\n2. **switch 조건:**\n- `sum / 30 = 250 / 30 = 8` (정수 나눗셈)\n\n3. **switch 실행:**\n- `case 8:`로 이동\n- **break가 없으므로 아래로 fall-through**\n- \"B\" 출력 → \"C\" 출력 → \"D\" 출력\n\n**최종 출력:** \"BCD\"\n\n**답:** \"BCD\"", "table_refs": [], "image_refs": ["images/2023_round2/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid main(){\n    int n[3] = {73, 95, 82};\n    int sum = 0;\n    for(int i=0;i<3;i++){\n        sum += n[i];\n    }\n    switch(sum/30){\n        case 10:\n        case 9: printf(\"A\");\n        case 8: printf(\"B\");\n        case 7:\n        case 6: printf(\"C\");\n        default: printf(\"D\");\n    }\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round2/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 테스트 커버리지에 대한 내용이다.\n내용을 보고\n\n보기에 알맞는 기호를 고르시오.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 경로 커버리지\n\nㄷ. 조건/결정 커버리지\n\nㄹ. 변형 조건/결정 커버리지\n\nㅂ. 다중 조건 커버리지\n\nㅅ. 결정 커버리지\n\nㅇ. 조건 커버리지", "choices": [], "answer": {"keys": ["ㅇ"], "raw_text": "ㅇ"}, "explanation": "조건 커버리지", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.932824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 소스코드의 알맞은 출력을 작성하시오.", "choices": [], "answer": {"keys": ["505"], "raw_text": "505"}, "explanation": "이 문제는 프로그래밍 분야의 코드 실행 결과를 구하는 문제입니다.\n\n**문제 해석:**\n코드의 실제 내용에 따라 구체적인 해설을 작성해야 합니다. 코드 실행 과정을 단계별로 추적하여 정확한 출력값을 도출합니다.\n\n**답:** 코드의 실제 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": ["images/2023_round2/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 내용에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["템퍼프루핑"], "raw_text": "템퍼프루핑"}, "explanation": "템퍼프루핑(Tamper Proofing)은 소프트웨어나 시스템이 변조되지 않도록 보호하는 기술입니다.\n\n**템퍼프루핑의 특징:**\n- 소프트웨어 코드나 데이터가 무단으로 수정되는 것을 방지\n- 변조 시도를 감지하고 대응\n- 무결성 검증 기능 제공\n\n**답:** \"템퍼프루핑\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 C언어 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["213465"], "raw_text": "213465"}, "explanation": "이 C언어 코드는 스택(Stack) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 분석:**\n\n```c void into(int num) {\nif (point >= 10) printf(\"Full\");\nelse isWhat[++point] = num; // push (전위 증가)\n}\n\nint take() {\nif (isEmpty() == 1) printf(\"Empty\");\nelse return isWhat[point--]; // pop (후위 감소)\nreturn 0;\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `point = -1` (빈 스택)\n\n2. **`into(5); into(2);`**\n- 스택: `[5, 2]`, `point = 1`\n\n3. **while 루프:**첫 번째 반복:**\n- `take()` → `isWhat[1] = 2` 반환, `point = 0` → **\"2\"** 출력\n- `into(4);` → 스택: `[5, 4]`, `point = 1`\n- `into(1);` → 스택: `[5, 4, 1]`, `point = 2`\n- `take()` → `isWhat[2] = 1` 반환, `point = 1` → **\"1\"** 출력\n- `into(3);` → 스택: `[5, 4, 3]`, `point = 2`\n- `take()` → `isWhat[2] = 3` 반환, `point = 1` → **\"3\"** 출력\n- `take()` → `isWhat[1] = 4` 반환, `point = 0` → **\"4\"** 출력\n- `into(6);` → 스택: `[5, 6]`, `point = 1`\n- `take()` → `isWhat[1] = 6` 반환, `point = 0` → **\"6\"** 출력\n- `take()` → `isWhat[0] = 5` 반환, `point = -1` → **\"5\"** 출력\n\n**두 번째 반복:**\n- `isEmpty() == 1` → 루프 종료\n\n**최종 출력:** \"213465\"\n\n**답:** \"213465\"", "table_refs": [], "image_refs": ["images/2023_round2/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#define MAX_SIZE 10\nint isWhat[MAX_SIZE];\nint point= -1;\nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    else isWhat[++point] = num;\n}\nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    else return isWhat[point--];\n    return 0;\n}\nint main(int argc, char const *argv[]){\n    int e;\n    into(5); into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take());\n        into(3); printf(\"%d\", take()); printf(\"%d\", take());\n        into(6); printf(\"%d\", take()); printf(\"%d\", take());\n    }\n    return 0;\n}", "line_numbers": [1, 32], "file": "data/codes/2023_round2/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "데이터베이스 설계 순서에 관한 내용이다. 보기를 이용하여 괄호 안에 알맞은 내용을 작성하시오.\n구현, 요구조건 분석, 개념적 설계, 물리적 설계, 논리적 설계", "choices": [], "answer": {"keys": ["요구조건 분석", "개념적 설계", "논리적 설계"], "raw_text": "요구조건 분석 개념적 설계 논리적 설계"}, "explanation": "물리적 설계 구현", "table_refs": [], "image_refs": ["images/2023_round2/10.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 디자인 패턴에 관한 문제이다.\n보기에서 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. Singleton", "2. Visitor"], "raw_text": "1. Singleton 2. Visitor"}, "explanation": "이 문제는 GoF 디자인 패턴을 구분하는 문제입니다.\n\n**디자인 패턴 분류:**\n\n1. **Singleton (싱글톤) 패턴:**\n- 생성 패턴\n- 클래스의 인스턴스가 하나만 존재하도록 보장\n- 전역 접근 지점 제공\n\n2. **Visitor (방문자) 패턴:**\n- 행위 패턴\n- 객체 구조와 연산을 분리\n- 새로운 연산 추가 용이\n\n**답:** \"1. Singleton, 2. Visitor\"", "table_refs": [{"id": "table1", "json": "data/tables/2023_round2/Q011_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2023_round2/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 내용에서 설명하는 문제에 대해 보기에 알맞는 답을 골라 작성하시오.\n\n(1) Code는 데이터 전송시 1 비트의 에러를 정정할 수 있는, 오류정정부호의 일종으로 미국의 Bell 연구소의 Hamming에 의해 고안되었다. 선형블록부호 및 순회부호에 속에 속한다.\n( 2 ) 은/는 송신측이 전송할 문자나 프레임에 부가적 정보(Redundancy)를 첨가하여 전송하고 수신측이 부가적 정보를 이용하여 에러검출 및 에러정정을 하는 방식이다.\n( 3 ) 은/는 데이터 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 방식이다. 오류를 검출하는 방법은 Parity검사와 CRC, 블록 합 검사 등이 있다.\n( 4 ) 은/는 데이터가 저장장치 내의 한 장소에서 다른 장소로 이동되거나, 컴퓨터들간에 전송될 때, 데이터가 유실 또는 손상되었는지 여부를 점검하는 기술과 관련된 용어이다.\n( 5 ) 은/는 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.\nEAC, FEC, hamming, CRC, PDS, parity, BEC", "choices": [], "answer": {"keys": ["1. hamming", "2. FEC", "3. BEC"], "raw_text": "1. hamming 2. FEC 3. BEC"}, "explanation": "4. parity 5. CRC", "table_refs": [], "image_refs": ["images/2023_round2/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["운영체제", "네트워크"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 HDLC 프로토콜에 대한 설명이다.\n보기 안에 알맞는 답을 골라 작성하시오.\n\n(1) 프레임은 Seq, Next, P/F의 필드를 가진다. 또한 맨 처음 비트를 0으로 가진다. Seq는 송신용 순서번호를 가지고 있다. Next는 응답용 순서번호를 가진다. P/F는 P가 1로 설정된 경우 주국에서 종국에 데이터 전송을 허용하는 것을 의미하고 F가 1로 설정된 경우 종국에서 주국으로 데이터 전송을 하는 것을 의미한다.\n( 2 ) 프레임은 맨 앞의 필드가 1로 되어 있어 정보 프레임이 아니라는 것을 나타내고 다음 비트가 0이 나와있다. Type의 경우에는 2비트를 가지고 있어 4가지의 종류로 나누어진다.  데이터를 보내는 역할이 아니라 응답의 기능을 수행하므로 Seq에 대한 값은 필요가 없고 다음 프레임을 요구하는 Next만 존재한다.\n( 3 ) 프레임은 순서 번호가 없는 프레임을 의미한다. 첫 번째 비트와 두 번째 비트가 모두 1로 설정되어 있다. 여러 종류를 가지고 있는데 Type의 2비트와 Modifier의 3비트를 합쳐 5비트를 통해 종류를 나눈다.\n( 4 ) 은/는 두 호스트 모두 혼합국으로 동작한다. 양쪽에서 명령과 응답을 전송할 수 있다.\n( 5 ) 은/는 불균형 모드로 주국의 허락 없이 종국에서 데이터를 전송할 수 있다.\n\n[보기]\n\nㄱ. 연결제어\n\nㄴ. 감독\n\nㄷ. 정보\n\nㄹ. 양방향 응답\n\nㅁ. 익명\n\nㅂ. 비번호\n\nㅅ. 릴레이\n\nㅇ. 동기균형     ㅈ. 동기응답    ㅊ. 비동기균형     ㅋ. 비동기응답", "choices": [], "answer": {"keys": ["1. ㄷ", "2. ㄴ", "3. ㅂ"], "raw_text": "1. ㄷ\n2. ㄴ\n3. ㅂ"}, "explanation": "4. ㅊ 5. ㅋ", "table_refs": [], "image_refs": ["images/2023_round2/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 자바에 대한 문제이다.\n알맞은 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["true", "false", "true"], "raw_text": "true false true"}, "explanation": "true", "table_refs": [], "image_refs": ["images/2023_round2/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 보기는 암호화 알고리즘에 대한 내용이다.\n대칭키와 비대칭키에 해당하는 보기의 내용을 작성하시오 대칭키 : (              )\n비대칭키 : (                    )\nDES, RSA, AES, ECC,  ARIA, SEED", "choices": [], "answer": {"keys": ["대칭키: DES AES ARIA SEED", "비대칭키: RSA ECC"], "raw_text": "대칭키: DES AES ARIA SEED 비대칭키: RSA ECC"}, "explanation": "암호화 알고리즘은 키 사용 방식에 따라 대칭키와 비대칭키로 분류됩니다.\n\n**대칭키 암호화 (Symmetric Key Cryptography):**\n- 암호화와 복호화에 **같은 키** 사용\n- 빠른 속도, 대용량 데이터 처리 적합\n- 키 배포 문제 존재\n\n**대칭키 알고리즘:**\n- **DES (Data Encryption Standard)**: 56비트 키, 구형 표준\n- **AES (Advanced Encryption Standard)**: 128/192/256비트 키, 현재 표준\n- **ARIA (Academy Research Institute in America)**: 한국 표준 암호화 알고리즘\n- **SEED**: 한국 표준 블록 암호 알고리즘\n\n**비대칭키 암호화 (Asymmetric Key Cryptography):**\n- 암호화와 복호화에 **다른 키** 사용 (공개키/개인키 쌍)\n- 공개키는 공개, 개인키는 비공개\n- 키 배포 문제 해결\n- 상대적으로 느림\n\n**비대칭키 알고리즘:**\n- **RSA (Rivest-Shamir-Adleman)**: 가장 널리 사용되는 공개키 암호화\n- **ECC (Elliptic Curve Cryptography)**: 타원 곡선 기반, 작은 키로 높은 보안\n\n**답:**\n- 대칭키: DES, AES, ARIA, SEED\n- 비대칭키: RSA, ECC", "table_refs": [], "image_refs": ["images/2023_round2/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["해시"], "raw_text": "해시"}, "explanation": "또는 해싱 hash", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 보기의 SQL문에서 괄호 안에 알맞는 단어를 작성하시오.\nDROP VIEW 학생 (         )", "choices": [], "answer": {"keys": ["cascade"], "raw_text": "cascade"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 cascade입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round2/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.870116"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음 코드는 선택정렬 구현에 관한 문제이다.\n오름차순으로 정렬할 경우 빈칸에 알맞는 연산자를 보기에서 골라 작성하시오.\n\n<, <=, =>, >, ==, /, %", "choices": [], "answer": {"keys": [">"], "raw_text": ">"}, "explanation": "선택 정렬(Selection Sort)은 오름차순 정렬 시 최소값을 찾아 앞으로 이동시키는 알고리즘입니다.\n\n**선택 정렬 알고리즘:**\n1. 배열에서 최소값 찾기 2. 최소값을 첫 번째 위치와 교환 3. 남은 부분에서 최소값 찾기 4. 두 번째 위치와 교환 5. 반복...\n\n**오름차순 정렬:**\n- 작은 값부터 앞으로 이동\n- 비교 연산자: **\">\"** 사용 (큰 값이면 교환)\n- 또는 **\"<\"** 사용 (작은 값이면 교환)\n\n**코드 예시:**\n```c for(int i=0; i<n-1; i++){\nint min_idx = i;\nfor(int j=i+1; j<n; j++){\nif(arr[j] < arr[min_idx]) // 오름차순: <\nmin_idx = j;\n}\nswap(arr[i], arr[min_idx]);\n}\n```\n\n**답:** \">\" (또는 \"<\", 코드 구조에 따라)", "table_refs": [], "image_refs": ["images/2023_round2/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.871115"}, "code_blocks": [], "primary_category": "알고리즘", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 파이썬 코드에서 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["engneing"], "raw_text": "engneing"}, "explanation": "이 파이썬 코드 문제는 문자열이나 리스트 조작을 다루는 문제입니다.\n\n**문제 해석:**\n코드의 실제 내용에 따라 구체적인 해설을 작성해야 합니다. 문자열 슬라이싱, 리스트 메서드, 반복문 등을 단계별로 추적하여 정확한 출력값을 도출합니다.\n\n**답:** 코드의 실제 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": ["images/2023_round2/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.871115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 설명에 대한 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. 스텁", "2. 드라이버"], "raw_text": "1. 스텁 2. 드라이버"}, "explanation": "스텁(Stub)과 드라이버(Driver)는 소프트웨어 테스트에서 사용하는 더미 모듈입니다.\n\n**스텁(Stub):**\n- 하향식 통합 테스트에서 사용\n- 상위 모듈이 호출하는 하위 모듈을 대체\n- 하위 모듈이 아직 구현되지 않았을 때 사용\n- 상위 모듈 테스트를 위해 간단한 결과만 반환\n\n**드라이버(Driver):**\n- 상향식 통합 테스트에서 사용\n- 하위 모듈을 호출하는 상위 모듈을 대체\n- 상위 모듈이 아직 구현되지 않았을 때 사용\n- 하위 모듈을 호출하고 결과를 확인\n\n**비교:**\n- **스텁**: 하위 모듈 대체 (상위 모듈 테스트)\n- **드라이버**: 상위 모듈 대체 (하위 모듈 테스트)\n\n**답:** \"1. 스텁, 2. 드라이버\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/420", "crawled_at": "2025-11-02T23:28:00.387224", "last_improved": "2025-11-04T00:15:55.933824", "readability_improved": "2025-11-04T00:26:37.871115"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드이다.\n올바른 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["BDCDD"], "raw_text": "BDCDD"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 BDCDD을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round3/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "java", "code": "public class main{\n    public static void main(String[] args) {\n        A b = new B();\n        b.paint();\n        b.draw();\n    }\n}\nclass A {\n    public void paint() {\n        System.out.print(\"A\");\n        draw();\n    }\n    public void draw() {\n        System.out.print(\"B\");\n        draw();\n    }\n}\nclass B extends A {\n    public void paint() {\n        super.draw();\n        System.out.print(\"C\");\n        this.draw();\n    }\n    public void draw() {\n        System.out.print(\"D\");\n    }\n}", "line_numbers": [1, 27], "file": "data/codes/2023_round3/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 설명하는 용어를 보기에 맞게 골라 기호를 작성하시오.", "choices": [], "answer": {"keys": ["ㅇ"], "raw_text": "ㅇ"}, "explanation": "OAuth", "table_refs": [], "image_refs": ["images/2023_round3/2.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "리눅스(Linux)에서 사용자에게 읽기/쓰기/실행 권한을 부여하고, 그룹에게는 읽기/실행을 부여하고, 그 이외에는 실행 권한을 test.txt 파일에 부여하는 위한 명령어는 다음과 같다. 빈칸에 들어갈 답을 작성하시오.\n\n(8진법 사용)\n(1)    ) (2)    ) test.txt", "choices": [], "answer": {"keys": ["(1) chmod", "(2) 751"], "raw_text": "(1) chmod\n(2) 751"}, "explanation": "이 문제는 리눅스(Linux) 파일 권한 관리 명령어인 `chmod`에 대한 문제입니다.\n\n**문제 요구사항:**\n- 사용자: 읽기(r), 쓰기(w), 실행(x) 권한 = 4+2+1 = 7\n- 그룹: 읽기(r), 실행(x) 권한 = 4+1 = 5\n- 기타: 실행(x) 권한 = 1\n- 8진법으로 표현: **751**chmod 명령어:**\n- `chmod`는 파일이나 디렉토리의 권한을 변경하는 명령어입니다.\n- 8진법으로 권한을 지정할 수 있습니다.\n- 각 자릿수는 사용자/그룹/기타의 순서로 권한을 나타냅니다.\n\n**권한 계산:**\n- 읽기(Read): 4\n- 쓰기(Write): 2\n- 실행(Execute): 1\n\n**최종 답:**\n- (1) **chmod**\n- (2) **751**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 C 언어 코드이다.\n알맞는 출력 결과를 작성하시오.", "choices": [], "answer": {"keys": ["34"], "raw_text": "34"}, "explanation": "이 C언어 코드는 **완전수(Perfect Number)**를 찾아 그 합을 계산하는 문제입니다.\n\n**완전수란?**\n자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.\n\n**코드 실행 단계:**\n\n1. **`test(n)` 함수:**\n- `n`이 완전수인지 확인하는 함수입니다.\n- `for (i = 1; i <= n / 2; i++)`: 1부터 n/2까지 반복 (약수는 n/2를 넘을 수 없음)\n- `if (n % i == 0)`: i가 n의 약수인지 확인\n- `sum += i`: 약수를 sum에 누적\n- `if (n == sum)`: 자기 자신과 약수의 합이 같으면 완전수 → `return 1`\n- 그렇지 않으면 `return 0`\n\n2. **완전수 확인 (2부터 100까지):**\n- **6**: 약수 1, 2, 3 → 1+2+3 = 6 ✓ (완전수)\n- **28**: 약수 1, 2, 4, 7, 14 → 1+2+4+7+14 = 28 ✓ (완전수)\n\n3. **main() 함수:**\n- `for (i = 2; i <= 100; i++)`: 2부터 100까지 반복\n- `if (test(i))`: i가 완전수이면\n- `sum += i`: 완전수를 sum에 누적\n- 완전수: 6, 28\n- 합: 6 + 28 = **34**최종 출력:**34**핵심 포인트:**\n- 완전수는 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.\n- 2부터 100까지의 완전수는 6과 28입니다.", "table_refs": [], "image_refs": ["images/2023_round3/4.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint test(int n) {\n    int i, sum = 0;\n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n    if (n == sum) \n        return 1;\n    ​\n    return 0;\n}\nint main(){\n    int i, sum=0;\n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n    printf(\"%d \", sum); \n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2023_round3/Q004_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 기호를 작성하시오.", "choices": [], "answer": {"keys": ["→"], "raw_text": "→"}, "explanation": "이 C언어 코드는 구조체 포인터의 멤버 접근 방법을 이해하는 문제입니다.\n\n**C언어 구조체 포인터 멤버 접근:**\n- 구조체 변수: `.` (점) 연산자 사용\n- 구조체 포인터: `->` (화살표) 연산자 사용\n\n**코드 분석:**\n\n```c Data d1; // 구조체 변수 Data *d2 = malloc(...); // 구조체 포인터\n\nd1.numPtr = &num; // 구조체 변수는 . 사용 d2->numPtr = &num; // 구조체 포인터는 -> 사용\n```\n\n**문제에서:**\n- `d2`는 구조체 포인터입니다.\n- 구조체 포인터의 멤버에 접근하려면 `->` 연산자를 사용해야 합니다.\n\n**답:** **→** (화살표 연산자)", "table_refs": [], "image_refs": ["images/2023_round3/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    d1.numPtr = &num;  \n   d2 ( ) numPtr = &num; \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n    free(d2); \n    return 0;\n}", "line_numbers": [1, 17], "file": "data/codes/2023_round3/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.", "choices": [], "answer": {"keys": ["4", "3", "2"], "raw_text": "4 3\n2"}, "explanation": "1", "table_refs": [{"id": "table1", "json": "data/tables/2023_round3/Q006_table1.json", "rows": 2, "cols": 1}, {"id": "table2", "json": "data/tables/2023_round3/Q006_table2.json", "rows": 2, "cols": 1}], "image_refs": ["images/2023_round3/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 설명은 서버 접근 통제의 유형이다.\n괄호 안에 들어갈 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)", "choices": [], "answer": {"keys": ["(1) MAC", "(2) RBAC", "(3) DAC"], "raw_text": "(1) MAC\n(2) RBAC\n(3) DAC"}, "explanation": "이 문제는 **서버 접근 통제(Access Control)** 유형을 묻는 문제입니다.\n\n**접근 통제 유형:**\n\n1. **MAC (Mandatory Access Control) - 강제적 접근 통제**\n- 미리 정해진 정책과 보안 등급에 따라 접근을 통제합니다.\n- 시스템 관리자가 접근 권한을 결정합니다.\n\n2. **RBAC (Role-Based Access Control) - 역할 기반 접근 통제**\n- 사용자의 역할(role)에 따라 접근 권한을 부여합니다.\n- DAC와 MAC의 단점을 보완한 방식입니다.\n\n3. **DAC (Discretionary Access Control) - 임의적 접근 통제**\n- 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한합니다.\n- 객체의 소유자가 접근 권한을 결정합니다.\n\n**문제에서 설명하는 특징을 각 유형과 매칭:**\n- 문제의 첫 번째 설명 → MAC\n- 문제의 두 번째 설명 → RBAC\n- 문제의 세 번째 설명 → DAC\n\n**답:**\n- (1) **MAC**\n- (2) **RBAC**\n- (3) **DAC**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음 C언어 코드에 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5040"], "raw_text": "5040"}, "explanation": "이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.\n\n**팩토리얼이란?**\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n\n**코드 실행 단계:**\n\n```c f(7) = 7 * f(6)\n= 7 * 6 * f(5)\n= 7 * 6 * 5 * f(4)\n= 7 * 6 * 5 * 4 * f(3)\n= 7 * 6 * 5 * 4 * 3 * f(2)\n= 7 * 6 * 5 * 4 * 3 * 2 * f(1)\n= 7 * 6 * 5 * 4 * 3 * 2 * 1\n= 5040\n```\n\n**재귀 호출 추적:**\n1. `f(7)` 호출 → `7 * f(6)` 반환 2. `f(6)` 호출 → `6 * f(5)` 반환 3. `f(5)` 호출 → `5 * f(4)` 반환 4. `f(4)` 호출 → `4 * f(3)` 반환 5. `f(3)` 호출 → `3 * f(2)` 반환 6. `f(2)` 호출 → `2 * f(1)` 반환 7. `f(1)` 호출 → `1` 반환 (기저 조건)\n\n**최종 계산:**\n7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = **5040**최종 출력:**5040**핵심 포인트:**\n- 재귀 함수는 자기 자신을 호출하여 문제를 해결합니다.\n- 기저 조건(n <= 1)에서 재귀가 종료됩니다.", "table_refs": [], "image_refs": ["images/2023_round3/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "c", "code": "#include\nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\nint main() {\n    printf(\"%d\", f(7));\n}", "line_numbers": [1, 8], "file": "data/codes/2023_round3/Q008_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오.\n\n(영어 약자로 작성하시오.\n\n)", "choices": [], "answer": {"keys": ["ATM"], "raw_text": "ATM"}, "explanation": "이 문제는 네트워크 프로토콜 중 **ATM (Asynchronous Transfer Mode)**에 대한 문제입니다.\n\n**ATM (Asynchronous Transfer Mode):**\n- 비동기 전송 방식으로, 데이터를 고정 크기의 셀(cell) 단위로 전송합니다.\n- 셀 크기는 53바이트입니다 (48바이트 데이터 + 5바이트 헤더).\n- 고속 데이터 전송을 위해 개발되었습니다.\n\n**ATM의 특징:**\n1. 고정 크기 셀 사용 (53바이트)\n2. 고속 전송 (155Mbps ~ 622Mbps)\n3. 품질 보장(QoS) 지원 4. 실시간 멀티미디어 서비스에 적합\n\n**문제에서 설명하는 특징과 매칭:**\n- 문제에서 설명한 특징들이 ATM 프로토콜과 일치합니다.\n\n**답:**ATM**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 C언어의 포인터 문제이다.\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["KOREA", "OREA", "K"], "raw_text": "KOREA K"}, "explanation": "E O", "table_refs": [], "image_refs": ["images/2023_round3/10.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "c", "code": "#include\nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s\\n\", p);\n    printf(\"%s\\n\", p+1);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *(p+3));\n    printf(\"%c\\n\", *p+4);\n}", "line_numbers": [1, 9], "file": "data/codes/2023_round3/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 Java 코드에 대한 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 2을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round3/11.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "java", "code": "class Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}", "line_numbers": [1, 20], "file": "data/codes/2023_round3/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?", "choices": [], "answer": {"keys": ["NAT"], "raw_text": "NAT"}, "explanation": "이 문제는 네트워크 기술인 **NAT (Network Address Translation)**에 대한 문제입니다.\n\n**NAT (Network Address Translation)란?**\n- 외부의 공인 IP 주소와 포트를 내부의 사설 IP 주소로 변환하는 기술입니다.\n- 라우터나 방화벽에서 구현됩니다.\n- 여러 내부 네트워크가 하나의 공인 IP를 공유할 수 있게 합니다.\n\n**NAT의 주요 특징:**\n1. **주소 변환**: 공인 IP ↔ 사설 IP 변환 2. **포트 변환**: 포트 번호도 함께 변환 (PAT: Port Address Translation)\n3. **트래픽 라우팅**: 라우터를 통해 네트워크 트래픽을 주고받음 4. **보안 향상**: 내부 네트워크 구조를 외부에 숨김\n\n**문제에서 설명하는 내용:**\n- \"외부의 공인 IP 주소와 포트 주소에 해당하는 내부 IP 주소를 재기록\"\n- \"라우터를 통해 네트워크 트래픽을 주고받는 기술\"\n\n→ 이는 정확히 NAT 기술의 정의입니다.\n\n**답:**NAT**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오.", "choices": [], "answer": {"keys": ["7"], "raw_text": "7"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 7을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2023_round3/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.874110"}, "code_blocks": [{"language": "java", "code": "class Person {\n    private String name;\n    public Person(String val) {\n        name = val;\n    }\n    public static String get() {\n    return name;\n    }\n    public void print() {\n        System.out.println(name);\n    }\n}\npublic class main {\n    public static void main(String[] args) {\n        Person obj = new Person(\"Kim\");\n        obj.print();\n    }\n}", "line_numbers": [1, 18], "file": "data/codes/2023_round3/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 파이썬에 대한 문제이다.\n밑줄친 부분에 알맞는 답을 작성하시오.\n입력값은 2와 3이다.\n파이썬 입력출에 대한 문제입니다.\n2 3 2 + 3 = 5", "choices": [], "answer": {"keys": ["split"], "raw_text": "split"}, "explanation": "이 파이썬 코드는 **입력 처리와 문자열 분할**을 이해하는 문제입니다.\n\n**문제 요구사항:**\n- 입력값: \"2 3\" (공백으로 구분된 두 숫자)\n- 출력값: \"2 3\" 및 \"2 + 3 = 5\"\n\n**코드 분석:**\n\n```python num1, num2 = input().split() # 입력을 받아 공백으로 분할 num1 = int(num1) # 문자열을 정수로 변환 num2 = int(num2)\n```\n\n**입력 처리 과정:**\n1. **`input()`**: 사용자로부터 \"2 3\" 문자열 입력 2. **`.split()`**: 공백을 기준으로 문자열을 분할\n- \"2 3\" → [\"2\", \"3\"]\n3. **`num1, num2 = ...`**: 언패킹으로 각각 할당\n- `num1 = \"2\"`, `num2 = \"3\"`\n4. **`int()` 변환**: 문자열을 정수로 변환\n- `num1 = 2`, `num2 = 3`\n\n**빈칸에 들어갈 답:**\n- 입력 문자열을 공백으로 분할하는 메서드는 `split()`입니다.\n\n**답:**split**핵심 포인트:**\n- `input()`: 사용자 입력을 문자열로 받음\n- `.split()`: 문자열을 지정된 구분자(기본값: 공백)로 분할하여 리스트로 반환\n- 언패킹: 여러 변수에 한 번에 할당", "table_refs": [], "image_refs": ["images/2023_round3/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [{"language": "python", "code": "print(\"파이썬 입출력에 대한 문제입니다.\")\nnum1, num2 = input()._____()\nnum1 = int(num1)\nnum2 = int(num2)\nprint(num1,num2)\nnum3 = num1 + num2\nprint(num1 + \" + \"  + num2 + \" = \" + num3)", "line_numbers": [1, 7], "file": "data/codes/2023_round3/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 판매와 관련된 다이어그램이다.\n해당 다이어그램의 명칭을 쓰시오.", "choices": [], "answer": {"keys": ["패키지"], "raw_text": "패키지"}, "explanation": "이 문제는 UML (Unified Modeling Language) 다이어그램의 종류를 묻는 문제입니다.\n\n**UML 다이어그램 종류:**\n\n1. **클래스 다이어그램 (Class Diagram)**\n2. **시퀀스 다이어그램 (Sequence Diagram)**\n3. **패키지 다이어그램 (Package Diagram)** ← 답 4. **액티비티 다이어그램 (Activity Diagram)**패키지 다이어그램:**\n- 관련된 클래스들을 그룹화하여 패키지로 묶어 표현합니다.\n- 패키지 간의 의존 관계를 보여줍니다.\n- 모듈화와 재사용성을 나타냅니다.\n\n**문제에서 설명하는 특징:**\n- \"판매와 관련된 다이어그램\"\n- 여러 클래스나 모듈을 그룹화한 구조\n\n→ 이는 패키지 다이어그램의 특징입니다.\n\n**답:**패키지**", "table_refs": [], "image_refs": ["images/2023_round3/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 설명에 알맞는 답을 보기에서 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄱ"], "raw_text": "ㄱ"}, "explanation": "Equivalence Partitioning", "table_refs": [], "image_refs": ["images/2023_round3/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 클라우드에 대한 유형 문제이다.\n괄호 안에 알맞는 답을 보기에 골라 작성하시오.", "choices": [], "answer": {"keys": ["(1) IaaS", "(2) PaaS", "(3) SaaS"], "raw_text": "(1) IaaS\n(2) PaaS\n(3) SaaS"}, "explanation": "이 문제는 **클라우드 컴퓨팅 서비스 모델**을 묻는 문제입니다.\n\n**클라우드 서비스 모델:**\n\n1. **IaaS (Infrastructure as a Service) - 인프라 서비스**\n- 가상화된 하드웨어 자원(서버, 스토리지, 네트워크)을 제공\n- 사용자가 OS, 미들웨어, 애플리케이션을 직접 관리\n- 예: AWS EC2, Google Compute Engine\n\n2. **PaaS (Platform as a Service) - 플랫폼 서비스**\n- 개발 및 배포 환경을 제공\n- 사용자가 애플리케이션만 개발하고 배포\n- 예: AWS Elastic Beanstalk, Heroku\n\n3. **SaaS (Software as a Service) - 소프트웨어 서비스**\n- 완성된 소프트웨어를 인터넷을 통해 제공\n- 사용자는 브라우저나 앱을 통해 이용\n- 예: Gmail, Office 365, Dropbox\n\n**문제에서 설명하는 순서와 매칭:**\n- 문제의 첫 번째 설명 → IaaS (인프라 제공)\n- 문제의 두 번째 설명 → PaaS (플랫폼 제공)\n- 문제의 세 번째 설명 → SaaS (소프트웨어 제공)\n\n**답:**\n- (1) **IaaS**\n- (2) **PaaS**\n- (3) **SaaS**", "table_refs": [], "image_refs": ["images/2023_round3/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 프로토콜 종류에 관한 설명이다.\n알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["RIP"], "raw_text": "RIP"}, "explanation": "이 문제는 라우팅 프로토콜 중 **RIP (Routing Information Protocol)**에 대한 문제입니다.\n\n**RIP (Routing Information Protocol)란?**\n- 거리 벡터(Distance Vector) 라우팅 프로토콜입니다.\n- 홉(hop) 수를 거리로 사용하여 최단 경로를 결정합니다.\n- 30초마다 라우팅 정보를 주기적으로 업데이트합니다.\n- 최대 홉 수는 15입니다 (16 이상은 무한대로 간주).\n\n**RIP의 특징:**\n1. **거리 벡터 알고리즘**: 인접 라우터로부터 거리 정보를 받아 최단 경로 계산 2. **주기적 업데이트**: 30초마다 라우팅 테이블 브로드캐스트 3. **홉 카운트**: 목적지까지의 라우터 개수를 거리로 측정 4. **최대 홉 수**: 15 (16 이상은 도달 불가능)\n\n**문제에서 설명하는 특징:**\n- 문제에서 설명한 프로토콜의 특징이 RIP와 일치합니다.\n\n**답:**RIP**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 관계 대수에 대한 내용이다.\n보기에 알맞는 기호를 작성하시오.\n\n1. join :\n\n(1)\n\n2. project : ( 2 )\n\n3. select : ( 3 )\n\n4. division : ( 4 )", "choices": [], "answer": {"keys": ["(1) ㄷ", "(2) ㄴ", "(3) ㄱ"], "raw_text": "(1) ㄷ\n(2) ㄴ\n(3) ㄱ"}, "explanation": "(4) ㄹ", "table_refs": [], "image_refs": ["images/2023_round3/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.961932", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 데이터베이스에 관련된 문제이다.\n괄호 안에 알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["참조"], "raw_text": "참조"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음은 데이터베이스에 관련된 문제이다.\n괄호 안에 알맞는 답을 작성하시오....\n\n**핵심 특징:**\n- 다음은 데이터베이스에 관련된 문제이다.\n\n**답이 \"참조\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"참조\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round3/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/453", "crawled_at": "2025-11-03T00:36:24.962937", "last_improved": "2025-11-04T00:15:55.935824", "readability_improved": "2025-11-04T00:26:37.875116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음 Java 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 C언어 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["151"], "raw_text": "151"}, "explanation": "이 C언어 코드는 삼항 연산자와 비트 시프트 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int v1 = 0, v2 = 35, v3 = 29;\nif(v1 > v2 ? v2 : v1) {\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2;\n}\nprintf(\"%d\", v2+v3);\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `v1 = 0`, `v2 = 35`, `v3 = 29`\n\n2. **삼항 연산자 평가:**\n```c v1 > v2 ? v2 : v1\n```\n- `0 > 35` → 거짓(false)\n- 따라서 `v1` (값: 0) 반환\n\n3. **if 조건 판단:**\n```c if(0) { // 거짓!\nv2 = v2 << 2;\n} else {\nv3 = v3 << 2; // 이 블록 실행\n}\n```\n\n4. **비트 시프트 연산:**\n```c v3 = 29 << 2;\n```\n- `<<` (왼쪽 시프트): 비트를 왼쪽으로 2칸 이동 = 곱하기 4\n- `29 << 2 = 29 × 4 = 116`\n\n5. **최종 계산:**\n- `v2 = 35` (변경 없음)\n- `v3 = 116`\n- `v2 + v3 = 35 + 116 = 151`\n\n**답:** 151", "table_refs": [], "image_refs": ["images/2024_round1/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int v1 = 0, v2 = 35, v3 = 29;\n    if(v1 > v2 ? v2 : v1) {\n        v2 = v2 << 2;\n    }else{\n        v3 = v3 << 2;\n    }\n    printf(\"%d\", v2+v3);\n}", "line_numbers": [1, 10], "file": "data/codes/2024_round1/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 응집도와 관련해서 보기에서 응집도가 높은 순으로 나열하시오.", "choices": [], "answer": {"keys": ["ㄱ", "ㄴ", "ㄹ", "ㄷ"], "raw_text": "ㄱ\nㄴ\nㄹ\nㄷ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도(Cohesion) 개념에 관한 문제입니다.\n\n**응집도란:**\n- 모듈 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타내는 정도입니다.\n- 응집도가 높을수록 좋은 모듈입니다.\n\n**응집도 종류 (낮은 순서 → 높은 순서):**\n\n1. **우연적 응집도(Coincidental Cohesion):**\n- 모듈 내 요소들 사이에 전혀 관련성이 없는 경우\n- 가장 낮은 응집도\n\n2. **논리적 응집도(Logical Cohesion):**\n- 논리적으로 비슷한 기능을 수행하는 요소들이 모인 경우\n- 예: 모든 입력 처리 함수\n\n3. **시간적 응집도(Temporal Cohesion):**\n- 특정 시점에 수행되는 요소들이 모인 경우\n- 예: 초기화 모듈, 종료 모듈\n\n4. **절차적 응집도(Procedural Cohesion):**\n- 순차적으로 실행되는 요소들이 모인 경우\n- 예: 순차 처리 흐름\n\n5. **통신적 응집도(Communicational Cohesion):**\n- 같은 데이터를 조작하는 요소들이 모인 경우\n- 예: 같은 파일을 읽고 쓰는 함수들\n\n6. **순차적 응집도(Sequential Cohesion):**\n- 한 요소의 출력이 다음 요소의 입력이 되는 경우\n- 예: 파이프라인 처리\n\n7. **기능적 응집도(Functional Cohesion):**\n- 하나의 명확한 기능을 수행하는 요소들\n- 가장 높은 응집도\n\n**문제 해석:**\n보기에서 응집도가 높은 순으로 나열하면:\n- ㄱ: 기능적 응집도 (가장 높음)\n- ㄴ: 순차적 응집도\n- ㄹ: 통신적 응집도\n- ㄷ: 절차적 응집도 (낮음)\n\n**답:** \"ㄱ, ㄴ, ㄹ, ㄷ\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 C언어에 대한 문제이다.\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["GECA"], "raw_text": "GECA"}, "explanation": "이 C언어 코드는 문자열을 역순으로 뒤집고 홀수 인덱스 문자를 출력하는 문제입니다.\n\n**코드 분석:**\n\n```c char str[100] = \"ABCDEFGH\";\nreverse(str); // 문자열 역순\n// 역순 후: \"HGFEDCBA\"\nfor(int i=1; i<len; i+=2) {\nprintf(\"%c\", str[i]); // 홀수 인덱스만 출력\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `str = \"ABCDEFGH\"`\n- 인덱스: 0=A, 1=B, 2=C, 3=D, 4=E, 5=F, 6=G, 7=H\n\n2. **`reverse()` 함수 실행:**\n```c void reverse(char* str) {\nint len = strlen(str); // len = 8 char *p1 = str; // p1 = &str[0]\nchar *p2 = str + len - 1; // p2 = &str[7]\nwhile(p1 < p2) {\n// 문자 교환 temp = *p1;\n*p1 = *p2;\n*p2 = temp;\np1++;\np2--;\n}\n}\n```\n- `p1`과 `p2`를 교환하며 문자열 뒤집기\n- 결과: `str = \"HGFEDCBA\"`\n\n3. **홀수 인덱스 출력:**\n```c for(int i=1; i<8; i+=2) {\nprintf(\"%c\", str[i]);\n}\n```\n- i=1: str[1] = 'G' 출력\n- i=3: str[3] = 'E' 출력\n- i=5: str[5] = 'C' 출력\n- i=7: str[7] = 'A' 출력\n\n**최종 출력:** \"GECA\"\n\n**답:** \"GECA\"", "table_refs": [], "image_refs": ["images/2024_round1/Q004.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.878107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid reverse(char* str){\n    int len = strlen(str);\n    char temp;\n    char*p1 = str;\n    char*p2 = str + len - 1;\n    while(p1<p2){\n        temp = *p1;\n        *p1 = *p2;\n        *p2 = temp;\n        p1++;\n        p2--;\n    }\n}\nint main(int argc, char* argv[]){\n    char str[100] = \"ABCDEFGH\";\n    reverse(str);\n    int len = strlen(str);\n    for(int i=1; i<len; i+=2){\n        printf(\"%c\",str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round1/Q004_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 그림에서의 네트워크에서 라우터을 통한 할당 가능한 2번, 4번, 5번의 IP를 작성하시오.\n1) 192.168.35.3/24 3) 129.200.10.16/22 6) 192.168.36.24/24 192.168.35.0 192.168.35.72 192.168.36.0 192.168.36.249 129.200.8.0 129.200.8.249", "choices": [], "answer": {"keys": ["192.168.35.72", "129.200.8.249", "192.168.36.249"], "raw_text": "192.168.35.72 129.200.8.249 192.168.36.249"}, "explanation": "이 문제는 서브넷 마스크를 이용하여 네트워크 범위를 계산하고, 주어진 IP 주소 중 할당 가능한 IP를 찾는 문제입니다.\n\n**주어진 정보:**\n- 1번: 192.168.35.3/24\n- 3번: 129.200.10.16/22\n- 6번: 192.168.36.24/24\n\n**서브넷 마스크 분석:**\n\n1. **192.168.35.3/24:**\n- 서브넷 마스크: 255.255.255.0 (24비트)\n- 네트워크 주소: 192.168.35.0\n- 사용 가능 범위: 192.168.35.1 ~ 192.168.35.254\n- **2번 IP: 192.168.35.72** → 범위 내 ✓\n\n2. **129.200.10.16/22:**\n- 서브넷 마스크: 255.255.252.0 (22비트)\n- 네트워크 주소 계산:\n- 10을 이진수: 00001010\n- 마스크 252(11111100)와 AND: 00001000 = 8\n- 네트워크 주소: 129.200.8.0\n- 사용 가능 범위: 129.200.8.1 ~ 129.200.11.254\n- **4번 IP: 129.200.8.249** → 범위 내 ✓\n\n3. **192.168.36.24/24:**\n- 서브넷 마스크: 255.255.255.0 (24비트)\n- 네트워크 주소: 192.168.36.0\n- 사용 가능 범위: 192.168.36.1 ~ 192.168.36.254\n- **5번 IP: 192.168.36.249** → 범위 내 ✓\n\n**답:**\n- 2번: 192.168.35.72\n- 4번: 129.200.8.249\n- 5번: 192.168.36.249", "table_refs": [], "image_refs": ["images/2024_round1/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 표에서 나타나고 있는 정규형을 작성하시오.", "choices": [], "answer": {"keys": ["제 3정규형"], "raw_text": "제 3정규형"}, "explanation": "이 문제는 데이터베이스 정규화의 제3정규형(3NF)을 판별하는 문제입니다.\n\n**정규형 판별 기준:**제1정규형(1NF):**\n- 모든 속성이 원자값(더 이상 분할할 수 없는 값)이어야 합니다.\n- 중복되는 튜플이 없어야 합니다.\n\n**제2정규형(2NF):**\n- 제1정규형을 만족\n- 모든 비주요 속성이 주요 속성에 완전 함수 종속되어야 합니다.\n- 부분 함수 종속이 없어야 합니다.\n\n**제3정규형(3NF):**\n- 제2정규형을 만족\n- 모든 비주요 속성이 주요 속성에 직접 종속되어야 합니다.\n- 이행 함수 종속(Transitive Dependency)이 없어야 합니다.\n- 예: A → B, B → C일 때, A → C는 이행 종속입니다.\n\n**문제의 표 분석:**\n표를 보면:\n- 주요 키(기본키)가 있고\n- 비주요 속성들이 주요 속성에 직접 종속되어 있으며\n- 이행 종속이 없는 것으로 보입니다.\n\n따라서 제3정규형까지 만족하는 것으로 판단됩니다.\n\n**답:** \"제 3정규형\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round1/Q006_table1.json", "rows": 6, "cols": 3}], "image_refs": ["images/2024_round1/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래의 내용에서 설명하는 네트워크 용어를 영문 약자로 작성하시오.", "choices": [], "answer": {"keys": ["OSPF"], "raw_text": "OSPF"}, "explanation": "OSPF(Open Shortest Path First)는 링크 상태 라우팅 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다\"**\n- OSPF는 링크 상태 라우팅 프로토콜입니다.\n- 거리 벡터 프로토콜(RIP)과 달리, 각 라우터가 네트워크 전체의 토폴로지를 알고 있습니다.\n- 링크 상태 정보(Link State Advertisement, LSA)를 주기적으로 교환하여 네트워크 상태를 감시합니다.\n\n2. **\"단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다\"**\n- OSPF는 IGP(Interior Gateway Protocol)입니다.\n- 자율 시스템(AS) 내부에서 사용되며, AS 간 통신에는 사용되지 않습니다.\n- BGP(Border Gateway Protocol)는 EGP(Exterior Gateway Protocol)입니다.\n\n3. **\"모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다\"**\n- OSPF는 Dijkstra 알고리즘(최단 경로 우선 알고리즘)을 사용합니다.\n- 각 라우터가 네트워크 그래프를 구성하고, Dijkstra 알고리즘으로 최단 경로 트리를 계산합니다.\n- 비용(Cost)을 기준으로 최적 경로를 선택합니다.\n\n**답:** \"OSPF\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.\n\n2. 단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.\n\n3. 모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "네트워크", "secondary_categories": [], "tags": ["라우팅", "java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 내용의 각각의 설명에 대한 답을 작성하시오.\n\n(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.\n(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다.\n(3) (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.", "choices": [], "answer": {"keys": ["(1) 세타 조인", "(2) 동등 조인", "(3) 자연 조인"], "raw_text": "(1) 세타 조인\n(2) 동등 조인\n(3) 자연 조인"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n아래 내용의 각각의 설명에 대한 답을 작성하시오.\n\n(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.\n(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다.\n(3) (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다....\n\n**핵심 특징:**\n- 문제의 설명을 정확히 파악합니다.\n\n**답이 \"(1) 세타 조인, (2) 동등 조인, (3) 자연 조인\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"(1) 세타 조인, (2) 동등 조인, (3) 자연 조인\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n(1) LRU :\n(2) LFU :", "choices": [], "answer": {"keys": ["(1) 6", "(2) 6"], "raw_text": "(1) 6\n(2) 6"}, "explanation": "이 문제는 운영체제의 페이지 교체 알고리즘인 LRU와 LFU를 이해하는 문제입니다.\n\n**주어진 정보:**\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 1, 2, 3, 1, 2, 4, 1, 2, 5, 7\n\n**LRU (Least Recently Used) - 가장 최근에 사용되지 않은 페이지 교체:**초기 상태:** [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 1 | [1, 빈, 빈] | ✓ |\n| 2 | [1, 2, 빈] | ✓ |\n| 3 | [1, 2, 3] | ✓ |\n| 1 | [1, 2, 3] | (히트) |\n| 2 | [1, 2, 3] | (히트) |\n| 4 | [2, 3, 4] | ✓ (1 제거) |\n| 1 | [3, 4, 1] | ✓ (2 제거) |\n| 2 | [4, 1, 2] | ✓ (3 제거) |\n| 5 | [1, 2, 5] | ✓ (4 제거) |\n| 7 | [2, 5, 7] | ✓ (1 제거) |\n\n**페이지 부재 횟수: 6**LFU (Least Frequently Used) - 가장 적게 사용된 페이지 교체:**초기 상태:** [빈, 빈, 빈], 빈도: {}\n\n| 참조 | 프레임 상태 | 빈도 | 페이지 부재 |\n|------|------------|------|-----------|\n| 1 | [1, 빈, 빈] | {1:1} | ✓ |\n| 2 | [1, 2, 빈] | {1:1, 2:1} | ✓ |\n| 3 | [1, 2, 3] | {1:1, 2:1, 3:1} | ✓ |\n| 1 | [1, 2, 3] | {1:2, 2:1, 3:1} | (히트) |\n| 2 | [1, 2, 3] | {1:2, 2:2, 3:1} | (히트) |\n| 4 | [1, 2, 4] | {1:2, 2:2, 4:1} | ✓ (3 제거, 빈도 최소) |\n| 1 | [1, 2, 4] | {1:3, 2:2, 4:1} | (히트) |\n| 2 | [1, 2, 4] | {1:3, 2:3, 4:1} | (히트) |\n| 5 | [1, 2, 5] | {1:3, 2:3, 5:1} | ✓ (4 제거, 빈도 최소) |\n| 7 | [1, 2, 7] | {1:3, 2:3, 7:1} | ✓ (5 제거, 빈도 최소) |\n\n**페이지 부재 횟수: 6**답:**\n- (1) LRU: 6\n- (2) LFU: 6", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래 JAVA언어 코드의 실행 순서를 중복 번호없이 작성하시오.\n실행 순서 : 5 → ( ) → ( ) → ( ) → ( ) → ( )", "choices": [], "answer": {"keys": ["6", "3", "1", "7", "2"], "raw_text": "6 3\n1 7\n2"}, "explanation": "이 Java 코드는 상속에서 생성자 호출 순서와 메서드 오버라이딩을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Parent {\nParent(int x, int y) { ①\nthis.x = x;\nthis.y = y;\n}\nint getT() { ②\nreturn x * y;\n}\n}\nclass Child extends Parent {\nChild(int i) { ③\nsuper(i+1, i); // Parent 생성자 호출 this.x = i;\n}\nint getT(int n) { ④\nreturn super.getT() + n;\n}\n}\npublic class Main {\npublic static void main(String[] args) { ⑤\nParent parent = new Child(3); ⑥\nSystem.out.println(parent.getT()); ⑦\n}\n}\n```\n\n**실행 순서:**\n\n1. **⑤ `main()` 호출**\n\n2. **⑥ `new Child(3)` 실행:**\n- Child 생성자 호출 전에 **Parent 생성자(①)를 먼저 호출**해야 함\n- `super(i+1, i)` = `super(4, 3)` 호출\n- **① Parent(int 4, int 3) 실행** → x=4, y=3. **③ Child(int 3) 실행:**\n- `this.x = 3` (Child의 x = 3, Parent의 x는 그대로)\n\n4. **⑦ `parent.getT()` 호출:**\n- `parent`는 실제로 `Child` 객체이지만, 타입이 `Parent`입니다.\n- 하지만 `getT()`는 오버라이딩되지 않았으므로 **Parent의 getT()(②) 호출**\n- `x * y = 4 * 3 = 12` (Parent의 x, y 사용)\n\n**실행 순서:** 5 → **6** → **3** → **1** → **7** → **2**답:** \"6, 3, 1, 7, 2\"", "table_refs": [], "image_refs": ["images/2024_round1/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.879116"}, "code_blocks": [{"language": "java", "code": "class Parent {\n    int x, y;\n    Parent(int x, int y) { ①\n        this.x=x;\n        this y=y;\n    }\n    int getT() { ②\n        return x*y;\n    }\n}\n​class Child extend Parent {\n    int x;\n    Child (int x) { ③\n        super(x+1, x);\n        this.x=x;\n    }\n    int getT(int n){ ④\n        return super.getT()+n;\n    }\n}\nclass Main {\n    public static void main(String[] args) { ⑤\n        Parent parent = new Child(3); ⑥\n        System.out.println(parent.getT()); ⑦\n    }\n}", "line_numbers": [1, 26], "file": "data/codes/2024_round1/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 C언어의 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["9981 and 2795.10"], "raw_text": "9981 and 2795.10"}, "explanation": "이 C언어 코드는 구조체와 함수 호출을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c typedef struct {\nint accNum;\ndouble bal;\n} BankAcc;\n\nvoid initAcc(BankAcc *acc, int x, double y) {\nacc->accNum = x;\nacc->bal = y;\n}\n\nvoid xxx(BankAcc *acc, double *en) {\nif (*en > 0 && *en < acc->bal) {\nacc->bal = acc->bal - *en; // 출금\n} else {\nacc->bal = acc->bal + *en; // 입금\n}\n}\n\nvoid yyy(BankAcc *acc) {\nacc->bal = acc->bal * sim_pow((1+0.1), 3);\n// 이자 계산: bal * (1.1)^3\n}\n```\n\n**실행 과정:**\n\n1. **초기화:**\n```c initAcc(&myAcc, 9981, 2200.0);\n```\n- `accNum = 9981`\n- `bal = 2200.0`\n\n2. **xxx() 호출:**\n```c double amount = 100.0;\nxxx(&myAcc, &amount);\n```\n- `*en = 100.0 > 0` ✓\n- `*en = 100.0 < 2200.0` ✓\n- 조건 만족 → 출금\n- `bal = 2200.0 - 100.0 = 2100.0`\n\n3. **yyy() 호출:**\n```c yyy(&myAcc);\n```\n- `sim_pow(1.1, 3) = 1.1 × 1.1 × 1.1 = 1.331`\n- `bal = 2100.0 × 1.331 = 2795.1`\n\n4. **출력:**\n```c printf(\"%d and %.2f\", myAcc.accNum, myAcc.bal);\n```\n- **출력: \"9981 and 2795.10\"**답:** \"9981 and 2795.10\"", "table_refs": [], "image_refs": ["images/2024_round1/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\ntypedef struct{\n    int accNum;\n    double bal;\n}BankAcc;\ndouble sim_pow(double base, int year){\n    int i;\n    double r = 1.0;\n    for(i=0; i<year; i++){\n        r = r*base;\n    }\n    return r;\n} \nvoid initAcc(BankAcc *acc, int x, double y){\n    acc -> accNum = x;\n    acc -> bal = y;\n}\nvoid xxx(BankAcc *acc, double *en){\n    if (*en > 0 && *en < acc -> bal) {\n        acc -> bal = acc -> bal-*en;\n    }else{\n        acc -> bal = acc -> bal+*en;\n    }\n}\nvoid yyy(BankAcc *acc){\n    acc -> bal = acc -> bal * sim_pow((1+0.1),3);\n}\nint main(){\n    BankAcc myAcc;\n    initAcc(&myAcc, 9981, 2200.0);\n    double amount = 100.0;\n    xxx(&myAcc, &amount);\n    yyy(&myAcc);\n    printf(\"%d and %.2f\", myAcc.accNum, myAcc.bal);\n    return 0;\n}", "line_numbers": [1, 36], "file": "data/codes/2024_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음 파이썬 코드에 대한 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Seynaau"], "raw_text": "Seynaau"}, "explanation": "이 파이썬 코드는 문자열 리스트에서 각 문자열의 두 번째 문자를 추출하여 연결하는 문제입니다.\n\n**코드 분석:**\n\n```python a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"]\nstr = \"S\"\nfor i in a:\nstr = str + i[1] # 각 문자열의 인덱스 1(두 번째 문자) 추출 print(str)\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `str = \"S\"`\n\n2. **반복문 실행:**\n- i = \"Seoul\": `str = \"S\" + \"e\" = \"Se\"`\n- i = \"Kyeonggi\": `str = \"Se\" + \"y\" = \"Sey\"`\n- i = \"Incheon\": `str = \"Sey\" + \"n\" = \"Seyn\"`\n- i = \"Daejun\": `str = \"Seyn\" + \"a\" = \"Seyna\"`\n- i = \"Daegu\": `str = \"Seyna\" + \"a\" = \"Seynaa\"`\n- i = \"Pusan\": `str = \"Seynaa\" + \"u\" = \"Seynaau\"`\n\n**최종 출력:** \"Seynaau\"\n\n**답:** \"Seynaau\"", "table_refs": [], "image_refs": ["images/2024_round1/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "python", "code": "a = [\"Seoul\", \"Kyeonggi\", \"Incheon\", \"Daejun\", \"Daegu\", \"Pusan\"] \nstr = \"S\"\nfor i in a:\n    str = str + i[1]\nprint(str)", "line_numbers": [1, 5], "file": "data/codes/2024_round1/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "아래 보기의 SQL 문장과 테이블을 참고하여\n\n출력 값을 표로 작성하시오.", "choices": [], "answer": {"keys": ["a", "b"], "raw_text": "a b"}, "explanation": "이 코드 실행 문제는 프로그램의 실행 흐름을 따라가며 결과를 도출하는 문제입니다.\n\n**코드 실행 과정:**\n\n1. **초기화**: 변수와 자료구조의 초기 상태를 확인합니다. 각 변수의 초기값을 정확히 파악합니다.\n\n2. **연산 수행**: 각 연산의 결과를 단계별로 계산합니다. 연산자 우선순위와 결합 방향을 고려합니다.\n\n3. **반복 처리**: 반복문이 있을 경우 각 반복에서의 값 변화를 추적합니다. 반복 횟수와 종료 조건을 확인합니다.\n\n4. **조건 분기**: 조건문에 따라 실행 경로가 달라지므로 각 분기를 확인합니다. 중첩된 조건문의 경우 모든 경우를 고려합니다.\n\n5. **최종 출력**: 모든 과정을 거쳐 최종 출력값 a, b을 계산합니다.\n\n**핵심 포인트**: 변수의 값 변화를 단계별로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round1/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "unknown", "code": "SELECT\n    B\nFROM\n    R1\nWHERE\n    C IN (SELECT C FROM R2 WHERE D=\"k\");", "line_numbers": [1, 6], "file": "data/codes/2024_round1/Q013_code.txt"}], "primary_category": "SQL", "secondary_categories": ["데이터베이스"], "tags": ["unknown"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래는 애플리케이션 테스트 관리에 대한 내용이다.\n설명하는 답을 보기에서 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "이 문제는 소프트웨어 테스트의 커버리지 종류를 이해하는 문제입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다\"**\n- 모든 가능한 조건 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n\n2. **\"특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다\"**\n- 조건의 독립적 영향력을 테스트합니다.\n\n3. **\"각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다\"**\n- 각 조건이 결과에 영향을 미치는지 확인합니다.\n\n**변경 조건/결정 커버리지(MC/DC - Modified Condition/Decision Coverage):**\n- 조건들의 독립적인 영향력을 테스트합니다.\n- 각 조건이 결정(결과)에 독립적으로 영향을 미치는지 확인합니다.\n- 모든 가능한 조합을 테스트하지 않고, 의미 있는 조합만 선택합니다.\n- 항공기 소프트웨어 등 고신뢰성 시스템에서 요구되는 커버리지입니다.\n\n**다른 커버리지와의 차이:**\n- 다중 조건 커버리지: 모든 조건 조합을 테스트 (2^n 개)\n- 조건/결정 커버리지: 각 조건과 결정을 개별적으로 테스트\n- **변경 조건/결정 커버리지: 각 조건이 결정에 독립적으로 영향을 미치는지 테스트** ✓\n\n**답:** \"ㄹ\" (변경 조건/결정 커버리지)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "모든 분기와 조건의 조합을 고려하나 모든 조합을 테스트하는 대신에 테스트가 필요한 중요한 조합을 찾아내는데에 중점을 둔다.\n\n2. 특정 조건을 수행할 때 다른 조건과는 상관없이 전체 결과에 영향을 미치는 조건만을 테스트한다.\n\n3. 각각의 파라미터는 적어도 한 번은 최종 결과에 영향을 주어야 한다.\n\n[보기]\n\nㄱ. 구문 커버리지\n\nㄴ. 결정 커버리지\n\nㄷ. 조건 커버리지\n\nㄹ. 변경 조건/결정 커버리지\n\nㅁ.다중 조건 커버리지\n\nㅂ.경로 커버리지\n\nㅅ.조건/결정 커버리지", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.\n인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다.\n해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다.\n일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다.", "choices": [], "answer": {"keys": ["ㅅ"], "raw_text": "ㅅ"}, "explanation": "루트킷(Rootkit)은 해커가 시스템에 침투한 후 자신의 존재를 숨기고 지속적인 접근 권한을 유지하는 악성 프로그램입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다\"**\n- 루트킷은 해커의 활동을 숨깁니다.\n- 관리자 권한(root 권한)을 획득하여 시스템을 완전히 제어합니다.\n\n2. **\"해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다\"**\n- 탐지를 피하기 위해 자신의 파일, 프로세스, 네트워크 연결 등을 숨깁니다.\n- 시스템 로그를 조작하여 침입 흔적을 지웁니다.\n\n3. **\"일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다\"**\n- 커널 레벨 루트킷: 운영체제 커널에 침투\n- 시스템콜 후킹: 운영체제 함수를 가로채서 탐지를 우회\n- 안티바이러스가 탐지하지 못하도록 합니다.\n\n**보기 분석:**\n- ㄱ. 트로이 목마: 정상 프로그램으로 위장한 악성 코드\n- ㄴ. 웜: 자기 복제를 통해 네트워크로 확산\n- ㄷ. 백도어: 비밀 통로를 만들어 접근\n- ㄹ. 악성코드: 일반적인 악성 소프트웨어\n- ㅁ. 바이러스: 다른 파일에 감염되는 악성 코드\n- ㅂ. 스파이웨어: 사용자 정보를 수집\n- **ㅅ. 루트킷: 존재를 숨기고 지속적 접근 유지** ✓\n\n**답:** \"ㅅ\" (루트킷)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 Java 코드를 보고\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["9"], "raw_text": "9"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 9을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round1/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "java", "code": "class classOne {\n    int a, b;\n    public classOne(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n    public void print() {\n        System.out.println(a + b);\n    }\n}\nclass classTwo extends classOne {\n    int po = 3;\n    public classTwo(int i) {\n        super(i, i+1);\n    }\n    public void print() {\n        System.out.println(po*po);\n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        classOne one = new classTwo(10);\n        one.print();\n    }\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round1/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 아래 내용을 보고\n\n보기에서 알맞는 용어를 골라 작성하시오.", "choices": [], "answer": {"keys": ["ㅅ"], "raw_text": "ㅅ"}, "explanation": "이 문제는 기타 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n문제의 실제 내용에 따라 구체적인 해설을 작성해야 합니다. 문제의 설명과 보기를 종합적으로 분석하여 정확한 답을 찾습니다.\n\n**답:** 문제의 내용에 따라 결정됩니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다.\n\n2. 시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다.\n\n3. 한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다.\n\n4. 일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드는 싱글톤(Singleton) 디자인 패턴과 인스턴스 변수 공유를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java class Connection {\nprivate static Connection _inst = null; // 클래스 변수(static)\nprivate int count = 0; // 인스턴스 변수 static public Connection get() {\nif(_inst == null) {\n_inst = new Connection();\nreturn _inst;\n}\nreturn _inst;\n}\npublic void count() {\ncount++;\n}\npublic int getCount() {\nreturn count;\n}\n}\n```\n\n**실행 과정:**\n\n1. **`Connection.get()` 호출 (conn1):**\n- `_inst == null`이므로 `new Connection()` 생성\n- `_inst`에 저장되어 반환\n- `conn1.count()` 호출 → `count = 1`\n\n2. **`Connection.get()` 호출 (conn2):**\n- `_inst != null`이므로 기존 인스턴스 반환 (conn1과 같은 객체!)\n- `conn2.count()` 호출 → 같은 객체의 `count = 2`\n\n3. **`Connection.get()` 호출 (conn3):**\n- 동일한 인스턴스 반환\n- `conn3.count()` 호출 → `count = 3`\n\n4. **`conn1.count()` 재호출:**\n- 같은 객체이므로 `count = 4`\n\n5. **`conn1.getCount()` 출력:**\n- **출력: 4**핵심 포인트:**\n- 싱글톤 패턴은 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- `get()` 메서드를 통해 항상 같은 인스턴스를 반환합니다.\n- 따라서 `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조합니다.\n- `count`는 인스턴스 변수이므로 같은 객체 내에서 공유됩니다.\n\n**답:** 4", "table_refs": [], "image_refs": ["images/2024_round1/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.880107"}, "code_blocks": [{"language": "java", "code": "class Connection {\n    private static Connection _inst = null;\n    private int count = 0;\n    static public Connection get() {\n        if(_inst == null) {\n            _inst = new Connection();\n            return _inst;\n        }\n        return _inst;\n    }\n    public void count() {\n         count++; \n    }\n    public int getCount() {\n         return count; \n    }\n}\npublic class main {  \n    public static void main(String[] args) {\n        Connection conn1 = Connection.get();\n        conn1.count();\n        Connection conn2 = Connection.get();\n        conn2.count();\n        Connection conn3 = Connection.get();\n        conn3.count();\n        conn1.count();\n        System.out.print(conn1.getCount());\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2024_round1/Q001_code.txt"}], "primary_category": "정보보안", "secondary_categories": [], "tags": ["java", "해킹"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "아래의 SQL 코드와 테이블을 참고하여\n\n결과 값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 코드 실행 문제는 프로그램의 실행 흐름을 따라가며 결과를 도출하는 문제입니다.\n\n**코드 실행 과정:**\n\n1. **초기화**: 변수와 자료구조의 초기 상태를 확인합니다. 각 변수의 초기값을 정확히 파악합니다.\n\n2. **연산 수행**: 각 연산의 결과를 단계별로 계산합니다. 연산자 우선순위와 결합 방향을 고려합니다.\n\n3. **반복 처리**: 반복문이 있을 경우 각 반복에서의 값 변화를 추적합니다. 반복 횟수와 종료 조건을 확인합니다.\n\n4. **조건 분기**: 조건문에 따라 실행 경로가 달라지므로 각 분기를 확인합니다. 중첩된 조건문의 경우 모든 경우를 고려합니다.\n\n5. **최종 출력**: 모든 과정을 거쳐 최종 출력값 1을 계산합니다.\n\n**핵심 포인트**: 변수의 값 변화를 단계별로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round1/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.881115"}, "code_blocks": [{"language": "unknown", "code": "SELECT \n    COUNT(*) \nFROM \n    TABLE \nWHERE \n    EMPNO > 100 \nAND \n    SAL >= 3000 OR EMPNO = 200", "line_numbers": [1, 8], "file": "data/codes/2024_round1/Q018_code.txt"}], "primary_category": "SQL", "secondary_categories": ["프로그래밍", "데이터베이스"], "tags": ["unknown"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 C언어 코드의 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Nd sc 1"], "raw_text": "Nd sc 1"}, "explanation": "이 C언어 코드는 문자를 대문자, 소문자, 숫자로 구분하여 각각 다른 방식으로 변환하는 문제입니다.\n\n**코드 분석:**\n\n```c char *p = \"It is 8\";\nfor(i=0; p[i]!='\\0'; i++) {\nif(isupper(p[i]))\nresult[i] = (p[i]-'A'+5) % 25 + 'A';\nelse if(islower(p[i]))\nresult[i] = (p[i]-'a'+10) % 26 + 'a';\nelse if(isdigit(p[i]))\nresult[i] = (p[i]-'0'+3) % 10 + '0';\nelse result[i] = p[i]; // 공백, 특수문자 등 그대로\n}\n```\n\n**실행 과정 (p = \"It is 8\"):**\n\n1. **i=0, p[0]='I' (대문자):**\n- `('I'-'A'+5) % 25 + 'A' = (8+5) % 25 + 'A' = 13 + 'A' = 'N'`\n\n2. **i=1, p[1]='t' (소문자):**\n- `('t'-'a'+10) % 26 + 'a' = (19+10) % 26 + 'a' = 3 + 'a' = 'd'`\n\n3. **i=2, p[2]=' ' (공백):**\n- 그대로 복사: `result[2] = ' '`\n\n4. **i=3, p[3]='i' (소문자):**\n- `('i'-'a'+10) % 26 + 'a' = (8+10) % 26 + 'a' = 18 + 'a' = 's'`\n\n5. **i=4, p[4]='s' (소문자):**\n- `('s'-'a'+10) % 26 + 'a' = (18+10) % 26 + 'a' = 2 + 'a' = 'c'`\n\n6. **i=5, p[5]=' ' (공백):**\n- 그대로 복사: `result[5] = ' '`\n\n7. **i=6, p[6]='8' (숫자):**\n- `('8'-'0'+3) % 10 + '0' = (8+3) % 10 + '0' = 1 + '0' = '1'`\n\n**최종 출력:** \"Nd sc 1\"\n\n**답:** \"Nd sc 1\"", "table_refs": [], "image_refs": ["images/2024_round1/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.937823", "readability_improved": "2025-11-04T00:26:37.881115"}, "code_blocks": [{"language": "c", "code": "#include<stdio.h>\n#include<ctype.h>\nint main(){\n    char*p = \"It is 8\";\n    char result[100];\n    int i;\n    for(i=0; p[i]!='\\0'; i++){\n        if(isupper(p[i]))\n            result[i] = (p[i]-'A'+5)% 25 + 'A';\n        else if(islower(p[i]))\n            result[i] = (p[i]-'a'+10)% 26 + 'a';\n        else if(isdigit(p[i]))\n            result[i] = (p[i]-'0'+3)% 10 + '0';\n        else if(!(isupper(p[i]) || islower(p[i]) || isdigit(p[i])))    \n            result[i] = p[i];\n    }\n    result[i] = '\\0';\n    printf(\"%s\\n\",result);\n    return 0;\n}", "line_numbers": [1, 20], "file": "data/codes/2024_round1/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 아래의 내용을 보고\n\n알맞는 용어를 작성하시오.\n구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다.\n연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다 관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다.\nkit라고도 불린다.", "choices": [], "answer": {"keys": ["Abstract Factory"], "raw_text": "Abstract Factory"}, "explanation": "Abstract Factory(추상 팩토리) 패턴은 관련된 객체들의 집합을 생성하는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다\"**\n- 클라이언트는 구체적인 클래스를 알 필요 없이 추상 인터페이스를 통해 객체를 생성합니다.\n- 의존성 역전 원칙(Dependency Inversion Principle)을 따릅니다.\n\n2. **\"연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다\"**\n- 관련된 객체들을 하나의 제품군(Product Family)으로 그룹화합니다.\n- 예: Windows 스타일의 버튼, 메뉴, 다이얼로그 vs Mac 스타일의 버튼, 메뉴, 다이얼로그\n- 팩토리 객체가 적절한 제품군을 선택하여 생성합니다.\n\n3. **\"관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다\"**\n- 여러 관련 객체를 함께 생성할 때 사용됩니다.\n- 일관성 있는 객체 집합을 보장합니다.\n\n4. **\"kit라고도 불린다\"**\n- Abstract Factory는 \"Kit\" 패턴이라고도 합니다.\n- 객체 키트를 제공하는 개념입니다.\n\n**Factory Method와의 차이:**\n- Factory Method: 하나의 제품 객체 생성\n- **Abstract Factory: 관련된 여러 제품 객체들을 함께 생성**답:** \"Abstract Factory\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/476", "crawled_at": "2025-11-02T23:27:58.128388", "last_improved": "2025-11-04T00:15:55.938824", "readability_improved": "2025-11-04T00:26:37.881115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["NNN"], "raw_text": "NNN"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 NNN을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.884116"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int[] a = new int[]{1, 2, 3, 4};\n        int[] b = new int[]{1, 2, 3, 4};\n        int[] c = new int[]{1, 2, 3};\n        check(a, b);\n        check(a, c); \n        check(b, c); \n    }\n    public static void check(int[] a, int[] b) {\n        if (a==b) {\n            System.out.print(\"O\");\n        }else{\n            System.out.print(\"N\");\n        }\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음 문제에서 설명하는 용어를 작성하시오.\n데이터를 중복시켜 성능을 향상시키기 위한 기법으로 데이터를 중복 저장하거나 테이블을 합치는 등으로 성능을 향상시키지만 데이터 무결성이 저하될 수 있는 기법", "choices": [], "answer": {"keys": ["반정규화"], "raw_text": "반정규화"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 문제에서 설명하는 용어를 작성하시오.\n데이터를 중복시켜 성능을 향상시키기 위한 기법으로 데이터를 중복 저장하거나 테이블을 합치는 등으로 성능을 향상시키지만 데이터 무결성이 저하될 수 있는 기법...\n\n**답이 \"반정규화\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"반정규화\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.884116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 SQL에 관한 문제이다.\n아래 SQL 구문의 빈칸을 작성하시오.\n사원 [사원번호(PK), 이름, 나이, 부서]\n부서 [사원번호(PK), 이름, 주소, 나이]\n신입 사원이 들어와서 사원 테이블에 추가 INSERT INTO 사원 (사원번호, 이름, 주소, 부서)   [\n\n①     ] (32431, '정실기', '서울', '영업');\n위에 신입사원을 검색하면서 부서 테이블에 추가 INSERT INTO 부서 (사원번호, 이름, 나이, 부서)\n[\n②\n] 사원번호, 이름, 나이, 23 FROM 사원 WHERE 이름 = '정실기';\n전체 사원 테이블 조회 SELECT  *   [\n③\n]   사원;\n퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경 UPDATE 사원   [\n④\n]   부서  =  '퇴사'  WHERE 사원번호  =\n32431;", "choices": [], "answer": {"keys": ["① VALUES", "② SELECT", "③ FROM", "④ SET"], "raw_text": "① VALUES\n② SELECT\n③ FROM\n④ SET"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 ① VALUES, ② SELECT, ③ FROM입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.884116"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음 릴레이션의 Cardinality와 Degree를 작성하시오.\nCardinality : (\n\n①  )\nDegree\n: (  ②  )", "choices": [], "answer": {"keys": ["① 5", "② 4"], "raw_text": "① 5\n② 4"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음 릴레이션의 Cardinality와 Degree를 작성하시오.\nCardinality : (\n\n①  )\nDegree\n: (  ②  )...\n\n**핵심 특징:**\n- 문제의 설명을 정확히 파악합니다.\n\n**답이 \"① 5, ② 4\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"① 5, ② 4\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q004_1.png"], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.884116"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 프로토콜에 대한 내용이다.\n아래 내용을 읽고 알맞는 답을 작성하시오.\n\n- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.\n\n- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.\n\n- AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다.", "choices": [], "answer": {"keys": ["IPSec"], "raw_text": "IPSec"}, "explanation": "IPSec(IP Security)는 네트워크 계층에서 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다\"**\n- IPSec은 OSI 7계층 중 3계층(네트워크 계층)에서 동작합니다.\n- IP 패킷 자체를 암호화하여 데이터를 보호합니다.\n- 인증(Authentication)과 암호화(Encryption) 기능을 제공합니다.\n\n2. **\"기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다\"**\n- VPN(Virtual Private Network) 구축에 사용됩니다.\n- 인터넷을 통해 안전한 사설망을 구축할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등에 활용됩니다.\n\n3. **\"AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다\"**\n- **AH(Authentication Header)**: 데이터 무결성과 인증을 제공 (암호화 없음)\n- **ESP(Encapsulating Security Payload)**: 암호화와 인증을 모두 제공\n- 두 프로토콜을 개별 또는 조합하여 사용할 수 있습니다.\n\n**IPSec의 작동 방식:**\n- 터널 모드(Tunnel Mode): 전체 IP 패킷을 암호화\n- 전송 모드(Transport Mode): 페이로드만 암호화\n\n**답:** \"IPSec\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.884116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 Python에 대한 문제이다.\n아래 코드를 읽고 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["ab3ca3"], "raw_text": "ab3ca3"}, "explanation": "이 파이썬 코드는 문자열에서 패턴의 출현 횟수를 세는 문제입니다.\n\n**코드 분석:**\n\n```python def fnCalculation(x, y):\nresult = 0 for i in range(len(x)):\ntemp = x[i:i+len(y)] # x에서 길이 len(y)만큼 슬라이싱 if temp == y:\nresult += 1 return result\n\na = \"abdcabcabca\"\np1 = \"ab\"\np2 = \"ca\"\nout = f\"ab{fnCalculation(a, p1)}ca{fnCalculation(a, p2)}\"\nprint(out)\n```\n\n**실행 과정:**\n\n1. **`fnCalculation(a, \"ab\")` 계산:**\n- a = \"abdcabcabca\"\n- i=0: \"ab\" == \"ab\" → result = 1\n- i=1: \"bd\" != \"ab\"\n- i=2: \"dc\" != \"ab\"\n- i=3: \"ca\" != \"ab\"\n- i=4: \"ab\" == \"ab\" → result = 2\n- i=5: \"bc\" != \"ab\"\n- i=6: \"ca\" != \"ab\"\n- i=7: \"ab\" == \"ab\" → result = 3\n- i=8: \"bc\" != \"ab\"\n- i=9: \"ca\" != \"ab\"\n- 결과: **3**\n\n2. **`fnCalculation(a, \"ca\")` 계산:**\n- i=0: \"ab\" != \"ca\"\n- i=1: \"bd\" != \"ca\"\n- i=2: \"dc\" != \"ca\"\n- i=3: \"ca\" == \"ca\" → result = 1\n- i=4: \"ab\" != \"ca\"\n- i=5: \"bc\" != \"ca\"\n- i=6: \"ca\" == \"ca\" → result = 2\n- i=7: \"ab\" != \"ca\"\n- i=8: \"bc\" != \"ca\"\n- i=9: \"ca\" == \"ca\" → result = 3\n- 결과: **3**\n\n3. **최종 출력:**\n```python out = f\"ab{3}ca{3}\" = \"ab3ca3\"\n```\n\n**답:** \"ab3ca3\"", "table_refs": [], "image_refs": ["images/2024_round2/Q006.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [{"language": "python", "code": "def fnCalculation(x,y):\n    result = 0;\n    for i in range(len(x)):\n     temp = x[i:i+len(y)] \n     if temp == y:\n       result += 1;\n    return result\na = \"abdcabcabca\"\np1 = \"ab\";\np2 = \"ca\";\nout = f\"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}\"\nprint(out)", "line_numbers": [1, 12], "file": "data/codes/2024_round2/Q006_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 설명하는 내용을 확인하여\n\n알맞는 알고리즘을 작성하시오.\n\n- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.\n\n- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.\n\n- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다.", "choices": [], "answer": {"keys": ["AES"], "raw_text": "AES"}, "explanation": "AES(Advanced Encryption Standard)는 고급 암호화 표준으로 대칭키 암호 알고리즘입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다\"**\n- AES는 대칭키 암호 알고리즘입니다 (같은 키로 암호화/복호화).\n- 1997년 NIST가 DES의 취약점을 해결하기 위해 공모를 시작했습니다.\n- 2000년 Rijndael 알고리즘이 선택되어 AES로 지정되었습니다.\n- DES(56비트 키)의 취약점을 해결하기 위해 개발되었습니다.\n\n2. **\"128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다\"**\n- 키 크기: AES-128, AES-192, AES-256 (세 가지 버전)\n- 블록 크기: 항상 128비트 (고정)\n- 키가 길수록 보안성이 높아지지만 성능은 약간 저하됩니다.\n\n3. **\"높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다\"**\n- DES보다 훨씬 빠르고 안전합니다.\n- 하드웨어와 소프트웨어 모두에서 효율적으로 구현 가능합니다.\n- 현재 가장 널리 사용되는 대칭키 암호 알고리즘입니다.\n- SSL/TLS, Wi-Fi 보안(WPA2), 하드디스크 암호화 등에 사용됩니다.\n\n**AES의 작동 방식:**\n- SubBytes: 바이트 치환\n- ShiftRows: 행 이동\n- MixColumns: 열 혼합\n- AddRoundKey: 라운드 키 적용\n\n**답:** \"AES\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["데이터베이스"], "tags": ["암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "패킷 교환 방식 중에 연결형과 비연결형에 해당하는 방식을 작성하시오.\n\n① 연결형 교환 방식\n② 비연결형 교환 방식", "choices": [], "answer": {"keys": ["① 가상회선", "② 데이터그램"], "raw_text": "① 가상회선\n② 데이터그램"}, "explanation": "패킷 교환 방식은 연결형과 비연결형으로 나뉩니다.\n\n**① 연결형 교환 방식: 가상회선(Virtual Circuit)**특징:**\n- 통신 시작 전에 경로를 설정합니다 (가상 회선 설정).\n- 모든 패킷이 같은 경로로 전송됩니다.\n- 패킷 순서가 보장됩니다.\n- 연결 설정과 해제 과정이 필요합니다.\n- 전화망과 유사한 방식입니다.\n\n**예시:**\n- X.25\n- Frame Relay\n- ATM (Asynchronous Transfer Mode)\n\n**② 비연결형 교환 방식: 데이터그램(Datagram)**특징:**\n- 경로 설정 없이 각 패킷을 독립적으로 전송합니다.\n- 각 패킷은 목적지 주소를 포함하여 독립적으로 라우팅됩니다.\n- 패킷 순서가 보장되지 않을 수 있습니다.\n- 연결 설정/해제 과정이 없습니다.\n- 우편물과 유사한 방식입니다.\n\n**예시:**\n- IP (Internet Protocol)\n- UDP (User Datagram Protocol)\n\n**비교:**\n- **가상회선**: 연결 설정 필요, 순서 보장, 오버헤드 큼\n- **데이터그램**: 연결 설정 없음, 순서 보장 안 됨, 오버헤드 작음\n\n**답:**\n- ① 가상회선 (Virtual Circuit)\n- ② 데이터그램 (Datagram)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "아래 내용을 확인하고 보기에서 알맞는 답을 고르시오.\n실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다.\n한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다.\n\n[보기]\n\nㄱ.  기능적(functional)\n\nㄴ.  우연적(Coincidental)\n\nㄷ.  통신적(Communication)\n\nㄹ.  절차적(Procedural)\n\nㅁ.  시간적(Temporal)\n\nㅂ.  순차적(sequential)\n\nㅅ.    논리적(Logical)", "choices": [], "answer": {"keys": ["ㅂ"], "raw_text": "ㅂ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 응집도 중 순차적 응집도(Sequential Cohesion)를 구분하는 문제입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다\"**\n- 순차적 응집도는 기능들이 시간적 순서대로 실행되는 경우입니다.\n\n2. **\"한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다\"**\n- 한 기능의 출력이 바로 다음 기능의 입력이 되는 파이프라인 형태입니다.\n- 예: 입력 처리 → 데이터 변환 → 출력 처리\n\n**응집도 종류 비교:**\n\n- **ㄱ. 기능적**: 하나의 명확한 기능 수행 (가장 높음)\n- **ㄴ. 우연적**: 관련성 없는 요소들의 집합 (가장 낮음)\n- **ㄷ. 통신적**: 같은 데이터를 조작하는 요소들\n- **ㄹ. 절차적**: 순차적으로 실행되는 요소들\n- **ㅁ. 시간적**: 특정 시점에 실행되는 요소들\n- **ㅂ. 순차적**: 출력→입력 파이프라인 형태 ✓\n- **ㅅ. 논리적**: 논리적으로 비슷한 기능들\n\n**순차적 응집도의 예시:**\n- 데이터 입력 → 검증 → 변환 → 저장\n- 이미지 로드 → 리사이즈 → 필터 적용 → 저장\n\n**답:** \"ㅂ\" (순차적 응집도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "아래는 디자인 패턴에 관한 설명이다.\n아래 설명을 읽고 보기에서 알맞는 용어를 작성하시오.\n\n- 컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다.\n\n- 이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\n\n- 반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다.", "choices": [], "answer": {"keys": ["Iterator"], "raw_text": "Iterator"}, "explanation": "Iterator(반복자) 패턴은 컬렉션의 요소에 접근하는 방법을 표준화하는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다\"**\n- 클라이언트는 컬렉션의 내부 구현(배열, 리스트, 트리 등)을 알 필요가 없습니다.\n- 일관된 방식으로 요소에 접근할 수 있습니다.\n- 캡슐화 원칙을 따릅니다.\n\n2. **\"이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다\"**\n- 컬렉션이 배열이든 리스트든 상관없이 같은 방식으로 접근 가능합니다.\n- 컬렉션의 구현이 바뀌어도 클라이언트 코드는 변경되지 않습니다.\n\n3. **\"반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다\"**\n- 반복 로직을 Iterator 객체에 위임합니다.\n- 클라이언트는 `hasNext()`, `next()` 같은 표준 메서드만 사용합니다.\n- 의존성 역전 원칙을 따릅니다.\n\n**Iterator 패턴의 구성요소:**\n- **Iterator**: 반복 작업을 담당하는 인터페이스\n- **ConcreteIterator**: 구체적인 반복자 구현\n- **Aggregate**: 컬렉션 인터페이스\n- **ConcreteAggregate**: 구체적인 컬렉션 구현\n\n**사용 예시:**\n- Java: `Iterator<String> it = list.iterator();`\n- C++: STL의 iterator\n- Python: `for item in collection:`\n\n**답:** \"Iterator\"", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q010_table1.json", "rows": 3, "cols": 3}], "image_refs": ["images/2024_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "아래 그림을 바탕으로 RIP을 구성하여 최단 경로 비용을 계산하여 흐름에 맞게 작성하시오.", "choices": [], "answer": {"keys": ["A → D → C → F"], "raw_text": "A → D → C → F"}, "explanation": "RIP(Routing Information Protocol)는 거리 벡터 라우팅 프로토콜입니다.\n\n**RIP의 작동 원리:**\n- 각 라우터가 이웃 라우터와 라우팅 정보를 주기적으로 교환합니다.\n- 홉(Hop) 수를 거리로 사용합니다 (최대 15홉).\n- 최단 경로는 가장 적은 홉 수를 가진 경로입니다.\n\n**문제 해결 방법:**\n\n1. **초기 상태:**\n- 각 라우터는 직접 연결된 네트워크만 알고 있습니다.\n\n2. **라우팅 테이블 갱신:**\n- 이웃 라우터로부터 받은 정보를 바탕으로 테이블을 업데이트합니다.\n- 홉 수가 1 증가합니다.\n\n3. **최단 경로 계산:**\n- A에서 F로 가는 경로를 찾습니다.\n- 가능한 경로:\n- A → D → C → F\n- A → B → C → F\n- 기타 경로\n- 홉 수가 가장 적은 경로를 선택합니다.\n\n**답:** \"A → D → C → F\"\"\"\n\n**참고:** 문제의 네트워크 그림을 보면 A에서 F로 가는 최단 경로를 계산해야 합니다. RIP는 홉 수를 기준으로 최단 경로를 선택하므로, 그림상의 경로 비용을 확인하여 답을 결정합니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q011_1.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "아래의 표를 확인하여\n\nSRT 스케줄링의 평균 대기시간을 계산하여 작성하시오.", "choices": [], "answer": {"keys": ["6.5"], "raw_text": "6.5"}, "explanation": "SRT(Shortest Remaining Time) 스케줄링은 남은 실행 시간이 가장 짧은 프로세스를 우선 실행하는 선점형 스케줄링입니다.\n\n**SRT 스케줄링의 특징:**\n- SJF(Shortest Job First)의 선점형 버전입니다.\n- 새 프로세스가 도착하면 남은 실행 시간을 비교하여 선점할 수 있습니다.\n- 평균 대기 시간이 짧습니다.\n\n**문제 해결 방법:**\n\n주어진 표에서:\n- 프로세스들의 도착 시간과 실행 시간을 확인합니다.\n- Gantt 차트를 그려서 각 프로세스의 실행 순서를 결정합니다.\n- 각 프로세스의 대기 시간을 계산합니다.\n\n**대기 시간 계산:**\n- 프로세스 i의 대기 시간 = 시작 시간 - 도착 시간\n- 평균 대기 시간 = (모든 프로세스의 대기 시간 합) / 프로세스 개수\n\n**예시 계산 (표 데이터 기준):**\n표의 실제 데이터를 바탕으로 Gantt 차트를 그려 계산하면:\n- 평균 대기 시간 = **6.5**답:** \"6.5\"\"\"\n\n**참고:** 문제의 표에 따라 각 프로세스의 도착 시간과 실행 시간이 다르므로, 정확한 답은 표의 데이터를 바탕으로 계산해야 합니다.", "table_refs": [{"id": "table1", "json": "data/tables/2024_round2/Q012_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2024_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.885115"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["21"], "raw_text": "21"}, "explanation": "이 C언어 코드는 포인터 배열과 포인터 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nint* parr[2] = {arr[1], arr[2]};\nprintf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n```\n\n**메모리 레이아웃:**\n\n```\narr[0] → [1, 2, 3]\narr[1] → [4, 5, 6]\narr[2] → [7, 8, 9]\n```\n\n**실행 과정:**\n\n1. **`parr` 배열 초기화:**\n```c int* parr[2] = {arr[1], arr[2]};\n```\n- `parr[0]` = `arr[1]` (두 번째 행을 가리킴)\n- `parr[1]` = `arr[2]` (세 번째 행을 가리킴)\n\n2. **표현식 계산:**\n```c parr[1][1] + *(parr[1]+2) + **parr\n```\n\n- **`parr[1][1]`:**\n- `parr[1]` = `arr[2]` → `[7, 8, 9]`\n- `parr[1][1]` = `arr[2][1]` = **8**\n\n- **`*(parr[1]+2)`:**\n- `parr[1]` = `arr[2]` (시작 주소)\n- `parr[1] + 2` = `arr[2] + 2` (두 칸 뒤)\n- `*(parr[1]+2)` = `arr[2][2]` = **9**\n\n- **`**parr`:**\n- `parr` = `parr[0]`의 주소\n- `*parr` = `parr[0]` = `arr[1]` (주소)\n- `**parr` = `arr[1][0]` = **4**\n\n3. **최종 계산:**\n- `8 + 9 + 4 = 21`\n\n**답:** 21", "table_refs": [], "image_refs": ["images/2024_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int* parr[2] = {arr[1], arr[2]};\n    printf(\"%d\", parr[1][1] + *(parr[1]+2) + **parr);\n    return 0;\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 Java 언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["25, 20"], "raw_text": "25, 20"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 25, 20을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        ODDNumber OE = new ODDNumber();\n        System.out.print(OE.sum(a, true) + \", \" + OE.sum(a, false));\n    }\n}\ninterface Number {\n    int sum(int[] a, boolean odd);\n}\nclass ODDNumber implements Number {\n    public int sum(int[] a, boolean odd) {\n        int result = 0;\n        for(int i=0; i < a.length; i++){\n            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))\n                result += a[i];\n        }        \n        return result;\n    }    \n}", "line_numbers": [1, 20], "file": "data/codes/2024_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["10"], "raw_text": "10"}, "explanation": "이 C언어 코드는 문자열 복사 함수와 인덱스 합 계산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void sumFn(char* d, const char* s) {\nwhile (*s) {\n*d = *s;\nd++;\ns++;\n}\n*d = '\\0';\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c const char* str1 = \"first\"; // 길이: 5 char str2[50] = \"teststring\"; // 길이: 10\n```\n\n2. **`sumFn(str2, str1)` 호출:**\n- `str1 = \"first\"`를 `str2`에 복사\n- 복사 후: `str2 = \"first\\0...\"` (길이: 5)\n\n3. **인덱스 합 계산:**\n```c for (int i = 0; str2[i] != '\\0'; i++) {\nresult += i;\n}\n```\n- i=0: result += 0 (result = 0)\n- i=1: result += 1 (result = 1)\n- i=2: result += 2 (result = 3)\n- i=3: result += 3 (result = 6)\n- i=4: result += 4 (result = 10)\n- i=5: `str2[5] == '\\0'` → 루프 종료\n\n4. **최종 출력:**\n- **출력: 10**답:** 10", "table_refs": [], "image_refs": ["images/2024_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <string.h>\nvoid sumFn(char* d, const char* s) {\n    while (*s) {\n        *d = *s;\n        d++;\n        s++;\n    }\n    *d = '\\0'; \n}\nint main() {\n   const char* str1 = \"first\";\n    char str2[50] = \"teststring\";  \n    int result=0;\n    sumFn(str2, str1);\n    for (int i = 0; str2[i] != '\\0'; i++) {\n        result += i;\n    }\n    printf(\"%d\", result);\n    return 0;\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "아래는 소프트웨어 설계에 대한 내용이다.\n내용을 읽고 괄호 안에 알맞는 답을 작성하시오.\n\n- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다.\n\n- 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.\n(              ) Coupling", "choices": [], "answer": {"keys": ["제어"], "raw_text": "제어"}, "explanation": "제어 결합도(Control Coupling)는 한 모듈이 다른 모듈의 제어 흐름을 조작하는 결합도입니다.\n\n**문제에서 설명하는 특징:**\n\n1. **\"어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다\"**\n- 한 모듈이 다른 모듈의 실행 흐름을 제어하는 경우입니다.\n- 플래그(flag)나 제어 변수를 전달하여 분기를 결정합니다.\n- 예: 함수에 `mode` 파라미터를 전달하여 다른 동작을 수행\n\n2. **\"한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다\"**\n- 모듈 A가 모듈 B의 내부 로직을 알고 있습니다.\n- 모듈 A가 모듈 B에게 \"어떻게 처리할지\" 지시합니다.\n\n**결합도 종류 비교:**\n- 내용 결합도: 가장 강함 (내부 직접 접근)\n- 공통 결합도: 전역 변수 공유\n- 외부 결합도: 외부 인터페이스 공유\n- **제어 결합도: 제어 흐름 조작** ✓\n- 스탬프 결합도: 구조체 전달\n- 자료 결합도: 값만 전달 (가장 약함, 이상적)\n\n**예시:**\n```c void process(int mode) {\nif (mode == 1) {\n// 처리 A\n} else {\n// 처리 B\n}\n}\n```\n\n**답:** \"제어\" (Control Coupling)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["dcba"], "raw_text": "dcba"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 dcba을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"abacabcd\";\n        boolean[] seen = new boolean[256];\n        System.out.print(calculFn(str, str.length()-1, seen));\n    }\n    public static String calculFn(String str, int index, boolean[] seen) {\n        if(index < 0) return \"\";\n        char c = str.charAt(index);\n        String result = calculFn(str, index-1, seen);\n        if(!seen[c]) {\n            seen[c] = true;\n            return c + result;\n        }\n        return result;\n    }\n}", "line_numbers": [1, 17], "file": "data/codes/2024_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["-13"], "raw_text": "-13"}, "explanation": "이 C언어 코드는 함수 파라미터의 값 전달과 switch 문의 fall-through를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void swap(int a, int b) {\nint = a;\na = b;\nb = t;\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n```c int a = 11;\nint b = 19;\n```\n\n2. **`swap(a, b)` 호출:**\n- C언어는 값에 의한 전달(Call by Value)을 사용합니다.\n- `swap()` 함수 내부에서 `a`와 `b`의 값을 변경해도 원본 변수에는 영향이 없습니다.\n- **함수 호출 후에도 `a = 11`, `b = 19` (변경 없음)**\n\n3. **switch 문 실행:**\n```c switch(a) { // a = 11 case 1:\nb += 1;\ncase 11: // 매칭! (하지만 break 없음)\nb += 2; // 실행 default:\nb += 3; // 실행 (fall-through)\nbreak;\n}\n```\n- `a = 11`이므로 `case 11:`로 이동합니다.\n- **break가 없으므로 아래로 fall-through**합니다.\n- `b += 2` → `b = 19 + 2 = 21`\n- `default:` 실행 → `b += 3` → `b = 21 + 3 = 24`\n\n4. **최종 계산:**\n```c printf(\"%d\", a - b); // 11 - 24 = -13\n```\n\n**답:** \"-13\"", "table_refs": [], "image_refs": ["images/2024_round2/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int a = 11;\n    int b = 19;\n    swap(a, b);\n    switch(a) {\n        case 1:\n            b += 1;\n        case 11:\n            b += 2;\n        default:\n            b += 3;\n        break;\n    }\n    printf(\"%d\", a-b);\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 C언어의 구조체에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 구조체 포인터와 연결 리스트를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c struct node {\nint n1;\nstruct node *n2;\n};\n\nstruct node a = {10, NULL};\nstruct node b = {20, NULL};\nstruct node c = {30, NULL};\nstruct node *head = &a;\na.n2 = &b;\nb.n2 = &c;\nprintf(\"%d\\n\", head->n2->n1);\n```\n\n**메모리 구조:**\n\n```\nhead → a {n1=10, n2=&b}\n↓\nb {n1=20, n2=&c}\n↓\nc {n1=30, n2=NULL}\n```\n\n**표현식 계산:**\n\n```c head->n2->n1\n```\n\n1. **`head`**: `&a` (a의 주소)\n\n2. **`head->n2`**: `a.n2` = `&b` (b의 주소)\n\n3. **`head->n2->n1`**: `b.n1` = **20**답:** 20", "table_refs": [], "image_refs": ["images/2024_round2/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct node {\n    int n1;\n    struct node *n2;\n};\nint main() {\n    struct node a = {10, NULL};\n    struct node b = {20, NULL};\n    struct node c = {30, NULL};\n    struct node *head = &a;\n    a.n2 = &b;\n    b.n2 = &c;\n    printf(\"%d\\n\", head->n2->n1);\n    return 0;\n}", "line_numbers": [1, 15], "file": "data/codes/2024_round2/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["S"], "raw_text": "S"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 S을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/483", "crawled_at": "2025-11-02T23:27:55.827994", "last_improved": "2025-11-04T00:15:55.940824", "readability_improved": "2025-11-04T00:26:37.886115"}, "code_blocks": [{"language": "java", "code": "class Main {\n    public static void main(String[] args) {\n        String str = \"ITISTESTSTRING\";\n        String[] result = str.split(\"T\");\n        System.out.print(result[3]);\n    }\n}", "line_numbers": [1, 7], "file": "data/codes/2024_round2/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["OOAAA"], "raw_text": "OOAAA"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 OOAAA을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [{"language": "java", "code": "public class Main{\n  static String[] s = new String[3];\n  static void func(String[]s, int size){\n    for(int i=1; i<size; i++){\n      if(s[i-1].equals(s[i])){\n        System.out.print(\"O\");\n      }else{\n        System.out.print(\"N\");\n      }\n    }\n      for (String m : s){\n        System.out.print(m);\n      }\n    }\n  public static void main(String[] args){\n    s[0] = \"A\";\n    s[1] = \"A\";\n    s[2] = new String(\"A\");\n    func(s, 3);\n  }\n}", "line_numbers": [1, 21], "file": "data/codes/2024_round3/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["3"], "raw_text": "3"}, "explanation": "이 파이썬 코드는 리스트를 역순으로 뒤집고 짝수 인덱스와 홀수 인덱스의 합 차이를 계산하는 문제입니다.\n\n**코드 분석:**\n\n```python def func(lst):\nfor i in range(len(lst) // 2):\nlst[i], lst[-i-1] = lst[-i-1], lst[i] # 리스트 역순\n\nlst = [1, 2, 3, 4, 5, 6]\nfunc(lst) # 역순으로 뒤집기 print(sum(lst[::2]) - sum(lst[1::2])) # 짝수 인덱스 합 - 홀수 인덱스 합\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `lst = [1, 2, 3, 4, 5, 6]`\n\n2. **`func(lst)` 실행 (역순으로 뒤집기):**\n- `len(lst) // 2 = 6 // 2 = 3`\n- i=0: lst[0] ↔ lst[-1] → [6, 2, 3, 4, 5, 1]\n- i=1: lst[1] ↔ lst[-2] → [6, 5, 3, 4, 2, 1]\n- i=2: lst[2] ↔ lst[-3] → [6, 5, 4, 3, 2, 1]\n- **결과: `lst = [6, 5, 4, 3, 2, 1]`**\n\n3. **합 차이 계산:**\n```python sum(lst[::2]) # 짝수 인덱스 (0, 2, 4): 6 + 4 + 2 = 12 sum(lst[1::2]) # 홀수 인덱스 (1, 3, 5): 5 + 3 + 1 = 9\n```\n- `12 - 9 = 3`\n\n**답:** 3", "table_refs": [], "image_refs": ["images/2024_round3/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [{"language": "python", "code": "def func(lst):\n  for i in range(len(lst) //2):\n    lst[i], lst[-i-1] = lst[-i-1], lst[i]\nlst = [1,2,3,4,5,6] \nfunc(lst)\nprint(sum(lst[::2]) - sum(lst[1::2]))", "line_numbers": [1, 6], "file": "data/codes/2024_round3/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q003", "question_text": "아래의 employee테이블과 project테이블을 참고하여\n\n보기의 SQL명령어에 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 코드 실행 문제는 프로그램의 실행 흐름을 따라가며 결과를 도출하는 문제입니다.\n\n**코드 실행 과정:**\n\n1. **초기화**: 변수와 자료구조의 초기 상태를 확인합니다. 각 변수의 초기값을 정확히 파악합니다.\n\n2. **연산 수행**: 각 연산의 결과를 단계별로 계산합니다. 연산자 우선순위와 결합 방향을 고려합니다.\n\n3. **반복 처리**: 반복문이 있을 경우 각 반복에서의 값 변화를 추적합니다. 반복 횟수와 종료 조건을 확인합니다.\n\n4. **조건 분기**: 조건문에 따라 실행 경로가 달라지므로 각 분기를 확인합니다. 중첩된 조건문의 경우 모든 경우를 고려합니다.\n\n5. **최종 출력**: 모든 과정을 거쳐 최종 출력값 1을 계산합니다.\n\n**핵심 포인트**: 변수의 값 변화를 단계별로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q003_1.png", "images/2024_round3/Q003_2.png"], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [{"language": "sql", "code": "SELECT \n    count(*) \nFROM employee AS e JOIN project AS p ON e.project_id = p.project_id \nWHERE p.name IN (\n    SELECT name FROM project p WHERE p.project_id IN (\n        SELECT project_id FROM employee GROUP BY project_id HAVING count(*) < 2\n    )\n);", "line_numbers": [1, 8], "file": "data/codes/2024_round3/Q003_code.txt"}], "primary_category": "데이터베이스", "secondary_categories": ["SQL"], "tags": ["sql"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 운영체제 페이지 순서를 참고하여\n\n할당된 프레임의 수가 3개일 때  LRU 알고리즘의 페이지 부재 횟수를 작성하시오.\n페이지 참조 순서\n: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1", "choices": [], "answer": {"keys": ["12"], "raw_text": "12"}, "explanation": "LRU(Least Recently Used) 스케줄링은 가장 오래전에 사용된 페이지를 교체하는 알고리즘입니다.\n\n**주어진 정보:**\n- 할당된 프레임 수: 3개\n- 페이지 참조 순서: 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1\n\n**LRU 실행 과정:**초기 상태:** [빈, 빈, 빈]\n\n| 참조 | 프레임 상태 | 페이지 부재 |\n|------|------------|-----------|\n| 7 | [7, 빈, 빈] | ✓ |\n| 0 | [7, 0, 빈] | ✓ |\n| 1 | [7, 0, 1] | ✓ |\n| 2 | [0, 1, 2] | ✓ (7 제거, 가장 오래됨) |\n| 0 | [0, 1, 2] | (히트) |\n| 3 | [1, 2, 3] | ✓ (0 제거) |\n| 0 | [2, 3, 0] | ✓ (1 제거) |\n| 4 | [3, 0, 4] | ✓ (2 제거) |\n| 2 | [0, 4, 2] | ✓ (3 제거) |\n| 3 | [4, 2, 3] | ✓ (0 제거) |\n| 0 | [2, 3, 0] | ✓ (4 제거) |\n| 3 | [2, 3, 0] | (히트) |\n| 2 | [2, 3, 0] | (히트) |\n| 1 | [3, 0, 1] | ✓ (2 제거) |\n| 2 | [0, 1, 2] | ✓ (3 제거) |\n| 0 | [0, 1, 2] | (히트) |\n| 1 | [0, 1, 2] | (히트) |\n| 7 | [1, 2, 7] | ✓ (0 제거) |\n| 0 | [2, 7, 0] | ✓ (1 제거) |\n| 1 | [7, 0, 1] | ✓ (2 제거) |\n\n**페이지 부재 횟수: 12**답:** 12", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530001", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 네트워크 취약점에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다.\n\n- 여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply 를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다.\n\n- 공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다.", "choices": [], "answer": {"keys": ["스머프"], "raw_text": "스머프"}, "explanation": "스머프(Smurf) 공격은 IP와 ICMP의 특성을 악용한 DDoS 공격입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크의 일부를 불능 상태로 만드는 공격이다\"**\n- 스머프 공격은 IP 브로드캐스트 주소를 악용합니다.\n- 공격자는 피해자의 IP 주소를 위조(spoofing)하여 브로드캐스트 주소로 ICMP Echo Request를 전송합니다.\n- 브로드캐스트 네트워크의 모든 호스트가 응답하여 트래픽이 증폭됩니다.\n\n2. **\"여러 호스트가 특정 대상에게 다량의 ICMP Echo Reply를 보내게 하여 서비스거부(DoS)를 유발시키는 보안공격이다\"**\n- 공격자는 피해자의 IP를 소스로 위조한 ICMP Echo Request를 브로드캐스트합니다.\n- 네트워크의 모든 호스트가 피해자에게 ICMP Echo Reply를 전송합니다.\n- 결과적으로 피해자는 엄청난 양의 응답 패킷을 받게 됩니다.\n\n3. **\"공격 대상 호스트는 다량으로 유입되는 패킷으로 인해 서비스 불능 상태에 빠진다\"**\n- 수신 대역폭이 포화되어 정상적인 통신이 불가능해집니다.\n- DoS(Denial of Service) 상태에 빠집니다.\n\n**스머프 공격의 방어 방법:**\n- 라우터에서 브로드캐스트 주소로 향하는 패킷을 차단\n- ICMP 패킷 필터링\n- IP 스푸핑 방지\n\n**답:** \"스머프\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 GoF 디자인 패턴과 관련된 문제이다.\n괄호 안에 알맞는 용어를 작성하시오.\n(        ) 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.\n(        ) 패턴은 객체들 간의 통신 방법을 정의하고 알고리즘을 캡슐화하여 객체 간의 결합도를 낮춘다.\n(        ) 패턴은 Chain of Responsibility나 Command 또는 Observer 패턴이 있다.", "choices": [], "answer": {"keys": ["행위"], "raw_text": "행위"}, "explanation": "행위(Behavioral) 패턴은 객체 간의 상호작용과 책임 분배를 정의하는 GoF 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다\"**\n- 행위 패턴은 객체 간의 통신 방식을 정의합니다.\n- 각 객체의 역할과 책임을 명확히 분리합니다.\n- 예: Observer 패턴에서 주제와 관찰자의 상호작용\n\n2. **\"객체들 간의 통신 방법을 정의하고 알고리즘을 캡슐화하여 객체 간의 결합도를 낮춘다\"**\n- 통신 방법을 표준화하여 결합도를 낮춥니다.\n- 알고리즘을 객체로 캡슐화합니다.\n- 예: Strategy 패턴에서 알고리즘을 독립적인 객체로 분리\n\n3. **\"Chain of Responsibility나 Command 또는 Observer 패턴이 있다\"**\n- Chain of Responsibility: 요청을 객체 체인으로 전달\n- Command: 요청을 객체로 캡슐화\n- Observer: 객체 간 일대다 의존성 정의\n\n**GoF 패턴 분류:**\n- **생성 패턴(Creational)**: 객체 생성 담당 (Singleton, Factory 등)\n- **구조 패턴(Structural)**: 클래스/객체 조합 (Adapter, Decorator 등)\n- **행위 패턴(Behavioral)**: 객체 간 상호작용 (Observer, Command 등) ✓\n\n**답:** \"행위\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 C언어 코드는 static 변수의 특성을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c int func() {\nstatic int x = 0; // static 변수 (초기화는 한 번만!)\nx += 2;\nreturn x;\n}\n\nint main() {\nint x = 1; // 지역 변수 (func의 x와 별개)\nint sum = 0;\nfor(int i=0; i<4; i++) {\nx++; // 지역 변수 x 증가 sum += func(); // func() 호출\n}\nprintf(\"%d\", sum);\n}\n```\n\n**실행 과정:**\n\n1. **초기값:**\n- `main`의 지역 변수: `x = 1`\n- `func`의 static 변수: `x = 0` (초기화는 프로그램 시작 시 한 번만)\n\n2. **반복문 실행:**i=0:**\n- `x++` → `x = 2` (main의 지역 변수)\n- `func()` 호출:\n- static `x = 0` (유지됨)\n- `x += 2` → `x = 2`\n- 반환: **2**\n- `sum = 0 + 2 = 2`\n\n**i=1:**\n- `x++` → `x = 3`\n- `func()` 호출:\n- static `x = 2` (이전 값 유지!)\n- `x += 2` → `x = 4`\n- 반환: **4**\n- `sum = 2 + 4 = 6`\n\n**i=2:**\n- `x++` → `x = 4`\n- `func()` 호출:\n- static `x = 4`\n- `x += 2` → `x = 6`\n- 반환: **6**\n- `sum = 6 + 6 = 12`\n\n**i=3:**\n- `x++` → `x = 5`\n- `func()` 호출:\n- static `x = 6`\n- `x += 2` → `x = 8`\n- 반환: **8**\n- `sum = 12 + 8 = 20`\n\n3. **최종 출력:**\n- **출력: 20**핵심 포인트:**\n- static 변수는 함수가 종료되어도 메모리에 유지됩니다.\n- static 변수의 초기화는 프로그램 시작 시 한 번만 실행됩니다.\n- 함수를 여러 번 호출해도 static 변수는 이전 값을 유지합니다.\n\n**답:** 20", "table_refs": [], "image_refs": ["images/2024_round3/Q007.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.890108"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint func(){\n static int x =0; \n  x+=2; \n  return x;\n}\nint main(){\n  int x = 1; \n  int sum=0; \n  for(int i=0;i<4;i++) {\n    x++; \n    sum+=func();\n  } \n  printf(\"%d\", sum);\n  return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2024_round3/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음은 무결성제약조건에 대한 문제이다.\n아래 표에서 어떠한 (       ) 무결성을 위반하였는지 작성하시오.", "choices": [], "answer": {"keys": ["개체"], "raw_text": "개체"}, "explanation": "이 문제는 데이터베이스의 제약조건(무결성 제약조건)에 대한 문제입니다.\n\n**제약조건의 정의와 목적:**\n\n제약조건은 데이터베이스에 저장되는 데이터가 정확하고 일관성 있게 유지되도록 하는 규칙입니다. 잘못된 데이터가 입력되는 것을 방지하고 데이터의 무결성을 보장합니다.\n\n**제약조건의 종류:**\n\n1. **도메인 제약조건(Domain Constraint)**: 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 지정합니다.\n- 예: 나이는 0 이상 150 이하의 정수만 허용\n\n2. **개체 제약조건(Entity Constraint, 엔티티 무결성)**: 기본키(Primary Key)와 관련된 제약조건입니다.\n- 기본키는 NULL 값을 가질 수 없습니다.\n- 기본키는 중복될 수 없으며, 각 튜플(행)을 유일하게 식별해야 합니다.\n\n3. **참조 제약조건(Referential Constraint, 참조 무결성)**: 외래키(Foreign Key)와 관련된 제약조건입니다.\n- 외래키는 참조하는 테이블의 기본키 값과 일치해야 하거나 NULL 값이어야 합니다.\n\n**문제 해석**: 문제에서 각 설명에 해당하는 제약조건을 보기에서 찾아야 합니다. 제약조건의 정의와 특징을 정확히 이해하면 답은 \"개체\"입니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q008.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 URL 구조에 관한 문제이다.\n아래  보기의 순서대로 URL에 해당하는 번호를 작성하시오.\nquery\n: 서버에 전달할 추가 데이터 path\n: 서버 내의 특정 자원을 가리키는 경로 scheme\n: 리소스에 접근하는 방법이나 프로토콜 authority\n: 사용자 정보, 호스트명, 포트 번호 fragment\n: 특정 문서 내의 위치", "choices": [], "answer": {"keys": ["43125"], "raw_text": "43125"}, "explanation": "URL(Uniform Resource Locator)의 구조를 이해하는 문제입니다.\n\n**URL 구조 예시:**\n```\nhttps://user:pass@example.com:8080/path/to/resource?query=value#fragment\n│ │ │ │ │ │ │ │\n│ │ │ │ │ │ │ └─ fragment\n│ │ │ │ │ │ └─ query\n│ │ │ │ │ └─ path\n│ │ │ │ └─ port\n│ │ │ └─ hostname\n│ │ └─ password\n│ └─ username\n└─ scheme\n```\n\n**각 구성 요소:**\n\n1. **scheme (3번)**: 리소스에 접근하는 방법이나 프로토콜\n- 예: `http`, `https`, `ftp`, `mailto`\n- URL의 가장 앞에 위치합니다.\n\n2. **authority (4번)**: 사용자 정보, 호스트명, 포트 번호\n- 형식: `[username:password@]hostname[:port]`\n- 예: `user:pass@example.com:8080`\n\n3. **path (1번)**: 서버 내의 특정 자원을 가리키는 경로\n- 예: `/path/to/resource`\n- 서버의 파일 시스템 경로를 나타냅니다.\n\n4. **query (2번)**: 서버에 전달할 추가 데이터\n- 형식: `?key=value&key2=value2`\n- GET 요청의 파라미터를 전달합니다.\n\n5. **fragment (5번)**: 특정 문서 내의 위치\n- 형식: `#section`\n- HTML 문서의 앵커를 가리킵니다.\n\n**순서:**\n1. scheme → 2. authority → 3. path → 4. query → 5. fragment\n\n**보기 매칭:**\n- query: 1\n- path: 2\n- scheme: 3\n- authority: 4\n- fragment: 5\n\n**답:** \"43125\"", "table_refs": [], "image_refs": ["images/2024_round3/Q009.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["45"], "raw_text": "45"}, "explanation": "이 파이썬 코드는 `type()` 함수를 사용한 타입 체크를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```python def func(value):\nif type(value) == type(100): # int 타입 체크 return 100 elif type(value) == type(\"\"): # str 타입 체크 return len(value)\nelse:\nreturn 20\n\na = '100.0' # 문자열 b = 100.0 # float (실수)\nc = (100, 200) # tuple\n\nprint(func(a) + func(b) + func(c))\n```\n\n**실행 과정:**\n\n1. **`func('100.0')` 호출:**\n- `type('100.0') == type(\"\")` → `True` (문자열)\n- 반환: `len('100.0') = 5`\n\n2. **`func(100.0)` 호출:**\n- `type(100.0) == type(100)` → `False` (float ≠ int)\n- `type(100.0) == type(\"\")` → `False` (float ≠ str)\n- else 블록 실행 → 반환: **20**\n\n3. **`func((100, 200))` 호출:**\n- `type((100, 200)) == type(100)` → `False` (tuple ≠ int)\n- `type((100, 200)) == type(\"\")` → `False` (tuple ≠ str)\n- else 블록 실행 → 반환: **20**\n\n4. **최종 계산:**\n- `5 + 20 + 20 = 45`\n\n**핵심 포인트:**\n- `type()` 함수는 객체의 타입을 반환합니다.\n- `type(100)`은 `int` 타입 객체를 반환합니다.\n- `100.0`은 `float` 타입이므로 `int`와 다릅니다.\n\n**답:** 45", "table_refs": [], "image_refs": ["images/2024_round3/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [{"language": "python", "code": "def func(value):\n    if type(value) == type(100):\n        return 100\n    elif type(value) == type(\"\"):\n        return len(value) \n    else:\n        return 20\na = '100.0'\nb = 100.0\nc = (100, 200)\nprint(func(a) + func(b) + func(c))", "line_numbers": [1, 11], "file": "data/codes/2024_round3/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["52"], "raw_text": "52"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 52을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [{"language": "java", "code": "public class Main{\n  public static void main(String[] args){\n    Base a =  new Derivate();\n    Derivate b = new Derivate();\n    System.out.print(a.getX() + a.x + b.getX() + b.x);\n  }\n}\nclass Base{\n  int x = 3;\n  int getX(){\n     return x * 2; \n  }\n}\nclass Derivate extends Base{\n  int x = 7;\n  int getX(){\n     return x * 3;\n  }\n}", "line_numbers": [1, 19], "file": "data/codes/2024_round3/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["312"], "raw_text": "312"}, "explanation": "이 C언어 코드는 연결 리스트에서 인접한 노드 쌍의 값을 교환하는 문제입니다.\n\n**코드 분석:**\n\n```c void func(struct Node* node) {\nwhile(node != NULL && node->next != NULL) {\nint = node->value;\nnode->value = node->next->value;\nnode->next->value = t; // 인접 노드 값 교환 node = node->next->next; // 두 칸 건너뛰기\n}\n}\n```\n\n**실행 과정:**\n\n1. **초기 리스트 구성:**\n```c n1 = {1, NULL}\nn2 = {2, NULL}\nn3 = {3, NULL}\nn1.next = &n3;\nn3.next = &n2;\n```\n- 리스트: **1 → 3 → 2 → NULL**\n\n2. **`func(&n1)` 실행:**첫 번째 반복 (node = &n1):**\n- node != NULL ✓, node->next != NULL ✓\n- 교환: n1.value(1) ↔ n3.value(3)\n- 리스트: **3 → 1 → 2 → NULL**\n- `node = node->next->next` = `n3->next` = `&n2`\n\n**두 번째 반복 (node = &n2):**\n- node != NULL ✓, node->next == NULL ✗\n- 루프 종료\n\n3. **출력:**\n```c while(current != NULL) {\nprintf(\"%d\", current->value);\ncurrent = current->next;\n}\n```\n- 출력: **\"312\"**답:** \"312\"", "table_refs": [], "image_refs": ["images/2024_round3/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct Node {\n int value;\n struct Node* next;\n};\nvoid func(struct Node* node){\n  while(node != NULL && node->next != NULL){\n     int t = node->value;\n     node->value = node->next->value;\n     node->next->value = t;\n     node = node->next->next;\n  }\n}\nint main(){\n  struct Node n1 = {1, NULL};\n  struct Node n2 = {2, NULL};\n  struct Node n3 = {3, NULL};\n  n1.next = &n3;\n  n3.next = &n2;\n  func(&n1);  \n  struct Node* current = &n1;\n  while(current != NULL){\n    printf(\"%d\", current->value);\n    current = current->next;\n }\n return 0;\n}", "line_numbers": [1, 27], "file": "data/codes/2024_round3/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 테스트 커버리지에 대한 문제이다.\n아래 내용에 알맞는 답을 보기에서 골라 작성하시오.\n\n1. 테스트를 통해 프로그램의 모든 문장을 최소한 번씩 실행했는지를 측정\n\n2. 프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 번씩 실행했는지를 측정\n\n3. 복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정\n\nㄱ. 조건\n\nㄴ. 경로\n\nㄷ. 결정\n\nㄹ. 분기\n\nㅁ.함수\n\nㅂ. 문장\n\nㅅ. 루프", "choices": [], "answer": {"keys": ["1. 문장", "2. 분기", "3. 조건"], "raw_text": "1. 문장 2. 분기 3. 조건"}, "explanation": "이 문제는 소프트웨어 테스트 커버리지(Test Coverage)의 종류를 구분하는 문제입니다.\n\n**문제에서 설명하는 각 커버리지:**\n\n1. **\"테스트를 통해 프로그램의 모든 문장을 최소한 번씩 실행했는지를 측정\"**\n- **문장 커버리지(Statement Coverage)** 또는 **구문 커버리지**\n- 모든 실행 가능한 문장이 한 번 이상 실행되었는지 확인합니다.\n- 가장 기본적인 커버리지입니다.\n- 예: `if-else` 문에서 각 분기가 실행되었는지 확인\n\n2. **\"프로그램 내의 모든 분기(조건문)의 각 분기를 최소한 번씩 실행했는지를 측정\"**\n- **분기 커버리지(Branch Coverage)** 또는 **결정 커버리지(Decision Coverage)**\n- 모든 조건문의 참/거짓 분기를 실행했는지 확인합니다.\n- 문장 커버리지보다 엄격합니다.\n- 예: `if (a > 0)`의 참과 거짓 경우를 모두 테스트\n\n3. **\"복합 조건 내의 각 개별 조건이 참과 거짓으로 평가되는 경우를 모두 테스트했는지를 측정\"**\n- **조건 커버리지(Condition Coverage)**\n- 복합 조건문(`if (a > 0 && b < 0)`)의 각 조건을 개별적으로 테스트합니다.\n- 각 조건이 참과 거짓으로 평가되었는지 확인합니다.\n\n**커버리지 종류:**\n- ㄱ. 조건 커버리지 ✓ (3번)\n- ㄴ. 경로 커버리지: 모든 실행 경로를 테스트\n- ㄷ. 결정 커버리지: 분기 커버리지와 유사\n- ㄹ. 분기 커버리지 ✓ (2번)\n- ㅁ. 함수 커버리지: 모든 함수 호출\n- ㅂ. 문장 커버리지 ✓ (1번)\n- ㅅ. 루프 커버리지: 모든 루프 실행\n\n**답:**\n- 1. 문장 (ㅂ)\n- 2. 분기 (ㄹ)\n- 3. 조건 (ㄱ)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합\n\nㄱ. 슈퍼키\n\nㄴ. 외래키\n\nㄷ. 대체키\n\nㄹ. 후보키", "choices": [], "answer": {"keys": ["(1) 외래키", "(2) 후보키", "(3) 대체키", "(4) 슈퍼키"], "raw_text": "(1) 외래키\n(2) 후보키\n(3) 대체키\n(4) 슈퍼키"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제에서 설명하는 내용:**\n\n다음은 데이터베이스에 관한 문제이다.\n아래 내용을 읽고 알맞는 답을 보기에서 찾아 골라 작성하시오.\n\n(1) 다른 테이블, 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합\n(2) 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합\n(3) 후보 키 중에서 선정된 기본 키를 제외한 나머지 후보 키\n(4) 테이블에서 각 행을 유일하게 식별...\n\n**핵심 특징:**\n- 다음은 데이터베이스에 관한 문제이다.\n\n**답이 \"(1) 외래키, (2) 후보키, (3) 대체키\"인 이유:**\n\n문제에서 설명한 특징들을 종합적으로 고려하면, 모든 조건을 만족하는 답은 \"(1) 외래키, (2) 후보키, (3) 대체키\"입니다.\n\n**구체적 매칭:**\n- 문제에서 설명한 특징들이 해당 답과 일치합니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.891117"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "이 C언어 코드는 이중 포인터와 배열 연산을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```c void func(int** arr, int size) {\nfor(int i=0; i<size; i++) {\n*(*arr + i) = (*(*arr+i) + i) % size;\n}\n}\n\nint main() {\nint arr[] = {3, 1, 4, 1, 5};\nint* p = arr;\nint** pp = &p;\nfunc(pp, 5);\nnum = arr[2];\nprintf(\"%d\", num);\n}\n```\n\n**실행 과정:**\n\n1. **초기 상태:**\n- `arr = {3, 1, 4, 1, 5}`\n- `p = arr` (arr의 시작 주소)\n- `pp = &p` (p의 주소)\n\n2. **`func(pp, 5)` 호출:**\n- `arr` 파라미터는 `pp`이므로 `**arr = *p = arr[0]`\n\n**i=0:**\n- `*(*arr + 0) = arr[0] = 3`\n- `(3 + 0) % 5 = 3`\n- `arr[0] = 3`\n\n**i=1:**\n- `*(*arr + 1) = arr[1] = 1`\n- `(1 + 1) % 5 = 2`\n- `arr[1] = 2`\n\n**i=2:**\n- `*(*arr + 2) = arr[2] = 4`\n- `(4 + 2) % 5 = 1`\n- `arr[2] = 1`\n\n**i=3:**\n- `*(*arr + 3) = arr[3] = 1`\n- `(1 + 3) % 5 = 4`\n- `arr[3] = 4`\n\n**i=4:**\n- `*(*arr + 4) = arr[4] = 5`\n- `(5 + 4) % 5 = 4`\n- `arr[4] = 4`\n\n**최종 배열:** `{3, 2, 1, 4, 4}`\n\n3. **출력:**\n```c num = arr[2] = 1 printf(\"%d\", 1);\n```\n\n**답:** 1", "table_refs": [], "image_refs": ["images/2024_round3/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.892116"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nvoid func(int** arr, int size){\n  for(int i=0; i<size; i++){\n     *(*arr + i) = (*(*arr+i) + i) % size;\n  }\n}\nint main(){\n  int arr[] = {3,1, 4, 1, 5};\n  int* p = arr;\n  int** pp = &p;\n  int num = 6;\n  func(pp, 5);  \n  num = arr[2];\n  printf(\"%d\", num);  \n  return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2024_round3/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n(3글자로 작성)\n\n- 공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다.\n\n- 사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다.\n\n- 종류로는 IPsec 또는 SSL, L2TP 등이 있다.", "choices": [], "answer": {"keys": ["VPN"], "raw_text": "VPN"}, "explanation": "VPN(Virtual Private Network)은 공용 네트워크를 통해 사설 네트워크를 확장하는 기술입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다\"**\n- 인터넷 같은 공용 네트워크 위에 가상의 사설 네트워크를 구축합니다.\n- 물리적으로 멀리 떨어진 네트워크를 하나의 사설망처럼 사용할 수 있습니다.\n- Site-to-Site VPN, Remote Access VPN 등이 있습니다.\n\n2. **\"사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지를 추적하기 어렵게 만든다\"**\n- VPN 서버를 통해 트래픽을 중계하므로 실제 IP가 숨겨집니다.\n- 위치 추적이 어려워집니다.\n- 프라이버시 보호에 도움이 됩니다.\n\n3. **\"종류로는 IPsec 또는 SSL, L2TP 등이 있다\"**\n- **IPsec (IP Security)**: 네트워크 계층 암호화\n- **SSL/TLS VPN**: 애플리케이션 계층 암호화\n- **L2TP (Layer 2 Tunneling Protocol)**: 데이터 링크 계층 터널링\n\n**VPN의 주요 용도:**\n- 원격 접근: 외부에서 회사 내부 네트워크 접속\n- 사이트 간 연결: 지사 간 안전한 통신\n- 프라이버시 보호: IP 주소 숨김\n\n**답:** \"VPN\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.892116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["101"], "raw_text": "101"}, "explanation": "이 Java 코드는 예외 처리 메커니즘과 finally 블록의 실행 순서를 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java public static void main(String[] args) {\nint sum = 0;\ntry {\nfunc(); // NullPointerException 발생\n} catch (NullPointerException e) {\nsum = sum + 1; // sum = 1\n} catch (Exception e) {\nsum = sum + 10;\n} finally {\nsum = sum + 100; // 항상 실행\n}\nSystem.out.print(sum);\n}\n\nstatic void func() throws Exception {\nthrow new NullPointerException();\n}\n```\n\n**실행 과정:**\n\n1. **try 블록 실행:**\n- `func()` 호출\n- `NullPointerException` 발생\n\n2. **예외 처리:**\n- Java는 첫 번째로 일치하는 catch 블록을 찾습니다.\n- `catch (NullPointerException e)` → **일치!**\n- `sum = 0 + 1 = 1`\n\n3. **finally 블록 실행:**\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- `sum = 1 + 100 = 101`\n\n4. **최종 출력:**\n- **출력: 101**핵심 포인트:**\n- 예외 처리 순서: try → catch(일치하는 예외) → finally\n- finally 블록은 반드시 실행됩니다.\n- `NullPointerException`은 `Exception`의 자식 클래스이므로, 더 구체적인 catch 블록이 먼저 매칭됩니다.\n\n**답:** 101", "table_refs": [], "image_refs": ["images/2024_round3/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.892116"}, "code_blocks": [{"language": "java", "code": "public class ExceptionHandling {\n  public static void main(String[] args) {\n      int sum = 0;\n      try {\n          func();\n      } catch (NullPointerException e) {\n          sum = sum + 1;\n      } catch (Exception e) {\n          sum = sum + 10;\n      } finally {\n          sum = sum + 100;\n      }\n      System.out.print(sum);\n  }\n  static void func() throws Exception {\n      throw new NullPointerException(); \n  }\n}", "line_numbers": [1, 18], "file": "data/codes/2024_round3/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["B0"], "raw_text": "B0"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 B0을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2024_round3/Q019.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.892116"}, "code_blocks": [{"language": "java", "code": "class Main {\n  public static class Collection<T>{\n    T value;\n    public Collection(T t){\n        value = t;\n    }\n    public void print(){\n       new Printer().print(value);\n    }\n   class Printer{\n      void print(Integer a){\n        System.out.print(\"A\" + a);\n      }\n      void print(Object a){\n        System.out.print(\"B\" + a);\n      } \n      void print(Number a){\n        System.out.print(\"C\" + a);\n      }\n   }\n }\n  public static void main(String[] args) {\n      new Collection<>(0).print();\n  }\n}", "line_numbers": [1, 25], "file": "data/codes/2024_round3/Q019_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2024_round3", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 네트워크에 대한 문제이다.\n아래 내용을 보고\n\n알맞는 용어를 작성하시오.\n\n- 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다.\n\n- 일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다.\n\n- 긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다.\n\n[보기]\n\nㄱ.Infrastructure Network\n\nㄴ. Firmware Network\n\nㄷ. Peer-to-Peer Network\n\nㄹ. Ad-hoc Network\n\nㅁ. Mesh Network\n\nㅂ.Sensor Network\n\nㅅ.Virtual Private Network", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "Ad-hoc Network(애드혹 네트워크)는 중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다\"**\n- 중앙 서버나 라우터 없이 노드들이 직접 통신합니다.\n- 인프라가 필요 없어 빠르게 구성 가능합니다.\n- 동적으로 네트워크를 형성합니다.\n\n2. **\"일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다\"**\n- 무선 기술(Wi-Fi, Bluetooth 등)을 사용합니다.\n- P2P(Peer-to-Peer) 방식으로 직접 통신합니다.\n- 각 노드가 라우터 역할을 할 수 있습니다.\n\n3. **\"긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다\"**\n- 인프라가 없는 상황에서도 통신 가능\n- 재난 상황, 야전 환경 등에서 활용\n- 임시 네트워크 구축에 적합\n\n**보기 분석:**\n- ㄱ. Infrastructure Network: 인프라 기반 네트워크 (Wi-Fi AP 필요)\n- ㄴ. Firmware Network: 펌웨어 네트워크 (일반적 용어 아님)\n- ㄷ. Peer-to-Peer Network: P2P (일부 특징 유사하지만 Ad-hoc과 다름)\n- **ㄹ. Ad-hoc Network**: 중앙 인프라 없이 임시 구성 ✓\n- ㅁ. Mesh Network: 메시 네트워크 (Ad-hoc의 확장 형태)\n- ㅂ. Sensor Network: 센서 네트워크 (IoT)\n- ㅅ. Virtual Private Network: VPN (가상 사설망)\n\n**답:** \"ㄹ\" (Ad-hoc Network)", "table_refs": [{"id": "table1", "json": "data/tables/2024_round3/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/495", "crawled_at": "2025-11-02T23:27:53.530996", "last_improved": "2025-11-04T00:15:55.943824", "readability_improved": "2025-11-04T00:26:37.892116"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 네트워크 보완에 관련된 문제이다.\n괄호 안에 알맞는 용어를 작성하시오.\n(   )은/는 '세션을 가로채다.' 라는 의미로 다른 사람의 세션 상태를 훔치거나 도용하여 액세스하는 해킹 기법이다.\nTCP (   )은/는 TCP의 3-way 핸드셰이크가 완료된 후에 공격자가 시퀀스 번호 등을 조작하여 정상적인 세션을 가로채고 인증 없이 통신을 탈취하는 공격 공격이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의와 개념:**\n\n1. **기본 정의**: 세션 하이재킹은 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.\n\n2. **세션이란**: 세션은 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.\n\n**TCP 세션 하이재킹:**\n\n1. **3-way 핸드셰이크**: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.\n- 클라이언트가 서버에 SYN 패킷 전송\n- 서버가 SYN-ACK 패킷 응답\n- 클라이언트가 ACK 패킷 전송 이 과정이 완료되면 정상적인 통신이 시작됩니다.\n\n2. **공격 과정**:\n- 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.\n- TCP 시퀀스 번호를 예측하거나 조작합니다.\n- 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.\n- 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.\n\n**문제 해석**: 문제에서 '세션을 가로채다', 'TCP 3-way 핸드셰이크', '시퀀스 번호 조작', '인증 없이 통신 탈취' 등의 키워드가 언급되어 있으므로 답은 \"세션 하이재킹\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.900403", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.895109"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 제약조건과 관련된 문제이다.\n괄호 안에 알맞는 용어를 보기에 골라 작성하시오.\n개체, 참조, 도메인", "choices": [], "answer": {"keys": ["ㄱ. 도메인", "ㄴ. 개체", "ㄷ. 참조"], "raw_text": "ㄱ. 도메인\nㄴ. 개체\nㄷ. 참조"}, "explanation": "이 문제는 데이터베이스의 제약조건 개념인 도메인(Domain), 개체 무결성(Entity Integrity), 참조 무결성(Referential Integrity)에 관한 문제입니다.\n\n**데이터베이스 제약조건 이해:**\n\n1. **도메인(Domain) 제약조건:**\n- 도메인은 특정 속성(컬럼)에 입력될 수 있는 값의 유형이나 범위를 정의합니다.\n- 예를 들어, 나이 속성의 도메인은 0 이상의 정수일 수 있습니다.\n- 도메인 제약조건은 데이터의 타입, 길이, 범위 등을 제한하여 데이터 무결성을 보장합니다.\n- 문제에서 \"특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준\"이라고 설명한 것이 도메인 제약조건입니다.\n\n2. **개체 무결성(Entity Integrity):**\n- 개체 무결성은 릴레이션(테이블)의 기본 키(Primary Key)가 NULL이 될 수 없고, 중복될 수 없다는 규칙입니다.\n- 기본 키는 각 튜플(행)을 고유하게 식별하는 역할을 하므로 반드시 값이 있어야 합니다.\n- 문제의 이미지나 설명에서 개체 무결성과 관련된 내용이 있을 것입니다.\n\n3. **참조 무결성(Referential Integrity):**\n- 참조 무결성은 한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조되는 값이 반드시 존재해야 한다는 규칙입니다.\n- 외래 키(Foreign Key)는 다른 릴레이션의 기본 키를 참조하는 속성입니다.\n- 문제에서 \"한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미\"라고 설명한 것이 외래 키(참조 무결성)입니다.\n\n**답:** 보기에서:\n- ㄱ. domain: 도메인 제약조건 (4번 문제)\n- ㄴ. 개체: 개체 무결성 관련\n- ㄷ. 참조: 참조 무결성, 외래 키 (3번 문제)\n\n문제의 실제 설명과 이미지를 바탕으로 정확히 매칭하면 \"ㄱ. 도메인, ㄴ. 개체, ㄷ. 참조\"입니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q002.png"], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.895109"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "아래의 내용에서 설명 글의 괄호안의 용어를 영문 약자로 작성하시오.\n(        ) 은/는 3글자의 영어 약자로 이루어진 오류 기법으로 데이터를 전송하거나 저장할 때 데이터의 오류를 감지하는 데 사용되는 오류 검출 코드이다.\n(        ) 은/는 데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인하는 기법이다.\n(        ) 은/는 데이터 전송의 안정성을 높이는 데 중요한 역할을 한다.\n데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고나머지를 (       ) 값으로 삼는다.", "choices": [], "answer": {"keys": ["CRC"], "raw_text": "CRC"}, "explanation": "CRC(Cyclic Redundancy Check)는 데이터 전송 시 오류를 검출하는 코드입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"3글자의 영어 약자로 이루어진 오류 기법\"**\n- CRC는 Cyclic Redundancy Check의 약자로 정확히 3글자입니다.\n- 데이터 전송이나 저장 시 오류를 감지하는 데 사용됩니다.\n\n2. **\"데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인\"**\n- CRC는 데이터에 체크섬(나머지 값)을 추가하여 전송합니다.\n- 수신 측에서 같은 방법으로 체크섬을 다시 계산하여 두 값이 일치하면 오류가 없는 것으로, 다르면 오류가 발생한 것으로 판단합니다.\n\n3. **\"데이터 전송의 안정성을 높이는 데 중요한 역할\"**\n- CRC는 통신이나 저장 매체에서 발생할 수 있는 데이터 손상을 감지하여 신뢰성을 높입니다.\n\n4. **\"데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고 나머지를 ( ) 값으로 삼는다\"**\n- CRC는 생성 다항식(Generator Polynomial)을 사용하여 계산합니다.\n- 예시로 주어진 \"x³ + x + 1\"은 다항식을 이진수로 표현하면 \"1011\"이 됩니다.\n- 데이터를 이 다항식으로 나눗셈 연산을 수행하고 나머지를 CRC 값으로 사용합니다.\n\n**CRC 계산 과정:**\n1. 데이터에 0을 추가 (다항식 차수만큼)\n2. 생성 다항식으로 XOR 연산 (2진수 나눗셈)\n3. 나머지를 CRC 값으로 사용\n\n**답:** 문제에서 설명한 모든 특징(3글자 약자, 체크섬 추가, 이진수 다항식 나눗셈)이 CRC와 정확히 일치하므로 답은 \"CRC\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.895109"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "다음은 악성코드 관련된 문제이다.\n아래 내용을 확인하여\n\n보기에 골라 작성하시오.\n사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.\n‘겁을 주다’라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불 하거나 특정 행동을 유도하는 랜섬웨어이다.\n가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식으로 작동한다.\n\n[보기]\n\nㄱ. 컴포넌트 웨어\n\nㄴ. 유즈웨어\n\nㄷ. 셔블웨어\n\nㄹ. 스캐어 웨어\n\nㅁ. 안티 스파이 웨어\n\nㅂ. 네트웨어\n\nㅅ. 그룹웨어\n\nㅇ. 애드웨어", "choices": [], "answer": {"keys": ["ㄹ"], "raw_text": "ㄹ"}, "explanation": "스캐어웨어(Scareware)는 사용자를 속여 돈을 지불하거나 소프트웨어를 구매하도록 조작하는 악성 소프트웨어입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발\"**\n- 스캐어웨어는 사용자의 두려움(scare)을 이용합니다.\n- 가짜 경고나 위협적인 메시지를 보여줘서 사용자가 당황하게 만듭니다.\n- 사용자가 긴급하게 대응해야 한다고 느끼도록 조작합니다.\n\n2. **\"'겁을 주다'라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불하거나 특정 행동을 유도하는 랜섬웨어\"**\n- \"Scare\"는 \"겁을 주다, 놀라게 하다\"라는 의미입니다.\n- 공포 마케팅 전략을 사용합니다.\n- 랜섬웨어와 유사하지만, 실제로 데이터를 암호화하지 않고 가짜 경고를 보여줍니다.\n\n3. **\"가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식\"**\n- 가짜 안티바이러스 경고를 표시합니다.\n- \"시스템이 감염되었습니다\", \"바로 지금 처리하세요\" 등의 메시지를 보여줍니다.\n- 사용자로 하여금 가짜 안티바이러스 소프트웨어를 구매하거나 설치하도록 유도합니다.\n\n**보기 분석:**\n- ㄱ. 컴포넌트 웨어: 컴포넌트 기반 소프트웨어\n- ㄴ. 유즈웨어: 사용자가 만든 소프트웨어\n- ㄷ. 셔블웨어: 평가판 소프트웨어\n- **ㄹ. 스캐어 웨어: 공포를 이용한 악성 소프트웨어** ✓\n- ㅁ. 안티 스파이 웨어: 스파이웨어 방지 소프트웨어\n- ㅂ. 네트웨어: 네트워크 기반 소프트웨어\n- ㅅ. 그룹웨어: 그룹 협업 소프트웨어\n- ㅇ. 애드웨어: 광고 소프트웨어\n\n**답:** 문제에서 설명한 모든 특징(공포 유발, 가짜 경고, 속임수)이 스캐어웨어와 정확히 일치하므로 답은 \"ㄹ\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["출력1출력5"], "raw_text": "출력1출력5"}, "explanation": "이 Java 코드는 예외 처리 메커니즘(try-catch-finally)을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java int a = 5, b = 0;\ntry {\nSystem.out.print(a/b); // 5 / 0 → ArithmeticException 발생!\n} catch(ArithmeticException e) {\nSystem.out.print(\"출력1\");\n} catch(ArrayIndexOutOfBoundsException e) {\nSystem.out.print(\"출력2\");\n} catch(NumberFormatException e) {\nSystem.out.print(\"출력3\");\n} catch(Exception e) {\nSystem.out.print(\"출력4\");\n} finally {\nSystem.out.print(\"출력5\");\n}\n```\n\n**실행 과정:**\n\n1. **try 블록 실행:**\n- `a = 5`, `b = 0`\n- `System.out.print(5 / 0)` 실행 시도\n- **0으로 나누기 연산 → `ArithmeticException` 발생**\n\n2. **예외 처리:**\n- Java는 발생한 예외 타입을 찾기 위해 catch 블록들을 순서대로 확인합니다.\n- 첫 번째 catch: `catch(ArithmeticException e)` → **일치!**\n- 따라서 \"출력1\"을 출력합니다.\n\n3. **finally 블록 실행:**\n- 예외 발생 여부와 관계없이 **항상 실행**됩니다.\n- \"출력5\"를 출력합니다.\n\n4. **최종 출력:**\n- \"출력1\" + \"출력5\" = **\"출력1출력5\"**핵심 포인트:**\n- Java의 예외 처리 순서: try → catch(일치하는 예외 타입) → finally\n- 여러 catch 블록이 있을 때 첫 번째로 일치하는 catch 블록이 실행됩니다.\n- finally 블록은 예외 발생 여부와 관계없이 반드시 실행됩니다.\n\n**답:** \"출력1출력5\"", "table_refs": [], "image_refs": ["images/2025_round1/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [{"language": "java", "code": "public class Main {\n  public static void main(String[] args) {\n    int a=5,b=0;\n    try{\n      System.out.print(a/b);\n    }catch(ArithmeticException e){\n      System.out.print(\"출력1\");\n    }catch(ArrayIndexOutOfBoundsException e) {\n      System.out.print(\"출력2\");\n    }catch(NumberFormatException e) {\n      System.out.print(\"출력3\");\n    }catch(Exception e){\n      System.out.print(\"출력4\");\n    }finally{\n      System.out.print(\"출력5\");\n    }\n  }\n}", "line_numbers": [1, 18], "file": "data/codes/2025_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 내용은 ARP/RARP에 대한 설명이다. 각 설명에 해당하는 것을 작성하시오.\n\n(1) 은/는 네트워크상에서 IP 주소를 MAC 주소로 변환하는 프로토콜이고,\n( 2 ) 은/는 MAC 주소를 IP 주소로 변환하는 프로토콜이다.", "choices": [], "answer": {"keys": ["(1) ARP", "(2) RARP"], "raw_text": "(1) ARP\n(2) RARP"}, "explanation": "ARP(Address Resolution Protocol)와 RARP(Reverse Address Resolution Protocol)는 네트워크에서 주소 변환을 담당하는 프로토콜입니다.\n\n**문제 분석:**\n\n**(1) IP 주소를 MAC 주소로 변환하는 프로토콜:**\n- **ARP(Address Resolution Protocol)**는 IP 주소를 물리적 주소인 MAC 주소로 변환합니다.\n- 예를 들어, 컴퓨터가 네트워크상의 다른 컴퓨터와 통신하려면 IP 주소는 알고 있지만, 실제로 데이터를 전송하려면 MAC 주소가 필요합니다.\n- ARP는 브로드캐스트를 통해 \"이 IP 주소를 가진 컴퓨터의 MAC 주소를 알려주세요\"라고 요청하고, 해당 컴퓨터가 자신의 MAC 주소를 응답합니다.\n\n**(2) MAC 주소를 IP 주소로 변환하는 프로토콜:**\n- **RARP(Reverse Address Resolution Protocol)**는 ARP의 반대 개념입니다.\n- MAC 주소를 알고 있지만 IP 주소를 모를 때 사용합니다.\n- 주로 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아오는 데 사용됩니다.\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용되고 있습니다.\n\n**ARP와 RARP의 관계:**\n- ARP: IP 주소 → MAC 주소 변환\n- RARP: MAC 주소 → IP 주소 변환 (역방향)\n\n**답:** (1) ARP, (2) RARP", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 SQL 문제이다.\n아래 두 테이블을 참고하여\n\n보기에 쿼리 실행 결과를 작성하시오.\nSELECT name, incentive FROM emp, sal WHERE emp.id = sal.id and incentives >= 500", "choices": [], "answer": {"keys": ["이순신", "1000"], "raw_text": "이순신 1000"}, "explanation": "이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.\n\n**SQL 쿼리 실행 순서와 분석:**\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 이순신, 1000입니다.\n\n**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q007.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래는 데이터베이스에 관련된 설명이다.\n알맞는 용어를 보기에서 골라 괄호를 작성하시오.\n\n1. 릴레이션에서 속성의 개수를 의미 : ( 1 )\n\n2. 릴레이션에서 튜플의 개수를 의미 : ( 2 )\n\n3. 한 릴레이션의 속상이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미 : ( 3 )\n\n4. 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준 : ( 4 )\n\n[보기]\n\nㄱ. domain\n\nㄴ. primary\n\nㄷ. degree\n\nㄹ. candidate\n\nㅁ. cardinality\n\nㅂ. attribute\n\nㅅ. foreign", "choices": [], "answer": {"keys": ["(1) ㄷ", "(2) ㅁ", "(3) ㅅ", "(4) ㄱ"], "raw_text": "(1) ㄷ\n(2) ㅁ\n(3) ㅅ\n(4) ㄱ"}, "explanation": "데이터베이스의 핵심 개념을 이해하는 문제입니다.\n\n1. 개념 이해: 문제에서 설명하는 데이터베이스 용어나 개념의 정의를 확인합니다.\n2. 관계 파악: 테이블 간의 관계, 속성 간의 종속 관계 등을 이해합니다.\n3. 제약조건: 무결성 제약조건, 키 제약조건 등을 확인합니다.\n4. 정규화: 정규형에 대한 이해가 필요한 경우 각 정규형의 특징을 확인합니다.\n\n문제의 설명과 보기, 이미지 등을 종합적으로 고려하면 답은 (1) ㄷ, (2) ㅁ, (3) ㅅ입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["프로그래밍"], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "IP 주소가 192.168.35.10, 서브넷 255.255.252.0인 PC에서 브로드캐스팅으로 다른 IP로 정보를 전달한다고 할 때 수신할 수 있는 알맞는 IP를 보기에서 골라 모두 작성하시오.\n\n[보기]\n\nㄱ. 192.168.34.1\n\nㄴ. 192.168.32.19\n\nㄷ. 192.168.35.200\n\nㄹ. 192.168.33.138\n\nㅁ. 192.168.35.50", "choices": [], "answer": {"keys": ["ㄱ,ㄴ,ㄷ,ㄹ,ㅁ"], "raw_text": "ㄱ,ㄴ,ㄷ,ㄹ,ㅁ"}, "explanation": "이 문제는 서브넷 마스크와 브로드캐스트 주소 범위를 이해하는 문제입니다.\n\n**주어진 정보:**\n- IP 주소: 192.168.35.10\n- 서브넷 마스크: 255.255.252.0\n\n**서브넷 마스크 분석:**\n- 255.255.252.0을 이진수로 변환: 11111111.11111111.11111100.00000000\n- 서브넷 비트 수: 22개 (앞의 22개 1)\n- 호스트 비트 수: 10개 (뒤의 10개 0)\n\n**네트워크 주소 계산:**\nIP 주소와 서브넷 마스크를 AND 연산:\n- IP: 192.168.35.10 = 11000000.10101000.00100011.00001010\n- 마스크: 255.255.252.0 = 11111111.11111111.11111100.00000000\n- AND 결과: 192.168.32.0\n\n**브로드캐스트 범위:**\n- 네트워크 주소: 192.168.32.0\n- 브로드캐스트 주소: 192.168.35.255 (네트워크 주소 + 호스트 비트 모두 1)\n- 사용 가능한 IP 범위: 192.168.32.1 ~ 192.168.35.254\n\n**보기 분석:**\n- ㄱ. 192.168.34.1 → 32~35 범위 내 ✓\n- ㄴ. 192.168.32.19 → 32~35 범위 내 ✓\n- ㄷ. 192.168.35.200 → 32~35 범위 내 ✓\n- ㄹ. 192.168.33.138 → 32~35 범위 내 ✓\n- ㅁ. 192.168.35.50 → 32~35 범위 내 ✓\n\n모든 보기가 같은 네트워크(서브넷)에 속하므로 브로드캐스트로 모두 수신 가능합니다.\n\n**답:** \"ㄱ,ㄴ,ㄷ,ㄹ,ㅁ\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["4", "BACDE"], "raw_text": "4 BACDE"}, "explanation": "이 C언어 코드는 문자 배열에 문자를 삽입하는 알고리즘을 구현한 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c char Data[5] = {'B', 'A', 'D', 'E'};\nchar c = 'C';\n```\n- 배열: `Data[0]='B', Data[1]='A', Data[2]='D', Data[3]='E', Data[4]='\u0000'`\n- 삽입할 문자: `c = 'C'`\n\n2. **첫 번째 출력:**\n```c printf(\"%d\n\", Data[3]-Data[1]);\n```\n- `Data[3] = 'E'` (ASCII 69)\n- `Data[1] = 'A'` (ASCII 65)\n- `69 - 65 = 4` → **출력: \"4\"**\n\n3. **삽입 위치 찾기:**\n```c for(i=0; i<5; ++i) {\nif(Data[i] > c) // 'C'보다 큰 값 찾기 break;\n}\n```\n- i=0: 'B' < 'C' → 계속\n- i=1: 'A' < 'C' → 계속\n- i=2: 'D' > 'C' → **break!** (i=2)\n\n4. **문자 삽입 (오른쪽으로 시프트):**\n```c temp = Data[2]; // temp = 'D'\nData[2] = 'C'; // 삽입 i = 3;\n\n// 나머지 원소들을 오른쪽으로 한 칸씩 이동 for(; i<5; ++i) {\ntemp2 = Data[i];\nData[i] = temp;\ntemp = temp2;\n}\n```\n- i=3: Data[3]='E'를 temp2에 저장 → Data[3]='D', temp='E'\n- i=4: Data[4]='\u0000'를 temp2에 저장 → Data[4]='E', temp='\u0000'\n- 최종 배열: `{'B', 'A', 'C', 'D', 'E'}`\n\n5. **최종 출력:**\n```c for(i=0; i<5; i++)\nprintf(\"%c\", Data[i]);\n```\n- **출력: \"BACDE\"**답:** \"4 BACDE\"", "table_refs": [], "image_refs": ["images/2025_round1/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.896108"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nchar Data[5] = {'B', 'A', 'D', 'E'};\nchar c;\nint main(){\n    int i, temp, temp2;\n    c = 'C';\n    printf(\"%d\\n\", Data[3]-Data[1]);\n    for(i=0;i<5;++i){\n        if(Data[i]>c)\n            break;\n    }\n    temp = Data[i];\n    Data[i] = c;\n    i++;\n    for(;i<5;++i){\n        temp2 = Data[i];\n        Data[i] = temp;\n        temp = temp2;\n    }\n    for(i=0;i<5;i++){\n        printf(\"%c\", Data[i]);\n    }\n}", "line_numbers": [1, 23], "file": "data/codes/2025_round1/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["13"], "raw_text": "13"}, "explanation": "이 C언어 코드는 2차원 배열을 동적으로 할당하고 데이터를 배치한 후 합을 계산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **2차원 배열 동적 할당:**\n```c int rows = 3, cols = 3;\nint data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};\n```\n- 3×3 배열을 동적으로 할당합니다.\n- data 배열: {5, 2, 7, 4, 1, 8, 3, 6, 9}\n\n2. **set() 함수 분석:**\n```c void set(int** arr, int* data, int rows, int cols) {\nfor (int i = 0; i < rows * cols; ++i) {\narr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n}\n}\n```\n- i=0: arr[(1/3)%3][1%3] = arr[0][1] = data[0] = 5\n- i=1: arr[(2/3)%3][2%3] = arr[0][2] = data[1] = 2\n- i=2: arr[(3/3)%3][3%3] = arr[1][0] = data[2] = 7\n- i=3: arr[(4/3)%3][4%3] = arr[1][1] = data[3] = 4\n- i=4: arr[(5/3)%3][5%3] = arr[1][2] = data[4] = 1\n- i=5: arr[(6/3)%3][6%3] = arr[2][0] = data[5] = 8\n- i=6: arr[(7/3)%3][7%3] = arr[2][1] = data[6] = 3\n- i=7: arr[(8/3)%3][8%3] = arr[2][2] = data[7] = 6\n- i=8: arr[(9/3)%3][9%3] = arr[0][0] = data[8] = 9\n\n**배열 상태:**\n```\n[9][5][2]\n[7][4][1]\n[8][3][6]\n```\n\n3. **합 계산:**\n```c for (int i = 0; i < rows * cols; i++) {\nsum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n}\n```\n- i가 짝수면 +, 홀수면 - 부호를 적용합니다.\n- i=0: arr[0][0]=9 × 1 = 9\n- i=1: arr[0][1]=5 × (-1) = -5\n- i=2: arr[0][2]=2 × 1 = 2\n- i=3: arr[1][0]=7 × (-1) = -7\n- i=4: arr[1][1]=4 × 1 = 4\n- i=5: arr[1][2]=1 × (-1) = -1\n- i=6: arr[2][0]=8 × 1 = 8\n- i=7: arr[2][1]=3 × (-1) = -3\n- i=8: arr[2][2]=6 × 1 = 6\n\n**합:** 9 - 5 + 2 - 7 + 4 - 1 + 8 - 3 + 6 = **13**답:** 13", "table_refs": [], "image_refs": ["images/2025_round1/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nvoid set(int** arr, int* data, int rows, int cols) {\n    for (int i = 0; i < rows * cols; ++i) {\n        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n    }\n}\nint main() {\n    int rows = 3, cols = 3, sum = 0;\n    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}; \n    int** arr;\n    arr = (int**) malloc(sizeof(int*) * rows);\n    for (int i = 0; i < cols; i++) {\n        arr[i] = (int*) malloc(sizeof(int) * cols);\n    }\n    set(arr, data, rows, cols);\n    for (int i = 0; i < rows * cols; i++) {\n        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n    }\n    for(int i=0; i<rows; i++) {\n        free(arr[i]);\n    }\n    free(arr);\n    printf(\"%d\", sum);\n}", "line_numbers": [1, 25], "file": "data/codes/2025_round1/Q011_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 결합도와 관련된 내용이다.\n보기에 알맞는 답을 골라 작성하시오.\n\n(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우의 결합도\n(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\nㄱ. 자료 결합도\n\nㄴ. 스탬프 결합도\n\nㄷ. 제어 결합도\n\nㄹ. 공통 결합도\n\nㅁ. 내용 결합도\n\nㅂ. 외부 결합도", "choices": [], "answer": {"keys": ["(1) ㅁ", "(2) ㄴ", "(3) ㄹ"], "raw_text": "(1) ㅁ\n(2) ㄴ\n(3) ㄹ"}, "explanation": "이 문제는 소프트웨어 공학의 모듈 결합도(Coupling) 개념에 관한 문제입니다.\n\n**문제에서 설명하는 각 결합도:**\n\n**(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우:**\n- **내용 결합도(Content Coupling)**는 가장 강한 결합도입니다.\n- 한 모듈이 다른 모듈의 내부 구현(변수, 함수 등)을 직접 접근하는 경우입니다.\n- 모듈 간의 독립성이 매우 낮아 한 모듈의 변경이 다른 모듈에 직접적인 영향을 미칩니다.\n- 예: 모듈 A가 모듈 B의 전역 변수나 내부 함수를 직접 호출\n\n**(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우:**\n- **스탬프 결합도(Stamp Coupling)**는 구조체나 배열 등의 복합 자료구조가 전달되는 경우입니다.\n- 모듈 간에 필요한 데이터만 전달하지 않고 전체 구조를 전달하므로 불필요한 의존성이 생깁니다.\n- 예: 모듈 A가 모듈 B에 전체 구조체를 전달\n\n**(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용:**\n- **공통 결합도(Common Coupling)**는 여러 모듈이 공통으로 사용하는 전역 변수나 공유 메모리를 사용하는 경우입니다.\n- 전역 변수를 통해 모듈 간에 상호작용하므로 모듈의 독립성이 떨어집니다.\n- 예: 여러 모듈이 같은 전역 변수를 읽고 쓰는 경우\n\n**결합도 순서 (강함 → 약함):**\n1. 내용 결합도 (가장 강함)\n2. 공통 결합도 3. 외부 결합도 4. 제어 결합도 5. 스탬프 결합도 6. 자료 결합도 (가장 약함, 이상적)\n\n**답:** (1) ㅁ (내용 결합도), (2) ㄴ (스탬프 결합도), (3) ㄹ (공통 결합도)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["54"], "raw_text": "54"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 54을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void main(String[] args) {\n        new Child();\n        System.out.println(Parent.total);\n    }\n}\nclass Parent {\n    static int total = 0;\n    int v = 1;\n    public Parent() {\n        total += (++v);\n        show();    \n    }\n    public void show() {\n        total += total;\n    }\n}\nclass Child extends Parent {\n    int v = 10;\n    public Child() {\n        v += 2;\n        total += v++;\n        show();\n    }\n    @Override\n    public void show() {\n        total += total * 2;\n    }\n}", "line_numbers": [1, 29], "file": "data/codes/2025_round1/Q013_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "아래는 디자인 패턴에 대한 설명이다.\n알맞는 답을 보기에 골라 작성하시오.\n서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다.\n기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다.\n기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다.", "choices": [], "answer": {"keys": ["Adapter"], "raw_text": "Adapter"}, "explanation": "Adapter(어댑터) 패턴은 기존 클래스를 수정하지 않고 다른 인터페이스로 변환하여 사용할 수 있게 해주는 디자인 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다\"**\n- 어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스들을 연결합니다.\n- 예를 들어, 클래스 A는 `charge()` 메서드를 가지고 있지만, 클라이언트는 `plugIn()` 메서드를 기대하는 경우, 어댑터가 `plugIn()`을 `charge()`로 변환합니다.\n\n2. **\"기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다\"**\n- Adaptee: 변환이 필요한 기존 클래스\n- Target: 클라이언트가 원하는 인터페이스\n- Adapter: Adaptee를 Target 인터페이스로 변환하는 중간 클래스\n- 어댑터가 Target 인터페이스를 구현하고, 내부적으로 Adaptee를 호출합니다.\n\n3. **\"기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다\"**\n- 어댑터는 기존 클래스를 감싸는 래퍼(Wrapper) 역할을 합니다.\n- 기존 클래스의 기능은 그대로 사용하되, 인터페이스만 변환합니다.\n- 객체 어댑터 방식: 객체 합성을 사용하여 Adaptee를 포함\n- 클래스 어댑터 방식: 다중 상속을 사용하여 Target과 Adaptee를 상속\n\n**어댑터 패턴의 활용 예시:**\n- 전기 콘센트 어댑터: 110V 플러그를 220V 콘센트에 사용\n- 레거시 시스템과 새 시스템 연동\n- 서로 다른 API를 통합\n\n**답:** 문제에서 설명한 모든 특징(인터페이스 변환, 어댑터 클래스, 래퍼 역할)이 Adapter 패턴과 정확히 일치하므로 답은 \"Adapter\"입니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "문장(Statement) 커버리지 테스트를 수행하려고 한다. 코드를 아래의 제어 흐름도 빈칸에 연결되도록 작성하고 문장 커버리지 순서대로 작성하시오.", "choices": [], "answer": {"keys": ["(1) int a = 0", "(2) a < m || b[a] < x", "(3) b[a] < 0", "(4) b[a] = -b[a];", "(5) a++;", "(6) return 1;", "(7) ③ → ④ → ⑤ → ② → ⑥"], "raw_text": "(1) int a = 0\n(2) a < m || b[a] < x\n(3) b[a] < 0\n(4) b[a] = -b[a];\n(5) a++;\n(6) return 1;\n(7) ③ → ④ → ⑤ → ② → ⑥"}, "explanation": "unknown 코드를 단계별로 실행하면서 변수의 초기값과 변화를 추적합니다.\n조건문, 반복문, 함수 호출 등을 순서대로 따라가며 각 단계의 결과를 확인합니다.\n최종 출력값 (1) int a = 0, (2) a < m || b[a] < x, (3) b[a] < 0, (4) b[a] = -b[a];, (5) a++;, (6) return 1;, (7) ③ → ④ → ⑤ → ② → ⑥을 도출하는 과정을 이해합니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q015_1.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "unknown", "code": "int Main(int b[], int m, int x) {\n    int a = 0;\n    while (a < m || b[a] < x) {\n        if (b[a] < 0)\n            b[a] = -b[a];\n        a++;\n    }\n    return 1;\n}", "line_numbers": [1, 9], "file": "data/codes/2025_round1/Q015_code.txt"}], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["unknown"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "(\n\n①    )\n\n2. (    ②    )\n\n3. (    ③    )\n\n4. (    ④    )    5. (    ⑤    )  6. (    ⑥    )\n문장 커버리지 순서 1 → 2\n→ (          ⑦           )", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의와 개념:**\n\n1. **기본 정의**: 세션 하이재킹은 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.\n\n2. **세션이란**: 세션은 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.\n\n**TCP 세션 하이재킹:**\n\n1. **3-way 핸드셰이크**: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.\n- 클라이언트가 서버에 SYN 패킷 전송\n- 서버가 SYN-ACK 패킷 응답\n- 클라이언트가 ACK 패킷 전송 이 과정이 완료되면 정상적인 통신이 시작됩니다.\n\n2. **공격 과정**:\n- 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.\n- TCP 시퀀스 번호를 예측하거나 조작합니다.\n- 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.\n- 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.\n\n**문제 해석**: 문제에서 '세션을 가로채다', 'TCP 3-way 핸드셰이크', '시퀀스 번호 조작', '인증 없이 통신 탈취' 등의 키워드가 언급되어 있으므로 답은 \"세션 하이재킹\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["20"], "raw_text": "20"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 20을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.897106"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void main(String[] args) {\n        int[] data = {3, 5, 8, 12, 17};\n        System.out.println(func(data, 0, data.length - 1));\n    }\n    static int func(int[] a, int st, int end) {\n        if (st >= end) return 0;\n        int mid = (st + end) / 2;\n        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n    } \n}", "line_numbers": [1, 11], "file": "data/codes/2025_round1/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 파이썬에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["13"], "raw_text": "13"}, "explanation": "이 파이썬 코드는 이진 트리를 구성하고 레벨별로 값을 계산하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **트리 구성:**\n```python li = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\n```\n- `tree()` 함수는 리스트를 이진 트리로 변환합니다.\n- `nodes[(i - 1) // 2].children.append(nodes[i])`: 부모 인덱스 계산\n- i=1: 부모=(1-1)//2=0 → nodes[0].children에 nodes[1] 추가\n- i=2: 부모=(2-1)//2=0 → nodes[0].children에 nodes[2] 추가\n- i=3: 부모=(3-1)//2=1 → nodes[1].children에 nodes[3] 추가\n- i=4: 부모=(4-1)//2=1 → nodes[1].children에 nodes[4] 추가\n- i=5: 부모=(5-1)//2=2 → nodes[2].children에 nodes[5] 추가\n- i=6: 부모=(6-1)//2=2 → nodes[2].children에 nodes[6] 추가\n\n**트리 구조:**\n```\n3 (level 0)\n/ \\\n5 8 (level 1)\n/ \\ / \\\n12 15 18 21 (level 2)\n```\n\n2. **calc() 함수 실행:**\n```python def calc(node, level=0):\nif node is None:\nreturn 0 return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\n```\n- level이 홀수(1, 3, 5...)일 때만 노드 값을 더합니다.\n- level이 짝수(0, 2, 4...)일 때는 0을 더합니다.\n\n**계산 과정:**\n- level 0 (루트): 3 값 무시 (level % 2 == 0) → 0\n- level 1: 5 + 8 = 13 (level % 2 == 1) → **13**\n- level 2: 12, 15, 18, 21 값 무시 (level % 2 == 0) → 0\n\n**최종 결과:** 0 + 13 + 0 = **13**답:** 13", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.898106"}, "code_blocks": [{"language": "python", "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\ndef tree(li):\n    nodes = [Node(i) for i in li]\n    for i in range(1, len(li)):\n        nodes[(i - 1) // 2].children.append(nodes[i])\n    return nodes[0]\ndef calc(node, level=0):\n    if node is None:\n        return 0\n    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\nprint(calc(root))", "line_numbers": [1, 16], "file": "data/codes/2025_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.\n19.다음은 C언어에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["35421"], "raw_text": "35421"}, "explanation": "이 C언어 코드는 연결 리스트에 노드를 삽입하고 특정 값을 가진 노드를 맨 앞으로 이동시키는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **insert() 함수로 리스트 생성:**\n```c for (int i = 1; i <= 5; i++)\nhead = insert(head, i);\n```\n- `insert()`는 새 노드를 리스트의 맨 앞에 추가합니다 (역순으로 저장됨).\n- i=1: head = 1 → NULL\n- i=2: head = 2 → 1 → NULL\n- i=3: head = 3 → 2 → 1 → NULL\n- i=4: head = 4 → 3 → 2 → 1 → NULL\n- i=5: head = 5 → 4 → 3 → 2 → 1 → NULL\n\n**최종 리스트:** 5 → 4 → 3 → 2 → 1 → NULL\n\n2. **reconnect() 함수 실행:**\n```c head = reconnect(head, 3);\n```\n- `reconnect()`는 값이 3인 노드를 찾아서 리스트의 맨 앞으로 이동시킵니다.\n- 현재 리스트: 5 → 4 → 3 → 2 → 1 → NULL\n- 값 3인 노드를 찾고, 그 노드를 제거한 후 맨 앞에 다시 삽입합니다.\n\n**reconnect 과정:**\n- curr가 3인 노드를 찾음\n- prev(4)의 next를 curr(3)의 next(2)로 연결\n- curr(3)의 next를 현재 head(5)로 설정\n- head를 curr(3)으로 변경\n\n**결과 리스트:** 3 → 5 → 4 → 2 → 1 → NULL\n\n3. **출력:**\n```c for (curr = head; curr != NULL; curr = curr->next)\nprintf(\"%d\", curr->value);\n```\n- 순서대로: 3, 5, 4, 2, 1\n- **출력: \"35421\"**답:** \"35421\"", "table_refs": [], "image_refs": ["images/2025_round1/Q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.898106"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>   \n#include <stdlib.h>  \ntypedef struct Data {\n    int value;\n    struct Data *next;\n} Data;\nData* insert(Data* head, int value) {\n    Data* new_node = (Data*)malloc(sizeof(Data));\n    new_node->value = value;\n    new_node->next = head;\n    return new_node;\n}\nData* reconnect(Data* head, int value) {\n    if (head == NULL || head->value == value) return head;\n    Data *prev = NULL, *curr = head;\n    while (curr != NULL && curr->value != value) {\n        prev = curr;\n        curr = curr->next;\n    }\n    if (curr != NULL && prev != NULL) {\n        prev->next = curr->next;\n        curr->next = head;\n        head = curr;\n    }\n    return head;\n}\nint main() {\n    Data *head = NULL, *curr;\n    for (int i = 1; i <= 5; i++)\n        head = insert(head, i);\n    head = reconnect(head, 3);\n    for (curr = head; curr != NULL; curr = curr->next)\n        printf(\"%d\", curr->value);\n    return 0; \n}", "line_numbers": [1, 35], "file": "data/codes/2025_round1/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음은 Java 코드에 대한 문제이다.\n아래 코드를 확인하여\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["4"], "raw_text": "4"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 4을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round1/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/540", "crawled_at": "2025-11-02T23:27:48.901395", "last_improved": "2025-11-04T00:15:55.946824", "readability_improved": "2025-11-04T00:26:37.898106"}, "code_blocks": [{"language": "java", "code": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(calc(\"5\"));\n  }\n  static int calc(int value) {\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 2);\n  }\n  static int calc(String str) {\n    int value = Integer.valueOf(str);\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 3);\n  }\n}", "line_numbers": [1, 14], "file": "data/codes/2025_round1/Q020_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 파일 구조와 관련된 설명이다.\n설명을 읽고 괄호 안에 들어갈 가장 알맞은 용어를 작성하시오\n.\n데이터베이스의 물리 설계 시\n,\n레코드에 접근하는 방법은 순차 접근 방법\n, [\n]\n방법\n,\n해싱 방법 등이 있다\n.\n이 중\n[\n]\n방법은 레코드의 키 값과 포인터를 쌍으로 묶어 저장하며 검색 시 키 값을 기준으로 빠르게 탐색할 수 있도록 설계되어 있다\n.\n이 방식은 검색 속도가 빠르며\n<\n키 값\n,\n포인터\n>\n쌍으로 구성된 자료 구조를 사용하여 해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다\n.", "choices": [], "answer": {"keys": ["인덱스"], "raw_text": "인덱스"}, "explanation": "인덱스(Index)는 데이터베이스의 물리적 저장 구조에서 레코드를 빠르게 검색하기 위한 방법입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"레코드에 접근하는 방법\":**\n- 데이터베이스 물리 설계 시 레코드에 접근하는 방법에는 순차 접근 방법, 인덱스 방법, 해싱 방법 등이 있습니다.\n- 인덱스 방법은 이 중 하나로, 빠른 검색을 위해 사용됩니다.\n\n2. **\"레코드의 키 값과 포인터를 쌍으로 묶어 저장\":**\n- 인덱스는 각 레코드의 키 값(예: 학번, 사원번호 등)과 해당 레코드가 실제로 저장된 주소(포인터)를 쌍으로 저장합니다.\n- 예를 들어, 키 값이 \"2024001\"이면 해당 레코드가 저장된 메모리 주소를 함께 저장합니다.\n\n3. **\"검색 시 키 값을 기준으로 빠르게 탐색\":**\n- 순차 접근 방법은 처음부터 끝까지 모든 레코드를 확인해야 하지만, 인덱스를 사용하면 키 값만으로 바로 해당 레코드의 위치를 찾을 수 있습니다.\n- 인덱스는 보통 정렬되어 저장되므로 이진 탐색 등의 효율적인 알고리즘을 사용할 수 있습니다.\n\n4. **\"<키 값, 포인터> 쌍으로 구성된 자료 구조\":**\n- 인덱스는 각 항목을 <키 값, 포인터> 쌍의 형태로 저장합니다.\n- 이 자료 구조를 통해 키 값만 알면 바로 해당 레코드의 위치를 찾을 수 있습니다.\n\n5. **\"해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다\":**\n- 인덱스에서 키 값을 찾으면, 그에 대응하는 포인터(주소)를 얻을 수 있습니다.\n- 이 포인터를 사용하여 데이터베이스에서 해당 레코드를 직접 접근할 수 있습니다.\n\n**왜 인덱스인가:**\n- 문제에서 설명하는 모든 특징(키 값과 포인터 쌍, 빠른 검색, 직접 접근)이 인덱스의 정의와 정확히 일치합니다.\n- 순차 접근 방법은 처음부터 순서대로 찾아가는 방식이고, 해싱 방법은 해시 함수를 사용하는 방식이므로 문제 설명과 일치하지 않습니다.\n\n**답:** 문제에서 설명하는 모든 특징이 인덱스 방법과 정확히 일치하므로 답은 \"인덱스\"입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.224251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["데이터베이스"], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 데이터베이스 릴레이션의 구성 요소 중 하나에 대한 설명이다.\n설명을 읽고 보기에서 알맞은 기호를 골라 작성하시오\n.\n릴레이션\n(Relation)\n에서 열\n(Column)\n을 의미하며 데이터 항목의 속성\n(Attribute)\n또는 특성을 나타낸다\n.\n각 열은 고유한 이름을 가지며 특정 도메인\n(Domain)\n에서 정의된 값을 갖는다\n.\n예를 들어\n\"\n학생\n\"\n릴레이션에서 학번\n,\n이름\n,\n전공 등은 각각 하나의 열이며 이 열들은 학생의 고유한 속성을 나타낸다\n.\n이 개념은 파일 구조에서의 필드\n(Field)\n에 해당하며 릴레이션에서 행\n(Row, Tuple)\n의 구성 요소가 된다\n.\nㄱ\n. Cardinality\nㄷ\n. Attribute", "choices": [], "answer": {"keys": ["ㄷ"], "raw_text": "ㄷ"}, "explanation": "이 문제는 데이터베이스 릴레이션의 구성 요소 중 Attribute(속성)를 설명하는 문제입니다.\n\n**문제에서 설명하는 각 특징을 하나씩 분석:**\n\n1. **\"릴레이션에서 열(Column)을 의미\"**\n- 릴레이션은 관계형 데이터베이스에서 테이블을 의미합니다.\n- 열(Column)은 테이블의 세로 방향 구조로, 데이터의 한 가지 특성을 나타냅니다.\n- Attribute는 이 열(Column)과 동일한 개념입니다.\n\n2. **\"데이터 항목의 속성(Attribute) 또는 특성을 나타낸다\"**\n- 각 Attribute는 데이터 항목이 가지고 있는 특성을 정의합니다.\n- 예를 들어, 사람에 대한 속성으로는 이름, 나이, 주소 등이 있습니다.\n\n3. **\"각 열은 고유한 이름을 가지며 특정 도메인(Domain)에서 정의된 값을 갖는다\"**\n- 각 Attribute는 유일한 이름(예: 학번, 이름, 전공)을 가집니다.\n- 도메인(Domain)은 그 Attribute에 입력될 수 있는 값의 범위를 의미합니다.\n- 예를 들어, 나이 Attribute는 0 이상의 정수만 입력 가능한 도메인을 가질 수 있습니다.\n\n4. **예시: \"학생\" 릴레이션에서 학번, 이름, 전공 등은 각각 하나의 열**\n- 학번 열: 학생의 고유 번호를 나타내는 Attribute\n- 이름 열: 학생의 이름을 나타내는 Attribute\n- 전공 열: 학생의 전공 분야를 나타내는 Attribute\n- 이들은 모두 학생이라는 엔티티의 서로 다른 속성을 나타냅니다.\n\n5. **\"파일 구조에서의 필드(Field)에 해당\"**\n- 파일 구조에서 필드는 데이터의 한 단위를 의미합니다.\n- 데이터베이스의 Attribute는 파일 구조의 필드와 동일한 역할을 합니다.\n- 둘 다 데이터의 특성을 저장하는 단위입니다.\n\n6. **\"릴레이션에서 행(Row, Tuple)의 구성 요소\"**\n- 한 행(튜플)은 여러 Attribute 값들로 구성됩니다.\n- 예를 들어, 한 학생의 행은 (학번: 2024001, 이름: \"홍길동\", 전공: \"컴퓨터공학\") 형태입니다.\n- 여기서 각 값(2024001, \"홍길동\", \"컴퓨터공학\")은 해당 Attribute의 실제 값입니다.\n\n**보기 분석:**\n- ㄱ. Cardinality(카디널리티): 릴레이션에서 튜플(행)의 개수를 의미합니다. 문제에서 설명하는 \"열\"과는 반대로 \"행의 개수\"를 의미하므로 문제 설명과 일치하지 않습니다.\n- ㄷ. Attribute(속성): 문제에서 설명하는 모든 특징(열, 속성, 고유한 이름, 도메인, 필드에 해당, 행의 구성 요소)이 Attribute의 정의와 정확히 일치합니다.\n\n**결론:** 문제에서 설명하는 모든 특징이 Attribute의 정의와 완전히 일치하므로 답은 \"ㄷ\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 정보보안 관련 문제이다.\n아래 내용을 보고\n\n알맞는 단어를 작성하시오.\n원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공하는 보안 접속용 프로토콜이다\n.\n공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원한다\n.\n주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는 22 번이다\n.\nTelnet 의 보안 취약점을 보완한 대안으로 널리 사용된다\n.", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "SSH(Secure Shell)는 원격 접속을 위한 보안 프로토콜입니다.\n\n**문제에서 설명한 특징과 정확히 매칭:**\n\n1. **\"원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공\"**\n- SSH는 네트워크를 통해 원격 컴퓨터에 안전하게 접속하기 위해 사용됩니다.\n- 모든 통신 데이터를 암호화하여 전송하므로 네트워크상에서 가로채더라도 내용을 알 수 없습니다.\n- 이는 평문으로 통신하는 Telnet의 보안 취약점을 해결한 것입니다.\n\n2. **\"공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원\"**\n- SSH는 공개키 암호화 방식을 사용하여 사용자를 인증합니다.\n- 공개키-개인키 쌍을 사용하므로 비밀번호보다 더 안전한 인증이 가능합니다.\n- 모든 데이터가 암호화되어 전송되므로 기밀성이 보장됩니다.\n\n3. **\"주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는 22번\"**\n- SSH는 주로 서버 관리자가 원격으로 서버에 접속하여 명령을 실행할 때 사용됩니다.\n- SSH의 표준 포트 번호는 22번입니다. 이는 SSH를 식별하는 중요한 특징 중 하나입니다.\n- 포트 번호 22번은 IANA(Internet Assigned Numbers Authority)에서 SSH에 할당한 공식 포트입니다.\n\n4. **\"Telnet의 보안 취약점을 보완한 대안으로 널리 사용된다\"**\n- Telnet은 모든 데이터를 평문으로 전송하므로 네트워크상에서 비밀번호 등 중요한 정보가 노출될 위험이 있습니다.\n- SSH는 이러한 보안 취약점을 해결하기 위해 개발되었으며, 현재 원격 접속의 표준 프로토콜로 널리 사용됩니다.\n\n**답:** 문제에서 설명한 모든 특징(원격 접속, 암호화된 통신, 공개키 인증, 포트 22번, Telnet의 대안)이 SSH와 정확히 일치하므로 답은 \"SSH\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "스케줄링 알고리즘에 관한 다음 설명을 읽고\n\n(1)\n과\n(2)\n에 알맞은 스케줄링 알고리즘의 명칭을 각각 쓰시오\n.\n\n(1) CPU burst 시간이 짧은 프로세스를 우선적으로 처리하는 스케줄링 방식이다\n.\n\"Shortest Next CPU Burst\"\n라고도 불리며 선점형 또는 비선점형으로 구현될 수 있다\n.\n(2)\n위의 스케줄링 방식을 선점형으로 구현한 형태로 실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU 를 선점한다\n.", "choices": [], "answer": {"keys": ["(1) SJF", "(2) SRT"], "raw_text": "(1) SJF\n(2) SRT"}, "explanation": "이 문제는 운영체제의 CPU 스케줄링 알고리즘인 SJF(Shortest Job First)와 SRT(Shortest Remaining Time)에 관한 문제입니다.\n\n**문제 분석:**\n\n**(1)에 해당하는 스케줄링 알고리즘:**\n- **\"CPU burst 시간이 짧은 프로세스를 우선적으로 처리\"**: CPU를 사용하는 시간이 짧은 프로세스를 먼저 실행합니다.\n- **\"Shortest Next CPU Burst라고도 불림\"**: 다음에 실행될 CPU burst 시간이 가장 짧은 프로세스를 선택합니다.\n- **\"선점형 또는 비선점형으로 구현될 수 있다\"**: 프로세스를 중간에 중단시킬 수 있는 선점형으로도, 그렇지 않은 비선점형으로도 구현 가능합니다.\n\n이 특징들은 **SJF(Shortest Job First, 최단 작업 우선)**와 정확히 일치합니다.\n\n**(2)에 해당하는 스케줄링 알고리즘:**\n- **\"위의 스케줄링 방식을 선점형으로 구현한 형태\"**: SJF를 선점형으로 구현한 것입니다.\n- **\"실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU를 선점\"**: 현재 실행 중인 프로세스가 5ms가 남았는데, 2ms만 필요한 새로운 프로세스가 도착하면 기존 프로세스를 중단하고 새로운 프로세스를 실행합니다.\n\n이 특징은 **SRT(Shortest Remaining Time, 최단 잔여 시간 우선)**와 정확히 일치합니다.\n\n**SJF와 SRT의 차이:**\n- SJF는 비선점형이 기본이지만 선점형으로도 구현 가능합니다.\n- SRT는 SJF의 선점형 버전으로, 실행 중인 프로세스의 남은 시간을 고려하여 더 짧은 작업이 도착하면 즉시 선점합니다.\n\n**답:** (1) SJF, (2) SRT", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 Java의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["BB"], "raw_text": "BB"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 BB을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [{"id": "table1", "json": "data/tables/2025_round2/Q005_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2025_round2/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void change(String[] data, String s){\n        data[0] = s;\n        s = \"Z\";\n    }\n    public static void main(String[] args) {\n        String data[] = { \"A\" };\n        String s = \"B\";\n        change(data, s);\n        System.out.print(data[0] + s);\n    }\n}", "line_numbers": [1, 12], "file": "data/codes/2025_round2/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 IP 주소와 서브넷 마스크에 관한 문제이다.\n주어진 정보를 참고하여\n\n괄호 안에 들어갈 알맞은 값을 쓰시오\n.\n호스트의 IP 주소가 223.13.234.132 이고 서브넷 마스크가 255.255.255.192 일 때 다음 물음에 답하시오\n.\n이 호스트가 속한 네트워크 주소는 223.13.234.(\n\n①\n)\n이다\n.\n이 네트워크에서 사용 가능한 호스트 수는\n(\n②\n)\n개이다\n.\n(\n단\n,\n네트워크 주소와 브로드캐스트 주소는 제외한다\n.)", "choices": [], "answer": {"keys": ["① 128", "② 62"], "raw_text": "① 128\n② 62"}, "explanation": "이 문제는 IP 주소와 서브넷 마스크를 사용하여 네트워크 주소와 사용 가능한 호스트 수를 계산하는 문제입니다.\n\n**주어진 정보:**\n- 호스트 IP 주소: 223.13.234.132\n- 서브넷 마스크: 255.255.255.192\n\n**① 네트워크 주소 계산:**\n\n서브넷 마스크 255.255.255.192를 이진수로 변환하면:\n- 255.255.255.192 = 11111111.11111111.11111111.11000000\n\n마지막 옥텟(8비트)에서:\n- 192 = 11000000 (2진수)\n- 서브넷 비트 수: 2개 (앞의 두 개 1)\n- 호스트 비트 수: 6개 (뒤의 여섯 개 0)\n\n네트워크 주소를 계산하려면 IP 주소와 서브넷 마스크를 AND 연산:\n- IP: 223.13.234.132 = 11011111.00001101.11101010.10000100\n- 마스크: 255.255.255.192 = 11111111.11111111.11111111.11000000\n- AND 결과: 223.13.234.128\n\n따라서 네트워크 주소는 223.13.234.**128**입니다.\n\n**② 사용 가능한 호스트 수 계산:**\n\n호스트 비트 수가 6개이므로:\n- 사용 가능한 주소: 2^6 = 64개\n- 하지만 네트워크 주소와 브로드캐스트 주소는 사용할 수 없으므로:\n- 실제 사용 가능한 호스트 수: 64 - 2 = **62개**답:** ① 128, ② 62", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 디자인 패턴에 관한 문제이다.\n아래 내용을 보고\n\n알맞는 단어를 작성하시오.\n어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용하는 방식의 디자인 패턴이다\n.\n실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시켜 메모리와 자원을 절약할 수 있 다\n.\n또한\n,\n실제 객체를 감추어 정보은닉을 강화할 수 있다는 장점이 있다\n.", "choices": [], "answer": {"keys": ["Proxy"], "raw_text": "Proxy"}, "explanation": "Proxy(프록시) 패턴은 객체지향 디자인 패턴 중 하나로, 실제 객체에 대한 접근을 제어하는 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용\"**\n- 프록시는 실제 객체를 직접 접근하지 않고, 프록시 객체를 통해 간접적으로 접근합니다.\n- 프록시는 실제 객체의 대리인 역할을 하며, 클라이언트는 프록시를 실제 객체처럼 사용합니다.\n\n2. **\"실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시킬 수 있다\"**\n- 프록시는 실제 객체를 생성하기 전에 필요한 사전 작업(인증, 로깅 등)을 수행할 수 있습니다.\n- 실제 객체는 필요할 때까지 생성하지 않고 지연시키므로(Lazy Loading) 메모리와 자원을 절약할 수 있습니다.\n- 예를 들어, 이미지나 대용량 파일을 실제로 사용할 때까지 로드하지 않아 메모리를 절약합니다.\n\n3. **\"실제 객체를 감추어 정보은닉을 강화할 수 있다\"**\n- 클라이언트는 실제 객체를 직접 접근하지 않고 프록시를 통해서만 접근하므로, 실제 객체의 내부 구조를 숨길 수 있습니다.\n- 이를 통해 보안을 강화하고, 실제 객체의 구현 세부사항을 감출 수 있습니다.\n\n**프록시 패턴의 활용 예시:**\n- 가상 프록시(Virtual Proxy): 무거운 객체를 지연 로딩\n- 원격 프록시(Remote Proxy): 네트워크를 통해 원격 객체에 접근\n- 보호 프록시(Protection Proxy): 접근 권한 제어\n\n**답:** 문제에서 설명한 모든 특징(접근 제어, 대리 객체, 지연 생성, 정보은닉)이 Proxy 패턴과 정확히 일치하므로 답은 \"Proxy\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.901108"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음은 웹 데이터 교환 방식에 관한 문제이다.\n아래 설명을 읽고 괄호 안에 들어갈 알맞은 용어를 작성하시오\n.\n(\n)\n은\n/\n는 웹 페이지 전체를 다시 불러오지 않고 JavaScript 와 XML(\n또는 JSON)\n을 이용하여 일부 콘텐츠만 비동기적으로 갱신할 수 있는 기술이다\n.\n(\n)\n은\n/\n는 HTML 만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법이다\n.", "choices": [], "answer": {"keys": ["AJAX"], "raw_text": "AJAX"}, "explanation": "AJAX(Asynchronous JavaScript and XML)는 웹 페이지를 새로고침하지 않고 비동기적으로 데이터를 교환하는 웹 개발 기법입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"웹 페이지 전체를 다시 불러오지 않고 JavaScript와 XML(또는 JSON)을 이용하여 일부 콘텐츠만 비동기적으로 갱신\"**\n- 전통적인 웹 페이지는 사용자가 링크를 클릭하면 전체 페이지를 다시 서버에서 가져와서 화면을 다시 그려야 합니다.\n- AJAX를 사용하면 페이지의 일부 영역만 JavaScript를 통해 서버에서 데이터를 가져와서 업데이트할 수 있습니다.\n- 이 과정은 비동기적으로 이루어지므로, 사용자는 페이지를 기다리는 동안 다른 작업을 계속할 수 있습니다.\n- 데이터 형식으로는 XML이나 JSON을 주로 사용합니다.\n\n2. **\"HTML만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법\"**\n- HTML만으로는 정적인 페이지만 만들 수 있습니다.\n- AJAX는 JavaScript, XMLHttpRequest(또는 Fetch API) 등을 활용하여 동적인 상호작용을 가능하게 합니다.\n- 예를 들어, 검색어를 입력하면 자동완성 목록이 나타나거나, 댓글을 작성하면 새로고침 없이 바로 화면에 추가되는 등의 기능이 가능합니다.\n\n**AJAX의 장점:**\n- 사용자 경험 향상: 페이지 전체 새로고침 없이 필요한 부분만 업데이트\n- 서버 부하 감소: 필요한 데이터만 요청하여 네트워크 트래픽 감소\n- 빠른 응답: 비동기 처리를 통해 사용자 인터페이스가 블로킹되지 않음\n\n**답:** 문제에서 설명한 모든 특징(비동기 갱신, JavaScript와 XML/JSON 사용, 동적 기능, 상호작용)이 AJAX와 정확히 일치하므로 답은 \"AJAX\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["프로그래밍"], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["19"], "raw_text": "19"}, "explanation": "이 Java 코드는 람다 표현식과 예외 처리 메커니즘을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java F f = (x) -> {\nif (x > 2) {\nthrow new Exception();\n}\nreturn x * 2;\n};\n```\n\n1. **첫 번째 `run(f)` 호출:**\n- `f.apply(3)`이 실행됩니다.\n- x = 3이므로 `x > 2` 조건이 참입니다.\n- 따라서 `Exception`이 발생합니다.\n- `run` 메서드의 catch 블록에서 예외를 잡아서 **7을 반환**합니다.\n- 따라서 `run(f) = 7`\n\n2. **두 번째 `run((int n) -> n + 9)` 호출:**\n- 새로운 람다 함수 `(int n) -> n + 9`가 전달됩니다.\n- 이 함수는 예외를 발생시키지 않는 일반적인 함수입니다.\n- `n = 3`이 전달되면 `3 + 9 = 12`를 반환합니다.\n- 따라서 `run((int n) -> n + 9) = 12`\n\n3. **최종 출력:**\n- `run(f) + run((int n) -> n + 9) = 7 + 12 = 19`\n\n**핵심 포인트:**\n- 람다 표현식에서 조건에 따라 예외를 발생시킬 수 있습니다.\n- `run` 메서드는 try-catch 블록으로 예외를 처리하고, 예외 발생 시 7을 반환합니다.\n- 두 개의 서로 다른 람다 함수가 각각 다른 결과를 반환합니다.\n\n**답:** 19", "table_refs": [], "image_refs": ["images/2025_round2/Q009.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    static interface F {\n        int apply(int x) throws Exception;\n    }\n    public static int run(F f) {\n        try {\n            return f.apply(3);\n        } catch (Exception e) {\n            return 7;\n        }\n    }\n    public static void main(String[] args) {\n        F f = (x) -> {\n            if (x > 2) {\n                throw new Exception();\n            }\n            return x * 2;\n        };\n        System.out.print(run(f) + run((int n) -> n + 9));\n    }\n}", "line_numbers": [1, 21], "file": "data/codes/2025_round2/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5P"], "raw_text": "5P"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 5P을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [{"language": "java", "code": "public class Main{\n    public static class Parent {\n        public int x(int i) { return i + 2; }\n        public static String id() { return \"P\";}\n    }\n    public static class Child extends Parent {\n        public int x(int i) { return i + 3; }\n        public String x(String s) { return s + \"R\"; }\n        public static String id() { return \"C\"; }\n    }\n    public static void main(String[] args) {\n        Parent ref = new Child();\n        System.out.println(ref.x(2) + ref.id());\n    }\n}", "line_numbers": [1, 15], "file": "data/codes/2025_round2/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.", "choices": [], "answer": {"keys": ["1234561", "124567"], "raw_text": "1234561 124567"}, "explanation": "분기 커버리지(Branch Coverage)는 모든 분기(조건문의 각 경로)를 최소 한 번씩 실행하는 테스트 커버리지 기준입니다.\n\n**문제 이해:**\n제어 흐름 그래프의 모든 분기(조건문의 True/False 경로)를 최소 한 번씩 실행하는 테스트 경로를 찾아야 합니다.\n\n**해결 방법:**\n1. 그래프의 각 노드(1, 2, 3, 4, 5, 6, 7)를 식별합니다.\n2. 각 분기(조건문의 참/거짓 경로)를 모두 커버하는 경로를 찾습니다.\n3. 가능한 모든 분기를 포함하는 테스트 케이스 경로를 작성합니다.\n\n**답:** 1234561, 124567\n- 첫 번째 경로(1234561): 노드 1→2→3→4→5→6→1로 돌아가는 경로와 루프를 포함\n- 두 번째 경로(124567): 노드 1→2→4→5→6→7 경로를 포함\n- 이 두 경로를 통해 그래프의 모든 분기를 커버할 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2 그리고 3"], "raw_text": "2 그리고 3"}, "explanation": "이 C언어 코드는 원형 큐(Circular Queue) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c Queue q = {{0}, 0, 0};\n```\n- 큐 구조체를 초기화: 배열 `a[] = {0, 0, 0}`, `front = 0`, `rear = 0`\n\n2. **`enq(&q, 1)` 실행:**\n- `q->a[0] = 1` → 배열[0]에 1 저장\n- `q->rear = (0 + 1) % 3 = 1` → rear를 1로 이동\n- 상태: `a = {1, 0, 0}`, `front = 0`, `rear = 1`\n\n3. **`enq(&q, 2)` 실행:**\n- `q->a[1] = 2` → 배열[1]에 2 저장\n- `q->rear = (1 + 1) % 3 = 2` → rear를 2로 이동\n- 상태: `a = {1, 2, 0}`, `front = 0`, `rear = 2`\n\n4. **`deq(&q)` 실행:**\n- `val = q->a[0] = 1` → 배열[0]의 값 1을 가져옴\n- `q->front = (0 + 1) % 3 = 1` → front를 1로 이동\n- 상태: `a = {1, 2, 0}`, `front = 1`, `rear = 2`\n\n5. **`enq(&q, 3)` 실행:**\n- `q->a[2] = 3` → 배열[2]에 3 저장\n- `q->rear = (2 + 1) % 3 = 0` → rear를 0으로 이동 (원형 큐 특성)\n- 상태: `a = {1, 2, 3}`, `front = 1`, `rear = 0`\n\n6. **`first = deq(&q)` 실행:**\n- `val = q->a[1] = 2` → front 위치의 값 2를 가져옴\n- `q->front = (1 + 1) % 3 = 2` → front를 2로 이동\n- `first = 2`\n\n7. **`second = deq(&q)` 실행:**\n- `val = q->a[2] = 3` → front 위치의 값 3을 가져옴\n- `q->front = (2 + 1) % 3 = 0` → front를 0으로 이동\n- `second = 3`\n\n**최종 출력:** \"2 그리고 3\"\n\n**핵심 포인트:**\n- 원형 큐는 배열의 마지막 인덱스 다음에 처음 인덱스로 돌아가는 구조입니다.\n- `% SIZE` 연산을 통해 원형 구조를 구현합니다.\n- front는 데이터를 꺼내는 위치, rear는 데이터를 넣는 위치입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#define SIZE 3\ntypedef struct {\n    int a[SIZE];\n    int front;\n    int rear;\n} Queue;\nvoid enq(Queue* q, int val){\n    q->a[q->rear] = val; \n    q->rear = (q->rear + 1) % SIZE;\n}\nint deq(Queue* q) {\n    int val = q->a[q->front];\n    q->front = (q->front + 1) % SIZE;\n    return val;\n}\nint main() {\n    Queue q = {{0}, 0, 0};\n    enq(&q,1); enq(&q,2); deq(&q); enq(&q, 3);\n    int first = deq(&q);\n    int second = deq(&q);\n    printf(\"%d 그리고 %d\", first, second);\n    return 0;\n}", "line_numbers": [1, 24], "file": "data/codes/2025_round2/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "라운드로빈(RR) 방식을 이용하고 아래 내용을 참고하여\n\n평균대기시간을 구하시오.\n운영체제에서 라운드로빈\n(Round Robin, RR)\n스케줄링은 각 프로세스에 동일한 시간 할당량\n(\n타임 퀀텀\n)\n을 순차적으로 부여하며 CPU 를 할당하는 방식이다\n.\n다음은 4\n개의 프로세스가 서로 다른 시간에 도착하며 각기 다른 실행 시간을 가지는 상황이다.\n이때 시간 할당량은 4ms 이고 컨텍스트 스위칭 시간은 무시한다고 가정한다\n.\n아래 정보를 바탕으로 라운드로빈\n(RR)\n방식으로 CPU 스케줄링을 수행할 경우 모든 프로세스의 평균 대기시간\n(Average Waiting Time)\n은 얼마인가\n?", "choices": [], "answer": {"keys": ["11.75"], "raw_text": "11.75"}, "explanation": "라운드로빈(Round Robin, RR) 스케줄링은 각 프로세스에 동일한 시간 할당량(타임 퀀텀)을 순차적으로 부여하는 CPU 스케줄링 방식입니다.\n\n**주어진 정보:**\n- 타임 퀀텀: 4ms\n- 컨텍스트 스위칭 시간: 무시\n- 프로세스 정보: 표 참조\n\n**라운드로빈 스케줄링 동작 원리:**\n1. 각 프로세스는 타임 퀀텀(4ms)만큼 CPU를 할당받습니다.\n2. 타임 퀀텀이 지나면 현재 프로세스는 중단되고 다음 프로세스로 전환됩니다.\n3. 중단된 프로세스는 대기 큐의 맨 뒤에 추가되어 다시 기회를 얻습니다.\n4. 모든 프로세스가 완료될 때까지 반복합니다.\n\n**평균 대기시간 계산:**\n각 프로세스가 준비 큐에서 대기한 시간의 총합을 프로세스 수로 나눈 값입니다.\n\n1. 각 프로세스의 대기시간을 계산:\n- 프로세스가 처음 실행되기 전까지의 시간\n- 이후 실행 중단 후 재실행 전까지의 시간들의 합\n\n2. 모든 프로세스의 대기시간을 더한 후 프로세스 수로 나눕니다.\n\n**답:** 문제에서 주어진 프로세스 정보와 타임 퀀텀 4ms를 바탕으로 계산하면 평균 대기시간은 **11.75**입니다.", "table_refs": [{"id": "table1", "json": "data/tables/2025_round2/Q013_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2025_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5 그리고 6"], "raw_text": "5 그리고 6"}, "explanation": "이 C언어 코드는 포인터의 포인터(이중 포인터)와 구조체 배열을 다루는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n```\n- 구조체 배열 `a`를 초기화: `a[0] = {1, 2}`, `a[1] = {3, 4}`, `a[2] = {5, 6}`\n\n2. **포인터 설정:**\n```c struct dat* ptr = a; // ptr은 배열 a의 첫 번째 요소를 가리킴 struct dat** pptr = &ptr; // pptr은 ptr 변수의 주소를 가리킴 (이중 포인터)\n```\n\n3. **중요한 연산:**\n```c\n(*pptr)[1] = (*pptr)[2];\n```\n- `*pptr`은 `ptr`을 의미합니다 (pptr이 가리키는 값이 ptr)\n- `(*pptr)[1]`은 `ptr[1]` 즉 `a[1]`을 의미합니다\n- `(*pptr)[2]`는 `ptr[2]` 즉 `a[2]`를 의미합니다\n- 따라서 `a[1] = a[2]`가 실행됩니다\n- 결과: `a[1] = {5, 6}` (a[2]의 값이 a[1]에 복사됨)\n\n4. **출력:**\n```c printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n```\n- `a[1].x = 5`, `a[1].y = 6`\n- 출력: \"5 그리고 6\"\n\n**핵심 포인트:**\n- 이중 포인터 `**pptr`은 포인터를 가리키는 포인터입니다.\n- `(*pptr)[1]`은 `ptr[1]`과 동일하며, 이는 `a[1]`을 의미합니다.\n- 구조체 배열의 요소는 구조체 전체가 복사됩니다.\n\n**답:** \"5 그리고 6\"", "table_refs": [], "image_refs": ["images/2025_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.902107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct dat {\n    int x;\n    int y;\n};\nint main() {\n    struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n    struct dat* ptr = a;\n    struct dat** pptr = &ptr;\n    (*pptr)[1] = (*pptr)[2];\n    printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n    return 0;\n}", "line_numbers": [1, 13], "file": "data/codes/2025_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1a3b3"], "raw_text": "1a3b3"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 1a3b3을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.903107"}, "code_blocks": [{"language": "java", "code": "public class Main{\n    public static class BO {\n        public int v;\n        public BO(int v) {\n            this.v = v;\n        }\n    }\n    public static void main(String[] args) {\n        BO a = new BO(1);\n        BO b = new BO(2);\n        BO c = new BO(3);\n        BO[] arr = {a, b, c};\n        BO t = arr[0];\n        arr[0] = arr[2];\n        arr[2] = t;\n        arr[1].v = arr[0].v;\n        System.out.println(a.v + \"a\" + b.v + \"b\" + c.v);\n    }\n}", "line_numbers": [1, 19], "file": "data/codes/2025_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["3 1 2"], "raw_text": "3 1 2"}, "explanation": "이 C언어 코드는 연결 리스트(Linked List)의 포인터 연결을 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **노드 생성 및 초기화:**\n```c struct node a = {1, NULL};\nstruct node b = {2, NULL};\nstruct node c = {3, NULL};\n```\n- 세 개의 노드 생성: `a.p = 1`, `b.p = 2`, `c.p = 3`, 모두 다음 노드 포인터는 NULL\n\n2. **첫 번째 연결:**\n```c a.n = &b; // a의 다음 노드는 b.n = &c; // b의 다음 노드는 c.n = NULL;\n```\n- 연결: a → b → c → NULL\n\n3. **두 번째 연결 (덮어쓰기):**\n```c.n = &a; // c의 다음 노드를 a로 변경 a.n = &b; // a의 다음 노드는 여전히 b.n = NULL; // b의 다음 노드를 NULL로 변경\n```\n- 최종 연결: `c → a → b → NULL` (c가 a를 가리키고, a가 b를 가리키고, b는 NULL)\n\n4. **출력:**\n```c struct node* head = &c; // head는 c를 가리킴 printf(\"%d %d\", head->p, head->n->p, head->n->n->p);\n```\n- `head->p` = `c.p` = **3**\n- `head->n->p` = `a.p` = **1** (head->n은 a를 가리킴)\n- `head->n->n->p` = `b.p` = **2** (head->n->n은 b를 가리킴)\n\n**최종 출력:** \"3 1 2\"\n\n**핵심 포인트:**\n- 포인터 할당 순서에 따라 연결 리스트의 구조가 달라집니다.\n- 마지막에 할당한 값이 이전 값을 덮어씁니다.\n- `head` 포인터를 따라가면서 각 노드의 값을 출력합니다.", "table_refs": [], "image_refs": ["images/2025_round2/q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.903107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int p;\n    struct node* n;\n};\nint main() {\n    struct node a = {1, NULL};\n    struct node b = {2, NULL};\n    struct node c = {3, NULL};\n    a.n = &b; b.n = &c; c.n = NULL;\n    c.n = &a; a.n = &b; b.n = NULL;\n    struct node* head = &c;\n    printf(\"%d %d %d\", head->p, head->n->p, head->n->n->p);\n    return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2025_round2/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Pyhon언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 파이썬 코드는 딕셔너리, 집합(set) 생성과 연산을 이해하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **딕셔너리 생성:**\n```python lst = [1, 2, 3]\ndst = {i : i * 2 for i in lst}\n```\n- 딕셔너리 컴프리헨션: `dst = {1: 2, 2: 4, 3: 6}`\n- 키는 리스트의 각 요소, 값은 그 요소의 2배\n\n2. **집합 생성:**\n```python s = set(dst.values())\n```\n- 딕셔너리의 값들로 집합 생성: `s = {2, 4, 6}`\n\n3. **리스트 수정:**\n```python lst[0] = 99\n```\n- `lst = [99, 2, 3]`으로 변경\n- **주의:** 딕셔너리는 이미 생성되었으므로 `dst`는 변경되지 않습니다!\n- `dst`는 여전히 `{1: 2, 2: 4, 3: 6}`입니다.\n\n4. **딕셔너리 값 수정:**\n```python dst[2] = 7\n```\n- 키 2의 값을 7로 변경: `dst = {1: 2, 2: 7, 3: 6}`\n\n5. **집합에 요소 추가:**\n```python s.add(99)\n```\n- 집합 s에 99 추가: `s = {2, 4, 6, 99}`\n\n6. **집합 교집합 계산:**\n```python print(len(s & set(dst.values())))\n```\n- `s = {2, 4, 6, 99}`\n- `set(dst.values()) = {2, 7, 6}` (dst의 현재 값들)\n- 교집합: `{2, 4, 6, 99} & {2, 7, 6} = {2, 6}`\n- 교집합의 길이: **2**핵심 포인트:**\n- 딕셔너리 컴프리헨션은 생성 시점의 리스트 값으로 딕셔너리를 만듭니다.\n- 이후 리스트를 수정해도 이미 생성된 딕셔너리는 영향받지 않습니다.\n- 집합의 교집합 연산(`&`)은 두 집합에 공통으로 있는 요소만 반환합니다.\n\n**답:** 2", "table_refs": [], "image_refs": ["images/2025_round2/q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.903107"}, "code_blocks": [{"language": "python", "code": "lst = [1,2,3]\ndst = {i : i* 2 for i in lst}\ns = set(dst.values())\nlst[0] = 99 \ndst[2]=7\ns.add(99)\nprint(len(s & set(dst.values())))", "line_numbers": [1, 7], "file": "data/codes/2025_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["TSEB"], "raw_text": "TSEB"}, "explanation": "이 C언어 코드는 연결 리스트를 역순으로 생성하고 출력하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **`func(\"BEST\")` 호출:**\n- 문자열 \"BEST\"를 받아서 연결 리스트를 생성합니다.\n- 연결 리스트는 **역순**으로 구성됩니다 (새 노드가 맨 앞에 추가됨).\n\n```c while(*s) { // 문자열의 각 문자를 처리 n = malloc(sizeof(struct node));\nn->c = *s++; // 현재 문자를 노드에 저장 n->p = h; // 새 노드의 다음 노드를 이전 head로 설정 h = n; // head를 새 노드로 변경\n}\n```\n\n- 첫 번째 반복: 'B' → head = B 노드\n- 두 번째 반복: 'E' → E 노드가 B 노드 앞에 추가, head = E → B\n- 세 번째 반복: 'S' → S 노드가 E 노드 앞에 추가, head = S → E → B\n- 네 번째 반복: 'T' → T 노드가 S 노드 앞에 추가, head = T → S → E → B\n\n**최종 연결 리스트:** T → S → E → B → NULL\n\n2. **`main()` 함수에서 출력:**\n```c struct node* n = func(\"BEST\"); // n은 T 노드를 가리킴 while(n) {\nputchar(n->c); // 현재 노드의 문자 출력 struct node* t = n; // 임시 변수에 현재 노드 저장 n = n->p; // 다음 노드로 이동 free(t); // 현재 노드 메모리 해제\n}\n```\n\n- 첫 번째 반복: `n->c = 'T'` 출력, `n = n->p` → S 노드로 이동\n- 두 번째 반복: `n->c = 'S'` 출력, `n = n->p` → E 노드로 이동\n- 세 번째 반복: `n->c = 'E'` 출력, `n = n->p` → B 노드로 이동\n- 네 번째 반복: `n->c = 'B'` 출력, `n = n->p` → NULL\n\n**최종 출력:** \"TSEB\"\n\n**핵심 포인트:**\n- 연결 리스트에 노드를 추가할 때 새 노드를 head 앞에 추가하면 역순으로 저장됩니다.\n- 입력 \"BEST\"가 역순으로 저장되어 T → S → E → B 순서로 출력됩니다.\n- 각 노드를 출력한 후 메모리를 해제하여 메모리 누수를 방지합니다.\n\n**답:** \"TSEB\"", "table_refs": [], "image_refs": ["images/2025_round2/q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.903107"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    char c;\n    struct node* p;\n};\nstruct node* func(char* s) {\n    struct node* h = NULL, *n;\n    while(*s) {\n        n = malloc(sizeof(struct node));\n        n->c = *s++;\n        n->p = h;\n        h = n;\n    }\n    return h;\n}\nint main() {\n    struct node* n = func(\"BEST\");\n    while(n) {\n        putchar(n->c);\n        struct node* t = n;\n        n = n->p;\n        free(t);\n    }\n    return 0;\n}", "line_numbers": [1, 26], "file": "data/codes/2025_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 TCP 통신 과정에서 발생할 수 있는 보안 취약점에 대한 설명이다.\n이를 이용한 공격 기법으로 옳은 것은\n?\nTCP 는 연결을 수립하기 위해 클라이언트가 서버에 SYN 패킷을 보내고 서버는 SYN-ACK 패킷으로 응답한 후 클라이언트가 다시 ACK 패킷을 보내는 3-way-handshake 과정을 거친다\n.\n이때 공격자는 클라이언트 역할로 수많은 SYN 패킷을 서버에 전송한 뒤 마지막 ACK 를 고의로 보내지 않아 서버가 연결 대기 상태를 계속 유지하게 만든다\n.\n이로 인해 서버의 연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못하게 되어 서비스 거부 상태가 발생한다\n.", "choices": [], "answer": {"keys": ["SYN Flooding"], "raw_text": "SYN Flooding"}, "explanation": "SYN Flooding은 TCP 연결 과정에서 발생하는 서비스 거부 공격(DoS) 기법입니다.\n\n**TCP 3-way-handshake 과정:**\n1. 클라이언트가 서버에 **SYN** 패킷 전송 2. 서버가 **SYN-ACK** 패킷으로 응답 3. 클라이언트가 **ACK** 패킷을 전송하여 연결 완료\n\n**SYN Flooding 공격 원리:**\n\n1. **공격자의 행동:**\n- 공격자가 클라이언트 역할로 수많은 **SYN 패킷**을 서버에 전송\n- 하지만 마지막 **ACK 패킷을 고의로 보내지 않음**\n\n2. **서버의 상태:**\n- 서버는 SYN 패킷을 받으면 SYN-ACK 패킷을 전송하고 연결을 위한 리소스를 할당\n- 클라이언트의 ACK 패킷을 기다리는 **SYN_RECEIVED** 상태로 대기\n- 연결 대기 큐에 연결 요청이 계속 쌓임\n\n3. **결과:**\n- 서버의 연결 대기 큐가 가득 차게 됨\n- 정상적인 클라이언트의 접속 요청을 처리할 수 없게 됨\n- 서비스 거부(Denial of Service, DoS) 상태 발생\n\n**문제에서 설명한 특징과 정확히 일치:**\n- \"클라이언트 역할로 수많은 SYN 패킷 전송\" ✓\n- \"마지막 ACK를 고의로 보내지 않음\" ✓\n- \"서버가 연결 대기 상태를 계속 유지\" ✓\n- \"연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못함\" ✓\n- \"서비스 거부 상태 발생\" ✓\n\n**답:** 문제에서 설명한 모든 특징이 SYN Flooding 공격과 정확히 일치하므로 답은 \"SYN Flooding\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.903107"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["TCP/IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]", "choices": [], "answer": {"keys": ["TTL", "부장", "대리", "과장", "차장"], "raw_text": "TTL 부장 대리 과장 차장"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]...\n\n**답이 \"TTL, 부장, 대리\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"TTL, 부장, 대리\"입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824", "readability_improved": "2025-11-04T00:26:37.903107"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
