{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q001", "question_text": "다음은 파일 구조와 관련된 설명이다.\n설명을 읽고 괄호 안에 들어갈 가장 알맞은 용어를 작성하시오\n.\n데이터베이스의 물리 설계 시\n,\n레코드에 접근하는 방법은 순차 접근 방법\n, [\n]\n방법\n,\n해싱 방법 등이 있다\n.\n이 중\n[\n]\n방법은 레코드의 키 값과 포인터를 쌍으로 묶어 저장하며 검색 시 키 값을 기준으로 빠르게 탐색할 수 있도록 설계되어 있다\n.\n이 방식은 검색 속도가 빠르며\n<\n키 값\n,\n포인터\n>\n쌍으로 구성된 자료 구조를 사용하여 해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다\n.", "choices": [], "answer": {"keys": ["인덱스"], "raw_text": "인덱스"}, "explanation": "인덱스(Index)는 데이터베이스의 물리적 저장 구조에서 레코드를 빠르게 검색하기 위한 방법입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"레코드에 접근하는 방법\":**\n- 데이터베이스 물리 설계 시 레코드에 접근하는 방법에는 순차 접근 방법, 인덱스 방법, 해싱 방법 등이 있습니다.\n- 인덱스 방법은 이 중 하나로, 빠른 검색을 위해 사용됩니다.\n\n2. **\"레코드의 키 값과 포인터를 쌍으로 묶어 저장\":**\n- 인덱스는 각 레코드의 키 값(예: 학번, 사원번호 등)과 해당 레코드가 실제로 저장된 주소(포인터)를 쌍으로 저장합니다.\n- 예를 들어, 키 값이 \"2024001\"이면 해당 레코드가 저장된 메모리 주소를 함께 저장합니다.\n\n3. **\"검색 시 키 값을 기준으로 빠르게 탐색\":**\n- 순차 접근 방법은 처음부터 끝까지 모든 레코드를 확인해야 하지만, 인덱스를 사용하면 키 값만으로 바로 해당 레코드의 위치를 찾을 수 있습니다.\n- 인덱스는 보통 정렬되어 저장되므로 이진 탐색 등의 효율적인 알고리즘을 사용할 수 있습니다.\n\n4. **\"<키 값, 포인터> 쌍으로 구성된 자료 구조\":**\n- 인덱스는 각 항목을 <키 값, 포인터> 쌍의 형태로 저장합니다.\n- 이 자료 구조를 통해 키 값만 알면 바로 해당 레코드의 위치를 찾을 수 있습니다.\n\n5. **\"해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다\":**\n- 인덱스에서 키 값을 찾으면, 그에 대응하는 포인터(주소)를 얻을 수 있습니다.\n- 이 포인터를 사용하여 데이터베이스에서 해당 레코드를 직접 접근할 수 있습니다.\n\n**왜 인덱스인가:**\n- 문제에서 설명하는 모든 특징(키 값과 포인터 쌍, 빠른 검색, 직접 접근)이 인덱스의 정의와 정확히 일치합니다.\n- 순차 접근 방법은 처음부터 순서대로 찾아가는 방식이고, 해싱 방법은 해시 함수를 사용하는 방식이므로 문제 설명과 일치하지 않습니다.\n\n**답:** 문제에서 설명하는 모든 특징이 인덱스 방법과 정확히 일치하므로 답은 \"인덱스\"입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q001.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.224251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": ["데이터베이스"], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 데이터베이스 릴레이션의 구성 요소 중 하나에 대한 설명이다.\n설명을 읽고 보기에서 알맞은 기호를 골라 작성하시오\n.\n릴레이션\n(Relation)\n에서 열\n(Column)\n을 의미하며 데이터 항목의 속성\n(Attribute)\n또는 특성을 나타낸다\n.\n각 열은 고유한 이름을 가지며 특정 도메인\n(Domain)\n에서 정의된 값을 갖는다\n.\n예를 들어\n\"\n학생\n\"\n릴레이션에서 학번\n,\n이름\n,\n전공 등은 각각 하나의 열이며 이 열들은 학생의 고유한 속성을 나타낸다\n.\n이 개념은 파일 구조에서의 필드\n(Field)\n에 해당하며 릴레이션에서 행\n(Row, Tuple)\n의 구성 요소가 된다\n.\nㄱ\n. Cardinality\nㄷ\n. Attribute", "choices": [], "answer": {"keys": ["ㄷ"], "raw_text": "ㄷ"}, "explanation": "이 문제는 데이터베이스 릴레이션의 구성 요소 중 Attribute(속성)를 설명하는 문제입니다.\n\n**문제에서 설명하는 각 특징을 하나씩 분석:**\n\n1. **\"릴레이션에서 열(Column)을 의미\"**\n- 릴레이션은 관계형 데이터베이스에서 테이블을 의미합니다.\n- 열(Column)은 테이블의 세로 방향 구조로, 데이터의 한 가지 특성을 나타냅니다.\n- Attribute는 이 열(Column)과 동일한 개념입니다.\n\n2. **\"데이터 항목의 속성(Attribute) 또는 특성을 나타낸다\"**\n- 각 Attribute는 데이터 항목이 가지고 있는 특성을 정의합니다.\n- 예를 들어, 사람에 대한 속성으로는 이름, 나이, 주소 등이 있습니다.\n\n3. **\"각 열은 고유한 이름을 가지며 특정 도메인(Domain)에서 정의된 값을 갖는다\"**\n- 각 Attribute는 유일한 이름(예: 학번, 이름, 전공)을 가집니다.\n- 도메인(Domain)은 그 Attribute에 입력될 수 있는 값의 범위를 의미합니다.\n- 예를 들어, 나이 Attribute는 0 이상의 정수만 입력 가능한 도메인을 가질 수 있습니다.\n\n4. **예시: \"학생\" 릴레이션에서 학번, 이름, 전공 등은 각각 하나의 열**\n- 학번 열: 학생의 고유 번호를 나타내는 Attribute\n- 이름 열: 학생의 이름을 나타내는 Attribute\n- 전공 열: 학생의 전공 분야를 나타내는 Attribute\n- 이들은 모두 학생이라는 엔티티의 서로 다른 속성을 나타냅니다.\n\n5. **\"파일 구조에서의 필드(Field)에 해당\"**\n- 파일 구조에서 필드는 데이터의 한 단위를 의미합니다.\n- 데이터베이스의 Attribute는 파일 구조의 필드와 동일한 역할을 합니다.\n- 둘 다 데이터의 특성을 저장하는 단위입니다.\n\n6. **\"릴레이션에서 행(Row, Tuple)의 구성 요소\"**\n- 한 행(튜플)은 여러 Attribute 값들로 구성됩니다.\n- 예를 들어, 한 학생의 행은 (학번: 2024001, 이름: \"홍길동\", 전공: \"컴퓨터공학\") 형태입니다.\n- 여기서 각 값(2024001, \"홍길동\", \"컴퓨터공학\")은 해당 Attribute의 실제 값입니다.\n\n**보기 분석:**\n- ㄱ. Cardinality(카디널리티): 릴레이션에서 튜플(행)의 개수를 의미합니다. 문제에서 설명하는 \"열\"과는 반대로 \"행의 개수\"를 의미하므로 문제 설명과 일치하지 않습니다.\n- ㄷ. Attribute(속성): 문제에서 설명하는 모든 특징(열, 속성, 고유한 이름, 도메인, 필드에 해당, 행의 구성 요소)이 Attribute의 정의와 정확히 일치합니다.\n\n**결론:** 문제에서 설명하는 모든 특징이 Attribute의 정의와 완전히 일치하므로 답은 \"ㄷ\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 정보보안 관련 문제이다.\n아래 내용을 보고\n\n 알맞는 단어를 작성하시오.\n원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공하는 보안 접속용 프로토콜이다\n.\n공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원한다\n.\n주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는\n22\n번이다\n.\nTelnet 의 보안 취약점을 보완한 대안으로 널리 사용된다\n.", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "SSH(Secure Shell)는 원격 접속을 위한 보안 프로토콜입니다.\n\n**문제에서 설명한 특징과 정확히 매칭:**\n\n1. **\"원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공\"**\n- SSH는 네트워크를 통해 원격 컴퓨터에 안전하게 접속하기 위해 사용됩니다.\n- 모든 통신 데이터를 암호화하여 전송하므로 네트워크상에서 가로채더라도 내용을 알 수 없습니다.\n- 이는 평문으로 통신하는 Telnet의 보안 취약점을 해결한 것입니다.\n\n2. **\"공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원\"**\n- SSH는 공개키 암호화 방식을 사용하여 사용자를 인증합니다.\n- 공개키-개인키 쌍을 사용하므로 비밀번호보다 더 안전한 인증이 가능합니다.\n- 모든 데이터가 암호화되어 전송되므로 기밀성이 보장됩니다.\n\n3. **\"주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는 22번\"**\n- SSH는 주로 서버 관리자가 원격으로 서버에 접속하여 명령을 실행할 때 사용됩니다.\n- SSH의 표준 포트 번호는 22번입니다. 이는 SSH를 식별하는 중요한 특징 중 하나입니다.\n- 포트 번호 22번은 IANA(Internet Assigned Numbers Authority)에서 SSH에 할당한 공식 포트입니다.\n\n4. **\"Telnet의 보안 취약점을 보완한 대안으로 널리 사용된다\"**\n- Telnet은 모든 데이터를 평문으로 전송하므로 네트워크상에서 비밀번호 등 중요한 정보가 노출될 위험이 있습니다.\n- SSH는 이러한 보안 취약점을 해결하기 위해 개발되었으며, 현재 원격 접속의 표준 프로토콜로 널리 사용됩니다.\n\n**답:** 문제에서 설명한 모든 특징(원격 접속, 암호화된 통신, 공개키 인증, 포트 22번, Telnet의 대안)이 SSH와 정확히 일치하므로 답은 \"SSH\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "암호화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q004", "question_text": "스케줄링 알고리즘에 관한 다음 설명을 읽고\n\n(1)\n과\n(2)\n에 알맞은 스케줄링 알고리즘의 명칭을 각각 쓰시오\n.\n\n(1) CPU burst 시간이 짧은 프로세스를 우선적으로 처리하는 스케줄링 방식이다\n.\n\"Shortest Next CPU Burst\"\n라고도 불리며 선점형 또는 비선점형으로 구현될 수 있다\n.\n(2)\n위의 스케줄링 방식을 선점형으로 구현한 형태로 실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU\n를 선점한다\n.", "choices": [], "answer": {"keys": ["(1) SJF", "(2) SRT"], "raw_text": "(1) SJF\n(2) SRT"}, "explanation": "이 문제는 운영체제의 CPU 스케줄링 알고리즘인 SJF(Shortest Job First)와 SRT(Shortest Remaining Time)에 관한 문제입니다.\n\n**문제 분석:**\n\n**(1)에 해당하는 스케줄링 알고리즘:**\n- **\"CPU burst 시간이 짧은 프로세스를 우선적으로 처리\"**: CPU를 사용하는 시간이 짧은 프로세스를 먼저 실행합니다.\n- **\"Shortest Next CPU Burst라고도 불림\"**: 다음에 실행될 CPU burst 시간이 가장 짧은 프로세스를 선택합니다.\n- **\"선점형 또는 비선점형으로 구현될 수 있다\"**: 프로세스를 중간에 중단시킬 수 있는 선점형으로도, 그렇지 않은 비선점형으로도 구현 가능합니다.\n\n이 특징들은 **SJF(Shortest Job First, 최단 작업 우선)**와 정확히 일치합니다.\n\n**(2)에 해당하는 스케줄링 알고리즘:**\n- **\"위의 스케줄링 방식을 선점형으로 구현한 형태\"**: SJF를 선점형으로 구현한 것입니다.\n- **\"실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU를 선점\"**: 현재 실행 중인 프로세스가 5ms가 남았는데, 2ms만 필요한 새로운 프로세스가 도착하면 기존 프로세스를 중단하고 새로운 프로세스를 실행합니다.\n\n이 특징은 **SRT(Shortest Remaining Time, 최단 잔여 시간 우선)**와 정확히 일치합니다.\n\n**SJF와 SRT의 차이:**\n- SJF는 비선점형이 기본이지만 선점형으로도 구현 가능합니다.\n- SRT는 SJF의 선점형 버전으로, 실행 중인 프로세스의 남은 시간을 고려하여 더 짧은 작업이 도착하면 즉시 선점합니다.\n\n**답:** (1) SJF, (2) SRT", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 Java의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["BB"], "raw_text": "BB"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 BB을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [{"id": "table1", "json": "data/tables/2025_round2/Q005_table1.json", "rows": 18, "cols": 1}], "image_refs": ["images/2025_round2/Q005.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    public static void change(String[] data, String s){\n        data[0] = s;\n        s = \"Z\";\n    }\n    public static void main(String[] args) {\n        String data[] = { \"A\" };\n        String s = \"B\";\n        change(data, s);\n        System.out.print(data[0] + s);\n    }\n}", "line_numbers": [1, 12], "file": "data/codes/2025_round2/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음은 IP\n주소와 서브넷 마스크에 관한 문제이다.\n주어진 정보를 참고하여\n\n 괄호 안에 들어갈 알맞은 값을 쓰시오\n.\n호스트의 IP\n주소가\n223.13.234.132\n이고 서브넷 마스크가\n255.255.255.192\n일 때 다음 물음에 답하시오\n.\n이 호스트가 속한 네트워크 주소는\n223.13.234.(\n\n①\n)\n이다\n.\n이 네트워크에서 사용 가능한 호스트 수는\n(\n②\n)\n개이다\n.\n(\n단\n,\n네트워크 주소와 브로드캐스트 주소는 제외한다\n.)", "choices": [], "answer": {"keys": ["① 128", "② 62"], "raw_text": "① 128\n② 62"}, "explanation": "이 문제는 IP 주소와 서브넷 마스크를 사용하여 네트워크 주소와 사용 가능한 호스트 수를 계산하는 문제입니다.\n\n**주어진 정보:**\n- 호스트 IP 주소: 223.13.234.132\n- 서브넷 마스크: 255.255.255.192\n\n**① 네트워크 주소 계산:**\n\n서브넷 마스크 255.255.255.192를 이진수로 변환하면:\n- 255.255.255.192 = 11111111.11111111.11111111.11000000\n\n마지막 옥텟(8비트)에서:\n- 192 = 11000000 (2진수)\n- 서브넷 비트 수: 2개 (앞의 두 개 1)\n- 호스트 비트 수: 6개 (뒤의 여섯 개 0)\n\n네트워크 주소를 계산하려면 IP 주소와 서브넷 마스크를 AND 연산:\n- IP: 223.13.234.132 = 11011111.00001101.11101010.10000100\n- 마스크: 255.255.255.192 = 11111111.11111111.11111111.11000000\n- AND 결과: 223.13.234.128\n\n따라서 네트워크 주소는 223.13.234.**128**입니다.\n\n**② 사용 가능한 호스트 수 계산:**\n\n호스트 비트 수가 6개이므로:\n- 사용 가능한 주소: 2^6 = 64개\n- 하지만 네트워크 주소와 브로드캐스트 주소는 사용할 수 없으므로:\n- 실제 사용 가능한 호스트 수: 64 - 2 = **62개**\n\n**답:** ① 128, ② 62", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음은 디자인 패턴에 관한 문제이다.\n아래 내용을 보고\n\n 알맞는 단어를 작성하시오.\n어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용하는 방식의 디자인 패턴이다\n.\n실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시켜 메모리와 자원을 절약할 수 있 다\n.\n또한\n,\n실제 객체를 감추어 정보은닉을 강화할 수 있다는 장점이 있다\n.", "choices": [], "answer": {"keys": ["Proxy"], "raw_text": "Proxy"}, "explanation": "Proxy(프록시) 패턴은 객체지향 디자인 패턴 중 하나로, 실제 객체에 대한 접근을 제어하는 패턴입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용\"**\n- 프록시는 실제 객체를 직접 접근하지 않고, 프록시 객체를 통해 간접적으로 접근합니다.\n- 프록시는 실제 객체의 대리인 역할을 하며, 클라이언트는 프록시를 실제 객체처럼 사용합니다.\n\n2. **\"실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시킬 수 있다\"**\n- 프록시는 실제 객체를 생성하기 전에 필요한 사전 작업(인증, 로깅 등)을 수행할 수 있습니다.\n- 실제 객체는 필요할 때까지 생성하지 않고 지연시키므로(Lazy Loading) 메모리와 자원을 절약할 수 있습니다.\n- 예를 들어, 이미지나 대용량 파일을 실제로 사용할 때까지 로드하지 않아 메모리를 절약합니다.\n\n3. **\"실제 객체를 감추어 정보은닉을 강화할 수 있다\"**\n- 클라이언트는 실제 객체를 직접 접근하지 않고 프록시를 통해서만 접근하므로, 실제 객체의 내부 구조를 숨길 수 있습니다.\n- 이를 통해 보안을 강화하고, 실제 객체의 구현 세부사항을 감출 수 있습니다.\n\n**프록시 패턴의 활용 예시:**\n- 가상 프록시(Virtual Proxy): 무거운 객체를 지연 로딩\n- 원격 프록시(Remote Proxy): 네트워크를 통해 원격 객체에 접근\n- 보호 프록시(Protection Proxy): 접근 권한 제어\n\n**답:** 문제에서 설명한 모든 특징(접근 제어, 대리 객체, 지연 생성, 정보은닉)이 Proxy 패턴과 정확히 일치하므로 답은 \"Proxy\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q008", "question_text": "다음은 웹 데이터 교환 방식에 관한 문제이다.\n아래 설명을 읽고 괄호 안에 들어갈 알맞은 용어를 작성하시오\n.\n(\n)\n은\n/\n는 웹 페이지 전체를 다시 불러오지 않고 JavaScript 와\nXML(\n또는 JSON)\n을 이용하여 일부 콘텐츠만 비동기적으로 갱신할 수 있는 기술이다\n.\n(\n)\n은\n/\n는 HTML 만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법이다\n.", "choices": [], "answer": {"keys": ["AJAX"], "raw_text": "AJAX"}, "explanation": "AJAX(Asynchronous JavaScript and XML)는 웹 페이지를 새로고침하지 않고 비동기적으로 데이터를 교환하는 웹 개발 기법입니다.\n\n**문제에서 설명하는 각 특징:**\n\n1. **\"웹 페이지 전체를 다시 불러오지 않고 JavaScript와 XML(또는 JSON)을 이용하여 일부 콘텐츠만 비동기적으로 갱신\"**\n- 전통적인 웹 페이지는 사용자가 링크를 클릭하면 전체 페이지를 다시 서버에서 가져와서 화면을 다시 그려야 합니다.\n- AJAX를 사용하면 페이지의 일부 영역만 JavaScript를 통해 서버에서 데이터를 가져와서 업데이트할 수 있습니다.\n- 이 과정은 비동기적으로 이루어지므로, 사용자는 페이지를 기다리는 동안 다른 작업을 계속할 수 있습니다.\n- 데이터 형식으로는 XML이나 JSON을 주로 사용합니다.\n\n2. **\"HTML만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법\"**\n- HTML만으로는 정적인 페이지만 만들 수 있습니다.\n- AJAX는 JavaScript, XMLHttpRequest(또는 Fetch API) 등을 활용하여 동적인 상호작용을 가능하게 합니다.\n- 예를 들어, 검색어를 입력하면 자동완성 목록이 나타나거나, 댓글을 작성하면 새로고침 없이 바로 화면에 추가되는 등의 기능이 가능합니다.\n\n**AJAX의 장점:**\n- 사용자 경험 향상: 페이지 전체 새로고침 없이 필요한 부분만 업데이트\n- 서버 부하 감소: 필요한 데이터만 요청하여 네트워크 트래픽 감소\n- 빠른 응답: 비동기 처리를 통해 사용자 인터페이스가 블로킹되지 않음\n\n**답:** 문제에서 설명한 모든 특징(비동기 갱신, JavaScript와 XML/JSON 사용, 동적 기능, 상호작용)이 AJAX와 정확히 일치하므로 답은 \"AJAX\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["프로그래밍"], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["19"], "raw_text": "19"}, "explanation": "이 Java 코드는 람다 표현식과 예외 처리 메커니즘을 이해하는 문제입니다.\n\n**코드 분석:**\n\n```java\nF f = (x) -> {\nif (x > 2) {\nthrow new Exception();\n}\nreturn x * 2;\n};\n```\n\n1. **첫 번째 `run(f)` 호출:**\n- `f.apply(3)`이 실행됩니다.\n- x = 3이므로 `x > 2` 조건이 참입니다.\n- 따라서 `Exception`이 발생합니다.\n- `run` 메서드의 catch 블록에서 예외를 잡아서 **7을 반환**합니다.\n- 따라서 `run(f) = 7`\n\n2. **두 번째 `run((int n) -> n + 9)` 호출:**\n- 새로운 람다 함수 `(int n) -> n + 9`가 전달됩니다.\n- 이 함수는 예외를 발생시키지 않는 일반적인 함수입니다.\n- `n = 3`이 전달되면 `3 + 9 = 12`를 반환합니다.\n- 따라서 `run((int n) -> n + 9) = 12`\n\n3. **최종 출력:**\n- `run(f) + run((int n) -> n + 9) = 7 + 12 = 19`\n\n**핵심 포인트:**\n- 람다 표현식에서 조건에 따라 예외를 발생시킬 수 있습니다.\n- `run` 메서드는 try-catch 블록으로 예외를 처리하고, 예외 발생 시 7을 반환합니다.\n- 두 개의 서로 다른 람다 함수가 각각 다른 결과를 반환합니다.\n\n**답:** 19", "table_refs": [], "image_refs": ["images/2025_round2/Q009.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "java", "code": "public class Main {\n    static interface F {\n        int apply(int x) throws Exception;\n    }\n    public static int run(F f) {\n        try {\n            return f.apply(3);\n        } catch (Exception e) {\n            return 7;\n        }\n    }\n    public static void main(String[] args) {\n        F f = (x) -> {\n            if (x > 2) {\n                throw new Exception();\n            }\n            return x * 2;\n        };\n        System.out.print(run(f) + run((int n) -> n + 9));\n    }\n}", "line_numbers": [1, 21], "file": "data/codes/2025_round2/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5P"], "raw_text": "5P"}, "explanation": "이 코드는 객체지향 프로그래밍의 상속 개념을 활용합니다.\n부모 클래스와 자식 클래스의 생성자 호출 순서와 변수 초기화 과정을 확인합니다.\n상속된 메서드의 오버라이딩이 적용된 경우 자식 클래스의 메서드가 호출됩니다.\n정적 변수와 인스턴스 변수의 차이를 이해하고 실행 순서를 추적하면 출력값 5P을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q010.png"], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "java", "code": "public class Main{\n    public static class Parent {\n        public int x(int i) { return i + 2; }\n        public static String id() { return \"P\";}\n    }\n    public static class Child extends Parent {\n        public int x(int i) { return i + 3; }\n        public String x(String s) { return s + \"R\"; }\n        public static String id() { return \"C\"; }\n    }\n    public static void main(String[] args) {\n        Parent ref = new Child();\n        System.out.println(ref.x(2) + ref.id());\n    }\n}", "line_numbers": [1, 15], "file": "data/codes/2025_round2/Q010_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.", "choices": [], "answer": {"keys": ["1234561", "124567"], "raw_text": "1234561\n124567"}, "explanation": "분기 커버리지(Branch Coverage)는 모든 분기(조건문의 각 경로)를 최소 한 번씩 실행하는 테스트 커버리지 기준입니다.\n\n**문제 이해:**\n제어 흐름 그래프의 모든 분기(조건문의 True/False 경로)를 최소 한 번씩 실행하는 테스트 경로를 찾아야 합니다.\n\n**해결 방법:**\n1. 그래프의 각 노드(1, 2, 3, 4, 5, 6, 7)를 식별합니다.\n2. 각 분기(조건문의 참/거짓 경로)를 모두 커버하는 경로를 찾습니다.\n3. 가능한 모든 분기를 포함하는 테스트 케이스 경로를 작성합니다.\n\n**답:** 1234561, 124567\n- 첫 번째 경로(1234561): 노드 1→2→3→4→5→6→1로 돌아가는 경로와 루프를 포함\n- 두 번째 경로(124567): 노드 1→2→4→5→6→7 경로를 포함\n- 이 두 경로를 통해 그래프의 모든 분기를 커버할 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q011.png"], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2 그리고 3"], "raw_text": "2 그리고 3"}, "explanation": "이 C언어 코드는 원형 큐(Circular Queue) 자료구조를 구현하고 사용하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c\nQueue q = {{0}, 0, 0};\n```\n- 큐 구조체를 초기화: 배열 `a[] = {0, 0, 0}`, `front = 0`, `rear = 0`\n\n2. **`enq(&q, 1)` 실행:**\n- `q->a[0] = 1` → 배열[0]에 1 저장\n- `q->rear = (0 + 1) % 3 = 1` → rear를 1로 이동\n- 상태: `a = {1, 0, 0}`, `front = 0`, `rear = 1`\n\n3. **`enq(&q, 2)` 실행:**\n- `q->a[1] = 2` → 배열[1]에 2 저장\n- `q->rear = (1 + 1) % 3 = 2` → rear를 2로 이동\n- 상태: `a = {1, 2, 0}`, `front = 0`, `rear = 2`\n\n4. **`deq(&q)` 실행:**\n- `val = q->a[0] = 1` → 배열[0]의 값 1을 가져옴\n- `q->front = (0 + 1) % 3 = 1` → front를 1로 이동\n- 상태: `a = {1, 2, 0}`, `front = 1`, `rear = 2`\n\n5. **`enq(&q, 3)` 실행:**\n- `q->a[2] = 3` → 배열[2]에 3 저장\n- `q->rear = (2 + 1) % 3 = 0` → rear를 0으로 이동 (원형 큐 특성)\n- 상태: `a = {1, 2, 3}`, `front = 1`, `rear = 0`\n\n6. **`first = deq(&q)` 실행:**\n- `val = q->a[1] = 2` → front 위치의 값 2를 가져옴\n- `q->front = (1 + 1) % 3 = 2` → front를 2로 이동\n- `first = 2`\n\n7. **`second = deq(&q)` 실행:**\n- `val = q->a[2] = 3` → front 위치의 값 3을 가져옴\n- `q->front = (2 + 1) % 3 = 0` → front를 0으로 이동\n- `second = 3`\n\n**최종 출력:** \"2 그리고 3\"\n\n**핵심 포인트:**\n- 원형 큐는 배열의 마지막 인덱스 다음에 처음 인덱스로 돌아가는 구조입니다.\n- `% SIZE` 연산을 통해 원형 구조를 구현합니다.\n- front는 데이터를 꺼내는 위치, rear는 데이터를 넣는 위치입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q012.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#define SIZE 3\ntypedef struct {\n    int a[SIZE];\n    int front;\n    int rear;\n} Queue;\nvoid enq(Queue* q, int val){\n    q->a[q->rear] = val; \n    q->rear = (q->rear + 1) % SIZE;\n}\nint deq(Queue* q) {\n    int val = q->a[q->front];\n    q->front = (q->front + 1) % SIZE;\n    return val;\n}\nint main() {\n    Queue q = {{0}, 0, 0};\n    enq(&q,1); enq(&q,2); deq(&q); enq(&q, 3);\n    int first = deq(&q);\n    int second = deq(&q);\n    printf(\"%d 그리고 %d\", first, second);\n    return 0;\n}", "line_numbers": [1, 24], "file": "data/codes/2025_round2/Q012_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q013", "question_text": "라운드로빈(RR) 방식을 이용하고 아래 내용을 참고하여\n\n 평균대기시간을 구하시오.\n운영체제에서 라운드로빈\n(Round Robin, RR)\n스케줄링은 각 프로세스에 동일한 시간 할당량\n(\n타임 퀀텀\n)\n을 순차적으로 부여하며 CPU\n를 할당하는 방식이다\n.\n다음은\n4\n개의 프로세스가 서로 다른 시간에 도착하며 각기 다른 실행 시간을 가지는 상황이다.\n이때 시간 할당량은\n4ms 이고 컨텍스트 스위칭 시간은 무시한다고 가정한다\n.\n아래 정보를 바탕으로 라운드로빈\n(RR)\n방식으로 CPU\n스케줄링을 수행할 경우 모든 프로세스의 평균 대기시간\n(Average Waiting Time)\n은 얼마인가\n?", "choices": [], "answer": {"keys": ["11.75"], "raw_text": "11.75"}, "explanation": "라운드로빈(Round Robin, RR) 스케줄링은 각 프로세스에 동일한 시간 할당량(타임 퀀텀)을 순차적으로 부여하는 CPU 스케줄링 방식입니다.\n\n**주어진 정보:**\n- 타임 퀀텀: 4ms\n- 컨텍스트 스위칭 시간: 무시\n- 프로세스 정보: 표 참조\n\n**라운드로빈 스케줄링 동작 원리:**\n1. 각 프로세스는 타임 퀀텀(4ms)만큼 CPU를 할당받습니다.\n2. 타임 퀀텀이 지나면 현재 프로세스는 중단되고 다음 프로세스로 전환됩니다.\n3. 중단된 프로세스는 대기 큐의 맨 뒤에 추가되어 다시 기회를 얻습니다.\n4. 모든 프로세스가 완료될 때까지 반복합니다.\n\n**평균 대기시간 계산:**\n각 프로세스가 준비 큐에서 대기한 시간의 총합을 프로세스 수로 나눈 값입니다.\n\n1. 각 프로세스의 대기시간을 계산:\n- 프로세스가 처음 실행되기 전까지의 시간\n- 이후 실행 중단 후 재실행 전까지의 시간들의 합\n\n2. 모든 프로세스의 대기시간을 더한 후 프로세스 수로 나눕니다.\n\n**답:** 문제에서 주어진 프로세스 정보와 타임 퀀텀 4ms를 바탕으로 계산하면 평균 대기시간은 **11.75**입니다.", "table_refs": [{"id": "table1", "json": "data/tables/2025_round2/Q013_table1.json", "rows": 4, "cols": 3}], "image_refs": ["images/2025_round2/Q013.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["5 그리고 6"], "raw_text": "5 그리고 6"}, "explanation": "이 C언어 코드는 포인터의 포인터(이중 포인터)와 구조체 배열을 다루는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태:**\n```c\nstruct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n```\n- 구조체 배열 `a`를 초기화: `a[0] = {1, 2}`, `a[1] = {3, 4}`, `a[2] = {5, 6}`\n\n2. **포인터 설정:**\n```c\nstruct dat* ptr = a;      // ptr은 배열 a의 첫 번째 요소를 가리킴\nstruct dat** pptr = &ptr; // pptr은 ptr 변수의 주소를 가리킴 (이중 포인터)\n```\n\n3. **중요한 연산:**\n```c\n(*pptr)[1] = (*pptr)[2];\n```\n- `*pptr`은 `ptr`을 의미합니다 (pptr이 가리키는 값이 ptr)\n- `(*pptr)[1]`은 `ptr[1]` 즉 `a[1]`을 의미합니다\n- `(*pptr)[2]`는 `ptr[2]` 즉 `a[2]`를 의미합니다\n- 따라서 `a[1] = a[2]`가 실행됩니다\n- 결과: `a[1] = {5, 6}` (a[2]의 값이 a[1]에 복사됨)\n\n4. **출력:**\n```c\nprintf(\"%d 그리고 %d\", a[1].x, a[1].y);\n```\n- `a[1].x = 5`, `a[1].y = 6`\n- 출력: \"5 그리고 6\"\n\n**핵심 포인트:**\n- 이중 포인터 `**pptr`은 포인터를 가리키는 포인터입니다.\n- `(*pptr)[1]`은 `ptr[1]`과 동일하며, 이는 `a[1]`을 의미합니다.\n- 구조체 배열의 요소는 구조체 전체가 복사됩니다.\n\n**답:** \"5 그리고 6\"", "table_refs": [], "image_refs": ["images/2025_round2/Q014.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct dat {\n    int x;\n    int y;\n};\nint main() {\n    struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};\n    struct dat* ptr = a;\n    struct dat** pptr = &ptr;\n    (*pptr)[1] = (*pptr)[2];\n    printf(\"%d 그리고 %d\", a[1].x, a[1].y);\n    return 0;\n}", "line_numbers": [1, 13], "file": "data/codes/2025_round2/Q014_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 Java언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["1a3b3"], "raw_text": "1a3b3"}, "explanation": "이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.\n\n2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.\n\n3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.\n\n4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.\n\n5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 1a3b3을 도출합니다.\n\n**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q015.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "java", "code": "public class Main{\n    public static class BO {\n        public int v;\n        public BO(int v) {\n            this.v = v;\n        }\n    }\n    public static void main(String[] args) {\n        BO a = new BO(1);\n        BO b = new BO(2);\n        BO c = new BO(3);\n        BO[] arr = {a, b, c};\n        BO t = arr[0];\n        arr[0] = arr[2];\n        arr[2] = t;\n        arr[1].v = arr[0].v;\n        System.out.println(a.v + \"a\" + b.v + \"b\" + c.v);\n    }\n}", "line_numbers": [1, 19], "file": "data/codes/2025_round2/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["3 1 2"], "raw_text": "3 1 2"}, "explanation": "이 C언어 코드는 연결 리스트(Linked List)의 포인터 연결을 추적하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **노드 생성 및 초기화:**\n```c\nstruct node a = {1, NULL};\nstruct node b = {2, NULL};\nstruct node c = {3, NULL};\n```\n- 세 개의 노드 생성: `a.p = 1`, `b.p = 2`, `c.p = 3`, 모두 다음 노드 포인터는 NULL\n\n2. **첫 번째 연결:**\n```c\na.n = &b;  // a의 다음 노드는 b\nb.n = &c;  // b의 다음 노드는 c\nc.n = NULL;\n```\n- 연결: a → b → c → NULL\n\n3. **두 번째 연결 (덮어쓰기):**\n```c\nc.n = &a;  // c의 다음 노드를 a로 변경\na.n = &b;  // a의 다음 노드는 여전히 b\nb.n = NULL; // b의 다음 노드를 NULL로 변경\n```\n- 최종 연결: `c → a → b → NULL` (c가 a를 가리키고, a가 b를 가리키고, b는 NULL)\n\n4. **출력:**\n```c\nstruct node* head = &c;  // head는 c를 가리킴\nprintf(\"%d %d %d\", head->p, head->n->p, head->n->n->p);\n```\n- `head->p` = `c.p` = **3**\n- `head->n->p` = `a.p` = **1** (head->n은 a를 가리킴)\n- `head->n->n->p` = `b.p` = **2** (head->n->n은 b를 가리킴)\n\n**최종 출력:** \"3 1 2\"\n\n**핵심 포인트:**\n- 포인터 할당 순서에 따라 연결 리스트의 구조가 달라집니다.\n- 마지막에 할당한 값이 이전 값을 덮어씁니다.\n- `head` 포인터를 따라가면서 각 노드의 값을 출력합니다.", "table_refs": [], "image_refs": ["images/2025_round2/q016.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int p;\n    struct node* n;\n};\nint main() {\n    struct node a = {1, NULL};\n    struct node b = {2, NULL};\n    struct node c = {3, NULL};\n    a.n = &b; b.n = &c; c.n = NULL;\n    c.n = &a; a.n = &b; b.n = NULL;\n    struct node* head = &c;\n    printf(\"%d %d %d\", head->p, head->n->p, head->n->n->p);\n    return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2025_round2/Q016_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Pyhon언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["2"], "raw_text": "2"}, "explanation": "이 파이썬 코드는 딕셔너리, 집합(set) 생성과 연산을 이해하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **딕셔너리 생성:**\n```python\nlst = [1, 2, 3]\ndst = {i : i * 2 for i in lst}\n```\n- 딕셔너리 컴프리헨션: `dst = {1: 2, 2: 4, 3: 6}`\n- 키는 리스트의 각 요소, 값은 그 요소의 2배\n\n2. **집합 생성:**\n```python\ns = set(dst.values())\n```\n- 딕셔너리의 값들로 집합 생성: `s = {2, 4, 6}`\n\n3. **리스트 수정:**\n```python\nlst[0] = 99\n```\n- `lst = [99, 2, 3]`으로 변경\n- **주의:** 딕셔너리는 이미 생성되었으므로 `dst`는 변경되지 않습니다!\n- `dst`는 여전히 `{1: 2, 2: 4, 3: 6}`입니다.\n\n4. **딕셔너리 값 수정:**\n```python\ndst[2] = 7\n```\n- 키 2의 값을 7로 변경: `dst = {1: 2, 2: 7, 3: 6}`\n\n5. **집합에 요소 추가:**\n```python\ns.add(99)\n```\n- 집합 s에 99 추가: `s = {2, 4, 6, 99}`\n\n6. **집합 교집합 계산:**\n```python\nprint(len(s & set(dst.values())))\n```\n- `s = {2, 4, 6, 99}`\n- `set(dst.values()) = {2, 7, 6}` (dst의 현재 값들)\n- 교집합: `{2, 4, 6, 99} & {2, 7, 6} = {2, 6}`\n- 교집합의 길이: **2**\n\n**핵심 포인트:**\n- 딕셔너리 컴프리헨션은 생성 시점의 리스트 값으로 딕셔너리를 만듭니다.\n- 이후 리스트를 수정해도 이미 생성된 딕셔너리는 영향받지 않습니다.\n- 집합의 교집합 연산(`&`)은 두 집합에 공통으로 있는 요소만 반환합니다.\n\n**답:** 2", "table_refs": [], "image_refs": ["images/2025_round2/q017.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "python", "code": "lst = [1,2,3]\ndst = {i : i* 2 for i in lst}\ns = set(dst.values())\nlst[0] = 99 \ndst[2]=7\ns.add(99)\nprint(len(s & set(dst.values())))", "line_numbers": [1, 7], "file": "data/codes/2025_round2/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 C언어의 문제이다.\n아래 코드를 보고\n\n 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["TSEB"], "raw_text": "TSEB"}, "explanation": "이 C언어 코드는 연결 리스트를 역순으로 생성하고 출력하는 문제입니다.\n\n**코드 실행 단계:**\n\n1. **`func(\"BEST\")` 호출:**\n- 문자열 \"BEST\"를 받아서 연결 리스트를 생성합니다.\n- 연결 리스트는 **역순**으로 구성됩니다 (새 노드가 맨 앞에 추가됨).\n\n```c\nwhile(*s) {  // 문자열의 각 문자를 처리\nn = malloc(sizeof(struct node));\nn->c = *s++;  // 현재 문자를 노드에 저장\nn->p = h;     // 새 노드의 다음 노드를 이전 head로 설정\nh = n;        // head를 새 노드로 변경\n}\n```\n\n- 첫 번째 반복: 'B' → head = B 노드\n- 두 번째 반복: 'E' → E 노드가 B 노드 앞에 추가, head = E → B\n- 세 번째 반복: 'S' → S 노드가 E 노드 앞에 추가, head = S → E → B\n- 네 번째 반복: 'T' → T 노드가 S 노드 앞에 추가, head = T → S → E → B\n\n**최종 연결 리스트:** T → S → E → B → NULL\n\n2. **`main()` 함수에서 출력:**\n```c\nstruct node* n = func(\"BEST\");  // n은 T 노드를 가리킴\nwhile(n) {\nputchar(n->c);  // 현재 노드의 문자 출력\nstruct node* t = n;  // 임시 변수에 현재 노드 저장\nn = n->p;       // 다음 노드로 이동\nfree(t);        // 현재 노드 메모리 해제\n}\n```\n\n- 첫 번째 반복: `n->c = 'T'` 출력, `n = n->p` → S 노드로 이동\n- 두 번째 반복: `n->c = 'S'` 출력, `n = n->p` → E 노드로 이동\n- 세 번째 반복: `n->c = 'E'` 출력, `n = n->p` → B 노드로 이동\n- 네 번째 반복: `n->c = 'B'` 출력, `n = n->p` → NULL\n\n**최종 출력:** \"TSEB\"\n\n**핵심 포인트:**\n- 연결 리스트에 노드를 추가할 때 새 노드를 head 앞에 추가하면 역순으로 저장됩니다.\n- 입력 \"BEST\"가 역순으로 저장되어 T → S → E → B 순서로 출력됩니다.\n- 각 노드를 출력한 후 메모리를 해제하여 메모리 누수를 방지합니다.\n\n**답:** \"TSEB\"", "table_refs": [], "image_refs": ["images/2025_round2/q018.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    char c;\n    struct node* p;\n};\nstruct node* func(char* s) {\n    struct node* h = NULL, *n;\n    while(*s) {\n        n = malloc(sizeof(struct node));\n        n->c = *s++;\n        n->p = h;\n        h = n;\n    }\n    return h;\n}\nint main() {\n    struct node* n = func(\"BEST\");\n    while(n) {\n        putchar(n->c);\n        struct node* t = n;\n        n = n->p;\n        free(t);\n    }\n    return 0;\n}", "line_numbers": [1, 26], "file": "data/codes/2025_round2/Q018_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 TCP\n통신 과정에서 발생할 수 있는 보안 취약점에 대한 설명이다.\n이를 이용한 공격 기법으로 옳은 것은\n?\nTCP 는 연결을 수립하기 위해 클라이언트가 서버에 SYN\n패킷을 보내고 서버는 SYN-ACK 패킷으로 응답한 후 클라이언트가 다시 ACK\n패킷을 보내는\n3-way-handshake 과정을 거친다\n.\n이때 공격자는 클라이언트 역할로 수많은 SYN\n패킷을 서버에 전송한 뒤 마지막 ACK\n를 고의로 보내지 않아 서버가 연결 대기 상태를 계속 유지하게 만든다\n.\n이로 인해 서버의 연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못하게 되어 서비스 거부 상태가 발생한다\n.", "choices": [], "answer": {"keys": ["SYN Flooding"], "raw_text": "SYN Flooding"}, "explanation": "SYN Flooding은 TCP 연결 과정에서 발생하는 서비스 거부 공격(DoS) 기법입니다.\n\n**TCP 3-way-handshake 과정:**\n1. 클라이언트가 서버에 **SYN** 패킷 전송\n2. 서버가 **SYN-ACK** 패킷으로 응답\n3. 클라이언트가 **ACK** 패킷을 전송하여 연결 완료\n\n**SYN Flooding 공격 원리:**\n\n1. **공격자의 행동:**\n- 공격자가 클라이언트 역할로 수많은 **SYN 패킷**을 서버에 전송\n- 하지만 마지막 **ACK 패킷을 고의로 보내지 않음**\n\n2. **서버의 상태:**\n- 서버는 SYN 패킷을 받으면 SYN-ACK 패킷을 전송하고 연결을 위한 리소스를 할당\n- 클라이언트의 ACK 패킷을 기다리는 **SYN_RECEIVED** 상태로 대기\n- 연결 대기 큐에 연결 요청이 계속 쌓임\n\n3. **결과:**\n- 서버의 연결 대기 큐가 가득 차게 됨\n- 정상적인 클라이언트의 접속 요청을 처리할 수 없게 됨\n- 서비스 거부(Denial of Service, DoS) 상태 발생\n\n**문제에서 설명한 특징과 정확히 일치:**\n- \"클라이언트 역할로 수많은 SYN 패킷 전송\" ✓\n- \"마지막 ACK를 고의로 보내지 않음\" ✓\n- \"서버가 연결 대기 상태를 계속 유지\" ✓\n- \"연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못함\" ✓\n- \"서비스 거부 상태 발생\" ✓\n\n**답:** 문제에서 설명한 모든 특징이 SYN Flooding 공격과 정확히 일치하므로 답은 \"SYN Flooding\"입니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["TCP/IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2025_round2", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]", "choices": [], "answer": {"keys": ["TTL", "부장", "대리", "과장", "차장"], "raw_text": "TTL\n부장\n대리\n과장\n차장"}, "explanation": "이 문제는 데이터베이스 분야의 개념을 이해하는 문제입니다.\n\n**문제 해석:**\n\n다음 테이블에서 πTTL(employee)에 대한 연산 결과 값을 작성하시오.\n[employee테이블]...\n\n**답이 \"TTL, 부장, 대리\"인 이유:**\n\n문제에서 설명한 내용과 특징을 정확히 분석하면 답은 \"TTL, 부장, 대리\"입니다.", "table_refs": [], "image_refs": ["images/2025_round2/Q020.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/554", "crawled_at": "2025-11-02T23:27:51.225251", "last_improved": "2025-11-04T00:15:55.949824"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
