{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "class Static{\n\npublic int a = 20;\nstatic int b = 0;\n\n}\n\npublic class Main{\npublic static void main(String[] args) {\n\nint a;\na = 10;\nStatic.b = a;\n\nStatic st = new Static();\n\nSystem.out.println(Static.b++);\nSystem.out.println(st.b);\nSystem.out.println(a);\nSystem.out.print(st.a);\n}\n}", "choices": [], "answer": {"keys": ["10", "11", "10", "20"], "raw_text": "10 11 10 20"}, "explanation": "[Java static 변수와 후위 증감 연산자 - 코드 실행 추적]\n\n**초기 상태:**\n```\nStatic.b = 0 (클래스 변수)\n```\n\n**실행 과정:**\n\n1. `int a = 10;` → 지역 변수 a = 10\n\n2. `Static.b = a;` → Static.b = 10\n\n3. `Static st = new Static();` → 객체 생성\n   - st.a = 20 (인스턴스 변수)\n   - st.b는 Static.b를 참조 (static 변수는 모든 인스턴스가 공유)\n\n4. `System.out.println(Static.b++);`\n   - **후위 증감**: 현재 값(10) 출력 후 증가\n   - 출력: **10**\n   - Static.b = 11로 증가\n\n5. `System.out.println(st.b);`\n   - st.b는 Static.b 참조 → 11\n   - 출력: **11**\n\n6. `System.out.println(a);`\n   - 지역 변수 a = 10\n   - 출력: **10**\n\n7. `System.out.print(st.a);`\n   - 인스턴스 변수 st.a = 20\n   - 출력: **20**\n\n**정답: 10, 11, 10, 20**\n\n**핵심:**\n- static 변수는 클래스 레벨, 모든 인스턴스가 공유\n- `b++`는 출력 후 증가, `++b`는 증가 후 출력", "table_refs": [], "image_refs": ["images/2023_round1/1.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-05T16:01:31.931456", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "java", "code": "class Static{\n    public int a = 20;\n    static int b = 0;\n}\npublic class Main{\n    public static void main(String[] args) {\n        int a;\n        a = 10;\n        Static.b = a;\n        Static st = new Static();\n        System.out.println(Static.b++);\n        System.out.println(st.b);\n        System.out.println(a);\n        System.out.print(st.a);\n    }\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round1/Q001_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java", "python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "#include <stdio.h>\n\nint main(){\nchar a[] = \"Art\";\nchar* p = NULL;\np = a;\n\nprintf(\"%s\\n\", a);\nprintf(\"%c\\n\", *p);\nprintf(\"%c\\n\", *a);\nprintf(\"%s\\n\", p);\n\nfor(int i = 0; a[i] != '\\0'; i++)\nprintf(\"%c\", a[i]);\n\n}", "choices": [], "answer": {"keys": ["Art", "A", "A", "Art", "Art"], "raw_text": "Art\nA\nA\nArt\nArt"}, "explanation": "[C 언어 포인터와 문자열 - 코드 실행 추적]\n\n**초기 상태:**\n```\nchar a[] = \"Art\";  // {'A', 'r', 't', '\\0'}\nchar* p = a;       // p는 a[0]의 주소를 가리킴\n```\n\n**실행 과정:**\n\n1. `printf(\"%s\\n\", a);` → 문자열 전체 출력: **Art**\n\n2. `printf(\"%c\\n\", *p);` → p가 가리키는 문자: **A**\n\n3. `printf(\"%c\\n\", *a);` → a[0] 문자: **A**\n\n4. `printf(\"%s\\n\", p);` → p가 가리키는 문자열: **Art**\n\n5. `for(int i=0; a[i]!='\\0'; i++) printf(\"%c\", a[i]);`\n   - i=0: 'A' 출력\n   - i=1: 'r' 출력\n   - i=2: 't' 출력\n   - 결과: **Art**\n\n**정답: Art, A, A, Art, Art**\n\n**핵심:**\n- `%s`: 문자열 출력, `%c`: 단일 문자 출력\n- `*p`: 포인터 역참조 (포인터가 가리키는 값)\n- 배열 이름 = 첫 번째 요소의 주소", "table_refs": [], "image_refs": ["images/2023_round1/2.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-05T16:01:31.939447", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main(){\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n}", "line_numbers": [1, 12], "file": "data/codes/2023_round1/Q002_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "쉬움", "estimated_time": 4}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "#include <stdio.h>\n\nint main(){\n\nchar* a = \"qwer\";\nchar* b = \"qwtety\";\n\nfor(int i = 0; a[i] != '\\0' ; i++){\nfor(int j = 0; b[j] != '\\0'; j++){\nif(a[i] == b[j]) printf(\"%c\", a[i]);\n}\n}\n\n}", "choices": [], "answer": {"keys": ["qwe"], "raw_text": "qwe"}, "explanation": "이 문제는 **C언어의 중첩 반복문**과 **문자열 비교**를 이해하는 문제입니다.\n\n[코드 분석]\n\n```c\n#include <stdio.h>\nint main(){\n    char* a = \"qwer\";      // 문자열 a = \"qwer\"\n    char* b = \"qwtety\";    // 문자열 b = \"qwtety\"\n    \n    for(int i = 0; a[i] != '\\0'; i++){           // 외부 반복문: a의 각 문자 순회\n        for(int j = 0; b[j] != '\\0'; j++){       // 내부 반복문: b의 각 문자 순회\n            if(a[i] == b[j])                     // a[i]와 b[j]가 같으면\n                printf(\"%c\", a[i]);             // a[i] 출력\n        }\n    }\n}\n```\n\n[실행 과정]\n\n[문자열 분석]\n- `a = \"qwer\"`: `a[0] = 'q'`, `a[1] = 'w'`, `a[2] = 'e'`, `a[3] = 'r'`, `a[4] = '\\0'`\n- `b = \"qwtety\"`: `b[0] = 'q'`, `b[1] = 'w'`, `b[2] = 't'`, `b[3] = 'e'`, `b[4] = 't'`, `b[5] = 'y'`, `b[6] = '\\0'`\n\n[중첩 반복문 실행]\n\n1. **`i = 0` (a[0] = 'q')**:\n   - `j = 0`: `a[0] == b[0]` → `'q' == 'q'` → **TRUE** → `'q'` 출력\n   - `j = 1`: `a[0] == b[1]` → `'q' == 'w'` → FALSE\n   - `j = 2`: `a[0] == b[2]` → `'q' == 't'` → FALSE\n   - `j = 3`: `a[0] == b[3]` → `'q' == 'e'` → FALSE\n   - `j = 4`: `a[0] == b[4]` → `'q' == 't'` → FALSE\n   - `j = 5`: `a[0] == b[5]` → `'q' == 'y'` → FALSE\n\n2. **`i = 1` (a[1] = 'w')**:\n   - `j = 0`: `a[1] == b[0]` → `'w' == 'q'` → FALSE\n   - `j = 1`: `a[1] == b[1]` → `'w' == 'w'` → **TRUE** → `'w'` 출력\n   - `j = 2`: `a[1] == b[2]` → `'w' == 't'` → FALSE\n   - `j = 3`: `a[1] == b[3]` → `'w' == 'e'` → FALSE\n   - `j = 4`: `a[1] == b[4]` → `'w' == 't'` → FALSE\n   - `j = 5`: `a[1] == b[5]` → `'w' == 'y'` → FALSE\n\n3. **`i = 2` (a[2] = 'e')**:\n   - `j = 0`: `a[2] == b[0]` → `'e' == 'q'` → FALSE\n   - `j = 1`: `a[2] == b[1]` → `'e' == 'w'` → FALSE\n   - `j = 2`: `a[2] == b[2]` → `'e' == 't'` → FALSE\n   - `j = 3`: `a[2] == b[3]` → `'e' == 'e'` → **TRUE** → `'e'` 출력\n   - `j = 4`: `a[2] == b[4]` → `'e' == 't'` → FALSE\n   - `j = 5`: `a[2] == b[5]` → `'e' == 'y'` → FALSE\n\n4. **`i = 3` (a[3] = 'r')**:\n   - `j = 0`: `a[3] == b[0]` → `'r' == 'q'` → FALSE\n   - `j = 1`: `a[3] == b[1]` → `'r' == 'w'` → FALSE\n   - `j = 2`: `a[3] == b[2]` → `'r' == 't'` → FALSE\n   - `j = 3`: `a[3] == b[3]` → `'r' == 'e'` → FALSE\n   - `j = 4`: `a[3] == b[4]` → `'r' == 't'` → FALSE\n   - `j = 5`: `a[3] == b[5]` → `'r' == 'y'` → FALSE\n   - 일치하는 문자 없음 (출력 없음)\n\n[출력 결과]\n- `'q'` (a[0]과 b[0] 일치)\n- `'w'` (a[1]과 b[1] 일치)\n- `'e'` (a[2]과 b[3] 일치)\n- **최종 출력: \"qwe\"**\n\n[핵심 개념]\n\n- **중첩 반복문**: 외부 반복문의 각 반복마다 내부 반복문이 완전히 실행됨\n- **문자열 비교**: 각 문자를 하나씩 비교하여 일치하는 문자를 찾음\n- **교집합**: 두 문자열에 공통으로 포함된 문자를 찾는 알고리즘\n\n[답] **\"qwe\"**", "table_refs": [], "image_refs": ["images/2023_round1/3.png"], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.378268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main(){\n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n    for(int i = 0; a[i] != '\\0'; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n}", "line_numbers": [1, 10], "file": "data/codes/2023_round1/Q003_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "아래 내용을 확인하여\n\n괄호 안에 용어를 표안에 알맞는 값을 고르시오.\n(보기가 있습니다.\nex: 패킷​\n등)", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "[SSH (Secure Shell, 시큐어 셸)]\n\n[영어 약자 풀이]\n- **S**ecure: 보안의, 안전한\n- **S**hell: 셸 (명령 프롬프트)\n- **H** (없음, SSH는 두 단어)\n- **SSH = Secure Shell**\n\n[SSH의 정의]\n- **원격 접속을 위한 보안 프로토콜**\n- 네트워크상의 다른 컴퓨터에 **암호화된 통신**으로 접속\n- 기본 포트: **22번**\n\n[SSH의 주요 특징]\n\n1. [원격 접속]\n   - 네트워크상의 다른 컴퓨터에 로그인\n   - 원격 시스템에서 명령 실행\n   - `ssh user@hostname` 형태로 접속\n\n2. [파일 전송]\n   - **SCP (Secure Copy)**: 암호화된 파일 복사\n   - SFTP (SSH File Transfer Protocol): 암호화된 파일 전송\n\n3. [보안 기능]\n   - **암호화된 통신**: 모든 데이터가 암호화되어 전송\n   - **공개키 기반 인증**: 비밀번호 없이 키 기반 인증 가능\n   - **IP 스푸핑 방지**: 연결 무결성 보장\n\n4. [기존 프로토콜의 보안 버전]\n   - rsh, rcp, rlogin, rexec: 평문 통신 → SSH로 대체\n   - **Telnet**: 평문 통신 → SSH로 대체\n   - **FTP**: 평문 파일 전송 → SFTP로 대체\n\n[SSH vs 기존 프로토콜]\n| 구분 | **기존 프로토콜** | **SSH** |\n|------|------------------|---------|\n| **통신** | 평문 (암호화 없음) | 암호화 |\n| **보안** | 취약 | 안전 |\n| **포트** | Telnet(23), FTP(21) | 22 |\n\n[답] **SSH**", "table_refs": [], "image_refs": ["images/2023_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "아래 내용을 확인하여\n\n알맞는 답을 작성하시오.", "choices": [], "answer": {"keys": ["1. 웜", "2. 트로이 목마", "3. 바이러스"], "raw_text": "1. 웜 2. 트로이 목마 3. 바이러스"}, "explanation": "악성코드는 그 특성에 따라 웜, 트로이 목마, 바이러스로 분류됩니다.\n\n[악성코드의 특징]\n\n1. [웜(Worm)]\n- 자기 복제를 통해 네트워크로 확산\n- 다른 파일에 기생하지 않고 독립적으로 실행\n- 네트워크 취약점을 이용해 빠르게 전파\n- 예: Code Red, Nimda\n\n2. [트로이 목마(Trojan Horse)]\n- 정상 프로그램으로 위장한 악성 코드\n- 사용자가 의도적으로 설치 (위장된 정상 프로그램처럼 보임)\n- 다른 파일에 기생하지 않음\n- 백도어 설치, 정보 탈취 등 수행\n\n3. [바이러스(Virus)]\n- 다른 파일에 기생하여 감염\n- 실행 파일, 문서 파일 등에 삽입\n- 사용자가 감염된 파일을 실행하면 활성화\n- 자기 복제 기능\n\n[비교]\n- **바이러스**: 파일에 기생, 사용자 개입 필요\n- **웜**: 독립 실행, 네트워크 자동 전파\n- **트로이 목마**: 정상 프로그램 위장, 사용자 설치 유도\n\n[답] \"1. 웜, 2. 트로이 목마, 3. 바이러스\"", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "아래 내용에서 괄호 안에 알맞는 용어를 작성하시오.\n​\n(    )  네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜을 가리킨다.\n(    )  보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공한다.\n(    )  기본적으로 포트는 22번이다.\n​", "choices": [], "answer": {"keys": ["SSH"], "raw_text": "SSH"}, "explanation": "이 문제는 SSH (Secure Shell, 시큐어 셸)에 대한 문제입니다.\n\n[SSH (Secure Shell)란?]\n\n[영어 약자 풀이]\n- **S**ecure: 보안\n- **S**hell: 셸 (명령 줄 인터페이스)\n- **H**: 생략 (일반적으로 SSH로 표기)\n- **SSH = Secure Shell**\n\n[문제에서 설명한 SSH의 특징]\n\n1. \"네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜을 가리킨다\":\n   - **원격 로그인**: 네트워크를 통해 다른 컴퓨터에 접속\n   - **원격 명령 실행**: 원격 시스템에서 명령어 실행\n   - **파일 전송**: 다른 시스템으로 파일 복사 (SCP, SFTP 사용)\n   - **응용 프로그램**: SSH 클라이언트 (PuTTY, OpenSSH 등)\n   - **프로토콜**: 네트워크 통신 규약\n\n2. \"보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공한다\":\n   - **보안 접속**: 암호화된 통신 제공\n   - rsh, rcp, rlogin, rexec: 기존의 보안 취약한 원격 접속 도구들의 보안 버전\n   - **telnet**: 평문 통신 (보안 취약) → SSH로 대체\n   - **ftp**: 평문 파일 전송 (보안 취약) → SFTP로 대체\n   - **IP spoofing 방지**: IP 주소 위/변조 공격 방지 기능\n\n3. **\"기본적으로 포트는 22번이다\"**:\n   - **포트 22번**: SSH의 기본 포트 번호\n   - 이것이 SSH를 식별하는 중요한 특징\n   - 보안을 위해 다른 포트로 변경 가능 (포트 변경)\n\n[SSH의 주요 기능]\n\n1. **원격 접속**:\n   - 네트워크상의 다른 컴퓨터에 로그인\n   - 원격 시스템에서 명령 실행\n\n2. **파일 전송**:\n   - **SCP (Secure Copy)**: 암호화된 파일 복사\n   - SFTP (SSH File Transfer Protocol): 암호화된 파일 전송\n\n3. [보안 기능]\n   - **암호화 통신**: 모든 데이터가 암호화되어 전송\n   - **공개키 인증**: 비밀번호 대신 공개키/개인키 사용 가능\n   - **IP spoofing 방지**: IP 주소 위조 방지\n\n[SSH vs 기존 프로토콜]\n| 구분 | **Telnet** | **FTP** | **SSH** |\n|------|-----------|---------|---------|\n| **통신** | 평문 | 평문 | 암호화 |\n| **보안** | 취약 | 취약 | 안전 |\n| **포트** | 23 | 21 | 22 |\n| **파일 전송** | 불가 | 가능 (FTP) | 가능 (SFTP/SCP) |\n\n[SSH의 사용 예시]\n- **서버 관리**: 원격 서버에 접속하여 관리\n- **파일 전송**: SFTP를 통한 안전한 파일 전송\n- **포트 포워딩**: SSH 터널링을 통한 보안 연결\n\n[답] **SSH (Secure Shell)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": ["정보보안"], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "아래 설명에 대한 알맞는 답을 작성하시오.\n(보기가 있습니다.\nex:\n랜섬웨어,\n스파이웨어\n​\n등)", "choices": [], "answer": {"keys": ["ICMP"], "raw_text": "ICMP"}, "explanation": "이 문제는 **악성코드 분류**에 대한 문제입니다. 문제의 표를 확인하여 각 악성코드의 특징을 매칭해야 합니다.\n\n[악성코드의 주요 분류]\n\n1. **웜(Worm)**:\n   - 자기 복제를 통해 네트워크로 확산\n   - 다른 파일에 기생하지 않고 독립적으로 실행\n   - 네트워크 취약점을 이용해 빠르게 전파\n\n2. **트로이 목마(Trojan Horse)**:\n   - 정상 프로그램으로 위장한 악성 코드\n   - 사용자가 의도적으로 설치 (위장된 정상 프로그램처럼 보임)\n   - 다른 파일에 기생하지 않음\n   - 백도어 설치, 정보 탈취 등 수행\n\n3. **바이러스(Virus)**:\n   - 다른 파일에 기생하여 감염\n   - 실행 파일, 문서 파일 등에 삽입\n   - 사용자가 감염된 파일을 실행하면 활성화\n   - 자기 복제 기능\n\n4. **랜섬웨어(Ransomware)**:\n   - 사용자의 파일을 암호화하여 접근 불가능하게 만듦\n   - 복구를 위해 돈을 요구하는 악성코드\n   - 파일 암호화, 시스템 잠금 등의 피해\n\n5. **스파이웨어(Spyware)**:\n   - 사용자의 개인정보를 수집하여 전송하는 악성코드\n   - 키로거, 브라우저 히스토리 수집 등\n   - 사용자 모르게 정보 수집\n\n[문제의 표를 확인하여]\n표에 나온 각 악성코드의 특징(네트워크 전파, 파일 기생, 위장 등)을 확인하고, 보기에서 가장 알맞는 답을 선택해야 합니다.\n\n[답] 표의 내용에 따라 결정됩니다.", "table_refs": [{"id": "table1", "json": "data/tables/2023_round1/Q008_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2023_round1/8.png"], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.", "choices": [], "answer": {"keys": ["%", "10"], "raw_text": "(a) % (b) 10"}, "explanation": "[이진수를 십진수로 변환 - 코드 실행 추적]\n\n**변환 원리:**\n이진수 101110 = 1×2⁵ + 0×2⁴ + 1×2³ + 1×2² + 1×2¹ + 0×2⁰ = 46\n\n**실행 과정:**\n\n초기값: `input=101110, di=1, sum=0`\n\n| 반복 | input%10 | sum 계산 | di×2 | input/10 |\n|------|----------|----------|------|----------|\n| 1회 | 0 | 0+0×1=0 | 2 | 10111 |\n| 2회 | 1 | 0+1×2=2 | 4 | 1011 |\n| 3회 | 1 | 2+1×4=6 | 8 | 101 |\n| 4회 | 1 | 6+1×8=14 | 16 | 10 |\n| 5회 | 0 | 14+0×16=14 | 32 | 1 |\n| 6회 | 1 | 14+1×32=**46** | 64 | 0 |\n\n**정답: (a) %, (b) 10**\n\n**핵심:**\n- `input % 10`: 마지막 자리 추출\n- `input / 10`: 마지막 자리 제거\n- `di`는 2의 거듭제곱 (1→2→4→8→16→32)", "table_refs": [], "image_refs": ["images/2023_round1/9.png"], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-05T16:01:31.952342", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nint main() {\n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n    while (1) {\n        if (input == 0) break\n        else {\n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n        }\n    }\n    printf(\"%d\", sum);\n    return 0;\n}", "line_numbers": [1, 16], "file": "data/codes/2023_round1/Q009_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c", "포인터"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음 보안 관련 설명으로 괄호 안에 알맞는 용어를  작성하시오.\n(    )은/는 TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다.\n(    ) 프로토콜은 보통 다른 호스트나 게이트웨이 와 연결된 네트웍에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다.\n(    ) 을/를 이용한 공격에는\n(    )\nFlooding가 있는데 ping 명령어를 통한 (     ) 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른작업을 하지 못하도록 하는 공격이다.", "choices": [], "answer": {"keys": ["ICMP"], "raw_text": "ICMP"}, "explanation": "이 문제는 ICMP (Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)에 대한 문제입니다.\n\n[ICMP (Internet Control Message Protocol)란?]\n\n[영어 약자 풀이]\n- **I**nternet: 인터넷\n- **C**ontrol: 제어\n- **M**essage: 메시지\n- **P**rotocol: 프로토콜\n- ICMP = Internet Control Message Protocol\n\n[문제에서 설명한 ICMP의 특징]\n\n1. \"TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다\":\n   - **네트워크 계층 프로토콜**: IP 계층에서 동작\n   - **오류 보고**: IP 패킷 전송 중 오류나 문제 발생 시 ICMP 메시지로 알림\n   - **예시**: 목적지 도달 불가, 시간 초과, 네트워크 혼잡 등\n\n2. \"프로토콜은 보통 다른 호스트나 게이트웨이와 연결된 네트워크에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다\":\n   - **네트워크 진단 도구**: 네트워크 상태 확인\n   - **`ping` 명령어**: ICMP Echo Request/Reply 사용\n   - **`traceroute`**: ICMP Time Exceeded 메시지 활용\n   - **연결성 확인**: 호스트나 게이트웨이와의 연결 상태 확인\n\n3. \"ICMP를 이용한 공격에는 ICMP Flooding이 있는데 ping 명령어를 통한 ICMP 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른 작업을 하지 못하도록 하는 공격이다\":\n   - ICMP Flooding (Ping Flood): DoS(Denial of Service) 공격\n   - **ping 명령어**: ICMP Echo Request 패킷을 대량으로 전송\n   - **서버 부하**: 서버가 응답 처리에만 집중하여 다른 작업 불가\n   - **방어 방법**: ICMP 패킷 필터링, Rate Limiting\n\n[ICMP 메시지 종류]\n\n1. **Echo Request/Reply**:\n   - **ping** 명령어에서 사용\n   - Echo Request를 보내고 Echo Reply를 받아 연결 확인\n\n2. Destination Unreachable:\n   - 목적지에 도달할 수 없을 때\n   - 예: 호스트 도달 불가, 포트 도달 불가\n\n3. **Time Exceeded**:\n   - 패킷이 TTL(Time To Live)을 초과했을 때\n   - **traceroute**에서 사용\n\n4. **Source Quench**:\n   - 네트워크 혼잡 시 전송 속도 조절 요청\n\n[ICMP의 주요 용도]\n- **네트워크 진단**: ping, traceroute 등\n- **오류 보고**: IP 패킷 전송 오류 알림\n- **라우팅 정보**: 네트워크 경로 정보 제공\n\n[ICMP Flooding 공격]\n- **공격 방식**: 대량의 ICMP Echo Request 패킷 전송\n- **목적**: 서버의 리소스를 소모하여 서비스 거부\n- **방어**: ICMP 패킷 차단, Rate Limiting, 방화벽 설정\n\n[답] ICMP (Internet Control Message Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.007450"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "TCP/IP"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "다음은 데이터베이스에 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.\nex:\n릴레이션 스키마\n​\n등)", "choices": [], "answer": {"keys": ["idx2", "nx"], "raw_text": "idx2 nx"}, "explanation": "데이터베이스의 3단계 스키마 구조를 묻는 문제입니다.\n\n[이미지의 표 내용 분석]\n\n문제 이미지에는 스키마의 3단계 구조에 대한 설명이 나와 있습니다:\n\n[( 1 ) 스키마]\n- 실 수 있는 수량의 손서 있는 열기이다\n- 어떤 요소의 집합, 혹은 테이블에서의 행을 가리키지만 일반적인 집합과는 달리 중복이 허용될 수 있다\n- 리스트와 동일하게 여러 객체를 모아 담으며, 숫자, 문자, 문자, 객체, 배열, 튜플 안의 튜플 전부 가능하다\n\n[( 2 ) 스키마]\n- 어느 한 시점에 릴레이션의 내용(상태), 즉 저장된 데이터 전체를 의미한다\n- 단순히 릴레이션 또는 릴레이션 익스텐션(Relation Extension)이라고도 한다\n- 특정 데이터 집합의 유니크(Unique)한 값의 개수이다\n- 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다\n\n[( 3 ) 스키마]\n- 물리적인 저장장치 입장에서 데이터가 저장되는 방법을 기술한 것이다\n- 실제 데이터베이스에 저장될 레코드의 물리적인 구조를 정의한다\n- 저장 데이터 항목의 표현방법, 내부 레코드의 물리적 순서, 인덱스 유/무 등을 나타낸다\n- 시스템 프로그래머나 시스템 설계자가 관리한다\n\n[데이터베이스 3단계 스키마 구조]\n\n1. 외부 스키마 (External Schema):\n   - 사용자나 응용 프로그램이 개인의 입장에서 필요한 데이터베이스의 논리적 구조를 정의한다\n   - 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있다\n   - 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있다\n   - 하나의 외부 스키마를 여러개의 응용 프로그램 혹은 사용자가 공유할 수 있다\n\n2. 개념 스키마 (Conceptual Schema):\n   - 개체 간의 관계(Relationship)와 제약 조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다\n   - 데이터베이스의 전체적인 논리적 구조로, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스\n   - 기관이나 조직의 관점에서 데이터베이스를 정의한 것이다\n   - 데이터베이스 파일에 저장되는 데이터의 형태를 나타내는 것이다\n\n3. 내부 스키마 (Internal Schema):\n   - 물리적 저장장치 입장에서 데이터가 저장되는 방법을 기술한 것이다\n   - 실제 데이터베이스에 저장될 레코드의 물리적인 구조를 정의한다\n   - 저장 데이터 항목의 표현방법, 내부 레코드의 물리적 순서, 인덱스 유/무 등을 나타낸다\n\n[답] 이미지의 표 내용에서 각 괄호 ( 1 ), ( 2 ), ( 3 )에 해당하는 스키마 종류를 보기에서 선택하여 작성합니다.", "table_refs": [], "image_refs": ["images/2023_round1/12.png"], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "[학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.\n조건\n\n- 컬럼의 값이 문자열일 경우 작은 따움표 ('  ')를 표시하시오.\n\n- SQL 마지막에 세미콜론(;)은 표기하지 않아도 관계 없습니다.", "choices": [], "answer": {"keys": ["DELETE FROM 학생 WHERE 이름 = '민수'"], "raw_text": "DELETE FROM 학생 WHERE 이름 = '민수'"}, "explanation": "이 문제는 **SQL DELETE 문**을 작성하는 문제입니다.\n\n[DELETE 문의 기본 구조]\n\n1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.\n\n2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.\n- INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환\n- LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환\n- JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.\n\n3. **WHERE 절**: 조건에 맞는 행만 선택합니다.\n- 비교 연산자: =, >, <, >=, <=, <>, !=\n- 논리 연산자: AND, OR, NOT\n- WHERE 절의 조건을 정확히 적용하여 필터링합니다.\n\n4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.\n\n5. **SELECT 절**: 조회할 컬럼을 지정합니다.\n- 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)\n- 집계 함수: COUNT, SUM, AVG, MAX, MIN 등\n\n6. **ORDER BY 절**: 결과를 정렬합니다.\n- ASC: 오름차순 (기본값)\n- DESC: 내림차순\n\n[답] DELETE FROM 학생 WHERE 이름 = '민수'", "table_refs": [], "image_refs": ["images/2023_round1/13.png"], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:15:55.930822", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": ["데이터베이스", "프로그래밍"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "다음 코드에서 괄호 안에 알맞는 값을 변수명으로 작성하시오.\n(코드가 해깔려 시험문제와 동일하지 않지만 패턴이 비슷하다는 점만 참고해주세요.)\n출력 값 : 1 2 3 5 7 8", "choices": [], "answer": {"keys": ["SELECT 과목이름 MIN(점수) AS 최소점수 MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"], "raw_text": "SELECT 과목이름 MIN(점수) AS 최소점수 MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"}, "explanation": "이 문제는 **프로그래밍 코드에서 변수명을 찾는** 문제입니다. 출력값이 \"1 2 3 5 7 8\"이므로, 이 순서대로 출력하는 코드를 분석해야 합니다.\n\n[문제 분석]\n\n**출력값**: \"1 2 3 5 7 8\"\n- 숫자가 순차적으로 나열되어 있지만, 4와 6이 빠져있음\n- 이는 특정 조건에 따라 숫자를 선택적으로 출력하는 패턴\n\n[일반적인 코드 패턴]\n\n1. **반복문과 조건문 조합**:\n   - 1부터 8까지 반복하면서 특정 조건을 만족하는 경우만 출력\n   - 예: 소수 출력, 홀수 출력, 특정 조건 만족하는 숫자 출력\n\n2. **배열/리스트 처리**:\n   - 배열의 특정 인덱스 값을 출력\n   - 조건에 따라 배열 요소를 선택적으로 출력\n\n3. **변수 추적**:\n   - 각 반복에서 변수 값의 변화를 추적\n   - 조건문의 조건을 확인하여 출력 여부 결정\n\n[가능한 코드 패턴 예시]\n\n```\n// 예시 1: 조건부 출력\nfor (int i = 1; i <= 8; i++) {\n    if (조건) {\n        System.out.print(i + \" \");\n    }\n}\n\n// 예시 2: 배열 인덱스\nint[] arr = {1, 2, 3, 4, 5, 6, 7, 8};\nfor (int i = 0; i < arr.length; i++) {\n    if (조건) {\n        System.out.print(arr[i] + \" \");\n    }\n}\n```\n\n[문제 해결 방법]\n\n1. **출력값 분석**: \"1 2 3 5 7 8\"에서 4와 6이 빠진 이유 확인\n2. **코드 구조 파악**: 반복문, 조건문, 변수 사용 확인\n3. **변수명 추론**: 괄호 안에 들어갈 변수명이 출력값과 어떤 관계인지 확인\n4. **패턴 매칭**: 출력값과 코드의 로직을 연결하여 변수명 도출\n\n[답] 문제의 이미지에서 코드를 확인하고, 출력값 \"1 2 3 5 7 8\"과 코드의 로직을 연결하여 괄호 안에 들어갈 변수명을 정확히 작성해야 합니다.", "table_refs": [], "image_refs": ["images/2023_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음 파이썬 코드의 알맞는 출력값을 작성하시오.", "choices": [], "answer": {"keys": ["{'중국', '한국', '일본', '베트남'}"], "raw_text": "{'중국', '한국', '일본', '베트남'}"}, "explanation": "Python Set 연산 문제입니다.\n\n[문제의 전체 코드]\n\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홀츠', '한국', '태국'})\nprint(a)\n```\n\n[코드 실행 과정]\n\n1. [초기 Set 생성]\n   ```python\n   a = {'한국', '중국', '일본'}\n   ```\n   - `a = {'한국', '중국', '일본'}`\n\n2. [`a.add('베트남')`]\n   - Set에 '베트남' 추가\n   - `a = {'한국', '중국', '일본', '베트남'}`\n\n3. [`a.add('중국')`]\n   - Set에 '중국' 추가 시도\n   - **Set은 중복을 허용하지 않음** → '중국'은 이미 있으므로 변화 없음\n   - `a = {'한국', '중국', '일본', '베트남'}`\n\n4. [`a.remove('일본')`]\n   - Set에서 '일본' 제거\n   - `a = {'한국', '중국', '베트남'}`\n\n5. [`a.update({'홀츠', '한국', '태국'})`]\n   - `update()`: 다른 Set의 모든 요소를 현재 Set에 추가 (합집합 연산)\n   - '홀츠', '한국', '태국' 추가 시도\n   - '한국'은 이미 있으므로 중복 제거됨\n   - '홀츠', '태국'만 추가됨\n   - `a = {'한국', '중국', '베트남', '홀츠', '태국'}`\n\n[그런데 이미지를 보면]\n\n이미지의 실제 코드에서는 `update` 대신 다른 연산이 있을 수 있습니다. 문제의 정답이 \"{'중국', '한국', '일본', '베트남'}\"이므로, 실제 코드를 확인하여 정확한 연산을 파악해야 합니다.\n\n[Python Set 연산 정리]\n\n- **`add(element)`**: 요소 1개 추가 (중복 시 무시)\n- **`remove(element)`**: 요소 제거 (없으면 에러)\n- **`update(set)`**: 다른 Set의 모든 요소 추가 (합집합)\n- **`discard(element)`**: 요소 제거 (없어도 에러 없음)\n\n[Set의 특징]\n\n- **중복 허용 안 됨**: 같은 요소는 하나만 저장\n- **순서 없음**: 출력 순서는 보장되지 않음 (Python 3.7+에서는 입력 순서 유지)\n- **가변**: 요소 추가/제거 가능\n\n[답] 문제 이미지의 실제 코드를 기반으로 연산을 추적하면 {'중국', '한국', '일본', '베트남'} - **메서드 오버라이딩**: 자식 클래스의 `display()`가 부모 클래스의 `display()`를 덮어씀\n   - 자식 클래스의 `display()` 메서드 실행\n   - `print(f\"Vehicle name: {self.name}\")` 실행\n   - `self.name = \"Spark\"`이므로 출력: \"Vehicle name: Spark\"\n\n[핵심 개념]\n\n- **상속**: `Car(Vehicle)` - `Car`가 `Vehicle`을 상속받음\n- **`super()`**: 부모 클래스의 메서드나 생성자를 호출\n- **메서드 오버라이딩**: 자식 클래스에서 부모 클래스의 메서드를 재정의\n- **메서드 호출 순서**: 자식 클래스에 메서드가 있으면 자식 클래스의 메서드가 우선 호출됨\n\n[답] \"Vehicle name: Spark\"", "table_refs": [], "image_refs": ["images/2023_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "다음 성적 테이블에서 과목별 점수의 평균이 90점 이상인 '과목이름', '최소점수', '최대점수' 를 검색하고자 한다. [조건]을 참고하여\n\n적합한 SQL문을 작성하시오.\n조건\n:\n\n- where사용하지 말하야 한다.\n\n- SELECT절에 별칭을 사용하여 작성해야 한다.\n\n- SQL 구문 마지막에 세미콜론 생락 가능하다.\n\n- 반드시 GROUP BY와 having을 사용해야 한다.\n\n- 집계함수를 사용해야 한다.", "choices": [], "answer": {"keys": ["SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"], "raw_text": "SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90"}, "explanation": "이 문제는 **SQL 쿼리 작성** 문제입니다. GROUP BY와 HAVING을 사용하여 그룹별 집계 조건을 적용해야 합니다.\n\n[SQL 쿼리 작성 방법]\n\n[요구사항 분석]\n- **조회할 컬럼**: 과목이름, 최소점수, 최대점수\n- **조건**: 과목별 평균 점수가 90점 이상\n- **제약사항**: WHERE 사용 불가, GROUP BY와 HAVING 필수, 별칭(AS) 사용, 집계 함수 사용\n\n[SQL 쿼리 구조]\n\n```sql\nSELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수\nFROM 성적\nGROUP BY 과목이름\nHAVING AVG(점수) >= 90\n```\n\n[각 절의 역할]\n\n1. **SELECT 절**:\n   - `과목이름`: 그룹화 기준 컬럼 (GROUP BY에 포함되어야 함)\n   - `MIN(점수) AS 최소점수`: 각 과목별 최소 점수 (집계 함수)\n   - `MAX(점수) AS 최대점수`: 각 과목별 최대 점수 (집계 함수)\n   - **별칭(AS) 사용**: `AS 최소점수`, `AS 최대점수`로 별칭 지정\n\n2. **FROM 절**:\n   - `FROM 성적`: 성적 테이블에서 조회\n\n3. **GROUP BY 절**:\n   - `GROUP BY 과목이름`: 과목별로 그룹화\n   - 각 과목별로 집계 함수(MIN, MAX, AVG) 적용\n\n4. **HAVING 절**:\n   - `HAVING AVG(점수) >= 90`: 그룹화된 결과 중 평균 점수가 90점 이상인 그룹만 선택\n   - **WHERE vs HAVING**:\n     - WHERE: 그룹화 전 행 단위 필터링\n     - HAVING: 그룹화 후 그룹 단위 필터링 (집계 함수 조건)\n   - 문제에서 WHERE 사용 불가라고 했으므로 HAVING 사용\n\n[실행 순서]\n1. FROM 성적: 성적 테이블 조회\n2. GROUP BY 과목이름: 과목별로 그룹화\n3. HAVING AVG(점수) >= 90: 평균 90점 이상인 그룹만 선택\n4. SELECT: 과목이름, 최소점수, 최대점수 출력\n\n[핵심 개념]\n- **GROUP BY**: 특정 컬럼 기준으로 그룹화\n- **집계 함수**: MIN, MAX, AVG, COUNT, SUM 등\n- **HAVING**: 그룹화 후 조건 필터링 (집계 함수 조건 사용 가능)\n- **별칭(AS)**: 컬럼명을 별칭으로 표시\n\n[답] SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) >= 90", "table_refs": [], "image_refs": ["images/2023_round1/16.png"], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["Vehicle name: Spark"], "raw_text": "Vehicle name: Spark"}, "explanation": "Java 추상 클래스, 메서드 오버로딩, 다형성을 묻는 문제입니다.\n\n[이미지의 코드 분석]\n\n```java\nabstract class Vehicle {\n    String name;\n    abstract public String getName(String val);\n    \n    public String getName() {\n        return \"Vehicle name: \" + name;\n    }\n}\n\nclass Car extends Vehicle {\n    public Car(String val) {\n        name=super.name=val;\n    }\n    \n    public String getName(String val) {\n        return \"Car name:\" + val;\n    }\n    \n    public String getName(byte val[]) {\n        return \"Car name:\" + val;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle obj = new Car(\"Spark\");\n        System.out.println(obj.getName());\n    }\n}\n```\n\n[코드 실행 과정]\n\n1. [추상 클래스 Vehicle]\n   - `String name` 필드 선언\n   - `abstract public String getName(String val)`: 추상 메서드 (파라미터 1개)\n   - `public String getName()`: 구현된 메서드 (파라미터 없음)\n\n2. [Car 클래스 (Vehicle 상속)]\n   - `public Car(String val)`: 생성자에서 `name = \"Spark\"` 설정\n   - `getName(String val)`: 추상 메서드 구현 (파라미터 String 1개)\n   - `getName(byte val[])`: 추가 오버로딩 메서드 (파라미터 byte배열)\n   - **주의**: `getName()` (파라미터 없음)은 오버라이딩하지 않음!\n\n3. [main 실행]\n   - `Vehicle obj = new Car(\"Spark\");`\n     - Car 객체 생성, Vehicle 타입 변수에 저장 (다형성)\n     - 생성자 실행: `name = \"Spark\"`\n   \n   - `obj.getName()` 호출:\n     - Car 클래스에 `getName()` (파라미터 없음)이 **오버라이딩되지 않음**\n     - 따라서 부모 클래스 Vehicle의 `getName()` 메서드 호출\n     - `return \"Vehicle name: \" + name;`\n     - `name = \"Spark\"`이므로 반환값: \"Vehicle name: Spark\"\n   \n   - `System.out.println(...)`: \"Vehicle name: Spark\" 출력\n\n[핵심 개념]\n\n1. [추상 클래스와 추상 메서드]\n   - `abstract` 키워드로 선언\n   - 추상 메서드는 자식 클래스에서 반드시 구현해야 함\n   - 추상 클래스도 구현된 메서드를 가질 수 있음\n\n2. [메서드 오버로딩(Overloading)]\n   - 같은 이름의 메서드를 **파라미터 타입/개수**를 다르게 하여 여러 개 정의\n   - Car 클래스에서 `getName(String)`, `getName(byte[])`로 오버로딩\n\n3. [메서드 오버라이딩(Overriding) vs 오버로딩]\n   - **오버라이딩**: 부모 클래스의 메서드를 **같은 시그니처(이름, 파라미터)**로 재정의\n   - **오버로딩**: 같은 이름의 메서드를 **다른 파라미터**로 정의\n   - 이 문제에서 `getName()`은 오버라이딩되지 않았으므로 부모 클래스 메서드 사용\n\n4. [다형성(Polymorphism)]\n   - `Vehicle obj = new Car(\"Spark\");`\n   - 부모 타입 변수에 자식 객체 저장\n   - 메서드 호출 시 실제 객체 타입(Car)의 메서드 우선 호출\n   - 단, 오버라이딩되지 않은 메서드는 부모 클래스 메서드 호출\n\n[메서드 호출 규칙]\n\n| 메서드 | Car 클래스 정의 여부 | 호출되는 메서드 |\n|--------|---------------------|----------------|\n| `getName()` (파라미터 없음) | X (오버라이딩 안 됨) | Vehicle.getName() |\n| `getName(String)` | O (구현됨) | Car.getName(String) |\n| `getName(byte[])` | O (오버로딩) | Car.getName(byte[]) |\n\n[답] \"Vehicle name: Spark\"", "table_refs": [], "image_refs": ["images/2023_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T08:45:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "다음은 스키마와 관련된 내용이다.\n각 괄호 안에 알맞는 답을 작성하시오.\n(보기가 있습니다.)", "choices": [], "answer": {"keys": ["500"], "raw_text": "500"}, "explanation": "이 문제는 **데이터베이스 스키마**와 관련된 내용을 이해하는 문제입니다. 문제의 이미지와 보기를 확인하여 정확한 답을 찾아야 합니다.\n\n[데이터베이스 스키마 관련 개념]\n\n1. **스키마(Schema)**:\n   - 데이터베이스의 구조를 정의하는 메타데이터\n   - 릴레이션, 속성, 제약조건 등을 정의\n\n2. 외부 스키마(External Schema):\n   - 사용자나 응용 프로그램이 보는 데이터베이스 뷰\n   - 서브스키마라고도 함\n   - 여러 외부 스키마가 존재할 수 있음\n\n3. 개념 스키마(Conceptual Schema):\n   - 전체 데이터베이스의 논리적 구조\n   - 모든 데이터와 관계를 정의\n   - 하나만 존재\n\n4. 내부 스키마(Internal Schema):\n   - 물리적 저장 구조를 정의\n   - 인덱스, 파일 구조, 저장 방식 등\n   - 하나만 존재\n\n[3단계 스키마 구조(Three-Schema Architecture)]\n\n| 단계 | 스키마 | 설명 | 개수 |\n|------|--------|------|------|\n| **외부** | 외부 스키마 | 사용자 뷰 | 여러 개 |\n| **개념** | 개념 스키마 | 논리적 구조 | 1개 |\n| **내부** | 내부 스키마 | 물리적 구조 | 1개 |\n\n[문제 해결 방법]\n\n문제의 이미지와 보기를 확인하여:\n1. 스키마의 3단계 구조를 이해\n2. 각 괄호에 해당하는 스키마 단계를 식별\n3. 보기에서 가장 적합한 답을 선택\n\n[일반적인 스키마 문제 유형]\n- 사용자 뷰를 나타내는 스키마: **외부 스키마**\n- 논리적 구조를 나타내는 스키마: **개념 스키마**\n- 물리적 구조를 나타내는 스키마: **내부 스키마**\n\n[답] 문제의 이미지와 보기를 확인하여 각 괄호에 해당하는 스키마 단계를 정확히 매칭하여 작성해야 합니다.", "table_refs": [], "image_refs": ["images/2023_round1/18.png"], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.", "choices": [], "answer": {"keys": ["1234561 124567"], "raw_text": "1234561 124567"}, "explanation": "이 문제는 제어 흐름 그래프(Control Flow Graph)에서 분기 커버리지(Branch Coverage)를 만족하는 테스트 경로를 찾는 문제입니다.\n\n[분기 커버리지(Branch Coverage)란?]\n\n[정의]\n- 모든 분기(decision)의 True와 False 경로를 최소 한 번씩 실행하는 테스트 커버리지\n- **Decision Coverage**, **Branch Coverage**라고도 함\n- 각 조건문의 참(true)과 거짓(false) 경로를 모두 테스트\n\n[제어 흐름 그래프 분석]\n\n문제의 이미지를 참고하여 제어 흐름 그래프를 분석해야 합니다:\n\n1. **노드(정점)**: 각 문장이나 명령을 나타냄\n2. **간선(화살표)**: 제어 흐름을 나타냄\n3. **분기점**: 조건문(if, while 등)이 있는 노드\n\n[분기 커버리지 만족 방법]\n\n1. **각 분기점 식별**:\n   - 조건문이 있는 노드를 찾음\n   - 각 분기점에서 True 경로와 False 경로 확인\n\n2. **테스트 경로 구성**:\n   - 각 분기의 True 경로를 포함하는 경로 선택\n   - 각 분기의 False 경로를 포함하는 경로 선택\n   - 최소한의 경로로 모든 분기를 커버하도록 구성\n\n3. **경로 순서 작성**:\n   - 노드 번호를 순서대로 나열하여 테스트 경로 표현\n   - 예: \"1 2 3 4 5 6 1 2 4 5 6 7\"\n\n[일반적인 제어 흐름 그래프 구조]\n- **시작 노드**: 1\n- **중간 노드**: 2, 3, 4, 5, 6, ...\n- **종료 노드**: 마지막 노드\n\n[분기 커버리지 예시]\n\n제어 흐름 그래프가 다음과 같다면:\n- 노드 1 → 노드 2 (조건문)\n- 노드 2 → True: 노드 3, False: 노드 4\n- 노드 3 → 노드 5\n- 노드 4 → 노드 5\n- 노드 5 → 노드 6\n\n[분기 커버리지 테스트 경로]\n- 경로 1: 1 → 2(True) → 3 → 5 → 6 (조건문 True 경로)\n- 경로 2: 1 → 2(False) → 4 → 5 → 6 (조건문 False 경로)\n\n[답] 문제의 이미지에서 제어 흐름 그래프를 확인하고, 모든 분기의 True/False 경로를 포함하는 최소 테스트 경로를 작성해야 합니다. 일반적으로 여러 경로를 조합하여 분기 커버리지를 만족시킵니다.", "table_refs": [], "image_refs": ["images/2023_round1/19.png"], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "자료구조", "secondary_categories": ["소프트웨어공학"], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2023_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "다음 자바 코드에 대한 출력 값을 작성하시오.", "choices": [], "answer": {"keys": ["500"], "raw_text": "500"}, "explanation": "✅ 정답: 500\n\n📌 코드 실행 과정 추적\n\n생성자 호출 순서:\n1️⃣ new Child() 실행\n   → Child() 생성자 호출\n\n2️⃣ Child() 생성자\n   → this(5000) 호출 → Child(int x) 생성자로 이동\n\n3️⃣ Child(int x) 생성자 (x=5000)\n   → 먼저 부모 생성자 Parent() 자동 호출\n\n4️⃣ Parent() 생성자\n   → this(500) 호출 → Parent(int x) 생성자로 이동\n\n5️⃣ Parent(int x) 생성자 (x=500)\n   → this.x = 500 실행\n   → Parent의 x = 500 ✅\n\n6️⃣ Child(int x) 생성자로 복귀\n   → this.x = 5000 실행\n   → Child의 x = 5000 (Parent의 x와는 별개)\n\n7️⃣ obj.getX() 호출\n   → getX()는 Parent 클래스에만 정의됨\n   → Parent의 x 반환 → 500 출력\n\n💡 핵심:\n- Parent와 Child 모두 x 필드를 가짐 (필드는 오버라이딩 안 됨)\n- getX()는 Parent 클래스의 메서드이므로 Parent의 x(500)를 반환\n\n", "table_refs": [], "image_refs": ["images/2023_round1/20.png"], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/372", "crawled_at": "2025-11-03T00:22:01.379268", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:19.008462"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "쉬움", "estimated_time": 2}
