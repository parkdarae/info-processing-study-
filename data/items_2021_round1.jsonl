{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["RARP (Reverse Address Resolution Protocol)"], "raw_text": "RARP (Reverse Address Resolution Protocol)"}, "explanation": "RARP(Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜)는 물리 네트워크 주소(MAC 주소)를 알고 있을 때, 해당하는 IP 주소를 알아내기 위한 프로토콜입니다.\n\n**RARP의 특징:**\n\n1. **역방향 변환:**\n- ARP는 IP 주소 → MAC 주소 변환\n- RARP는 MAC 주소 → IP 주소 변환 (역방향)\n\n2. **사용 목적:**\n- 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아올 때 사용\n- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용\n\n3. **동작 방식:**\n- 클라이언트가 자신의 MAC 주소를 포함한 RARP 요청을 브로드캐스트로 전송\n- RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답\n\n**답:** RARP (Reverse Address Resolution Protocol)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "다음은 DB 설계 절차에 관한 설명이다.\n다음 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- (1)은/는 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.\n\n- (2)은/는 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다.\n\n- (3)은/는 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.\n\n[보기]\n\n: 구현 / 개념적 설계 / 논리적 설계 / 요구사항 분석 / 물리적 설계", "choices": [], "answer": {"keys": ["1. 물리적 설계", "2. 개념적 설계", "3. 논리적 설계"], "raw_text": "1. 물리적 설계 2. 개념적 설계 3. 논리적 설계"}, "explanation": "이 문제는 **데이터베이스 설계 절차**를 이해하는 문제입니다.\n\n**데이터베이스 설계 절차:**\n\n1. **요구사항 분석:**\n- 사용자 요구사항을 파악하고 분석\n- 시스템이 처리해야 할 데이터와 기능 정의\n\n2. **개념적 설계:**\n- 현실 세계에 대한 인식을 추상적, 개념적으로 표현\n- 개념적 구조를 도출하는 과정\n- 주요 산출물: E-R 다이어그램\n- 엔티티와 속성, 관계를 정의\n\n3. **논리적 설계:**\n- 목표 DBMS에 맞는 스키마 설계\n- 트랜잭션 인터페이스 설계\n- 정규화 과정 수행\n- 관계형 데이터 모델로 변환\n\n4. **물리적 설계:**\n- 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환\n- 인덱스 설계, 저장 공간 할당\n- 결과 산출물: 테이블 정의서 등\n\n5. **구현:**\n- 실제 데이터베이스 생성 및 응용 프로그램 개발\n\n**문제에서 요구하는 답:**\n- (1) 물리적 설계: 테이블 정의서 등 명세서 생성\n- (2) 개념적 설계: E-R 다이어그램 등 개념적 구조 도출\n- (3) 논리적 설계: 정규화 과정 수행\n\n**답:** 1. 물리적 설계, 2. 개념적 설계, 3. 논리적 설계", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q003", "question_text": "다음은 요구사항의 분류에 대한 설명이다.\n괄호 (   ) 안에 들어갈 요구사항의 유형에 대해서 쓰시오.\n\n- (1) 요구사항은 시스템이 제공하는 기능, 서비스에 대한 요구사항이다.\n\n- (2) 요구사항은 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항이다.", "choices": [], "answer": {"keys": ["1. 기능적", "2. 비기능적"], "raw_text": "1. 기능적 2. 비기능적"}, "explanation": "이 문제는 **요구사항의 분류**에 대한 이해를 묻는 문제입니다.\n\n**요구사항이란?**\n시스템 개발 분야에서 어떤 과제를 수행하기 위해 필요한 조건이나 능력을 말합니다. 요구사항은 시스템이 무엇을 해야 하는지를 정의합니다.\n\n**요구사항의 두 가지 주요 유형:**\n\n**1. 기능적 요구사항 (Functional Requirements):**\n- **정의**: 시스템이 **제공해야 하는 기능, 서비스**에 대한 요구사항\n- **특징**:\n  - 시스템이 \"무엇을\" 해야 하는지 명시\n  - 시스템의 입력, 처리, 출력에 대한 명세\n  - 사용자가 시스템을 통해 수행할 수 있는 기능들\n- **예시**:\n  - \"사용자는 로그인할 수 있어야 한다\"\n  - \"시스템은 주문을 처리할 수 있어야 한다\"\n  - \"게시판에 글을 작성, 수정, 삭제할 수 있어야 한다\"\n- **분류**: 사용자 요구사항, 시스템 요구사항\n\n**2. 비기능적 요구사항 (Non-Functional Requirements):**\n- **정의**: 시스템이 수행하는 **기능 이외의 사항**, 즉 **시스템 구축에 대한 제약사항**에 관한 요구사항\n- **특징**:\n  - 시스템이 \"어떻게\" 작동해야 하는지에 대한 품질 특성\n  - 성능, 보안, 신뢰성, 사용성 등의 측면\n  - 기능적 요구사항의 제약 조건\n- **예시**:\n  - 성능: \"응답 시간은 3초 이내여야 한다\"\n  - 보안: \"데이터는 암호화되어 저장되어야 한다\"\n  - 신뢰성: \"시스템 가동률은 99.9% 이상이어야 한다\"\n  - 사용성: \"초보자도 쉽게 사용할 수 있어야 한다\"\n- **분류**: 제품 요구사항, 조직 요구사항, 외부 요구사항\n\n**비교 요약:**\n| 구분 | 기능적 요구사항 | 비기능적 요구사항 |\n|------|----------------|------------------|\n| **관점** | 무엇을 (What) | 어떻게 (How) |\n| **내용** | 기능, 서비스 | 제약사항, 품질 |\n| **예시** | 로그인 기능 | 응답 시간, 보안 |\n\n**문제에서 요구하는 답:**\n- (1) **기능적**: 시스템이 제공하는 기능, 서비스에 대한 요구사항\n- (2) **비기능적**: 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항\n\n**답:** 1. 기능적, 2. 비기능적", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["3."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q004", "question_text": "웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구성된 언어를 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["WSDL"], "raw_text": "WSDL"}, "explanation": "WSDL(Web Services Description Language의 약자)은 웹 서비스 기술언어 또는 기술된 정의 파일의 총칭으로 XML로 기술됩니다. 웹 서비스의 구체적 내용이 기술되어 있으며 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술됩니다.", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["4."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:15:55.919491", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP", "라우팅"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q005", "question_text": "다음은 파이썬 코드이다.\n출력 결과를 쓰시오.", "choices": [], "answer": {"keys": ["skiddp"], "raw_text": "skiddp"}, "explanation": "이 파이썬 코드는 **문자열 리스트의 각 요소에서 첫 번째 문자를 추출**하는 문제입니다.\n\n**코드 분석:**\n```python class good :\nli = [\"seoul\", \"kyeonggi\", \"inchon\", \"daejeon\", \"daegu\", \"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\nstr01 = str01 + i[0]\nprint(str01)\n```\n\n**실행 과정:**\n\n1. **클래스 정의 및 인스턴스 생성:**\n- `good` 클래스의 클래스 변수 `li`에 도시명 리스트 저장\n- `g = good()`로 인스턴스 생성\n\n2. **반복문 실행:**\n- `for i in g.li`: 리스트의 각 요소를 순회\n- 각 도시명 문자열에서 첫 번째 문자(`i[0]`) 추출\n\n3. **문자 추출 과정:**\n- `i = \"seoul\"` → `i[0] = 's'` → `str01 = 's'`\n- `i = \"kyeonggi\"` → `i[0] = 'k'` → `str01 = 'sk'`\n- `i = \"inchon\"` → `i[0] = 'i'` → `str01 = 'ski'`\n- `i = \"daejeon\"` → `i[0] = 'd'` → `str01 = 'skid'`\n- `i = \"daegu\"` → `i[0] = 'd'` → `str01 = 'skidd'`\n- `i = \"pusan\"` → `i[0] = 'p'` → `str01 = 'skiddp'`\n\n**최종 출력:** `skiddp`\n\n**핵심 포인트:**\n- 문자열 인덱싱: `문자열[0]`은 첫 번째 문자를 반환합니다.\n- 문자열 연결: `str01 = str01 + i[0]`는 기존 문자열에 새 문자를 추가합니다.\n\n**답:**skiddp**", "table_refs": [], "image_refs": ["images/2021_round1/5.png"], "meta": {"layout": "single", "anchors": ["5."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [{"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}, {"language": "python", "code": "class good :\n\tli = [\"seoul\", \"kyeonggi\",\"inchon\",\"daejeon\",\"daegu\",\"pusan\"]\ng = good()\nstr01 = ''\nfor i in g.li:\n\tstr01 = str01 + i[0]\nprint(str01)", "line_numbers": [1, 7], "file": "data/codes/2021_round1/Q005_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["python"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q006", "question_text": "다음 SQL 실행 결과를 숫자만 쓰시오.\nSELECT COUNT(*) FROM 급여 WHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;", "choices": [], "answer": {"keys": ["1"], "raw_text": "1"}, "explanation": "**SQL 쿼리 실행 결과 분석:**\n\n**주어진 쿼리:**\n```sql\nSELECT COUNT(*) FROM 급여 \nWHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;\n```\n\n**연산자 우선순위 적용:**\n- `AND`가 `OR`보다 우선순위가 높음\n- 실제 조건: `(EMPNO > 100 AND SAL >= 3000) OR EMPNO = 200`\n\n**급여 테이블 데이터 (문제 이미지 참고):**\n| EMPNO | SAL |\n|-------|-----|\n| 100   | 1000|\n| 200   | 3000|\n| 300   | 1500|\n\n**각 행별 조건 평가:**\n\n**행1 (EMPNO=100, SAL=1000):**\n- 조건: `(100 > 100 AND 1000 >= 3000) OR 100 = 200`\n- 계산: `(FALSE AND FALSE) OR FALSE` = `FALSE OR FALSE` = **FALSE**\n- 결과: 카운트 제외\n\n**행2 (EMPNO=200, SAL=3000):**\n- 조건: `(200 > 100 AND 3000 >= 3000) OR 200 = 200`\n- 계산: `(TRUE AND TRUE) OR TRUE` = `TRUE OR TRUE` = **TRUE**\n- 결과: 카운트 포함 ✓\n\n**행3 (EMPNO=300, SAL=1500):**\n- 조건: `(300 > 100 AND 1500 >= 3000) OR 300 = 200`\n- 계산: `(TRUE AND FALSE) OR FALSE` = `FALSE OR FALSE` = **FALSE**\n- 결과: 카운트 제외\n\n**최종 결과:**\n- 조건을 만족하는 행은 **EMPNO=200인 행 1개**\n- **답: 1**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q006_table1.json", "rows": 3, "cols": 2}], "image_refs": ["images/2021_round1/6.png"], "meta": {"layout": "single", "anchors": ["6."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "SQL", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q007", "question_text": "다음 Java 프로그램 결과를 쓰시오.", "choices": [], "answer": {"keys": ["3 1 45 50 89"], "raw_text": "3 1 45 50 89"}, "explanation": "이 Java 코드는 **2차원 배열의 구조와 접근 방법**을 이해하는 문제입니다.\n\n**코드 분석:**\n```java int[][]arr = new int[][]{{45,50,75},{89}};\nSystem.out.println(arr[0].length); // 첫 번째 행의 길이 System.out.println(arr[1].length); // 두 번째 행의 길이 System.out.println(arr[0][0]); // 첫 번째 행, 첫 번째 요소 System.out.println(arr[0][1]); // 첫 번째 행, 두 번째 요소 System.out.println(arr[1][0]); // 두 번째 행, 첫 번째 요소\n```\n\n**2차원 배열 구조:**\n- `arr[0] = {45, 50, 75}` → 길이 3\n- `arr[1] = {89}` → 길이 1\n\n**실행 순서:**\n\n1. `arr[0].length`: 첫 번째 행의 길이 → **3**\n2. `arr[1].length`: 두 번째 행의 길이 → **1**\n3. `arr[0][0]`: 첫 번째 행의 첫 번째 요소 → **45**\n4. `arr[0][1]`: 첫 번째 행의 두 번째 요소 → **50**\n5. `arr[1][0]`: 두 번째 행의 첫 번째 요소 → **89**출력:** `3 1 45 50 89`\n\n**핵심 포인트:**\n- Java에서 2차원 배열은 행마다 길이가 다를 수 있습니다(가변 배열).\n- `arr[i].length`는 i번째 행의 길이를 반환합니다.\n- `arr[i][j]`는 i번째 행의 j번째 요소에 접근합니다.\n\n**답:**3 1 45 50 89**", "table_refs": [], "image_refs": ["images/2021_round1/7.png"], "meta": {"layout": "single", "anchors": ["7."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [{"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}, {"language": "java", "code": "public class good{\n\tpublic static void main(String[] args){\n    \tint[][]arr = new int[][]{{45,50,75},{89}};\n        System.out.println(arr[0].length);\n        System.out.println(arr[1].length);\n        System.out.println(arr[0][0]);\n        System.out.println(arr[0][1]);\n        System.out.println(arr[1][0]);", "line_numbers": [1, 8], "file": "data/codes/2021_round1/Q007_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q008", "question_text": "정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["비정규화 (반정규화/역정규화)"], "raw_text": "비정규화 (반정규화/역정규화)"}, "explanation": "이 문제는 **비정규화(반정규화/역정규화)**에 대한 문제입니다.\n\n**비정규화란?**\n- 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법\n- 정규화의 반대 개념으로, 성능을 위해 의도적으로 정규화 원칙을 완화\n\n**비정규화 방법:**\n\n1. **테이블 통합:**\n- 관련된 여러 테이블을 하나로 통합\n- 조인 연산 감소로 성능 향상\n\n2. **테이블 분할:**\n- 하나의 테이블을 여러 테이블로 분할\n- 수직 분할: 컬럼 단위 분할\n- 수평 분할: 행 단위 분할\n\n3. **중복 테이블 추가:**\n- 조회 성능 향상을 위해 중복 테이블 생성\n- 집계 테이블, 통계 테이블 등\n\n4. **중복 속성 추가:**\n- 조인 없이 접근하기 위해 중복 컬럼 추가\n- 계산된 값 저장\n\n**비정규화의 목적:**\n- 조회 성능 향상\n- 개발 및 운영 단순화\n- 응답 시간 단축\n\n**주의사항:**\n- 데이터 일관성 관리 필요\n- 저장 공간 증가\n- 데이터 중복으로 인한 업데이트 비용 증가\n\n**답:**비정규화 (반정규화/역정규화)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["8."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.979449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["ERD", "정규화"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q009", "question_text": "다음은 블랙박스 기법에 대한 예제이다.\n블랙박스 기법 두 가지를 쓰시오.", "choices": [], "answer": {"keys": ["1. 경곗값 분석", "2. 동등분할 테스트"], "raw_text": "1. 경곗값 분석 2. 동등분할 테스트"}, "explanation": "이 문제는 **블랙박스 테스트 기법**을 이해하는 문제입니다.\n\n**블랙박스 테스트란?**\n- 소프트웨어의 내부 구조를 알지 못한 상태에서 입력과 출력만을 확인하는 테스트\n- 시스템의 기능이 요구사항에 맞게 동작하는지 검증\n\n**블랙박스 테스트 종류:**\n\n1. **동치 분할 검사(동등분할 테스트, Equivalence Partitioning):**\n- 입력 데이터를 유사한 도메인별로 그룹핑하여 대표값으로 테스트\n- 동일한 결과를 낼 것으로 예상되는 입력값들을 하나의 그룹으로 묶음\n- 예: 0~100 범위면 0, 50, 100 등으로 테스트\n\n2. **경계값 분석(Boundary Value Analysis):**\n- 입력 조건의 경계값을 테스트 케이스로 선정\n- 경계와 그 근처 값을 테스트\n- 예: 0 <= x <= 10이면 -1, 0, 10, 11을 테스트\n\n3. **원인-효과 그래프 검사(Cause-Effect Graphing):**\n- 입력 조건과 출력 결과 간의 인과관계를 그래프로 표현하여 테스트 케이스 생성\n\n4. **오류 예측 검사(Error Guessing):**\n- 과거 경험이나 직관으로 오류를 예측하여 테스트\n\n5. **비교 검사(Comparison Testing):**\n- 여러 버전의 프로그램에 동일한 입력을 제공하여 결과 비교\n\n**문제에서 요구하는 기법:**\n- 블랙박스 기법 두 가지: **경계값 분석**, **동등분할 테스트**답:** 1. 경계값 분석, 2. 동등분할 테스트", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["9."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": ["블랙박스"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q001", "question_text": "0 <= x <= 10이면 -1 0 10 11 검사", "choices": [], "answer": {"keys": ["경계값 분석"], "raw_text": "경계값 분석"}, "explanation": "이 문제는 **경계값 분석(Boundary Value Analysis)** 테스트 기법을 설명하는 문제입니다.\n\n**경계값 분석이란?**\n- 블랙박스 테스트 기법 중 하나\n- 입력 조건의 **경계값과 그 근처 값**을 테스트 케이스로 선정하는 기법\n- 경계에서 오류가 발생할 가능성이 높기 때문에 경계값을 집중적으로 테스트\n\n**문제 분석:**\n- 입력 조건: `0 <= x <= 10`\n- 경계값: 0 (하한 경계), 10 (상한 경계)\n- 경계 근처 값: -1 (하한 경계 바로 아래), 11 (상한 경계 바로 위)\n\n**테스트 케이스:**\n- **-1**: 경계값(0) 바로 아래, 무효값 (경계 오류 검사)\n- **0**: 하한 경계값, 유효값 (경계 검사)\n- **10**: 상한 경계값, 유효값 (경계 검사)\n- **11**: 경계값(10) 바로 위, 무효값 (경계 오류 검사)\n\n**경계값 분석의 원리:**\n- 경계값: 유효 범위의 최소값과 최대값 (0, 10)\n- 경계 바로 밖: 무효 범위의 값 (-1, 11)\n- 경계에서 오류가 발생할 가능성이 높으므로 이러한 값들을 반드시 테스트\n\n**일반적인 경계값 분석 규칙:**\n- 입력 범위가 `a <= x <= b`일 때:\n  - 경계값: `a`, `b` (유효 경계)\n  - 경계 바로 밖: `a-1`, `b+1` (무효 경계)\n  - 경계 바로 안: `a+1`, `b-1` (유효 내부)\n\n**답:** **경계값 분석**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["1."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "기타", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q002", "question_text": "입력 데이터의 영역을 유사한 도메인별로 유횻값 / 무횻값을 그룹핑하여 나누어서 검사", "choices": [], "answer": {"keys": ["동등분할 테스트"], "raw_text": "동등분할 테스트"}, "explanation": "이 문제는 **동등분할 테스트(Equivalence Partitioning)** 블랙박스 테스트 기법을 설명하는 문제입니다.\n\n**동등분할 테스트란?**\n- **입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 나누어서 검사**하는 테스트 기법\n- 블랙박스 테스트 기법 중 하나\n- 동일한 결과를 낼 것으로 예상되는 입력값들을 하나의 그룹(동등 분할)으로 묶어서 대표값으로 테스트\n\n**동등분할의 원리:**\n1. **입력 도메인 분할:**\n   - 입력 데이터를 유사한 도메인별로 그룹핑\n   - 각 그룹은 동일한 동작을 할 것으로 예상\n\n2. **유효값/무효값 구분:**\n   - **유효값**: 정상적인 입력 범위에 속하는 값들\n   - **무효값**: 정상적인 입력 범위를 벗어난 값들\n\n3. **대표값 테스트:**\n   - 각 동등 분할에서 대표값 하나만 선택하여 테스트\n   - 동일한 그룹 내의 다른 값들은 같은 결과를 낼 것으로 가정\n\n**예시:**\n- 입력 조건: `0 <= 나이 <= 100`\n- **유효 분할**: 0~100 사이의 값 (예: 25, 50, 75)\n- **무효 분할**: 0 미만 (예: -5), 100 초과 (예: 150)\n- 각 분할에서 대표값 하나씩만 테스트 (예: 50, -5, 150)\n\n**동등분할 테스트의 장점:**\n- 테스트 케이스 수를 크게 줄일 수 있음\n- 효율적인 테스트 수행 가능\n- 입력 공간을 체계적으로 분할하여 커버리지 향상\n\n**경계값 분석과의 차이:**\n| 구분 | 동등분할 테스트 | 경계값 분석 |\n|------|----------------|-----------|\n| **초점** | 입력 도메인 분할 | 경계값 집중 |\n| **방법** | 그룹별 대표값 | 경계값과 근처값 |\n| **예시** | 0~100 범위면 25, 50, 75 테스트 | 0~100 범위면 -1, 0, 100, 101 테스트 |\n\n**답:** **동등분할 테스트**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["2."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["데이터베이스"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q010", "question_text": "다음은 테스트 종류에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n\n- (2) 은/는 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n\n[보기]\n\n: 시스템 테스트 / 인수 테스트 / 알파 테스트 / 단위 테스트 / 통합 테스트 / 회귀 테스트", "choices": [], "answer": {"keys": ["1. 단위 테스트", "2. 통합 테스트"], "raw_text": "1. 단위 테스트 2. 통합 테스트"}, "explanation": "이 문제는 **테스트 종류**를 이해하는 문제입니다.\n\n**각 테스트 레벨의 정의:**\n\n1. **단위 테스트(Unit Test):**\n- 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인\n- 가장 작은 단위(함수, 메서드)를 독립적으로 테스트\n- 화이트박스 테스트 기법 사용\n- 개발자가 수행\n\n2. **통합 테스트(Integration Test):**\n- 인터페이스 간 시스템이 정상적으로 실행되는지 확인\n- 여러 모듈을 결합하여 테스트\n- 모듈 간 인터페이스와 상호작용 검증\n\n**다른 테스트 레벨:**\n\n3. **시스템 테스트(System Test):**\n- 구현된 시스템이 정해진 요건에 적합한지 여부를 평가\n- 실제 운용과 같은 환경에서 시스템 전체에 대해 수행\n- 기능적 요구사항과 비기능적 요구사항 검증\n\n4. **인수 테스트(Acceptance Test):**\n- 사용자나 고객이 수행하는 최종 테스트\n- 시스템이 사용자의 요구사항을 만족하는지 확인\n\n**테스트 순서:**\n단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트\n\n**답:**\n- (1) **단위 테스트**: 개별 모듈 확인\n- (2) **통합 테스트**: 인터페이스 간 시스템 확인", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["10."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q011", "question_text": "다음은 빈칸에 들어갈 알맞은 용어를 쓰시오.\n\n- IPv6는 (1.)  비트 길이를 가진다.\n\n- IPv4는 길이 32bit이며, (2.) 비트씩 네 부분으로 나눈다.", "choices": [], "answer": {"keys": ["1. 128", "2. 8"], "raw_text": "1. 128 2. 8"}, "explanation": "이 문제는 **IPv6와 IPv4의 주소 체계**를 이해하는 문제입니다.\n\n**IPv6 주소:**\n- **128비트 길이**를 가집니다.\n- IPv4의 주소 고갈 문제를 해결하기 위해 개발\n- 16진수로 표현하며 8그룹으로 나눔 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)\n\n**IPv4 주소:**\n- **32비트 길이**를 가집니다.\n- **8비트씩 네 부분**으로 나누어 표현\n- 각 부분을 10진수로 표현 (예: 192.168.0.1)\n- 총 32비트 = 8비트 × 4개 부분\n\n**비교:**\n| 항목 | IPv4 | IPv6 |\n|------|------|------|\n| 주소 길이 | 32비트 | 128비트 |\n| 표현 방식 | 10진수, 4개 부분 | 16진수, 8개 부분 |\n| 예시 | 192.168.0.1 | 2001:0db8::1 |\n\n**답:**\n- (1) **128** (IPv6는 128비트)\n- (2) **8** (IPv4는 8비트씩 네 부분)", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["11."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "네트워크", "secondary_categories": [], "tags": ["IP"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q012", "question_text": "공유메모리, 소켓, 세마포어, 메세지 큐 등 프로세스 간 통신하는 기술을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["IPC (Inter Process Communication)"], "raw_text": "IPC (Inter Process Communication)"}, "explanation": "이 문제는 **IPC (Inter Process Communication, 프로세스 간 통신)**에 대한 이해를 묻는 문제입니다.\n\n**IPC란?**\n- **Inter Process Communication**의 약자\n- **프로세스 간 통신**을 위한 기술들의 총칭\n- 운영체제에서 서로 다른 프로세스가 데이터를 주고받을 수 있도록 하는 메커니즘\n\n**IPC가 필요한 이유:**\n- 각 프로세스는 **독립적인 메모리 공간**을 가짐\n- 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없음\n- 따라서 프로세스 간 데이터 교환을 위한 특별한 메커니즘이 필요\n\n**문제에서 언급한 IPC의 종류:**\n\n**1. 공유 메모리 (Shared Memory):**\n- 여러 프로세스가 **같은 물리적 메모리 영역을 공유**하는 방식\n- 특징:\n  - 가장 빠른 IPC 방식 (메모리 직접 접근)\n  - 데이터 복사 없이 직접 읽기/쓰기 가능\n  - 동기화 메커니즘 필요 (세마포어, 뮤텍스 등으로 동시 접근 제어)\n- 예시: 두 프로세스가 공유 메모리 영역에 데이터를 읽고 쓰기\n\n**2. 소켓 (Socket):**\n- **네트워크를 통한 프로세스 간 통신** 방식\n- 특징:\n  - 로컬 프로세스 간 통신과 원격 프로세스 간 통신 모두 가능\n  - TCP/UDP 프로토콜 사용\n  - 클라이언트-서버 모델에서 주로 사용\n- 예시: 웹 브라우저와 웹 서버 간 통신\n\n**3. 세마포어 (Semaphore):**\n- **공유 자원에 대한 접근을 제어하는 동기화 메커니즘**\n- 특징:\n  - 정수값(카운터)을 사용하여 사용 가능한 자원의 개수 표현\n  - P 연산 (wait, 대기): 자원을 사용하려고 시도\n  - V 연산 (signal, 신호): 자원 사용 후 해제\n  - 상호 배제(Mutual Exclusion) 제공\n- 예시: 여러 프로세스가 프린터를 공유할 때 순서 제어\n\n**4. 메시지 큐 (Message Queue):**\n- 프로세스 간 **메시지를 큐(대기열) 형태로 전송**하는 방식\n- 특징:\n  - 비동기 통신 지원 (송신자와 수신자가 동시에 실행 중이지 않아도 됨)\n  - 시스템 커널이 관리하는 큐를 통해 메시지 전달\n  - 메시지에 우선순위 부여 가능\n- 예시: 프로세스 A가 메시지를 큐에 보내고, 프로세스 B가 나중에 읽기\n\n**IPC 방법 비교:**\n| 방법 | 통신 방식 | 속도 | 동기화 |\n|------|----------|------|--------|\n| 공유 메모리 | 메모리 직접 접근 | 매우 빠름 | 필요 (별도 메커니즘) |\n| 소켓 | 네트워크/파이프 | 느림 | 자동 (연결 기반) |\n| 세마포어 | 동기화 메커니즘 | - | 제공 |\n| 메시지 큐 | 큐를 통한 전달 | 중간 | 자동 (큐 기반) |\n\n**답:** **IPC (Inter Process Communication)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["12."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "운영체제", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q013", "question_text": "시스템 통합에 사용되는 솔루션으로 구축 유형에는 Point to Point, Hub & Spoke, Message Bus가 있다. 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 , 통합이 가능하도록 해주는 솔루션을 무엇이라고 하는지 쓰시오.", "choices": [], "answer": {"keys": ["EAI (Enterprise Application Integration)"], "raw_text": "EAI (Enterprise Application Integration)"}, "explanation": "이 문제는 **EAI (Enterprise Application Integration, 기업 애플리케이션 통합)**에 대한 이해를 묻는 문제입니다.\n\n**EAI란?**\n- **Enterprise Application Integration**의 약자\n- **기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합**이 가능하도록 해주는 솔루션\n- 기업 내 다양한 시스템(ERP, CRM, DBMS 등)을 연결하여 데이터와 프로세스를 통합하는 기술\n\n**EAI의 목적:**\n- 이기종 시스템 간의 정보 교환 및 연계\n- 데이터 일관성 유지\n- 비즈니스 프로세스 통합\n- 시스템 간 상호 운용성 향상\n\n**문제에서 언급한 EAI 구축 유형:**\n\n1. **Point to Point (포인트 투 포인트):**\n- 가장 기초적인 애플리케이션 통합 방법\n- 애플리케이션 간 **1:1 직접 연결** 방식\n- 단순하고 직접적이지만, 시스템이 많아질수록 연결 복잡도가 증가\n- 예: 애플리케이션 A ↔ 애플리케이션 B 직접 연결\n\n2. **Hub & Spoke (허브 앤 스포크):**\n- **단일한 접점의 허브 시스템**을 통하여 데이터를 전송하는 중앙 집중적 방식\n- 모든 애플리케이션이 중앙 허브를 통해 통신\n- 허브가 모든 연결을 관리하므로 중앙 집중적 관리 가능\n- 단점: 허브에 장애가 발생하면 전체 시스템 영향\n- 예: 허브 ← 애플리케이션 A, B, C, D (스포크들)\n\n3. **Message Bus (메시지 버스):**\n- **애플리케이션 사이 미들웨어를 두어** 연계하는 통합 방식\n- 공통 버스(버스 아키텍처)를 통해 메시지 기반 통신\n- 느슨한 결합(Loosely Coupled) 방식\n- 애플리케이션이 독립적으로 운영 가능\n- 예: 애플리케이션 A, B, C, D ↔ 메시지 버스 ↔ 서로 통신\n\n4. **하이브리드 (Hybrid):**\n- 여러 방식을 조합한 형태\n- 그룹 내에서는 허브 앤 스포크 방식, 그룹 간에는 메시지 버스 방식 사용\n- 유연성과 확장성 제공\n\n**비교 요약:**\n| 구축 유형 | 특징 | 장점 | 단점 |\n|----------|------|------|------|\n| Point to Point | 1:1 직접 연결 | 단순, 빠름 | 복잡도 증가 |\n| Hub & Spoke | 중앙 허브 관리 | 중앙 집중 관리 | 허브 장애 시 전체 영향 |\n| Message Bus | 미들웨어 기반 | 느슨한 결합, 확장성 | 초기 구축 복잡 |\n\n**답:** **EAI (Enterprise Application Integration)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["13."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["포인터"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q014", "question_text": "주어진 테이블의 Cardinality / Degree를 구하시오.", "choices": [], "answer": {"keys": ["Cardinality : 5", "Degree : 4"], "raw_text": "Cardinality : 5 Degree : 4"}, "explanation": "이 문제는 데이터베이스의 **Cardinality와 Degree**를 구하는 문제입니다.\n\n**Cardinality (카디널리티):**\n- 릴레이션(테이블)에서 **튜플(행)의 개수**\n- 데이터의 행 수\n- 예: 테이블에 5개의 행이 있으면 Cardinality = 5\n\n**Degree (차수):**\n- 릴레이션(테이블)에서 **속성(컬럼)의 개수**\n- 테이블의 컬럼 수\n- 예: 테이블에 4개의 컬럼이 있으면 Degree = 4\n\n**문제에서 요구하는 답:**\n주어진 테이블을 확인하면:\n- 행(Row)의 개수: 5개 → **Cardinality = 5**\n- 컬럼(Column)의 개수: 4개 → **Degree = 4**기억하기:**\n- Cardinality = 데이터 행 수 (카운트)\n- Degree = 속성 컬럼 수 (도메인)\n\n**답:**\n- **Cardinality : 5**\n- **Degree : 4**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q014_table1.json", "rows": 5, "cols": 4}], "image_refs": ["images/2021_round1/14.png"], "meta": {"layout": "single", "anchors": ["14."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": [], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q015", "question_text": "다음은 C언어 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["Lee 38"], "raw_text": "Lee 38"}, "explanation": "이 C언어 코드는 **구조체 배열과 포인터**를 이해하는 문제입니다.\n\n**코드 분석:**\n```c struct good {\nchar name[10];\nint age;\n};\nvoid main(){\nstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\nstruct good *p;\np = s;\np++;\nprintf(\"%s\\n\", p->name);\nprintf(\"%d\\n\", p->age);\n}\n```\n\n**실행 과정:**\n\n1. **구조체 배열 초기화:**\n- `s[0] = {\"Kim\", 28}`\n- `s[1] = {\"Lee\", 38}`\n- `s[2] = {\"Seo\", 50}`\n- `s[3] = {\"Park\", 35}`\n\n2. **포인터 설정:**\n- `p = s` → `p`는 배열의 첫 번째 요소(`s[0]`)를 가리킴\n\n3. **포인터 증가:**\n- `p++` → 포인터가 다음 구조체를 가리킴 (`s[1]`)\n- 구조체 포인터는 구조체 크기만큼 이동\n\n4. **출력:**\n- `p->name`: `s[1].name` = **\"Lee\"**\n- `p->age`: `s[1].age` = **38**핵심 포인트:**\n- 구조체 포인터의 `++` 연산은 구조체 크기만큼 증가합니다.\n- `p->` 연산자는 포인터가 가리키는 구조체의 멤버에 접근합니다.\n\n**답:**Lee 38**", "table_refs": [], "image_refs": ["images/2021_round1/15.png"], "meta": {"layout": "single", "anchors": ["15."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.980449"}, "code_blocks": [{"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}, {"language": "c", "code": "#include <stdio.h>\nstruct good {\n\tchar name[10];\n    int age;\n };\n void main(){\n \tstruct good s[] = {\"Kim\",28,\"Lee\",38,\"Seo\",50,\"Park\",35};\n    struct good *p;\n    p = s;\n    p++;\n    printf(\"%s\\n\", p-> name);\n    printf(\"%d\\n\", p-> age);", "line_numbers": [1, 12], "file": "data/codes/2021_round1/Q015_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["c"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q016", "question_text": "데이터 모델 구성요소 3가지를 쓰시오.\n\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.\n\n- 개체 데이터 모델에서는 (1.) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 (2.) 을/를 어떻게 나타낼 것인지 표현한다.\n\n- (3) 은/는 데이터 무결성 유지를 위한 db의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.", "choices": [], "answer": {"keys": ["1. 연산", "2. 구조", "3. 제약조건"], "raw_text": "1. 연산 2. 구조 3. 제약조건"}, "explanation": "데이터 모델은 데이터베이스 설계의 기초가 되는 개념적 틀입니다. 데이터 모델의 구성요소는 다음과 같습니다.\n\n**데이터 모델 구성요소 3가지:**\n\n1. **연산(Operation):**\n- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세\n- 데이터베이스를 조작하는 기본 도구\n- 예: SELECT, INSERT, UPDATE, DELETE 등의 연산\n\n2. **구조(Structure):**\n- 개체 데이터 모델에서는 연산을 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타냄\n- 논리 데이터 모델에서는 구조를 어떻게 나타낼 것인지 표현\n- 데이터의 논리적 구조와 물리적 구조를 정의\n- 예: 릴레이션 구조, 스키마 구조 등\n\n3. **제약조건(Constraint):**\n- 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법\n- 릴레이션의 특정 칼럼에 설정하는 제약\n- 개체 무결성: 기본 키가 NULL이 될 수 없고 중복될 수 없음\n- 참조 무결성: 외래 키가 참조하는 기본 키 값이 반드시 존재해야 함\n\n**데이터 모델의 역할:**\n- 현실 세계의 정보를 데이터베이스에 표현하기 위한 구조와 규칙 제공\n- 데이터의 일관성과 무결성 보장\n\n**답:**\n- (1) **연산**\n- (2) **구조**\n- (3) **제약조건**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["16."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "데이터베이스", "secondary_categories": [], "tags": ["무결성"], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q017", "question_text": "다음은 Java 프로그램이다.\n실행 결과를 쓰시오.", "choices": [], "answer": {"keys": ["15"], "raw_text": "15"}, "explanation": "이 Java 코드는 **반복문을 이용한 누적 합계**를 계산하는 문제입니다.\n\n**코드 분석:**\n```java int i, j;\nfor(j=0, i=0; i<=5; i++){\nj += i;\nSystem.out.print(i);\nif(i==5){\nSystem.out.print(\"=\");\nSystem.out.print(j);\n}else{\nSystem.out.print(\"+\");\n}\n}\n```\n\n**실행 과정:**\n\n1. **초기화:**\n- `i = 0`, `j = 0`\n\n2. **반복문 실행 (i=0부터 i=5까지):**\n\n| 반복 | i 값 | j 값 | j += i 후 | 출력 |\n|------|------|------|----------|------|\n| 초기 | 0 | 0 | - | - |\n| 1회 | 0 | 0 | j = 0 + 0 = 0 | `0+` |\n| 2회 | 1 | 0 | j = 0 + 1 = 1 | `1+` |\n| 3회 | 2 | 1 | j = 1 + 2 = 3 | `2+` |\n| 4회 | 3 | 3 | j = 3 + 3 = 6 | `3+` |\n| 5회 | 4 | 6 | j = 6 + 4 = 10 | `4+` |\n| 6회 | 5 | 10 | j = 10 + 5 = 15 | `5=15` |\n\n3. **최종 출력:**\n- `0+1+2+3+4+5=15`\n- 하지만 문제에서 요구하는 것은 숫자만이므로: **15**핵심 포인트:**\n- `j += i`는 `j = j + i`와 같습니다 (누적 합계).\n- 반복문이 끝날 때 `j`는 0부터 5까지의 합인 15가 됩니다.\n\n**답:**15**", "table_refs": [], "image_refs": ["images/2021_round1/17.png"], "meta": {"layout": "single", "anchors": ["17."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:24:50.863971", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [{"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}, {"language": "java", "code": "public class good {\n\tpublic static void main(String[] args){\n    int i, j;\n    for(j=0, i=0; i<=5; i++){\n    j+=i;\n    System.out.print(i);\n    if(i==5){\n    System.out.print(\"=\");\n    System.out.print(j);\n   }else{\n   \tSystem.out.print(\"+\");\n\t}\n   }\n  }\n }", "line_numbers": [1, 15], "file": "data/codes/2021_round1/Q017_code.txt"}], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["java"], "difficulty": "보통", "estimated_time": 5}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q018", "question_text": "시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법, 어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식은 ?", "choices": [], "answer": {"keys": ["임의적 접근 통제 (DAC)"], "raw_text": "임의적 접근 통제 (DAC)"}, "explanation": "이 문제는 **임의적 접근 통제 (DAC)**에 대한 이해를 묻는 문제입니다.\n\n**접근 통제란?**\n사람이나 프로세스가 시스템이나 파일에 접근 여부를 허가하거나 거부하는 기능을 말합니다. 시스템 보안의 핵심 요소로, 무단 접근을 방지하고 자원을 보호합니다.\n\n**임의적 접근 통제 (DAC - Discretionary Access Control):**\n\n**정의:**\n- **시스템 객체에 대한 접근을 개인 또는 그룹의 식별자에 기반**을 둔 방법\n- **접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용**하는 접근제어 방식\n- 객체의 소유자(Owner)가 자신의 판단으로 접근 권한을 결정\n\n**특징:**\n1. **소유자 중심**: 객체의 소유자가 접근 권한을 결정\n2. **임의적**: 소유자의 재량에 따라 권한 부여/제거 가능\n3. **신분 기반**: 사용자나 그룹의 신분(식별자)을 기준으로 접근 제어\n4. **유연성**: 필요에 따라 권한을 변경할 수 있음\n\n**예시:**\n- Windows 파일 시스템: 파일 소유자가 \"읽기\", \"쓰기\", \"실행\" 권한을 다른 사용자에게 부여\n- Linux 파일 권한: chmod 명령어로 소유자가 파일 권한 설정\n- 문서 공유 시스템: 문서 작성자가 특정 사용자에게만 접근 권한 부여\n\n**다른 접근 통제 방식과의 비교:**\n\n1. **MAC (Mandatory Access Control) - 강제적 접근 통제:**\n- 시스템 정책에 따라 접근 권한이 강제적으로 결정됨\n- 소유자가 임의로 변경 불가\n- 보안 등급 기반 (예: 군사 시스템)\n\n2. **RBAC (Role-Based Access Control) - 역할 기반 접근 통제:**\n- 역할(직책, 부서 등)에 따라 권한 부여\n- 개인 신분이 아닌 역할 기반\n\n**DAC의 장단점:**\n- **장점**: 유연성, 사용자 편의성, 세밀한 권한 제어\n- **단점**: 소유자의 실수로 인한 보안 취약점 가능, 권한 관리 복잡도 증가\n\n**답:** **임의적 접근 통제 (DAC)**", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["18."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "프로그래밍", "secondary_categories": [], "tags": ["객체지향"], "difficulty": "쉬움", "estimated_time": 2}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q019", "question_text": "다음은 결합도에 대한 설명이다.\n빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.\n\n- (1) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n\n- (2) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도\n\n- (3) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\n\n: 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도", "choices": [], "answer": {"keys": ["1. 내용 결합도", "2. 스탬프 결합도", "3. 공통 결합도"], "raw_text": "1. 내용 결합도 2. 스탬프 결합도 3. 공통 결합도"}, "explanation": "이 문제는 **결합도(Coupling)**의 종류를 이해하는 문제입니다.\n\n**결합도란?**\n모듈 간의 상호 의존 정도를 나타내는 개념입니다. 결합도가 낮을수록 모듈 간 독립성이 높아지고, 유지보수성과 재사용성이 향상됩니다.\n\n**문제에서 요구하는 결합도 유형:**\n\n**1. 내용 결합도 (Content Coupling):**\n- **정의**: 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 직접 사용하는 경우의 결합도\n- **특징**:\n  - 한 모듈이 다른 모듈의 내부 구현을 직접 참조\n  - 모듈의 캡슐화를 완전히 위반\n  - 가장 높은 결합도 (가장 나쁜 결합도)\n- **예시**:\n  - 모듈 A가 모듈 B의 전역 변수를 직접 읽기/쓰기\n  - 모듈 A가 모듈 B의 내부 함수를 직접 호출\n- **문제점**: 한 모듈의 변경이 다른 모듈에 직접적인 영향을 미침\n\n**2. 스탬프 결합도 (Stamp Coupling):**\n- **정의**: 모듈 간의 인터페이스로 **배열이나 객체, 구조** 등이 전달되는 경우의 결합도\n- **특징**:\n  - 복합 자료구조(구조체, 배열, 객체)를 파라미터로 전달\n  - 필요한 데이터만 전달하는 것이 아니라 전체 구조를 전달\n  - 자료 결합도보다는 높지만 내용 결합도보다는 낮음\n- **예시**:\n  - 함수 호출 시 전체 구조체를 파라미터로 전달\n  - 배열 전체를 전달 (일부만 필요해도)\n- **개선 방법**: 필요한 필드만 전달하여 자료 결합도로 개선\n\n**3. 공통 결합도 (Common Coupling):**\n- **정의**: 파라미터가 아닌 **모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신**하는 식으로 상호작용하는 경우의 결합도\n- **특징**:\n  - 여러 모듈이 공통 전역 변수나 공유 데이터를 사용\n  - 한 모듈이 전역 변수를 변경하면 다른 모듈에 영향\n  - 데이터 흐름 추적이 어려움\n- **예시**:\n  - 여러 모듈이 공통 전역 변수 `global_data`를 읽고 쓰기\n  - 공유 메모리를 여러 모듈이 접근\n- **문제점**: 어떤 모듈이 전역 변수를 변경했는지 추적 어려움, 버그 발생 시 원인 파악 곤란\n\n**전체 결합도 순위 (낮은 품질 → 좋은 품질 순):**\n1. **내용 결합도** (Content Coupling) - 가장 나쁨\n2. **공통 결합도** (Common Coupling)\n3. **외부 결합도** (External Coupling)\n4. **제어 결합도** (Control Coupling)\n5. **스탬프 결합도** (Stamp Coupling)\n6. **자료 결합도** (Data Coupling) - 가장 좋음\n\n**결합도 개선 원칙:**\n- 가능한 한 자료 결합도를 목표로 설계\n- 모듈 간 데이터 교환은 파라미터를 통해 필요한 최소한의 데이터만 전달\n- 전역 변수 사용 최소화\n- 모듈의 내부 구현을 숨기고 인터페이스를 통해 상호작용\n\n**답:**\n- (1) **내용 결합도**: 다른 모듈 내부 변수/기능 직접 사용\n- (2) **스탬프 결합도**: 배열, 객체, 구조 전달\n- (3) **공통 결합도**: 전역 변수 공유 및 갱신", "table_refs": [], "image_refs": [], "meta": {"layout": "single", "anchors": ["19."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:50:00.000000", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "소프트웨어공학", "secondary_categories": ["프로그래밍"], "tags": [], "difficulty": "보통", "estimated_time": 3}
{"doc_id": "2021_round1", "page_range": [1, 1], "q_no": "Q020", "question_text": "괄호 안에 공통으로 들어갈 공격 기법을 적으시오.\n\n- (      ) 은/는 '세션을 가로채다' 라는 의미로 정상적 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결한다.\n\n- (      ) 은/는 세션 관리 취약점을 이용한 공격 기법이다.", "choices": [], "answer": {"keys": ["세션 하이재킹"], "raw_text": "세션 하이재킹"}, "explanation": "세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.\n\n**세션 하이재킹의 정의:**\n\n1. **기본 의미:**\n- '세션을 가로채다(Hijack)'라는 의미\n- 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법\n\n2. **공격 방식:**\n- 정상적인 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결\n- 세션 관리 취약점을 이용한 공격 기법\n\n**세션 하이재킹의 과정:**\n\n1. **세션 정보 획득:**\n- 네트워크 스니핑을 통해 세션 ID, 쿠키 등의 세션 정보 탈취\n- 또는 XSS 공격을 통해 세션 정보 유출\n\n2. **세션 가로채기:**\n- 획득한 세션 정보를 사용하여 정상 사용자인 것처럼 위장\n- 서버가 공격자를 정상 사용자로 인식\n\n3. **권한 획득:**\n- 정상 사용자의 권한으로 시스템 접근 및 조작\n\n**방어 방법:**\n- HTTPS 사용 (암호화 통신)\n- 세션 ID 암호화\n- 세션 타임아웃 설정\n- IP 주소 검증\n\n**답:**세션 하이재킹**", "table_refs": [{"id": "table1", "json": "data/tables/2021_round1/Q020_table1.json", "rows": 18, "cols": 1}], "image_refs": [], "meta": {"layout": "single", "anchors": ["20."], "page_anchors": [1], "confidence": 1.0, "warnings": [], "source_url": "https://chobopark.tistory.com/191", "crawled_at": "2025-11-02T23:41:32.248037", "last_improved": "2025-11-04T00:20:14.534633", "readability_improved": "2025-11-04T00:27:18.981447"}, "code_blocks": [], "primary_category": "정보보안", "secondary_categories": [], "tags": ["해킹", "세션"], "difficulty": "쉬움", "estimated_time": 2}
