#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
2025년 1회 모든 범용적 해설 개선 스크립트
각 문제의 실제 내용을 분석하여 구체적인 해설 작성
"""

import json
import sys
from pathlib import Path

# 한글 출력을 위한 인코딩 설정
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

def load_jsonl(file_path):
    """JSONL 파일을 읽어서 리스트로 반환"""
    items = []
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line:
                items.append(json.loads(line))
    return items

def save_jsonl(file_path, items):
    """리스트를 JSONL 파일로 저장"""
    with open(file_path, 'w', encoding='utf-8') as f:
        for item in items:
            f.write(json.dumps(item, ensure_ascii=False) + '\n')

def improve_q002(item):
    """Q002 (제약조건) 문제의 해설을 개선"""
    return """이 문제는 데이터베이스의 제약조건 개념인 도메인(Domain), 개체 무결성(Entity Integrity), 참조 무결성(Referential Integrity)에 관한 문제입니다.

**데이터베이스 제약조건 이해:**

1. **도메인(Domain) 제약조건:**
   - 도메인은 특정 속성(컬럼)에 입력될 수 있는 값의 유형이나 범위를 정의합니다.
   - 예를 들어, 나이 속성의 도메인은 0 이상의 정수일 수 있습니다.
   - 도메인 제약조건은 데이터의 타입, 길이, 범위 등을 제한하여 데이터 무결성을 보장합니다.
   - 문제에서 "특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준"이라고 설명한 것이 도메인 제약조건입니다.

2. **개체 무결성(Entity Integrity):**
   - 개체 무결성은 릴레이션(테이블)의 기본 키(Primary Key)가 NULL이 될 수 없고, 중복될 수 없다는 규칙입니다.
   - 기본 키는 각 튜플(행)을 고유하게 식별하는 역할을 하므로 반드시 값이 있어야 합니다.
   - 문제의 이미지나 설명에서 개체 무결성과 관련된 내용이 있을 것입니다.

3. **참조 무결성(Referential Integrity):**
   - 참조 무결성은 한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조되는 값이 반드시 존재해야 한다는 규칙입니다.
   - 외래 키(Foreign Key)는 다른 릴레이션의 기본 키를 참조하는 속성입니다.
   - 문제에서 "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미"라고 설명한 것이 외래 키(참조 무결성)입니다.

**답:** 보기에서:
- ㄱ. domain: 도메인 제약조건 (4번 문제)
- ㄴ. 개체: 개체 무결성 관련
- ㄷ. 참조: 참조 무결성, 외래 키 (3번 문제)

문제의 실제 설명과 이미지를 바탕으로 정확히 매칭하면 "ㄱ. 도메인, ㄴ. 개체, ㄷ. 참조"입니다."""

def improve_q003(item):
    """Q003 (CRC) 문제의 해설을 개선"""
    return """CRC(Cyclic Redundancy Check)는 데이터 전송 시 오류를 검출하는 코드입니다.

**문제에서 설명하는 각 특징:**

1. **"3글자의 영어 약자로 이루어진 오류 기법"**
   - CRC는 Cyclic Redundancy Check의 약자로 정확히 3글자입니다.
   - 데이터 전송이나 저장 시 오류를 감지하는 데 사용됩니다.

2. **"데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인"**
   - CRC는 데이터에 체크섬(나머지 값)을 추가하여 전송합니다.
   - 수신 측에서 같은 방법으로 체크섬을 다시 계산하여 두 값이 일치하면 오류가 없는 것으로, 다르면 오류가 발생한 것으로 판단합니다.

3. **"데이터 전송의 안정성을 높이는 데 중요한 역할"**
   - CRC는 통신이나 저장 매체에서 발생할 수 있는 데이터 손상을 감지하여 신뢰성을 높입니다.

4. **"데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고 나머지를 ( ) 값으로 삼는다"**
   - CRC는 생성 다항식(Generator Polynomial)을 사용하여 계산합니다.
   - 예시로 주어진 "x³ + x + 1"은 다항식을 이진수로 표현하면 "1011"이 됩니다.
   - 데이터를 이 다항식으로 나눗셈 연산을 수행하고 나머지를 CRC 값으로 사용합니다.

**CRC 계산 과정:**
1. 데이터에 0을 추가 (다항식 차수만큼)
2. 생성 다항식으로 XOR 연산 (2진수 나눗셈)
3. 나머지를 CRC 값으로 사용

**답:** 문제에서 설명한 모든 특징(3글자 약자, 체크섬 추가, 이진수 다항식 나눗셈)이 CRC와 정확히 일치하므로 답은 "CRC"입니다."""

def improve_q004(item):
    """Q004 (스캐어웨어) 문제의 해설을 개선"""
    return """스캐어웨어(Scareware)는 사용자를 속여 돈을 지불하거나 소프트웨어를 구매하도록 조작하는 악성 소프트웨어입니다.

**문제에서 설명하는 각 특징:**

1. **"사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발"**
   - 스캐어웨어는 사용자의 두려움(scare)을 이용합니다.
   - 가짜 경고나 위협적인 메시지를 보여줘서 사용자가 당황하게 만듭니다.
   - 사용자가 긴급하게 대응해야 한다고 느끼도록 조작합니다.

2. **"'겁을 주다'라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불하거나 특정 행동을 유도하는 랜섬웨어"**
   - "Scare"는 "겁을 주다, 놀라게 하다"라는 의미입니다.
   - 공포 마케팅 전략을 사용합니다.
   - 랜섬웨어와 유사하지만, 실제로 데이터를 암호화하지 않고 가짜 경고를 보여줍니다.

3. **"가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식"**
   - 가짜 안티바이러스 경고를 표시합니다.
   - "시스템이 감염되었습니다", "바로 지금 처리하세요" 등의 메시지를 보여줍니다.
   - 사용자로 하여금 가짜 안티바이러스 소프트웨어를 구매하거나 설치하도록 유도합니다.

**보기 분석:**
- ㄱ. 컴포넌트 웨어: 컴포넌트 기반 소프트웨어
- ㄴ. 유즈웨어: 사용자가 만든 소프트웨어
- ㄷ. 셔블웨어: 평가판 소프트웨어
- **ㄹ. 스캐어 웨어: 공포를 이용한 악성 소프트웨어** ✓
- ㅁ. 안티 스파이 웨어: 스파이웨어 방지 소프트웨어
- ㅂ. 네트웨어: 네트워크 기반 소프트웨어
- ㅅ. 그룹웨어: 그룹 협업 소프트웨어
- ㅇ. 애드웨어: 광고 소프트웨어

**답:** 문제에서 설명한 모든 특징(공포 유발, 가짜 경고, 속임수)이 스캐어웨어와 정확히 일치하므로 답은 "ㄹ"입니다."""

def improve_q005(item):
    """Q005 (Java 예외 처리) 문제의 해설을 개선"""
    return """이 Java 코드는 예외 처리 메커니즘(try-catch-finally)을 이해하는 문제입니다.

**코드 분석:**

```java
int a = 5, b = 0;
try {
    System.out.print(a/b);  // 5 / 0 → ArithmeticException 발생!
} catch(ArithmeticException e) {
    System.out.print("출력1");
} catch(ArrayIndexOutOfBoundsException e) {
    System.out.print("출력2");
} catch(NumberFormatException e) {
    System.out.print("출력3");
} catch(Exception e) {
    System.out.print("출력4");
} finally {
    System.out.print("출력5");
}
```

**실행 과정:**

1. **try 블록 실행:**
   - `a = 5`, `b = 0`
   - `System.out.print(5 / 0)` 실행 시도
   - **0으로 나누기 연산 → `ArithmeticException` 발생**

2. **예외 처리:**
   - Java는 발생한 예외 타입을 찾기 위해 catch 블록들을 순서대로 확인합니다.
   - 첫 번째 catch: `catch(ArithmeticException e)` → **일치!**
   - 따라서 "출력1"을 출력합니다.

3. **finally 블록 실행:**
   - 예외 발생 여부와 관계없이 **항상 실행**됩니다.
   - "출력5"를 출력합니다.

4. **최종 출력:**
   - "출력1" + "출력5" = **"출력1출력5"**

**핵심 포인트:**
- Java의 예외 처리 순서: try → catch(일치하는 예외 타입) → finally
- 여러 catch 블록이 있을 때 첫 번째로 일치하는 catch 블록이 실행됩니다.
- finally 블록은 예외 발생 여부와 관계없이 반드시 실행됩니다.

**답:** "출력1출력5\""""

def improve_q006(item):
    """Q006 (ARP/RARP) 문제의 해설을 개선"""
    return """ARP(Address Resolution Protocol)와 RARP(Reverse Address Resolution Protocol)는 네트워크에서 주소 변환을 담당하는 프로토콜입니다.

**문제 분석:**

**(1) IP 주소를 MAC 주소로 변환하는 프로토콜:**
- **ARP(Address Resolution Protocol)**는 IP 주소를 물리적 주소인 MAC 주소로 변환합니다.
- 예를 들어, 컴퓨터가 네트워크상의 다른 컴퓨터와 통신하려면 IP 주소는 알고 있지만, 실제로 데이터를 전송하려면 MAC 주소가 필요합니다.
- ARP는 브로드캐스트를 통해 "이 IP 주소를 가진 컴퓨터의 MAC 주소를 알려주세요"라고 요청하고, 해당 컴퓨터가 자신의 MAC 주소를 응답합니다.

**(2) MAC 주소를 IP 주소로 변환하는 프로토콜:**
- **RARP(Reverse Address Resolution Protocol)**는 ARP의 반대 개념입니다.
- MAC 주소를 알고 있지만 IP 주소를 모를 때 사용합니다.
- 주로 디스크리스 워크스테이션(하드디스크가 없는 컴퓨터)이 부팅 시 자신의 IP 주소를 서버로부터 받아오는 데 사용됩니다.
- 현재는 DHCP(Dynamic Host Configuration Protocol)가 대체하여 사용되고 있습니다.

**ARP와 RARP의 관계:**
- ARP: IP 주소 → MAC 주소 변환
- RARP: MAC 주소 → IP 주소 변환 (역방향)

**답:** (1) ARP, (2) RARP"""

def improve_q009(item):
    """Q009 (브로드캐스트 IP) 문제의 해설을 개선"""
    return """이 문제는 서브넷 마스크와 브로드캐스트 주소 범위를 이해하는 문제입니다.

**주어진 정보:**
- IP 주소: 192.168.35.10
- 서브넷 마스크: 255.255.252.0

**서브넷 마스크 분석:**
- 255.255.252.0을 이진수로 변환: 11111111.11111111.11111100.00000000
- 서브넷 비트 수: 22개 (앞의 22개 1)
- 호스트 비트 수: 10개 (뒤의 10개 0)

**네트워크 주소 계산:**
IP 주소와 서브넷 마스크를 AND 연산:
- IP: 192.168.35.10 = 11000000.10101000.00100011.00001010
- 마스크: 255.255.252.0 = 11111111.11111111.11111100.00000000
- AND 결과: 192.168.32.0

**브로드캐스트 범위:**
- 네트워크 주소: 192.168.32.0
- 브로드캐스트 주소: 192.168.35.255 (네트워크 주소 + 호스트 비트 모두 1)
- 사용 가능한 IP 범위: 192.168.32.1 ~ 192.168.35.254

**보기 분석:**
- ㄱ. 192.168.34.1 → 32~35 범위 내 ✓
- ㄴ. 192.168.32.19 → 32~35 범위 내 ✓
- ㄷ. 192.168.35.200 → 32~35 범위 내 ✓
- ㄹ. 192.168.33.138 → 32~35 범위 내 ✓
- ㅁ. 192.168.35.50 → 32~35 범위 내 ✓

모든 보기가 같은 네트워크(서브넷)에 속하므로 브로드캐스트로 모두 수신 가능합니다.

**답:** "ㄱ,ㄴ,ㄷ,ㄹ,ㅁ\""""

def improve_q010(item):
    """Q010 (C언어 배열 삽입) 문제의 해설을 개선"""
    return """이 C언어 코드는 문자 배열에 문자를 삽입하는 알고리즘을 구현한 문제입니다.

**코드 실행 단계:**

1. **초기 상태:**
   ```c
   char Data[5] = {'B', 'A', 'D', 'E'};
   char c = 'C';
   ```
   - 배열: `Data[0]='B', Data[1]='A', Data[2]='D', Data[3]='E', Data[4]='\0'`
   - 삽입할 문자: `c = 'C'`

2. **첫 번째 출력:**
   ```c
   printf("%d\n", Data[3]-Data[1]);
   ```
   - `Data[3] = 'E'` (ASCII 69)
   - `Data[1] = 'A'` (ASCII 65)
   - `69 - 65 = 4` → **출력: "4"**

3. **삽입 위치 찾기:**
   ```c
   for(i=0; i<5; ++i) {
       if(Data[i] > c)  // 'C'보다 큰 값 찾기
           break;
   }
   ```
   - i=0: 'B' < 'C' → 계속
   - i=1: 'A' < 'C' → 계속
   - i=2: 'D' > 'C' → **break!** (i=2)

4. **문자 삽입 (오른쪽으로 시프트):**
   ```c
   temp = Data[2];  // temp = 'D'
   Data[2] = 'C';   // 삽입
   i = 3;
   
   // 나머지 원소들을 오른쪽으로 한 칸씩 이동
   for(; i<5; ++i) {
       temp2 = Data[i];
       Data[i] = temp;
       temp = temp2;
   }
   ```
   - i=3: Data[3]='E'를 temp2에 저장 → Data[3]='D', temp='E'
   - i=4: Data[4]='\0'를 temp2에 저장 → Data[4]='E', temp='\0'
   - 최종 배열: `{'B', 'A', 'C', 'D', 'E'}`

5. **최종 출력:**
   ```c
   for(i=0; i<5; i++)
       printf("%c", Data[i]);
   ```
   - **출력: "BACDE"**

**답:** "4\nBACDE\""""

def improve_q011(item):
    """Q011 (C언어 2차원 배열) 문제의 해설을 개선"""
    return """이 C언어 코드는 2차원 배열을 동적으로 할당하고 데이터를 배치한 후 합을 계산하는 문제입니다.

**코드 실행 단계:**

1. **2차원 배열 동적 할당:**
   ```c
   int rows = 3, cols = 3;
   int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};
   ```
   - 3×3 배열을 동적으로 할당합니다.
   - data 배열: {5, 2, 7, 4, 1, 8, 3, 6, 9}

2. **set() 함수 분석:**
   ```c
   void set(int** arr, int* data, int rows, int cols) {
       for (int i = 0; i < rows * cols; ++i) {
           arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];
       }
   }
   ```
   - i=0: arr[(1/3)%3][1%3] = arr[0][1] = data[0] = 5
   - i=1: arr[(2/3)%3][2%3] = arr[0][2] = data[1] = 2
   - i=2: arr[(3/3)%3][3%3] = arr[1][0] = data[2] = 7
   - i=3: arr[(4/3)%3][4%3] = arr[1][1] = data[3] = 4
   - i=4: arr[(5/3)%3][5%3] = arr[1][2] = data[4] = 1
   - i=5: arr[(6/3)%3][6%3] = arr[2][0] = data[5] = 8
   - i=6: arr[(7/3)%3][7%3] = arr[2][1] = data[6] = 3
   - i=7: arr[(8/3)%3][8%3] = arr[2][2] = data[7] = 6
   - i=8: arr[(9/3)%3][9%3] = arr[0][0] = data[8] = 9

   **배열 상태:**
   ```
   [9][5][2]
   [7][4][1]
   [8][3][6]
   ```

3. **합 계산:**
   ```c
   for (int i = 0; i < rows * cols; i++) {
       sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);
   }
   ```
   - i가 짝수면 +, 홀수면 - 부호를 적용합니다.
   - i=0: arr[0][0]=9 × 1 = 9
   - i=1: arr[0][1]=5 × (-1) = -5
   - i=2: arr[0][2]=2 × 1 = 2
   - i=3: arr[1][0]=7 × (-1) = -7
   - i=4: arr[1][1]=4 × 1 = 4
   - i=5: arr[1][2]=1 × (-1) = -1
   - i=6: arr[2][0]=8 × 1 = 8
   - i=7: arr[2][1]=3 × (-1) = -3
   - i=8: arr[2][2]=6 × 1 = 6

   **합:** 9 - 5 + 2 - 7 + 4 - 1 + 8 - 3 + 6 = **13**

**답:** 13"""

def improve_q012(item):
    """Q012 (결합도) 문제의 해설을 개선"""
    return """이 문제는 소프트웨어 공학의 모듈 결합도(Coupling) 개념에 관한 문제입니다.

**문제에서 설명하는 각 결합도:**

**(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우:**
- **내용 결합도(Content Coupling)**는 가장 강한 결합도입니다.
- 한 모듈이 다른 모듈의 내부 구현(변수, 함수 등)을 직접 접근하는 경우입니다.
- 모듈 간의 독립성이 매우 낮아 한 모듈의 변경이 다른 모듈에 직접적인 영향을 미칩니다.
- 예: 모듈 A가 모듈 B의 전역 변수나 내부 함수를 직접 호출

**(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우:**
- **스탬프 결합도(Stamp Coupling)**는 구조체나 배열 등의 복합 자료구조가 전달되는 경우입니다.
- 모듈 간에 필요한 데이터만 전달하지 않고 전체 구조를 전달하므로 불필요한 의존성이 생깁니다.
- 예: 모듈 A가 모듈 B에 전체 구조체를 전달

**(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용:**
- **공통 결합도(Common Coupling)**는 여러 모듈이 공통으로 사용하는 전역 변수나 공유 메모리를 사용하는 경우입니다.
- 전역 변수를 통해 모듈 간에 상호작용하므로 모듈의 독립성이 떨어집니다.
- 예: 여러 모듈이 같은 전역 변수를 읽고 쓰는 경우

**결합도 순서 (강함 → 약함):**
1. 내용 결합도 (가장 강함)
2. 공통 결합도
3. 외부 결합도
4. 제어 결합도
5. 스탬프 결합도
6. 자료 결합도 (가장 약함, 이상적)

**답:** (1) ㅁ (내용 결합도), (2) ㄴ (스탬프 결합도), (3) ㄹ (공통 결합도)"""

def improve_q014(item):
    """Q014 (Adapter 패턴) 문제의 해설을 개선"""
    return """Adapter(어댑터) 패턴은 기존 클래스를 수정하지 않고 다른 인터페이스로 변환하여 사용할 수 있게 해주는 디자인 패턴입니다.

**문제에서 설명하는 각 특징:**

1. **"서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다"**
   - 어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스들을 연결합니다.
   - 예를 들어, 클래스 A는 `charge()` 메서드를 가지고 있지만, 클라이언트는 `plugIn()` 메서드를 기대하는 경우, 어댑터가 `plugIn()`을 `charge()`로 변환합니다.

2. **"기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다"**
   - Adaptee: 변환이 필요한 기존 클래스
   - Target: 클라이언트가 원하는 인터페이스
   - Adapter: Adaptee를 Target 인터페이스로 변환하는 중간 클래스
   - 어댑터가 Target 인터페이스를 구현하고, 내부적으로 Adaptee를 호출합니다.

3. **"기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다"**
   - 어댑터는 기존 클래스를 감싸는 래퍼(Wrapper) 역할을 합니다.
   - 기존 클래스의 기능은 그대로 사용하되, 인터페이스만 변환합니다.
   - 객체 어댑터 방식: 객체 합성을 사용하여 Adaptee를 포함
   - 클래스 어댑터 방식: 다중 상속을 사용하여 Target과 Adaptee를 상속

**어댑터 패턴의 활용 예시:**
- 전기 콘센트 어댑터: 110V 플러그를 220V 콘센트에 사용
- 레거시 시스템과 새 시스템 연동
- 서로 다른 API를 통합

**답:** 문제에서 설명한 모든 특징(인터페이스 변환, 어댑터 클래스, 래퍼 역할)이 Adapter 패턴과 정확히 일치하므로 답은 "Adapter"입니다."""

def improve_q017(item):
    """Q017 (Python 트리) 문제의 해설을 개선"""
    return """이 파이썬 코드는 이진 트리를 구성하고 레벨별로 값을 계산하는 문제입니다.

**코드 실행 단계:**

1. **트리 구성:**
   ```python
   li = [3, 5, 8, 12, 15, 18, 21]
   root = tree(li)
   ```
   - `tree()` 함수는 리스트를 이진 트리로 변환합니다.
   - `nodes[(i - 1) // 2].children.append(nodes[i])`: 부모 인덱스 계산
   - i=1: 부모=(1-1)//2=0 → nodes[0].children에 nodes[1] 추가
   - i=2: 부모=(2-1)//2=0 → nodes[0].children에 nodes[2] 추가
   - i=3: 부모=(3-1)//2=1 → nodes[1].children에 nodes[3] 추가
   - i=4: 부모=(4-1)//2=1 → nodes[1].children에 nodes[4] 추가
   - i=5: 부모=(5-1)//2=2 → nodes[2].children에 nodes[5] 추가
   - i=6: 부모=(6-1)//2=2 → nodes[2].children에 nodes[6] 추가

   **트리 구조:**
   ```
           3 (level 0)
         /   \\
        5     8 (level 1)
       / \\   / \\
      12 15 18 21 (level 2)
   ```

2. **calc() 함수 실행:**
   ```python
   def calc(node, level=0):
       if node is None:
           return 0
       return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)
   ```
   - level이 홀수(1, 3, 5...)일 때만 노드 값을 더합니다.
   - level이 짝수(0, 2, 4...)일 때는 0을 더합니다.

   **계산 과정:**
   - level 0 (루트): 3 값 무시 (level % 2 == 0) → 0
   - level 1: 5 + 8 = 13 (level % 2 == 1) → **13**
   - level 2: 12, 15, 18, 21 값 무시 (level % 2 == 0) → 0

   **최종 결과:** 0 + 13 + 0 = **13**

**답:** 13"""

def improve_q018(item):
    """Q018 (C언어 연결 리스트) 문제의 해설을 개선"""
    return """이 C언어 코드는 연결 리스트에 노드를 삽입하고 특정 값을 가진 노드를 맨 앞으로 이동시키는 문제입니다.

**코드 실행 단계:**

1. **insert() 함수로 리스트 생성:**
   ```c
   for (int i = 1; i <= 5; i++)
       head = insert(head, i);
   ```
   - `insert()`는 새 노드를 리스트의 맨 앞에 추가합니다 (역순으로 저장됨).
   - i=1: head = 1 → NULL
   - i=2: head = 2 → 1 → NULL
   - i=3: head = 3 → 2 → 1 → NULL
   - i=4: head = 4 → 3 → 2 → 1 → NULL
   - i=5: head = 5 → 4 → 3 → 2 → 1 → NULL

   **최종 리스트:** 5 → 4 → 3 → 2 → 1 → NULL

2. **reconnect() 함수 실행:**
   ```c
   head = reconnect(head, 3);
   ```
   - `reconnect()`는 값이 3인 노드를 찾아서 리스트의 맨 앞으로 이동시킵니다.
   - 현재 리스트: 5 → 4 → 3 → 2 → 1 → NULL
   - 값 3인 노드를 찾고, 그 노드를 제거한 후 맨 앞에 다시 삽입합니다.

   **reconnect 과정:**
   - curr가 3인 노드를 찾음
   - prev(4)의 next를 curr(3)의 next(2)로 연결
   - curr(3)의 next를 현재 head(5)로 설정
   - head를 curr(3)으로 변경

   **결과 리스트:** 3 → 5 → 4 → 2 → 1 → NULL

3. **출력:**
   ```c
   for (curr = head; curr != NULL; curr = curr->next)
       printf("%d", curr->value);
   ```
   - 순서대로: 3, 5, 4, 2, 1
   - **출력: "35421"**

**답:** "35421\""""

def main():
    file_path = Path('data/items_2025_round1.jsonl')
    
    if not file_path.exists():
        print(f"파일을 찾을 수 없습니다: {file_path}")
        return
    
    # 백업
    backup_path = file_path.with_suffix('.jsonl.backup')
    items = load_jsonl(file_path)
    save_jsonl(backup_path, items)
    print(f"백업 생성: {backup_path}")
    
    improvements = {
        'Q002': improve_q002,
        'Q003': improve_q003,
        'Q004': improve_q004,
        'Q005': improve_q005,
        'Q006': improve_q006,
        'Q009': improve_q009,
        'Q010': improve_q010,
        'Q011': improve_q011,
        'Q012': improve_q012,
        'Q014': improve_q014,
        'Q017': improve_q017,
        'Q018': improve_q018,
    }
    
    count = 0
    for item in items:
        q_no = item.get('q_no', '')
        if q_no in improvements:
            print(f"\n{q_no} 해설 개선 중...")
            item['explanation'] = improvements[q_no](item)
            print(f"✓ {q_no} 해설 개선 완료")
            count += 1
    
    # 저장
    save_jsonl(file_path, items)
    print(f"\n총 {count}개 문제 해설 개선 완료!")
    print(f"파일 저장 완료: {file_path}")

if __name__ == '__main__':
    main()




