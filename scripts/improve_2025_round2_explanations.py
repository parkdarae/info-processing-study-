#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
2025년 2회 모든 범용적 해설 개선 스크립트
각 문제의 실제 내용을 분석하여 구체적인 해설 작성
"""

import json
import sys
from pathlib import Path

# 한글 출력을 위한 인코딩 설정
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

def load_jsonl(file_path):
    """JSONL 파일을 읽어서 리스트로 반환"""
    items = []
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line:
                items.append(json.loads(line))
    return items

def save_jsonl(file_path, items):
    """리스트를 JSONL 파일로 저장"""
    with open(file_path, 'w', encoding='utf-8') as f:
        for item in items:
            f.write(json.dumps(item, ensure_ascii=False) + '\n')

def improve_q001(item):
    """Q001 (인덱스) 문제의 해설을 개선"""
    return """인덱스(Index)는 데이터베이스의 물리적 저장 구조에서 레코드를 빠르게 검색하기 위한 방법입니다.

**문제에서 설명하는 각 특징:**

1. **"레코드에 접근하는 방법":**
   - 데이터베이스 물리 설계 시 레코드에 접근하는 방법에는 순차 접근 방법, 인덱스 방법, 해싱 방법 등이 있습니다.
   - 인덱스 방법은 이 중 하나로, 빠른 검색을 위해 사용됩니다.

2. **"레코드의 키 값과 포인터를 쌍으로 묶어 저장":**
   - 인덱스는 각 레코드의 키 값(예: 학번, 사원번호 등)과 해당 레코드가 실제로 저장된 주소(포인터)를 쌍으로 저장합니다.
   - 예를 들어, 키 값이 "2024001"이면 해당 레코드가 저장된 메모리 주소를 함께 저장합니다.

3. **"검색 시 키 값을 기준으로 빠르게 탐색":**
   - 순차 접근 방법은 처음부터 끝까지 모든 레코드를 확인해야 하지만, 인덱스를 사용하면 키 값만으로 바로 해당 레코드의 위치를 찾을 수 있습니다.
   - 인덱스는 보통 정렬되어 저장되므로 이진 탐색 등의 효율적인 알고리즘을 사용할 수 있습니다.

4. **"<키 값, 포인터> 쌍으로 구성된 자료 구조":**
   - 인덱스는 각 항목을 <키 값, 포인터> 쌍의 형태로 저장합니다.
   - 이 자료 구조를 통해 키 값만 알면 바로 해당 레코드의 위치를 찾을 수 있습니다.

5. **"해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다":**
   - 인덱스에서 키 값을 찾으면, 그에 대응하는 포인터(주소)를 얻을 수 있습니다.
   - 이 포인터를 사용하여 데이터베이스에서 해당 레코드를 직접 접근할 수 있습니다.

**왜 인덱스인가:**
- 문제에서 설명하는 모든 특징(키 값과 포인터 쌍, 빠른 검색, 직접 접근)이 인덱스의 정의와 정확히 일치합니다.
- 순차 접근 방법은 처음부터 순서대로 찾아가는 방식이고, 해싱 방법은 해시 함수를 사용하는 방식이므로 문제 설명과 일치하지 않습니다.

**답:** 문제에서 설명하는 모든 특징이 인덱스 방법과 정확히 일치하므로 답은 "인덱스"입니다."""

def improve_q004(item):
    """Q004 (SJF, SRT) 문제의 해설을 개선"""
    return """이 문제는 운영체제의 CPU 스케줄링 알고리즘인 SJF(Shortest Job First)와 SRT(Shortest Remaining Time)에 관한 문제입니다.

**문제 분석:**

**(1)에 해당하는 스케줄링 알고리즘:**
- **"CPU burst 시간이 짧은 프로세스를 우선적으로 처리"**: CPU를 사용하는 시간이 짧은 프로세스를 먼저 실행합니다.
- **"Shortest Next CPU Burst라고도 불림"**: 다음에 실행될 CPU burst 시간이 가장 짧은 프로세스를 선택합니다.
- **"선점형 또는 비선점형으로 구현될 수 있다"**: 프로세스를 중간에 중단시킬 수 있는 선점형으로도, 그렇지 않은 비선점형으로도 구현 가능합니다.

이 특징들은 **SJF(Shortest Job First, 최단 작업 우선)**와 정확히 일치합니다.

**(2)에 해당하는 스케줄링 알고리즘:**
- **"위의 스케줄링 방식을 선점형으로 구현한 형태"**: SJF를 선점형으로 구현한 것입니다.
- **"실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU를 선점"**: 현재 실행 중인 프로세스가 5ms가 남았는데, 2ms만 필요한 새로운 프로세스가 도착하면 기존 프로세스를 중단하고 새로운 프로세스를 실행합니다.

이 특징은 **SRT(Shortest Remaining Time, 최단 잔여 시간 우선)**와 정확히 일치합니다.

**SJF와 SRT의 차이:**
- SJF는 비선점형이 기본이지만 선점형으로도 구현 가능합니다.
- SRT는 SJF의 선점형 버전으로, 실행 중인 프로세스의 남은 시간을 고려하여 더 짧은 작업이 도착하면 즉시 선점합니다.

**답:** (1) SJF, (2) SRT"""

def improve_q006(item):
    """Q006 (서브넷 마스크) 문제의 해설을 개선"""
    return """이 문제는 IP 주소와 서브넷 마스크를 사용하여 네트워크 주소와 사용 가능한 호스트 수를 계산하는 문제입니다.

**주어진 정보:**
- 호스트 IP 주소: 223.13.234.132
- 서브넷 마스크: 255.255.255.192

**① 네트워크 주소 계산:**

서브넷 마스크 255.255.255.192를 이진수로 변환하면:
- 255.255.255.192 = 11111111.11111111.11111111.11000000

마지막 옥텟(8비트)에서:
- 192 = 11000000 (2진수)
- 서브넷 비트 수: 2개 (앞의 두 개 1)
- 호스트 비트 수: 6개 (뒤의 여섯 개 0)

네트워크 주소를 계산하려면 IP 주소와 서브넷 마스크를 AND 연산:
- IP: 223.13.234.132 = 11011111.00001101.11101010.10000100
- 마스크: 255.255.255.192 = 11111111.11111111.11111111.11000000
- AND 결과: 223.13.234.128

따라서 네트워크 주소는 223.13.234.**128**입니다.

**② 사용 가능한 호스트 수 계산:**

호스트 비트 수가 6개이므로:
- 사용 가능한 주소: 2^6 = 64개
- 하지만 네트워크 주소와 브로드캐스트 주소는 사용할 수 없으므로:
- 실제 사용 가능한 호스트 수: 64 - 2 = **62개**

**답:** ① 128, ② 62"""

def improve_q007(item):
    """Q007 (Proxy) 문제의 해설을 개선"""
    return """Proxy(프록시) 패턴은 객체지향 디자인 패턴 중 하나로, 실제 객체에 대한 접근을 제어하는 패턴입니다.

**문제에서 설명하는 각 특징:**

1. **"어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용"**
   - 프록시는 실제 객체를 직접 접근하지 않고, 프록시 객체를 통해 간접적으로 접근합니다.
   - 프록시는 실제 객체의 대리인 역할을 하며, 클라이언트는 프록시를 실제 객체처럼 사용합니다.

2. **"실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시킬 수 있다"**
   - 프록시는 실제 객체를 생성하기 전에 필요한 사전 작업(인증, 로깅 등)을 수행할 수 있습니다.
   - 실제 객체는 필요할 때까지 생성하지 않고 지연시키므로(Lazy Loading) 메모리와 자원을 절약할 수 있습니다.
   - 예를 들어, 이미지나 대용량 파일을 실제로 사용할 때까지 로드하지 않아 메모리를 절약합니다.

3. **"실제 객체를 감추어 정보은닉을 강화할 수 있다"**
   - 클라이언트는 실제 객체를 직접 접근하지 않고 프록시를 통해서만 접근하므로, 실제 객체의 내부 구조를 숨길 수 있습니다.
   - 이를 통해 보안을 강화하고, 실제 객체의 구현 세부사항을 감출 수 있습니다.

**프록시 패턴의 활용 예시:**
- 가상 프록시(Virtual Proxy): 무거운 객체를 지연 로딩
- 원격 프록시(Remote Proxy): 네트워크를 통해 원격 객체에 접근
- 보호 프록시(Protection Proxy): 접근 권한 제어

**답:** 문제에서 설명한 모든 특징(접근 제어, 대리 객체, 지연 생성, 정보은닉)이 Proxy 패턴과 정확히 일치하므로 답은 "Proxy"입니다."""

def improve_q008(item):
    """Q008 (AJAX) 문제의 해설을 개선"""
    return """AJAX(Asynchronous JavaScript and XML)는 웹 페이지를 새로고침하지 않고 비동기적으로 데이터를 교환하는 웹 개발 기법입니다.

**문제에서 설명하는 각 특징:**

1. **"웹 페이지 전체를 다시 불러오지 않고 JavaScript와 XML(또는 JSON)을 이용하여 일부 콘텐츠만 비동기적으로 갱신"**
   - 전통적인 웹 페이지는 사용자가 링크를 클릭하면 전체 페이지를 다시 서버에서 가져와서 화면을 다시 그려야 합니다.
   - AJAX를 사용하면 페이지의 일부 영역만 JavaScript를 통해 서버에서 데이터를 가져와서 업데이트할 수 있습니다.
   - 이 과정은 비동기적으로 이루어지므로, 사용자는 페이지를 기다리는 동안 다른 작업을 계속할 수 있습니다.
   - 데이터 형식으로는 XML이나 JSON을 주로 사용합니다.

2. **"HTML만으로는 구현하기 어려운 동적인 기능들을 가능하게 하여 사용자가 웹 페이지와 보다 자유롭게 상호작용할 수 있도록 해주는 웹 개발 기법"**
   - HTML만으로는 정적인 페이지만 만들 수 있습니다.
   - AJAX는 JavaScript, XMLHttpRequest(또는 Fetch API) 등을 활용하여 동적인 상호작용을 가능하게 합니다.
   - 예를 들어, 검색어를 입력하면 자동완성 목록이 나타나거나, 댓글을 작성하면 새로고침 없이 바로 화면에 추가되는 등의 기능이 가능합니다.

**AJAX의 장점:**
- 사용자 경험 향상: 페이지 전체 새로고침 없이 필요한 부분만 업데이트
- 서버 부하 감소: 필요한 데이터만 요청하여 네트워크 트래픽 감소
- 빠른 응답: 비동기 처리를 통해 사용자 인터페이스가 블로킹되지 않음

**답:** 문제에서 설명한 모든 특징(비동기 갱신, JavaScript와 XML/JSON 사용, 동적 기능, 상호작용)이 AJAX와 정확히 일치하므로 답은 "AJAX"입니다."""

def improve_q009(item):
    """Q009 (Java 예외 처리) 문제의 해설을 개선"""
    return """이 Java 코드는 람다 표현식과 예외 처리 메커니즘을 이해하는 문제입니다.

**코드 분석:**

```java
F f = (x) -> {
    if (x > 2) {
        throw new Exception();
    }
    return x * 2;
};
```

1. **첫 번째 `run(f)` 호출:**
   - `f.apply(3)`이 실행됩니다.
   - x = 3이므로 `x > 2` 조건이 참입니다.
   - 따라서 `Exception`이 발생합니다.
   - `run` 메서드의 catch 블록에서 예외를 잡아서 **7을 반환**합니다.
   - 따라서 `run(f) = 7`

2. **두 번째 `run((int n) -> n + 9)` 호출:**
   - 새로운 람다 함수 `(int n) -> n + 9`가 전달됩니다.
   - 이 함수는 예외를 발생시키지 않는 일반적인 함수입니다.
   - `n = 3`이 전달되면 `3 + 9 = 12`를 반환합니다.
   - 따라서 `run((int n) -> n + 9) = 12`

3. **최종 출력:**
   - `run(f) + run((int n) -> n + 9) = 7 + 12 = 19`

**핵심 포인트:**
- 람다 표현식에서 조건에 따라 예외를 발생시킬 수 있습니다.
- `run` 메서드는 try-catch 블록으로 예외를 처리하고, 예외 발생 시 7을 반환합니다.
- 두 개의 서로 다른 람다 함수가 각각 다른 결과를 반환합니다.

**답:** 19"""

def improve_q011(item):
    """Q011 (분기 커버리지) 문제의 해설을 개선"""
    return """분기 커버리지(Branch Coverage)는 모든 분기(조건문의 각 경로)를 최소 한 번씩 실행하는 테스트 커버리지 기준입니다.

**문제 이해:**
제어 흐름 그래프의 모든 분기(조건문의 True/False 경로)를 최소 한 번씩 실행하는 테스트 경로를 찾아야 합니다.

**해결 방법:**
1. 그래프의 각 노드(1, 2, 3, 4, 5, 6, 7)를 식별합니다.
2. 각 분기(조건문의 참/거짓 경로)를 모두 커버하는 경로를 찾습니다.
3. 가능한 모든 분기를 포함하는 테스트 케이스 경로를 작성합니다.

**답:** 1234561, 124567
- 첫 번째 경로(1234561): 노드 1→2→3→4→5→6→1로 돌아가는 경로와 루프를 포함
- 두 번째 경로(124567): 노드 1→2→4→5→6→7 경로를 포함
- 이 두 경로를 통해 그래프의 모든 분기를 커버할 수 있습니다."""

def improve_q012(item):
    """Q012 (Queue 구현) 문제의 해설을 개선"""
    return """이 C언어 코드는 원형 큐(Circular Queue) 자료구조를 구현하고 사용하는 문제입니다.

**코드 실행 단계:**

1. **초기 상태:**
   ```c
   Queue q = {{0}, 0, 0};
   ```
   - 큐 구조체를 초기화: 배열 `a[] = {0, 0, 0}`, `front = 0`, `rear = 0`

2. **`enq(&q, 1)` 실행:**
   - `q->a[0] = 1` → 배열[0]에 1 저장
   - `q->rear = (0 + 1) % 3 = 1` → rear를 1로 이동
   - 상태: `a = {1, 0, 0}`, `front = 0`, `rear = 1`

3. **`enq(&q, 2)` 실행:**
   - `q->a[1] = 2` → 배열[1]에 2 저장
   - `q->rear = (1 + 1) % 3 = 2` → rear를 2로 이동
   - 상태: `a = {1, 2, 0}`, `front = 0`, `rear = 2`

4. **`deq(&q)` 실행:**
   - `val = q->a[0] = 1` → 배열[0]의 값 1을 가져옴
   - `q->front = (0 + 1) % 3 = 1` → front를 1로 이동
   - 상태: `a = {1, 2, 0}`, `front = 1`, `rear = 2`

5. **`enq(&q, 3)` 실행:**
   - `q->a[2] = 3` → 배열[2]에 3 저장
   - `q->rear = (2 + 1) % 3 = 0` → rear를 0으로 이동 (원형 큐 특성)
   - 상태: `a = {1, 2, 3}`, `front = 1`, `rear = 0`

6. **`first = deq(&q)` 실행:**
   - `val = q->a[1] = 2` → front 위치의 값 2를 가져옴
   - `q->front = (1 + 1) % 3 = 2` → front를 2로 이동
   - `first = 2`

7. **`second = deq(&q)` 실행:**
   - `val = q->a[2] = 3` → front 위치의 값 3을 가져옴
   - `q->front = (2 + 1) % 3 = 0` → front를 0으로 이동
   - `second = 3`

**최종 출력:** "2 그리고 3"

**핵심 포인트:**
- 원형 큐는 배열의 마지막 인덱스 다음에 처음 인덱스로 돌아가는 구조입니다.
- `% SIZE` 연산을 통해 원형 구조를 구현합니다.
- front는 데이터를 꺼내는 위치, rear는 데이터를 넣는 위치입니다."""

def improve_q013(item):
    """Q013 (라운드로빈 스케줄링) 문제의 해설을 개선"""
    return """라운드로빈(Round Robin, RR) 스케줄링은 각 프로세스에 동일한 시간 할당량(타임 퀀텀)을 순차적으로 부여하는 CPU 스케줄링 방식입니다.

**주어진 정보:**
- 타임 퀀텀: 4ms
- 컨텍스트 스위칭 시간: 무시
- 프로세스 정보: 표 참조

**라운드로빈 스케줄링 동작 원리:**
1. 각 프로세스는 타임 퀀텀(4ms)만큼 CPU를 할당받습니다.
2. 타임 퀀텀이 지나면 현재 프로세스는 중단되고 다음 프로세스로 전환됩니다.
3. 중단된 프로세스는 대기 큐의 맨 뒤에 추가되어 다시 기회를 얻습니다.
4. 모든 프로세스가 완료될 때까지 반복합니다.

**평균 대기시간 계산:**
각 프로세스가 준비 큐에서 대기한 시간의 총합을 프로세스 수로 나눈 값입니다.

1. 각 프로세스의 대기시간을 계산:
   - 프로세스가 처음 실행되기 전까지의 시간
   - 이후 실행 중단 후 재실행 전까지의 시간들의 합

2. 모든 프로세스의 대기시간을 더한 후 프로세스 수로 나눕니다.

**답:** 문제에서 주어진 프로세스 정보와 타임 퀀텀 4ms를 바탕으로 계산하면 평균 대기시간은 **11.75**입니다."""

def improve_q014(item):
    """Q014 (포인터와 구조체) 문제의 해설을 개선"""
    return """이 C언어 코드는 포인터의 포인터(이중 포인터)와 구조체 배열을 다루는 문제입니다.

**코드 실행 단계:**

1. **초기 상태:**
   ```c
   struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};
   ```
   - 구조체 배열 `a`를 초기화: `a[0] = {1, 2}`, `a[1] = {3, 4}`, `a[2] = {5, 6}`

2. **포인터 설정:**
   ```c
   struct dat* ptr = a;      // ptr은 배열 a의 첫 번째 요소를 가리킴
   struct dat** pptr = &ptr; // pptr은 ptr 변수의 주소를 가리킴 (이중 포인터)
   ```

3. **중요한 연산:**
   ```c
   (*pptr)[1] = (*pptr)[2];
   ```
   - `*pptr`은 `ptr`을 의미합니다 (pptr이 가리키는 값이 ptr)
   - `(*pptr)[1]`은 `ptr[1]` 즉 `a[1]`을 의미합니다
   - `(*pptr)[2]`는 `ptr[2]` 즉 `a[2]`를 의미합니다
   - 따라서 `a[1] = a[2]`가 실행됩니다
   - 결과: `a[1] = {5, 6}` (a[2]의 값이 a[1]에 복사됨)

4. **출력:**
   ```c
   printf("%d 그리고 %d", a[1].x, a[1].y);
   ```
   - `a[1].x = 5`, `a[1].y = 6`
   - 출력: "5 그리고 6"

**핵심 포인트:**
- 이중 포인터 `**pptr`은 포인터를 가리키는 포인터입니다.
- `(*pptr)[1]`은 `ptr[1]`과 동일하며, 이는 `a[1]`을 의미합니다.
- 구조체 배열의 요소는 구조체 전체가 복사됩니다.

**답:** "5 그리고 6\""""

def improve_q016(item):
    """Q016 (연결 리스트) 문제의 해설을 개선"""
    return """이 C언어 코드는 연결 리스트(Linked List)의 포인터 연결을 추적하는 문제입니다.

**코드 실행 단계:**

1. **노드 생성 및 초기화:**
   ```c
   struct node a = {1, NULL};
   struct node b = {2, NULL};
   struct node c = {3, NULL};
   ```
   - 세 개의 노드 생성: `a.p = 1`, `b.p = 2`, `c.p = 3`, 모두 다음 노드 포인터는 NULL

2. **첫 번째 연결:**
   ```c
   a.n = &b;  // a의 다음 노드는 b
   b.n = &c;  // b의 다음 노드는 c
   c.n = NULL;
   ```
   - 연결: a → b → c → NULL

3. **두 번째 연결 (덮어쓰기):**
   ```c
   c.n = &a;  // c의 다음 노드를 a로 변경
   a.n = &b;  // a의 다음 노드는 여전히 b
   b.n = NULL; // b의 다음 노드를 NULL로 변경
   ```
   - 최종 연결: `c → a → b → NULL` (c가 a를 가리키고, a가 b를 가리키고, b는 NULL)

4. **출력:**
   ```c
   struct node* head = &c;  // head는 c를 가리킴
   printf("%d %d %d", head->p, head->n->p, head->n->n->p);
   ```
   - `head->p` = `c.p` = **3**
   - `head->n->p` = `a.p` = **1** (head->n은 a를 가리킴)
   - `head->n->n->p` = `b.p` = **2** (head->n->n은 b를 가리킴)

**최종 출력:** "3 1 2"

**핵심 포인트:**
- 포인터 할당 순서에 따라 연결 리스트의 구조가 달라집니다.
- 마지막에 할당한 값이 이전 값을 덮어씁니다.
- `head` 포인터를 따라가면서 각 노드의 값을 출력합니다."""

def improve_q017(item):
    """Q017 (Python 집합 연산) 문제의 해설을 개선"""
    return """이 파이썬 코드는 딕셔너리, 집합(set) 생성과 연산을 이해하는 문제입니다.

**코드 실행 단계:**

1. **딕셔너리 생성:**
   ```python
   lst = [1, 2, 3]
   dst = {i : i * 2 for i in lst}
   ```
   - 딕셔너리 컴프리헨션: `dst = {1: 2, 2: 4, 3: 6}`
   - 키는 리스트의 각 요소, 값은 그 요소의 2배

2. **집합 생성:**
   ```python
   s = set(dst.values())
   ```
   - 딕셔너리의 값들로 집합 생성: `s = {2, 4, 6}`

3. **리스트 수정:**
   ```python
   lst[0] = 99
   ```
   - `lst = [99, 2, 3]`으로 변경
   - **주의:** 딕셔너리는 이미 생성되었으므로 `dst`는 변경되지 않습니다!
   - `dst`는 여전히 `{1: 2, 2: 4, 3: 6}`입니다.

4. **딕셔너리 값 수정:**
   ```python
   dst[2] = 7
   ```
   - 키 2의 값을 7로 변경: `dst = {1: 2, 2: 7, 3: 6}`

5. **집합에 요소 추가:**
   ```python
   s.add(99)
   ```
   - 집합 s에 99 추가: `s = {2, 4, 6, 99}`

6. **집합 교집합 계산:**
   ```python
   print(len(s & set(dst.values())))
   ```
   - `s = {2, 4, 6, 99}`
   - `set(dst.values()) = {2, 7, 6}` (dst의 현재 값들)
   - 교집합: `{2, 4, 6, 99} & {2, 7, 6} = {2, 6}`
   - 교집합의 길이: **2**

**핵심 포인트:**
- 딕셔너리 컴프리헨션은 생성 시점의 리스트 값으로 딕셔너리를 만듭니다.
- 이후 리스트를 수정해도 이미 생성된 딕셔너리는 영향받지 않습니다.
- 집합의 교집합 연산(`&`)은 두 집합에 공통으로 있는 요소만 반환합니다.

**답:** 2"""

def improve_q018(item):
    """Q018 (연결 리스트 역순 출력) 문제의 해설을 개선"""
    return """이 C언어 코드는 연결 리스트를 역순으로 생성하고 출력하는 문제입니다.

**코드 실행 단계:**

1. **`func("BEST")` 호출:**
   - 문자열 "BEST"를 받아서 연결 리스트를 생성합니다.
   - 연결 리스트는 **역순**으로 구성됩니다 (새 노드가 맨 앞에 추가됨).

   ```c
   while(*s) {  // 문자열의 각 문자를 처리
       n = malloc(sizeof(struct node));
       n->c = *s++;  // 현재 문자를 노드에 저장
       n->p = h;     // 새 노드의 다음 노드를 이전 head로 설정
       h = n;        // head를 새 노드로 변경
   }
   ```

   - 첫 번째 반복: 'B' → head = B 노드
   - 두 번째 반복: 'E' → E 노드가 B 노드 앞에 추가, head = E → B
   - 세 번째 반복: 'S' → S 노드가 E 노드 앞에 추가, head = S → E → B
   - 네 번째 반복: 'T' → T 노드가 S 노드 앞에 추가, head = T → S → E → B

   **최종 연결 리스트:** T → S → E → B → NULL

2. **`main()` 함수에서 출력:**
   ```c
   struct node* n = func("BEST");  // n은 T 노드를 가리킴
   while(n) {
       putchar(n->c);  // 현재 노드의 문자 출력
       struct node* t = n;  // 임시 변수에 현재 노드 저장
       n = n->p;       // 다음 노드로 이동
       free(t);        // 현재 노드 메모리 해제
   }
   ```

   - 첫 번째 반복: `n->c = 'T'` 출력, `n = n->p` → S 노드로 이동
   - 두 번째 반복: `n->c = 'S'` 출력, `n = n->p` → E 노드로 이동
   - 세 번째 반복: `n->c = 'E'` 출력, `n = n->p` → B 노드로 이동
   - 네 번째 반복: `n->c = 'B'` 출력, `n = n->p` → NULL

**최종 출력:** "TSEB"

**핵심 포인트:**
- 연결 리스트에 노드를 추가할 때 새 노드를 head 앞에 추가하면 역순으로 저장됩니다.
- 입력 "BEST"가 역순으로 저장되어 T → S → E → B 순서로 출력됩니다.
- 각 노드를 출력한 후 메모리를 해제하여 메모리 누수를 방지합니다.

**답:** "TSEB\""""

def improve_q019(item):
    """Q019 (SYN Flooding) 문제의 해설을 개선"""
    return """SYN Flooding은 TCP 연결 과정에서 발생하는 서비스 거부 공격(DoS) 기법입니다.

**TCP 3-way-handshake 과정:**
1. 클라이언트가 서버에 **SYN** 패킷 전송
2. 서버가 **SYN-ACK** 패킷으로 응답
3. 클라이언트가 **ACK** 패킷을 전송하여 연결 완료

**SYN Flooding 공격 원리:**

1. **공격자의 행동:**
   - 공격자가 클라이언트 역할로 수많은 **SYN 패킷**을 서버에 전송
   - 하지만 마지막 **ACK 패킷을 고의로 보내지 않음**

2. **서버의 상태:**
   - 서버는 SYN 패킷을 받으면 SYN-ACK 패킷을 전송하고 연결을 위한 리소스를 할당
   - 클라이언트의 ACK 패킷을 기다리는 **SYN_RECEIVED** 상태로 대기
   - 연결 대기 큐에 연결 요청이 계속 쌓임

3. **결과:**
   - 서버의 연결 대기 큐가 가득 차게 됨
   - 정상적인 클라이언트의 접속 요청을 처리할 수 없게 됨
   - 서비스 거부(Denial of Service, DoS) 상태 발생

**문제에서 설명한 특징과 정확히 일치:**
- "클라이언트 역할로 수많은 SYN 패킷 전송" ✓
- "마지막 ACK를 고의로 보내지 않음" ✓
- "서버가 연결 대기 상태를 계속 유지" ✓
- "연결 대기 큐가 가득 차면서 정상적인 접속 요청을 처리하지 못함" ✓
- "서비스 거부 상태 발생" ✓

**답:** 문제에서 설명한 모든 특징이 SYN Flooding 공격과 정확히 일치하므로 답은 "SYN Flooding"입니다."""

def main():
    file_path = Path('data/items_2025_round2.jsonl')
    
    if not file_path.exists():
        print(f"파일을 찾을 수 없습니다: {file_path}")
        return
    
    # 백업
    backup_path = file_path.with_suffix('.jsonl.backup2')
    items = load_jsonl(file_path)
    save_jsonl(backup_path, items)
    print(f"백업 생성: {backup_path}")
    
    improvements = {
        'Q001': improve_q001,
        'Q004': improve_q004,
        'Q006': improve_q006,
        'Q007': improve_q007,
        'Q008': improve_q008,
        'Q009': improve_q009,
        'Q011': improve_q011,
        'Q012': improve_q012,
        'Q013': improve_q013,
        'Q014': improve_q014,
        'Q016': improve_q016,
        'Q017': improve_q017,
        'Q018': improve_q018,
        'Q019': improve_q019,
    }
    
    count = 0
    for item in items:
        q_no = item.get('q_no', '')
        if q_no in improvements:
            print(f"\n{q_no} 해설 개선 중...")
            item['explanation'] = improvements[q_no](item)
            print(f"✓ {q_no} 해설 개선 완료")
            count += 1
    
    # 저장
    save_jsonl(file_path, items)
    print(f"\n총 {count}개 문제 해설 개선 완료!")
    print(f"파일 저장 완료: {file_path}")

if __name__ == '__main__':
    main()

