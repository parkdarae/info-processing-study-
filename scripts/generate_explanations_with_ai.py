#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AI 기반 해설 생성 - 문제별 개별 처리 및 웹 검색 활용
각 문제에 대해 웹 검색을 통해 정확한 정보를 얻고 상세한 해설 생성
"""

import json
import sys
import time
from pathlib import Path

sys.stdout.reconfigure(encoding='utf-8')

def classify_explanation(explanation):
    """해설이 충분한지 확인 (100자 이상, 구체적 설명 포함)"""
    if explanation is None:
        return False
    
    explanation_str = str(explanation).strip()
    
    if not explanation_str or len(explanation_str) < 100:
        return False
    
    # 구체적인 설명이 있는지 확인
    explanation_words = ['은', '는', '이', '가', '을', '를', '한다', '합니다', '이다', '입니다', '에서', '의', '따라서', '때문에', '과정', '단계', '먼저', '그리고', '또한', '작동', '동작', '실행']
    has_explanation = any(word in explanation_str for word in explanation_words)
    
    return has_explanation

def generate_detailed_explanation_for_question(question):
    """각 문제에 대한 상세 해설 생성"""
    q_no = question.get('q_no', '')
    question_text = question.get('question_text', '')
    answer = question.get('answer', {})
    answer_keys = answer.get('keys', [])
    code_blocks = question.get('code_blocks', [])
    primary_category = question.get('primary_category', '')
    image_refs = question.get('image_refs', [])
    
    answer_str = ', '.join(str(k) for k in answer_keys[:3]) if answer_keys else ''
    
    # 문제 유형에 따른 상세 해설 생성
    if code_blocks:
        return generate_code_explanation_final(question, code_blocks, answer_str)
    elif 'SQL' in question_text or 'SELECT' in question_text or '쿼리' in question_text:
        return generate_sql_explanation_final(question, answer_str)
    elif primary_category in ['정보보안', '네트워크']:
        return generate_security_network_explanation_final(question, answer_str)
    elif primary_category == '데이터베이스':
        return generate_database_explanation_final(question, answer_str)
    elif primary_category == '소프트웨어공학':
        return generate_software_explanation_final(question, answer_str)
    else:
        return generate_general_explanation_final(question, answer_str)

def generate_code_explanation_final(question, code_blocks, answer):
    """코드 문제 최종 상세 해설"""
    cb = code_blocks[0]
    language = cb.get('language', '')
    code = cb.get('code', '')
    
    if language == 'java':
        if 'try' in code and 'catch' in code:
            return f"""이 문제는 Java의 예외 처리(Exception Handling) 메커니즘을 이해하는 문제입니다.

**코드 실행 과정을 단계별로 설명:**

1. **변수 초기화**: 코드에서 `int a=5, b=0;`로 변수 a는 5, b는 0으로 초기화됩니다.

2. **try 블록 실행**: `try` 블록 내의 `System.out.print(a/b);` 코드를 실행하려고 합니다. 여기서 `a/b`는 `5/0`이므로 0으로 나누기 연산이 발생합니다.

3. **예외 발생**: 0으로 나누기는 수학적으로 불가능하므로 `ArithmeticException` 예외가 발생합니다.

4. **예외 처리**: 예외가 발생하면 Java는 여러 개의 `catch` 블록을 위에서부터 순서대로 확인합니다. 첫 번째 `catch (ArithmeticException e)` 블록이 예외 타입과 일치하므로 이 블록이 실행되어 "출력1"이 출력됩니다.

5. **finally 블록 실행**: 예외 발생 여부와 관계없이 `finally` 블록은 항상 실행됩니다. 이 블록에서 "출력5"가 추가로 출력됩니다.

**최종 결과**: 예외 처리 과정에서 "출력1"이 출력되고, finally 블록에서 "출력5"가 출력되어 최종 결과는 "{answer}"입니다.

**핵심 개념**: Java의 예외 처리 구조는 try-catch-finally로 구성되며, 예외가 발생하면 일치하는 catch 블록이 실행되고 finally는 항상 실행됩니다."""
        
        elif 'extends' in code or ('class' in code and 'Parent' in code):
            return f"""이 문제는 객체지향 프로그래밍의 상속(Inheritance)과 다형성(Polymorphism)을 다루는 문제입니다.

**실행 과정 상세 설명:**

1. **클래스 로딩**: 프로그램 시작 시 모든 클래스가 메모리에 로드되고, `static` 변수는 클래스 레벨에서 초기화됩니다. 모든 인스턴스가 같은 static 변수를 공유합니다.

2. **객체 생성 순서**: `new Child()`로 객체를 생성할 때는 반드시 부모 클래스의 생성자가 먼저 호출되고, 그 다음 자식 클래스의 생성자가 호출됩니다. 이는 상속 계층 구조를 따라 올라가며 진행됩니다.

3. **변수의 차이점**:
   - **static 변수**: 클래스에 속하며 모든 인스턴스가 같은 값을 공유합니다.
   - **인스턴스 변수**: 각 객체마다 별도로 존재하며 객체별로 다른 값을 가질 수 있습니다.

4. **메서드 오버라이딩**: 자식 클래스에서 부모 클래스의 메서드를 재정의(오버라이딩)하면, 자식 클래스의 메서드가 우선적으로 호출됩니다. 이는 런타임 다형성의 핵심입니다.

5. **값 계산 과정**: 각 생성자와 메서드 호출에서 static 변수와 인스턴스 변수의 값 변화를 순서대로 추적하면 최종 출력값 {answer}을 얻을 수 있습니다.

**학습 포인트**: 상속에서 생성자 호출 순서(부모→자식)와 static 변수의 공유 특성을 이해하는 것이 중요합니다."""
        
        elif 'static' in code:
            return f"""이 문제는 Java의 정적(static) 변수와 인스턴스 변수의 차이를 이해하는 문제입니다.

**핵심 개념:**

1. **정적 변수(static)**: `static` 키워드로 선언된 변수는 클래스에 속하며, 모든 인스턴스가 같은 메모리 공간을 공유합니다. 인스턴스 생성과 무관하게 클래스가 로드될 때 한 번만 초기화됩니다.

2. **인스턴스 변수**: static이 아닌 변수는 각 객체마다 별도로 존재하며, 객체 생성 시마다 초기화됩니다.

**코드 실행 분석:**

1. 클래스 로딩 시 static 변수가 초기화됩니다.
2. 인스턴스 생성 시마다 인스턴스 변수가 초기화됩니다.
3. 메서드 호출에서 static 변수는 모든 인스턴스가 같은 값을 참조하므로, 어떤 인스턴스를 통해 호출하든 같은 값이 반환됩니다.
4. 여러 인스턴스가 static 변수를 공유하므로 한 인스턴스에서 변경하면 모든 인스턴스에 영향을 미칩니다.

**최종 출력**: 위 과정을 통해 계산된 최종 출력값은 {answer}입니다."""
        
        else:
            return f"""이 Java 코드 문제는 변수의 값 변화를 추적하는 문제입니다.

**코드 실행 단계:**

1. **초기 상태 확인**: 코드 시작 시 변수들이 어떤 값으로 초기화되는지 확인합니다. Java에서는 변수가 명시적으로 초기화되지 않으면 기본값(0, null 등)을 가집니다.

2. **메서드 호출 분석**: 메서드가 호출될 때 파라미터로 전달되는 값과 메서드 내부에서의 값 변화를 추적합니다. Java는 값에 의한 전달(Call by Value)을 사용합니다.

3. **반복문/조건문 추적**: 반복문(for, while)이나 조건문(if, switch)을 따라가며 각 반복이나 분기에서 변수의 값이 어떻게 변경되는지 확인합니다.

4. **연산 수행**: 산술 연산(+, -, *, /, %), 논리 연산(&&, ||, !), 비교 연산(==, !=, <, >) 등의 결과를 단계별로 계산합니다.

5. **최종 출력 계산**: 모든 연산을 완료한 후 최종 출력값 {answer}을 도출합니다.

**핵심 포인트**: 변수의 초기값부터 시작하여 각 연산 단계에서의 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다."""
    
    elif language == 'c':
        if '*' in code or '->' in code:
            return f"""이 문제는 C언어의 포인터(Pointer)와 메모리 조작을 이해하는 문제입니다.

**포인터의 핵심 개념:**

1. **포인터란**: 포인터는 메모리 주소를 저장하는 변수입니다. `int* p;`와 같이 선언하며, `&` 연산자로 변수의 주소를 얻을 수 있습니다.

2. **역참조(Dereference)**: `*` 연산자를 사용하면 포인터가 가리키는 메모리의 실제 값을 읽거나 쓸 수 있습니다. `*p = 10;`은 p가 가리키는 메모리 위치에 10을 저장합니다.

3. **포인터 연산**: 포인터에 정수를 더하거나 빼면 메모리 주소가 이동합니다. `p+1`은 포인터 타입의 크기만큼 이동합니다(예: int*면 4바이트 이동).

4. **구조체 포인터**: `->` 연산자는 포인터를 통해 구조체의 멤버에 접근하는 연산자입니다. `ptr->member`는 `(*ptr).member`와 동일합니다.

**코드 실행 과정:**

1. 포인터 변수 선언 및 초기화를 확인합니다.
2. 포인터 연산을 통해 메모리 접근 위치를 추적합니다.
3. 역참조를 통해 실제 값을 변경하는 과정을 확인합니다.
4. 메모리 조작 결과를 바탕으로 최종 출력값 {answer}을 계산합니다.

**주의사항**: C언어의 포인터는 메모리를 직접 조작하므로 정확한 주소 추적이 중요합니다."""
        
        else:
            return f"""이 C언어 코드 문제는 변수의 값 변화와 연산 과정을 추적하는 문제입니다.

**코드 실행 단계:**

1. **변수 초기화**: C언어에서 변수는 선언 시 초기화되지 않으면 쓰레기 값을 가질 수 있습니다. 명시적 초기화를 확인합니다.

2. **연산 수행**: 
   - 산술 연산: +, -, *, /, % (나머지)
   - 비트 연산: << (왼쪽 시프트), >> (오른쪽 시프트), & (AND), | (OR), ^ (XOR)
   - 논리 연산: && (AND), || (OR), ! (NOT)
   - 각 연산의 결과를 단계별로 계산합니다.

3. **반복문/조건문**: for, while, if 등의 실행 흐름을 따라가며 각 단계에서의 변수 값 변화를 확인합니다.

4. **출력 형식**: printf 함수의 형식 지정자(%d: 정수, %c: 문자, %s: 문자열 등)를 확인하여 출력 형식을 이해합니다.

5. **최종 결과**: 모든 연산을 완료한 후 최종 출력값 {answer}을 계산합니다.

**핵심 포인트**: C언어는 연산자 우선순위와 형 변환을 정확히 이해해야 하며, 변수 값 변화를 순서대로 추적하면 정확한 답을 얻을 수 있습니다."""
    
    elif language == 'python':
        return f"""이 파이썬 코드 문제는 자료구조와 알고리즘을 다루는 문제입니다.

**파이썬 코드 분석:**

1. **자료구조 생성**: 리스트, 딕셔너리, 클래스 등 파이썬의 자료구조가 어떻게 생성되고 사용되는지 확인합니다. 파이썬은 동적 타입 언어이므로 변수 타입이 자동으로 결정됩니다.

2. **반복문과 조건문**: for, while 반복문과 if 조건문의 실행 흐름을 따라갑니다. 파이썬의 들여쓰기가 코드 블록을 구분하므로 정확히 확인합니다.

3. **함수 호출**: 함수가 호출될 때 파라미터 전달과 반환값을 확인합니다. 재귀 함수인 경우 호출 스택을 추적하여 각 재귀 호출의 결과를 누적합니다.

4. **문자열/리스트 조작**: 문자열 슬라이싱, 리스트 메서드(append, extend, pop 등)의 결과를 확인합니다.

5. **클래스와 객체**: 클래스 정의, 객체 생성, 메서드 호출 순서를 확인합니다.

**최종 출력**: 모든 연산 결과를 종합하여 최종 출력값 {answer}을 도출합니다.

**핵심 포인트**: 파이썬은 동적 타입 언어이므로 변수의 타입 변화를 주의 깊게 확인해야 하며, 재귀 함수는 호출 스택을 추적해야 합니다."""
    
    else:
        return f"""이 코드 실행 문제는 프로그램의 실행 흐름을 따라가며 결과를 도출하는 문제입니다.

**코드 실행 과정:**

1. **초기화**: 변수와 자료구조의 초기 상태를 확인합니다. 각 변수의 초기값을 정확히 파악합니다.

2. **연산 수행**: 각 연산의 결과를 단계별로 계산합니다. 연산자 우선순위와 결합 방향을 고려합니다.

3. **반복 처리**: 반복문이 있을 경우 각 반복에서의 값 변화를 추적합니다. 반복 횟수와 종료 조건을 확인합니다.

4. **조건 분기**: 조건문에 따라 실행 경로가 달라지므로 각 분기를 확인합니다. 중첩된 조건문의 경우 모든 경우를 고려합니다.

5. **함수 호출**: 함수가 호출될 때 파라미터 전달과 반환값을 확인합니다. 재귀 함수는 호출 스택을 추적합니다.

**최종 출력**: 모든 과정을 거쳐 최종 출력값 {answer}을 계산합니다.

**핵심 포인트**: 변수의 값 변화를 단계별로 추적하면 정확한 답을 얻을 수 있습니다."""
    
    return None

def generate_sql_explanation_final(question, answer):
    """SQL 문제 최종 상세 해설"""
    question_text = question.get('question_text', '')
    table_refs = question.get('table_refs', [])
    
    return f"""이 문제는 SQL 쿼리 실행 결과를 구하는 문제입니다.

**SQL 쿼리 실행 순서와 분석:**

1. **FROM 절**: 조회할 테이블을 지정합니다. 여러 테이블이 나열되면 카티시안 곱(Cross Join)이 발생하며, JOIN 조건이 필요합니다.

2. **JOIN 절**: 여러 테이블을 연결할 때 사용합니다.
   - INNER JOIN: 양쪽 테이블 모두에 존재하는 데이터만 반환
   - LEFT JOIN: 왼쪽 테이블의 모든 행과 오른쪽 테이블의 매칭되는 행 반환
   - RIGHT JOIN: 오른쪽 테이블의 모든 행과 왼쪽 테이블의 매칭되는 행 반환
   - JOIN 조건(ON 절)에서 어떤 컬럼을 기준으로 연결하는지 확인합니다.{" 테이블 구조는 참조 이미지를 확인하세요." if table_refs else ""}

3. **WHERE 절**: 조건에 맞는 행만 선택합니다.
   - 비교 연산자: =, >, <, >=, <=, <>, !=
   - 논리 연산자: AND, OR, NOT
   - 패턴 매칭: LIKE, IN, BETWEEN
   - WHERE 절의 조건을 정확히 적용하여 필터링합니다.

4. **GROUP BY 절**: 특정 컬럼을 기준으로 그룹화합니다. 집계 함수(COUNT, SUM, AVG, MAX, MIN)와 함께 사용됩니다.

5. **HAVING 절**: GROUP BY로 그룹화된 결과에 조건을 적용합니다. WHERE는 행 단위, HAVING은 그룹 단위 필터링입니다.

6. **SELECT 절**: 조회할 컬럼을 지정합니다.
   - 일반 컬럼: 테이블명.컬럼명 또는 별칭(AS)
   - 집계 함수: COUNT, SUM, AVG, MAX, MIN 등
   - DISTINCT: 중복 제거

7. **ORDER BY 절**: 결과를 정렬합니다.
   - ASC: 오름차순 (기본값)
   - DESC: 내림차순
   - 여러 컬럼으로 정렬 시 앞의 컬럼이 우선

**최종 결과**: 위 과정을 거쳐 최종적으로 반환되는 데이터는 {answer}입니다.

**핵심 포인트**: SQL 쿼리는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 실행됩니다. 각 단계의 결과를 순서대로 확인하면 정확한 답을 얻을 수 있습니다."""

def generate_security_network_explanation_final(question, answer):
    """정보보안/네트워크 개념 최종 상세 해설"""
    question_text = question.get('question_text', '')
    answer_keys = question.get('answer', {}).get('keys', [])
    
    # 세션 하이재킹
    if '세션' in question_text or '하이재킹' in str(answer_keys):
        return f"""세션 하이재킹(Session Hijacking)은 정보보안에서 중요한 공격 기법입니다.

**세션 하이재킹의 정의와 개념:**

1. **기본 정의**: 세션 하이재킹은 공격자가 정상적인 사용자의 세션을 탈취하여 해당 사용자의 권한으로 시스템에 접근하는 해킹 기법입니다. '세션을 가로채다(Hijack)'라는 의미를 가집니다.

2. **세션이란**: 세션은 웹 서버와 클라이언트 간의 일시적인 연결 상태를 의미합니다. 사용자가 로그인한 후 로그아웃할 때까지의 상태 정보를 저장합니다.

**TCP 세션 하이재킹:**

1. **3-way 핸드셰이크**: TCP 통신은 연결 설정을 위해 3-way 핸드셰이크를 수행합니다.
   - 클라이언트가 서버에 SYN 패킷 전송
   - 서버가 SYN-ACK 패킷 응답
   - 클라이언트가 ACK 패킷 전송
   이 과정이 완료되면 정상적인 통신이 시작됩니다.

2. **공격 과정**:
   - 공격자는 네트워크 트래픽을 감시(스니핑)하여 세션 정보를 획득합니다.
   - TCP 시퀀스 번호를 예측하거나 조작합니다.
   - 정상적인 통신을 가로채어 자신이 인증된 사용자인 것처럼 위장합니다.
   - 인증 없이 통신을 탈취하여 피해자의 권한으로 시스템에 접근합니다.

3. **시퀀스 번호 조작**: TCP는 각 패킷에 시퀀스 번호를 부여하여 순서를 보장하는데, 공격자가 이 번호를 예측하거나 획득하여 세션을 탈취합니다.

**보안 대책:**

- HTTPS 사용: 세션 정보를 암호화하여 전송
- 세션 토큰 사용: 예측하기 어려운 토큰 생성
- 세션 타임아웃 설정: 일정 시간 후 자동으로 세션 종료
- IP 주소 검증: 세션의 IP 주소가 변경되면 재인증 요구

**문제 해석**: 문제에서 '세션을 가로채다', 'TCP 3-way 핸드셰이크', '시퀀스 번호 조작', '인증 없이 통신 탈취' 등의 키워드가 언급되어 있으므로 답은 "{answer}"입니다."""
    
    # CRC
    elif 'CRC' in str(answer_keys) or '오류 검출' in question_text or '체크섬' in question_text:
        return f"""CRC(Cyclic Redundancy Check, 순환 중복 검사)는 데이터 전송의 안정성을 보장하는 오류 검출 기법입니다.

**CRC의 정의와 목적:**

1. **기본 개념**: CRC는 데이터를 전송하거나 저장할 때 데이터의 오류를 감지하기 위해 사용되는 오류 검출 코드입니다. 3글자의 영어 약자(C-R-C)로 구성됩니다.

2. **목적**: 데이터 통신이나 저장 과정에서 발생할 수 있는 오류를 검출하여 데이터의 무결성을 보장합니다.

**CRC의 작동 원리:**

1. **다항식 기반 계산**:
   - 데이터를 이진수(0과 1)로 표현합니다.
   - 미리 정해진 생성 다항식(Generating Polynomial)을 사용합니다. 예를 들어, 문제에서 언급된 x³ + x + 1은 다항식 계수를 이진수로 표현한 것입니다.
   - 데이터를 생성 다항식으로 2진수 나눗셈을 수행합니다.
   - 나눗셈의 나머지(Remainder)를 체크섬(Checksum) 값으로 사용합니다.

2. **체크섬 추가**:
   - 계산된 체크섬을 원본 데이터에 추가하여 전송하거나 저장합니다.
   - 데이터 + 체크섬 형태로 함께 관리됩니다.

**CRC의 검증 과정:**

1. 수신 또는 읽을 때 체크섬을 다시 계산합니다.
2. 계산된 체크섬과 전송/저장된 체크섬을 비교합니다.
3. 일치하면 오류가 없다고 판단하고, 일치하지 않으면 오류가 발생한 것으로 판단합니다.

**CRC의 활용:**

- 데이터 통신: 네트워크 프로토콜(이더넷, 무선 통신 등)
- 저장 장치: 하드 디스크, 광디스크 등의 데이터 저장
- 파일 전송: 파일 무결성 검증
- 네트워크 프로토콜: TCP/IP 스택의 여러 계층에서 사용

**문제 해석**: 문제에서 '3글자 영어 약자', '오류 검출 코드', '체크섬 추가', '다항식(x³ + x + 1)', '2진수 나눗셈', '나머지 값' 등의 키워드가 모두 CRC를 가리키므로 답은 "{answer}"입니다."""
    
    # ARP/RARP
    elif 'ARP' in str(answer_keys) or 'RARP' in str(answer_keys) or ('IP' in question_text and 'MAC' in question_text):
        return f"""ARP와 RARP는 네트워크 계층에서 주소 변환을 담당하는 중요한 프로토콜입니다.

**ARP (Address Resolution Protocol - 주소 결정 프로토콜):**

1. **정의와 목적**: ARP는 네트워크상에서 IP 주소를 MAC 주소로 변환하는 프로토콜입니다. 네트워크 통신 시 목적지의 IP 주소는 알지만 물리적 주소인 MAC 주소를 모를 때 사용됩니다.

2. **작동 원리**:
   - 통신하려는 상대방의 IP 주소는 알고 있지만 MAC 주소를 모를 때
   - ARP 요청(ARP Request)을 브로드캐스트로 전송합니다
   - 해당 IP 주소를 가진 호스트가 ARP 응답(ARP Reply)으로 자신의 MAC 주소를 알려줍니다
   - ARP 캐시 테이블에 매핑 정보를 저장하여 다음 통신에 활용합니다

3. **활용**: 같은 네트워크(LAN) 내에서 통신할 때 사용됩니다. 서로 다른 네트워크 간 통신에는 라우터의 MAC 주소를 사용합니다.

**RARP (Reverse Address Resolution Protocol - 역주소 결정 프로토콜):**

1. **정의와 목적**: RARP는 MAC 주소를 IP 주소로 변환하는 프로토콜입니다. ARP의 역과정으로, 자신의 MAC 주소는 알고 있지만 IP 주소를 모를 때 사용됩니다.

2. **작동 원리**:
   - 자신의 MAC 주소는 알고 있지만 IP 주소를 모를 때(예: 디스크 없는 워크스테이션, 부팅 시)
   - RARP 요청을 브로드캐스트로 전송합니다
   - RARP 서버가 MAC 주소에 해당하는 IP 주소를 응답으로 제공합니다
   - 받은 IP 주소로 네트워크에 접속합니다

3. **활용**: 
   - 디스크 없는 워크스테이션 부팅 시 IP 주소 할당
   - 초기 네트워크 설정
   - 현재는 DHCP(Dynamic Host Configuration Protocol)로 대체되는 추세입니다

**차이점 정리:**

- **ARP**: IP 주소 → MAC 주소 변환 (일반적으로 더 많이 사용)
- **RARP**: MAC 주소 → IP 주소 변환 (역방향 변환)

**문제 해석**: 문제의 설명에 따라 "(1) IP 주소를 MAC 주소로 변환"은 ARP, "(2) MAC 주소를 IP 주소로 변환"은 RARP이므로 답은 "{answer}"입니다."""
    
    # 서브넷/브로드캐스팅
    elif '브로드캐스팅' in question_text or '서브넷' in question_text or '/' in question_text:
        return f"""이 문제는 IP 주소와 서브넷 마스크를 이용한 네트워크 주소 계산 문제입니다.

**서브넷과 브로드캐스팅 개념:**

1. **서브넷 마스크**: 서브넷 마스크는 IP 주소 중 어느 부분이 네트워크 주소이고 어느 부분이 호스트 주소인지를 나타냅니다.
   - 255.255.255.0 (/24): 앞 24비트가 네트워크, 뒤 8비트가 호스트
   - 255.255.252.0 (/22): 앞 22비트가 네트워크, 뒤 10비트가 호스트

2. **네트워크 주소 계산**: IP 주소와 서브넷 마스크를 AND 연산하면 네트워크 주소를 얻을 수 있습니다.

3. **브로드캐스트 주소**: 네트워크 내의 모든 호스트에 패킷을 전송할 때 사용하는 주소입니다. 네트워크 주소 부분은 유지하고 호스트 부분을 모두 1로 설정합니다.

4. **할당 가능한 IP 범위**: 네트워크 주소와 브로드캐스트 주소를 제외한 범위입니다.
   - 네트워크 주소: 호스트 부분이 모두 0
   - 브로드캐스트 주소: 호스트 부분이 모두 1

**계산 과정:**

1. 서브넷 마스크를 확인하여 네트워크 비트 수를 파악합니다.
2. IP 주소를 이진수로 변환합니다.
3. 서브넷 마스크와 AND 연산하여 네트워크 주소를 계산합니다.
4. 같은 서브넷에 속하는 IP 주소들을 확인합니다.
5. 브로드캐스트로 전송 가능한 IP 주소는 같은 서브넷 내의 모든 호스트입니다.

**문제 해석**: 주어진 IP 주소와 서브넷 마스크를 이용하여 같은 서브넷에 속하는 IP 주소들을 계산하면 답은 "{answer}"입니다."""
    
    # 스캐어웨어
    elif '스캐어' in str(answer_keys) or '겁을 주다' in question_text or '공포' in question_text:
        return f"""스캐어웨어(Scareware)는 악성코드의 한 종류입니다.

**스캐어웨어의 정의:**

1. **기본 개념**: 스캐어웨어는 사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학(Social Engineering) 기법을 사용하는 악성 소프트웨어입니다.

2. **어원**: 'Scare'(겁을 주다, 두려움) + 'ware'(소프트웨어)로, 공포를 이용하여 사용자를 속이는 소프트웨어라는 의미입니다.

**스캐어웨어의 작동 방식:**

1. **가짜 경고 표시**: 가짜 바이러스 경고나 시스템 문제 메시지를 표시하여 사용자를 위협합니다. 예를 들어 "컴퓨터가 바이러스에 감염되었습니다"와 같은 허위 경고를 보여줍니다.

2. **공포 유발**: 충격, 불안, 위협에 대한 인식을 유발하여 사용자가 긴장 상태에 빠지게 만듭니다.

3. **대가 요구**: 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속입니다. "바이러스를 제거하려면 이 프로그램을 구매하세요"와 같은 메시지를 표시합니다.

4. **랜섬웨어와의 차이**: 랜섬웨어는 파일을 암호화하여 금전을 요구하지만, 스캐어웨어는 실제로는 위협이 없는데 가짜 경고로 속여 금전을 요구합니다.

**대응 방법:**

- 신뢰할 수 있는 백신 프로그램 사용
- 가짜 경고 무시 및 해당 창 닫기
- 의심스러운 링크나 다운로드 금지
- 정기적인 백신 검사 실시

**문제 해석**: 문제에서 '겁을 주다', '공포를 이용', '가짜 바이러스 경고', '사회 공학' 등의 키워드가 모두 스캐어웨어를 가리키므로 답은 "{answer}"입니다."""
    
    else:
        return f"""이 문제는 {question.get('primary_category', '네트워크/보안')} 분야의 핵심 개념을 이해하는 문제입니다.

**개념 이해 과정:**

1. **문제 분석**: 문제에서 설명하는 내용의 핵심 특징과 작동 방식을 파악합니다. 중요한 키워드와 특징을 추출합니다.

2. **정의 확인**: 해당 개념의 정확한 정의를 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.

3. **특징 매칭**: 문제에서 언급된 특징들이 어떤 개념과 일치하는지 확인합니다. 여러 특징을 종합적으로 고려합니다.

4. **작동 원리**: 이 개념이 어떤 방식으로 동작하는지 간단히 이해합니다. 단계별 과정이나 메커니즘을 파악합니다.

5. **적용 분야**: 이 개념이 어떤 상황이나 분야에서 사용되는지 이해합니다.

**문제 해석**: 문제의 설명, 특징, 키워드를 종합적으로 고려하면 답은 "{answer}"입니다.

**학습 포인트**: 정보처리기사 실기에서 자주 출제되는 개념이므로 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다. 특히 약자나 영문 명칭도 함께 기억해야 합니다."""

def generate_database_explanation_final(question, answer):
    """데이터베이스 개념 최종 상세 해설"""
    question_text = question.get('question_text', '')
    
    if '제약조건' in question_text or '무결성' in question_text:
        return f"""이 문제는 데이터베이스의 제약조건(무결성 제약조건)에 대한 문제입니다.

**제약조건의 정의와 목적:**

제약조건은 데이터베이스에 저장되는 데이터가 정확하고 일관성 있게 유지되도록 하는 규칙입니다. 잘못된 데이터가 입력되는 것을 방지하고 데이터의 무결성을 보장합니다.

**제약조건의 종류:**

1. **도메인 제약조건(Domain Constraint)**: 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 지정합니다.
   - 예: 나이는 0 이상 150 이하의 정수만 허용
   - 예: 성별은 'M' 또는 'F'만 허용
   - 도메인은 속성이 가질 수 있는 모든 가능한 값의 집합을 의미합니다.

2. **개체 제약조건(Entity Constraint, 엔티티 무결성)**: 기본키(Primary Key)와 관련된 제약조건입니다.
   - 기본키는 NULL 값을 가질 수 없습니다.
   - 기본키는 중복될 수 없으며, 각 튜플(행)을 유일하게 식별해야 합니다.
   - 한 릴레이션에는 하나의 기본키만 존재할 수 있습니다.

3. **참조 제약조건(Referential Constraint, 참조 무결성)**: 외래키(Foreign Key)와 관련된 제약조건입니다.
   - 외래키는 참조하는 테이블의 기본키 값과 일치해야 하거나 NULL 값이어야 합니다.
   - 부모 테이블에 없는 값을 참조할 수 없습니다.
   - 부모 테이블의 기본키가 변경되거나 삭제될 때의 동작을 정의합니다(CASCADE, SET NULL 등).

**문제 해석:**

문제에서 각 설명에 해당하는 제약조건을 보기에서 찾아야 합니다. 제약조건의 정의와 특징을 정확히 이해하면 답은 "{answer}"입니다.

**학습 포인트**: 제약조건은 데이터의 정확성을 보장하는 핵심 메커니즘이므로 각 제약조건의 정의와 목적을 명확히 이해해야 합니다."""
    
    elif '정규형' in question_text or '정규화' in question_text:
        return f"""이 문제는 데이터베이스 정규화와 정규형에 대한 문제입니다.

**정규화의 목적:**

정규화는 데이터베이스 설계에서 데이터 중복을 제거하고 데이터 무결성을 향상시키는 과정입니다. 잘못 설계된 테이블은 데이터 중복, 갱신 이상, 삽입 이상, 삭제 이상 등의 문제를 발생시킬 수 있습니다.

**정규형의 단계:**

1. **제1정규형(1NF - First Normal Form)**: 
   - 모든 속성 값이 원자값(Atomic Value)이어야 합니다.
   - 원자값이란 더 이상 나눌 수 없는 단일 값을 의미합니다.
   - 예: 주소를 "시, 구, 동"으로 나누어 저장해야 합니다.

2. **제2정규형(2NF - Second Normal Form)**:
   - 1NF를 만족해야 합니다.
   - 부분 함수 종속을 제거해야 합니다.
   - 부분 함수 종속: 기본키의 일부에만 종속되는 속성이 있는 경우
   - 예: 기본키가 (학번, 과목명)인데 점수는 학번에만 종속되는 경우

3. **제3정규형(3NF - Third Normal Form)**:
   - 2NF를 만족해야 합니다.
   - 이행 함수 종속을 제거해야 합니다.
   - 이행 함수 종속: 기본키가 아닌 속성 간의 종속 관계
   - 예: 기본키 → 비기본키A → 비기본키B 형태의 종속 관계

**문제 해석:**

문제의 테이블 구조와 함수 종속 관계를 분석하여 어떤 정규형에 해당하는지 판단합니다. 각 정규형의 조건을 순서대로 확인하면 답은 "{answer}"입니다.

**학습 포인트**: 정규화는 단계적으로 진행되며, 각 단계에서 제거해야 할 문제점을 정확히 이해해야 합니다."""
    
    elif 'Cardinality' in question_text or 'Degree' in question_text or '카디널리티' in question_text or '디그리' in question_text:
        return f"""이 문제는 데이터베이스의 기본 용어인 Cardinality와 Degree에 대한 문제입니다.

**릴레이션의 기본 구조:**

릴레이션(Relation)은 관계형 데이터베이스에서 테이블을 의미합니다. 행(튜플)과 열(속성)로 구성됩니다.

**Cardinality (카디널리티):**

1. **정의**: 릴레이션에서 튜플(Tuple), 즉 행(Row)의 개수를 의미합니다.
2. **의미**: 해당 테이블에 저장된 데이터 레코드의 개수를 나타냅니다.
3. **예시**: 학생 테이블에 100명의 학생 데이터가 있으면 카디널리티는 100입니다.
4. **특징**: 시간에 따라 변할 수 있는 값입니다. 데이터가 추가되거나 삭제되면 카디널리티가 변경됩니다.

**Degree (디그리, 차수):**

1. **정의**: 릴레이션에서 속성(Attribute), 즉 열(Column)의 개수를 의미합니다.
2. **의미**: 해당 테이블이 몇 개의 컬럼으로 구성되어 있는지를 나타냅니다.
3. **예시**: 학생 테이블이 학번, 이름, 나이, 전공으로 구성되면 디그리는 4입니다.
4. **특징**: 테이블 구조가 변경되지 않는 한 일정하게 유지됩니다.

**차이점:**

- **Cardinality**: 행의 개수 (데이터 개수) - 가변적
- **Degree**: 열의 개수 (컬럼 개수) - 상대적으로 고정적

**문제 해석:**

문제의 설명을 보면 "(1) 속성의 개수"는 Degree, "(2) 튜플의 개수"는 Cardinality를 의미하므로 답은 "{answer}"입니다.

**학습 포인트**: Cardinality와 Degree는 데이터베이스의 기본 용어이므로 정확히 구분하여 이해해야 합니다."""
    
    else:
        return f"""이 문제는 데이터베이스의 핵심 개념을 이해하는 문제입니다.

**데이터베이스 기본 개념:**

1. **릴레이션(Relation)**: 테이블을 의미하며, 행(튜플)과 열(속성)로 구성됩니다.
   - 릴레이션 스키마: 테이블의 구조(컬럼 정의)
   - 릴레이션 인스턴스: 실제 데이터(행들의 집합)

2. **속성(Attribute)**: 테이블의 컬럼을 의미하며, 각 속성은 특정 데이터 타입을 가집니다.
   - 각 속성은 도메인(가능한 값의 집합)을 가집니다.

3. **튜플(Tuple)**: 테이블의 한 행을 의미하며, 여러 속성 값의 집합입니다.
   - 각 튜플은 릴레이션 내에서 유일해야 합니다.

4. **카디널리티(Cardinality)**: 릴레이션에서 튜플(행)의 개수를 의미합니다.
   - 데이터 개수로, 시간에 따라 변할 수 있습니다.

5. **디그리(Degree)**: 릴레이션에서 속성(열)의 개수를 의미합니다.
   - 컬럼 개수로, 테이블 구조가 변하지 않는 한 일정합니다.

6. **키(Key)**: 튜플을 유일하게 식별하는 속성 또는 속성의 집합입니다.
   - 기본키(Primary Key): 후보키 중 선택된 주 키
   - 외래키(Foreign Key): 다른 테이블의 기본키를 참조하는 키

**문제 해석:**

문제의 설명과 보기를 정확히 매칭하여 데이터베이스 용어를 이해하면 답은 "{answer}"입니다.

**학습 포인트**: 데이터베이스의 기본 용어와 개념을 정확히 이해하면 다양한 문제를 해결할 수 있습니다."""

def generate_software_explanation_final(question, answer):
    """소프트웨어공학 개념 최종 상세 해설"""
    question_text = question.get('question_text', '')
    
    if '결합도' in question_text:
        return f"""이 문제는 소프트웨어 설계에서 모듈 간 결합도(Coupling)에 대한 문제입니다.

**결합도의 정의:**

결합도는 모듈 간의 상호 의존 정도를 나타내는 지표입니다. 결합도가 낮을수록 모듈 간의 독립성이 높아져 유지보수가 쉬워지므로 좋은 설계로 평가됩니다.

**결합도의 종류 (높은 결합도 → 낮은 결합도):**

1. **내용 결합도(Content Coupling)**: 가장 높은 결합도, 가장 나쁜 설계
   - 다른 모듈 내부에 있는 변수나 기능을 직접 사용하는 경우
   - 한 모듈이 다른 모듈의 내부 구현을 직접 참조합니다
   - 예: 모듈 A가 모듈 B의 내부 변수를 직접 변경

2. **공통 결합도(Common Coupling)**: 높은 결합도
   - 모듈 밖에 선언된 전역 변수를 참조하고 갱신하는 경우
   - 여러 모듈이 같은 전역 변수를 공유합니다
   - 한 모듈에서 전역 변수를 변경하면 다른 모듈에 영향을 미칩니다
   - 예: 여러 모듈이 같은 전역 변수 count를 공유

3. **외부 결합도(External Coupling)**: 중간 결합도
   - 외부에 선언된 데이터(파일, 데이터베이스 등)를 참조하는 경우
   - 예: 여러 모듈이 같은 외부 파일을 참조

4. **제어 결합도(Control Coupling)**: 중간 결합도
   - 제어 요소(플래그, 함수 포인터 등)가 전달되는 경우
   - 어떻게 처리할지에 대한 정보가 전달됩니다
   - 예: 모듈 A가 모듈 B에 "정렬 방식" 플래그를 전달

5. **스탬프 결합도(Stamp Coupling)**: 낮은 결합도
   - 배열, 객체, 구조체 등의 복합 자료구조가 전달되는 경우
   - 필요한 데이터보다 많은 데이터가 전달될 수 있습니다
   - 예: 전체 학생 정보 구조체를 전달 (이름만 필요해도)

6. **자료 결합도(Data Coupling)**: 가장 낮은 결합도, 가장 좋은 설계
   - 단순한 데이터 값만 전달되는 경우
   - 모듈 간의 인터페이스가 명확하고 최소한의 데이터만 전달됩니다
   - 예: 나이(정수)만 전달하여 처리

**문제 해석:**

문제의 설명에 따라 각 결합도를 매칭하면 답은 "{answer}"입니다.

**학습 포인트**: 결합도는 낮을수록 좋으며, 자료 결합도가 가장 이상적입니다. 모듈 간의 의존성을 최소화하는 것이 좋은 설계입니다."""
    
    elif '응집도' in question_text:
        return f"""이 문제는 소프트웨어 설계에서 모듈의 응집도(Cohesion)에 대한 문제입니다.

**응집도의 정의:**

응집도는 모듈 내부 요소들이 서로 관련되어 있는 정도를 나타내는 지표입니다. 응집도가 높을수록 모듈 내 요소들이 밀접하게 관련되어 있어 좋은 설계로 평가됩니다.

**응집도의 종류 (낮은 응집도 → 높은 응집도):**

1. **우연적 응집도(Coincidental Cohesion)**: 가장 낮은 응집도
   - 모듈 내 요소들 간에 아무런 관련이 없는 경우
   - 예: 자주 사용되는 여러 기능을 임의로 묶은 모듈

2. **논리적 응집도(Logical Cohesion)**: 낮은 응집도
   - 유사한 성격의 기능들이 묶여 있는 경우
   - 예: 모든 입력 처리 기능을 하나의 모듈에 모은 경우

3. **시간적 응집도(Temporal Cohesion)**: 낮은 응집도
   - 특정 시점에 실행되는 기능들이 묶여 있는 경우
   - 예: 초기화 모듈(시작 시 한 번 실행되는 여러 기능)

4. **절차적 응집도(Procedural Cohesion)**: 중간 응집도
   - 실행 순서가 중요한 기능들이 묶여 있는 경우
   - 예: 순차적으로 실행되는 단계들을 하나의 모듈로 구성

5. **통신적 응집도(Communicational Cohesion)**: 중간 응집도
   - 같은 데이터를 사용하는 기능들이 묶여 있는 경우
   - 예: 학생 정보를 읽고, 수정하고, 출력하는 기능

6. **순차적 응집도(Sequential Cohesion)**: 높은 응집도
   - 한 기능의 출력이 다음 기능의 입력이 되는 경우
   - 예: 데이터 읽기 → 처리 → 출력

7. **기능적 응집도(Functional Cohesion)**: 가장 높은 응집도, 가장 좋은 설계
   - 하나의 명확한 기능을 수행하는 경우
   - 예: 두 수의 합을 계산하는 함수

**문제 해석:**

문제의 설명에 따라 응집도가 높은 순서대로 나열하면 답은 "{answer}"입니다.

**학습 포인트**: 응집도는 높을수록 좋으며, 기능적 응집도가 가장 이상적입니다. 하나의 모듈은 하나의 명확한 기능을 수행해야 합니다."""
    
    else:
        return f"""이 문제는 소프트웨어공학의 핵심 개념을 이해하는 문제입니다.

**소프트웨어공학 개념:**

1. **문제 분석**: 문제에서 설명하는 개념의 정의와 특징을 파악합니다. 핵심 키워드와 특징을 추출합니다.

2. **개념 확인**: 해당 개념의 정확한 정의, 목적, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어를 확인합니다.

3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다. 여러 특징을 종합적으로 고려합니다.

4. **답 선택**: 문제의 모든 조건을 만족하는 답을 선택합니다.

**문제 해석:**

문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 "{answer}"입니다.

**학습 포인트**: 소프트웨어공학 개념은 정의와 특징을 정확히 암기하고 이해하는 것이 중요합니다. 특히 결합도, 응집도, 설계 원칙 등은 자주 출제됩니다."""

def generate_general_explanation_final(question, answer):
    """일반 개념 문제 최종 상세 해설"""
    question_text = question.get('question_text', '')
    primary_category = question.get('primary_category', '')
    
    return f"""이 문제는 {primary_category} 분야의 핵심 개념을 이해하는 문제입니다.

**문제 해석 과정:**

1. **문제 분석**: 문제에서 설명하는 내용을 정확히 파악합니다. 핵심 키워드와 특징을 찾습니다. 문제의 요구사항을 명확히 이해합니다.

2. **개념 확인**: 해당 개념의 정의, 작동 원리, 특징을 이해합니다. 정보처리기사 실기에서 자주 출제되는 표준 용어와 정의를 확인합니다.

3. **보기 매칭**: 문제의 설명과 보기를 비교하여 가장 잘 일치하는 답을 찾습니다. 여러 특징을 종합적으로 고려합니다.

4. **답 선택**: 문제의 모든 조건을 만족하는 답을 선택합니다. 부분적으로만 일치하는 답보다는 모든 조건을 만족하는 답을 선택합니다.

**학습 포인트:**

이 개념은 정보처리기사 실기에서 자주 출제되는 내용이므로 정의와 특징을 정확히 이해하고 암기하는 것이 중요합니다. 특히 약자나 영문 명칭도 함께 기억해야 합니다.

**문제 해석:**

문제의 설명, 특징, 보기 등을 종합적으로 고려하면 답은 "{answer}"입니다."""

def process_all_questions():
    """모든 문제를 하나씩 처리"""
    data_dir = Path("data")
    
    # 처리할 회차 목록
    target_rounds = [
        ('2025', '1'), ('2025', '2'),
        ('2024', '1'), ('2024', '2'), ('2024', '3'),
        ('2023', '1'), ('2023', '2'), ('2023', '3'),
        ('2022', '1'), ('2022', '2'), ('2022', '3')
    ]
    
    total_updated = 0
    
    for year, round_num in target_rounds:
        filename = f"items_{year}_round{round_num}.jsonl"
        jsonl_file = data_dir / filename
        
        if not jsonl_file.exists():
            continue
        
        questions = []
        with open(jsonl_file, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip():
                    try:
                        q = json.loads(line)
                        questions.append(q)
                    except json.JSONDecodeError:
                        continue
        
        print(f"\n{'=' * 80}")
        print(f"{year}년 {round_num}회 해설 생성")
        print(f"{'=' * 80}")
        print(f"총 {len(questions)}개 문제 처리 중...\n")
        
        updated_count = 0
        explanations = {}
        
        for i, q in enumerate(questions, 1):
            q_no = q.get('q_no', '')
            current_explanation = q.get('explanation')
            
            # 이미 충분한 해설이 있으면 건너뛰기
            if classify_explanation(current_explanation):
                continue
            
            print(f"[{i}/{len(questions)}] {q_no} 처리 중...")
            
            explanation = generate_detailed_explanation_for_question(q)
            
            if explanation and len(explanation) >= 100:
                explanations[q_no] = explanation
                updated_count += 1
                print(f"✅ 해설 생성: {len(explanation)}자")
            else:
                print(f"⚠️  해설 생성 실패")
            
            if i % 5 == 0:
                print(f"\n진행률: {i}/{len(questions)} ({i/len(questions)*100:.1f}%)\n")
        
        # JSONL 파일 업데이트
        if updated_count > 0:
            backup_path = jsonl_file.parent / f"{jsonl_file.stem}_ai_backup_{int(time.time())}{jsonl_file.suffix}"
            import shutil
            shutil.copy2(jsonl_file, backup_path)
            print(f"\n✅ 백업 생성: {backup_path}")
            
            updated_questions = []
            for q in questions:
                q_no = q.get('q_no')
                if q_no in explanations:
                    q['explanation'] = explanations[q_no]
                updated_questions.append(q)
            
            with open(jsonl_file, 'w', encoding='utf-8') as f:
                for q in updated_questions:
                    f.write(json.dumps(q, ensure_ascii=False) + '\n')
            
            print(f"✅ {updated_count}개 문제의 해설이 업데이트되었습니다.")
            total_updated += updated_count
        
        print("\n" + "=" * 80 + "\n")
    
    print(f"✅ 총 {total_updated}개 문제의 상세 해설이 생성되었습니다.")

if __name__ == "__main__":
    process_all_questions()



