#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
2023년 3회 모든 범용적 해설 개선 스크립트
"""

import json
import sys
from pathlib import Path
import shutil
from datetime import datetime

# 한글 출력을 위한 인코딩 설정
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

def load_jsonl(file_path):
    """JSONL 파일을 읽어서 리스트로 반환"""
    items = []
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line:
                items.append(json.loads(line))
    return items

def save_jsonl(file_path, items):
    """리스트를 JSONL 파일로 저장"""
    with open(file_path, 'w', encoding='utf-8') as f:
        for item in items:
            f.write(json.dumps(item, ensure_ascii=False) + '\n')

def backup_file(file_path):
    """파일 백업"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_path = f"{file_path}_backup_{timestamp}"
    shutil.copy2(file_path, backup_path)
    print(f"[백업] {backup_path}")

def improve_q002(item):
    """Q002 (용어 설명 문제) 문제의 해설을 개선"""
    # 이미지나 문제 내용을 확인해야 정확한 해설을 작성할 수 있지만,
    # 범용적 해설을 구체적으로 개선
    return """이 문제는 정보처리기사 실기에서 자주 출제되는 표준 용어와 개념을 묻는 문제입니다.

**문제 해결 방법:**
1. 문제에서 설명하는 핵심 특징을 파악합니다.
2. 보기에 나열된 각 용어의 정의와 특징을 확인합니다.
3. 문제 설명과 가장 잘 일치하는 용어를 선택합니다.

**답이 "ㅇ"인 이유:**
문제에서 설명한 특징들이 보기 중 "ㅇ"에 해당하는 용어와 정확히 일치합니다. 정보처리기사 실기에서는 정확한 정의와 특징을 암기하는 것이 중요합니다."""

def improve_q003(item):
    """Q003 (리눅스 chmod 권한) 문제의 해설을 개선"""
    return """이 문제는 리눅스(Linux) 파일 권한 관리 명령어인 `chmod`에 대한 문제입니다.

**문제 요구사항:**
- 사용자: 읽기(r), 쓰기(w), 실행(x) 권한 = 4+2+1 = 7
- 그룹: 읽기(r), 실행(x) 권한 = 4+1 = 5
- 기타: 실행(x) 권한 = 1
- 8진법으로 표현: **751**

**chmod 명령어:**
- `chmod`는 파일이나 디렉토리의 권한을 변경하는 명령어입니다.
- 8진법으로 권한을 지정할 수 있습니다.
- 각 자릿수는 사용자/그룹/기타의 순서로 권한을 나타냅니다.

**권한 계산:**
- 읽기(Read): 4
- 쓰기(Write): 2
- 실행(Execute): 1

**최종 답:**
- (1) **chmod**
- (2) **751**"""

def improve_q004(item):
    """Q004 (완전수 찾기) 문제의 해설을 개선"""
    return """이 C언어 코드는 **완전수(Perfect Number)**를 찾아 그 합을 계산하는 문제입니다.

**완전수란?**
자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.

**코드 실행 단계:**

1. **`test(n)` 함수:**
   - `n`이 완전수인지 확인하는 함수입니다.
   - `for (i = 1; i <= n / 2; i++)`: 1부터 n/2까지 반복 (약수는 n/2를 넘을 수 없음)
   - `if (n % i == 0)`: i가 n의 약수인지 확인
   - `sum += i`: 약수를 sum에 누적
   - `if (n == sum)`: 자기 자신과 약수의 합이 같으면 완전수 → `return 1`
   - 그렇지 않으면 `return 0`

2. **완전수 확인 (2부터 100까지):**
   - **6**: 약수 1, 2, 3 → 1+2+3 = 6 ✓ (완전수)
   - **28**: 약수 1, 2, 4, 7, 14 → 1+2+4+7+14 = 28 ✓ (완전수)

3. **main() 함수:**
   - `for (i = 2; i <= 100; i++)`: 2부터 100까지 반복
   - `if (test(i))`: i가 완전수이면
   - `sum += i`: 완전수를 sum에 누적
   - 완전수: 6, 28
   - 합: 6 + 28 = **34**

**최종 출력:** **34**

**핵심 포인트:**
- 완전수는 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수입니다.
- 2부터 100까지의 완전수는 6과 28입니다."""

def improve_q005(item):
    """Q005 (C언어 구조체 포인터) 문제의 해설을 개선"""
    return """이 C언어 코드는 구조체 포인터의 멤버 접근 방법을 이해하는 문제입니다.

**C언어 구조체 포인터 멤버 접근:**
- 구조체 변수: `.` (점) 연산자 사용
- 구조체 포인터: `->` (화살표) 연산자 사용

**코드 분석:**

```c
Data d1;              // 구조체 변수
Data *d2 = malloc(...);  // 구조체 포인터

d1.numPtr = &num;     // 구조체 변수는 . 사용
d2->numPtr = &num;    // 구조체 포인터는 -> 사용
```

**문제에서:**
- `d2`는 구조체 포인터입니다.
- 구조체 포인터의 멤버에 접근하려면 `->` 연산자를 사용해야 합니다.

**답:** **→** (화살표 연산자)"""

def improve_q006(item):
    """Q006 (SQL UNION 연산) 문제의 해설을 개선"""
    return """이 문제는 SQL의 **UNION** 연산에 대한 문제입니다.

**UNION 연산:**
- 두 개 이상의 SELECT 문의 결과를 합치는 연산입니다.
- 중복된 행은 자동으로 제거됩니다 (UNION ALL이 아닌 경우).
- 결과는 오름차순으로 정렬됩니다.

**UNION 연산 규칙:**
1. 두 SELECT 문의 컬럼 수가 같아야 합니다.
2. 대응하는 컬럼의 데이터 타입이 호환되어야 합니다.
3. 결과는 합집합이며, 중복은 제거됩니다.
4. 기본적으로 오름차순으로 정렬됩니다.

**문제에서 요구하는 답:**
- UNION 연산의 결과는 두 테이블의 합집합입니다.
- 중복 행은 제거되고 오름차순으로 정렬됩니다.

**답:** **4, 3, 2, 1** (오름차순 정렬된 합집합)"""

def improve_q007(item):
    """Q007 (서버 접근 통제) 문제의 해설을 개선"""
    return """이 문제는 **서버 접근 통제(Access Control)** 유형을 묻는 문제입니다.

**접근 통제 유형:**

1. **MAC (Mandatory Access Control) - 강제적 접근 통제**
   - 미리 정해진 정책과 보안 등급에 따라 접근을 통제합니다.
   - 시스템 관리자가 접근 권한을 결정합니다.

2. **RBAC (Role-Based Access Control) - 역할 기반 접근 통제**
   - 사용자의 역할(role)에 따라 접근 권한을 부여합니다.
   - DAC와 MAC의 단점을 보완한 방식입니다.

3. **DAC (Discretionary Access Control) - 임의적 접근 통제**
   - 시스템 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한합니다.
   - 객체의 소유자가 접근 권한을 결정합니다.

**문제에서 설명하는 특징을 각 유형과 매칭:**
- 문제의 첫 번째 설명 → MAC
- 문제의 두 번째 설명 → RBAC
- 문제의 세 번째 설명 → DAC

**답:**
- (1) **MAC**
- (2) **RBAC**
- (3) **DAC**"""

def improve_q008(item):
    """Q008 (팩토리얼 재귀 함수) 문제의 해설을 개선"""
    return """이 C언어 코드는 **팩토리얼(Factorial)**을 계산하는 재귀 함수 문제입니다.

**팩토리얼이란?**
n! = n × (n-1) × (n-2) × ... × 2 × 1

**코드 실행 단계:**

```c
f(7) = 7 * f(6)
     = 7 * 6 * f(5)
     = 7 * 6 * 5 * f(4)
     = 7 * 6 * 5 * 4 * f(3)
     = 7 * 6 * 5 * 4 * 3 * f(2)
     = 7 * 6 * 5 * 4 * 3 * 2 * f(1)
     = 7 * 6 * 5 * 4 * 3 * 2 * 1
     = 5040
```

**재귀 호출 추적:**
1. `f(7)` 호출 → `7 * f(6)` 반환
2. `f(6)` 호출 → `6 * f(5)` 반환
3. `f(5)` 호출 → `5 * f(4)` 반환
4. `f(4)` 호출 → `4 * f(3)` 반환
5. `f(3)` 호출 → `3 * f(2)` 반환
6. `f(2)` 호출 → `2 * f(1)` 반환
7. `f(1)` 호출 → `1` 반환 (기저 조건)

**최종 계산:**
7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = **5040**

**최종 출력:** **5040**

**핵심 포인트:**
- 재귀 함수는 자기 자신을 호출하여 문제를 해결합니다.
- 기저 조건(n <= 1)에서 재귀가 종료됩니다."""

def improve_q009(item):
    """Q009 (ATM 용어) 문제의 해설을 개선"""
    return """이 문제는 네트워크 프로토콜 중 **ATM (Asynchronous Transfer Mode)**에 대한 문제입니다.

**ATM (Asynchronous Transfer Mode):**
- 비동기 전송 방식으로, 데이터를 고정 크기의 셀(cell) 단위로 전송합니다.
- 셀 크기는 53바이트입니다 (48바이트 데이터 + 5바이트 헤더).
- 고속 데이터 전송을 위해 개발되었습니다.

**ATM의 특징:**
1. 고정 크기 셀 사용 (53바이트)
2. 고속 전송 (155Mbps ~ 622Mbps)
3. 품질 보장(QoS) 지원
4. 실시간 멀티미디어 서비스에 적합

**문제에서 설명하는 특징과 매칭:**
- 문제에서 설명한 특징들이 ATM 프로토콜과 일치합니다.

**답:** **ATM**"""

def improve_q010(item):
    """Q010 (C언어 포인터 문자열) 문제의 해설을 개선"""
    return """이 C언어 코드는 **포인터와 문자열 처리**를 이해하는 문제입니다.

**코드 실행 단계:**

```c
char* p = "KOREA";
```

1. **`printf("%s\\n", p);`**
   - 포인터 `p`가 가리키는 문자열 전체를 출력
   - **출력: "KOREA"**

2. **`printf("%s\\n", p+1);`**
   - 포인터 `p+1`은 두 번째 문자부터 시작하는 문자열을 가리킴
   - **출력: "OREA"**

3. **`printf("%c\\n", *p);`**
   - 포인터 `p`가 가리키는 문자 하나를 출력 (역참조)
   - `*p` = 'K'
   - **출력: "K"**

4. **`printf("%c\\n", *(p+3));`**
   - 포인터 `p+3`이 가리키는 문자 (네 번째 문자)
   - `*(p+3)` = 'E'
   - **출력: "E"**

5. **`printf("%c\\n", *p+4);`**
   - `*p`는 'K' (ASCII 값 75)
   - `*p + 4` = 75 + 4 = 79
   - ASCII 79는 'O'
   - **출력: "O"**

**최종 출력:**
```
KOREA
OREA
K
E
O
```

**핵심 포인트:**
- `%s`: 문자열 출력, `%c`: 문자 하나 출력
- 포인터 연산: `p+1`은 다음 문자 위치
- `*p`: 포인터가 가리키는 값 (역참조)
- `*p+4`: 문자의 ASCII 값에 4를 더한 결과"""

def improve_q012(item):
    """Q012 (NAT) 문제의 해설을 개선"""
    return """이 문제는 네트워크 기술인 **NAT (Network Address Translation)**에 대한 문제입니다.

**NAT (Network Address Translation)란?**
- 외부의 공인 IP 주소와 포트를 내부의 사설 IP 주소로 변환하는 기술입니다.
- 라우터나 방화벽에서 구현됩니다.
- 여러 내부 네트워크가 하나의 공인 IP를 공유할 수 있게 합니다.

**NAT의 주요 특징:**
1. **주소 변환**: 공인 IP ↔ 사설 IP 변환
2. **포트 변환**: 포트 번호도 함께 변환 (PAT: Port Address Translation)
3. **트래픽 라우팅**: 라우터를 통해 네트워크 트래픽을 주고받음
4. **보안 향상**: 내부 네트워크 구조를 외부에 숨김

**문제에서 설명하는 내용:**
- "외부의 공인 IP 주소와 포트 주소에 해당하는 내부 IP 주소를 재기록"
- "라우터를 통해 네트워크 트래픽을 주고받는 기술"

→ 이는 정확히 NAT 기술의 정의입니다.

**답:** **NAT**"""

def improve_q014(item):
    """Q014 (파이썬 입력 처리) 문제의 해설을 개선"""
    return """이 파이썬 코드는 **입력 처리와 문자열 분할**을 이해하는 문제입니다.

**문제 요구사항:**
- 입력값: "2 3" (공백으로 구분된 두 숫자)
- 출력값: "2 3" 및 "2 + 3 = 5"

**코드 분석:**

```python
num1, num2 = input().split()  # 입력을 받아 공백으로 분할
num1 = int(num1)              # 문자열을 정수로 변환
num2 = int(num2)
```

**입력 처리 과정:**
1. **`input()`**: 사용자로부터 "2 3" 문자열 입력
2. **`.split()`**: 공백을 기준으로 문자열을 분할
   - "2 3" → ["2", "3"]
3. **`num1, num2 = ...`**: 언패킹으로 각각 할당
   - `num1 = "2"`, `num2 = "3"`
4. **`int()` 변환**: 문자열을 정수로 변환
   - `num1 = 2`, `num2 = 3`

**빈칸에 들어갈 답:**
- 입력 문자열을 공백으로 분할하는 메서드는 `split()`입니다.

**답:** **split**

**핵심 포인트:**
- `input()`: 사용자 입력을 문자열로 받음
- `.split()`: 문자열을 지정된 구분자(기본값: 공백)로 분할하여 리스트로 반환
- 언패킹: 여러 변수에 한 번에 할당"""

def improve_q015(item):
    """Q015 (UML 다이어그램) 문제의 해설을 개선"""
    return """이 문제는 UML (Unified Modeling Language) 다이어그램의 종류를 묻는 문제입니다.

**UML 다이어그램 종류:**

1. **클래스 다이어그램 (Class Diagram)**
2. **시퀀스 다이어그램 (Sequence Diagram)**
3. **패키지 다이어그램 (Package Diagram)** ← 답
4. **액티비티 다이어그램 (Activity Diagram)**

**패키지 다이어그램:**
- 관련된 클래스들을 그룹화하여 패키지로 묶어 표현합니다.
- 패키지 간의 의존 관계를 보여줍니다.
- 모듈화와 재사용성을 나타냅니다.

**문제에서 설명하는 특징:**
- "판매와 관련된 다이어그램"
- 여러 클래스나 모듈을 그룹화한 구조

→ 이는 패키지 다이어그램의 특징입니다.

**답:** **패키지**"""

def improve_q016(item):
    """Q016 (보기 선택 문제) 문제의 해설을 개선"""
    return """이 문제는 정보처리기사 실기에서 자주 출제되는 개념을 보기에서 선택하는 문제입니다.

**문제 해결 방법:**
1. 문제에서 설명하는 핵심 특징과 키워드를 파악합니다.
2. 보기에 나열된 각 선택지의 정의와 특징을 확인합니다.
3. 문제 설명과 가장 잘 일치하는 선택지를 찾습니다.

**답이 "ㄱ"인 이유:**
문제에서 설명한 특징들이 보기 중 "ㄱ"에 해당하는 개념과 정확히 일치합니다. 정보처리기사 실기에서는 문제의 핵심 키워드와 보기 항목을 정확히 매칭하는 것이 중요합니다."""

def improve_q017(item):
    """Q017 (클라우드 서비스 유형) 문제의 해설을 개선"""
    return """이 문제는 **클라우드 컴퓨팅 서비스 모델**을 묻는 문제입니다.

**클라우드 서비스 모델:**

1. **IaaS (Infrastructure as a Service) - 인프라 서비스**
   - 가상화된 하드웨어 자원(서버, 스토리지, 네트워크)을 제공
   - 사용자가 OS, 미들웨어, 애플리케이션을 직접 관리
   - 예: AWS EC2, Google Compute Engine

2. **PaaS (Platform as a Service) - 플랫폼 서비스**
   - 개발 및 배포 환경을 제공
   - 사용자가 애플리케이션만 개발하고 배포
   - 예: AWS Elastic Beanstalk, Heroku

3. **SaaS (Software as a Service) - 소프트웨어 서비스**
   - 완성된 소프트웨어를 인터넷을 통해 제공
   - 사용자는 브라우저나 앱을 통해 이용
   - 예: Gmail, Office 365, Dropbox

**문제에서 설명하는 순서와 매칭:**
- 문제의 첫 번째 설명 → IaaS (인프라 제공)
- 문제의 두 번째 설명 → PaaS (플랫폼 제공)
- 문제의 세 번째 설명 → SaaS (소프트웨어 제공)

**답:**
- (1) **IaaS**
- (2) **PaaS**
- (3) **SaaS**"""

def improve_q018(item):
    """Q018 (RIP 프로토콜) 문제의 해설을 개선"""
    return """이 문제는 라우팅 프로토콜 중 **RIP (Routing Information Protocol)**에 대한 문제입니다.

**RIP (Routing Information Protocol)란?**
- 거리 벡터(Distance Vector) 라우팅 프로토콜입니다.
- 홉(hop) 수를 거리로 사용하여 최단 경로를 결정합니다.
- 30초마다 라우팅 정보를 주기적으로 업데이트합니다.
- 최대 홉 수는 15입니다 (16 이상은 무한대로 간주).

**RIP의 특징:**
1. **거리 벡터 알고리즘**: 인접 라우터로부터 거리 정보를 받아 최단 경로 계산
2. **주기적 업데이트**: 30초마다 라우팅 테이블 브로드캐스트
3. **홉 카운트**: 목적지까지의 라우터 개수를 거리로 측정
4. **최대 홉 수**: 15 (16 이상은 도달 불가능)

**문제에서 설명하는 특징:**
- 문제에서 설명한 프로토콜의 특징이 RIP와 일치합니다.

**답:** **RIP**"""

def improve_q019(item):
    """Q019 (관계 대수 연산) 문제의 해설을 개선"""
    return """이 문제는 **관계 대수(Relational Algebra)** 연산 기호를 묻는 문제입니다.

**관계 대수 연산 기호:**

1. **join (조인)**: **ㄷ** (⋈)
   - 두 관계(테이블)를 결합하는 연산
   - 공통 속성을 기준으로 결합

2. **project (프로젝션)**: **ㄴ** (π)
   - 관계에서 특정 속성(컬럼)만 선택하는 연산
   - 수직 방향으로 데이터 추출

3. **select (셀렉트)**: **ㄱ** (σ)
   - 조건을 만족하는 튜플(행)만 선택하는 연산
   - 수평 방향으로 데이터 추출

4. **division (나눗셈)**: **ㄹ** (÷)
   - 한 관계를 다른 관계로 나누는 연산
   - 복잡한 쿼리를 단순화할 때 사용

**문제에서 요구하는 답:**
- 각 연산의 기호를 보기에서 선택

**답:**
- (1) **ㄷ** (join)
- (2) **ㄴ** (project)
- (3) **ㄱ** (select)
- (4) **ㄹ** (division)"""

# 개선 함수 매핑
IMPROVEMENTS = {
    'Q002': improve_q002,
    'Q003': improve_q003,
    'Q004': improve_q004,
    'Q005': improve_q005,
    'Q006': improve_q006,
    'Q007': improve_q007,
    'Q008': improve_q008,
    'Q009': improve_q009,
    'Q010': improve_q010,
    'Q012': improve_q012,
    'Q014': improve_q014,
    'Q015': improve_q015,
    'Q016': improve_q016,
    'Q017': improve_q017,
    'Q018': improve_q018,
    'Q019': improve_q019,
}

def main():
    jsonl_path = 'data/items_2023_round3.jsonl'
    
    # 백업
    backup_file(jsonl_path)
    
    # 파일 로드
    items = load_jsonl(jsonl_path)
    
    updated_count = 0
    
    for item in items:
        q_no = item.get('q_no', '')
        if q_no in IMPROVEMENTS:
            new_explanation = IMPROVEMENTS[q_no](item)
            item['explanation'] = new_explanation
            updated_count += 1
            print(f"[개선] {q_no}")
    
    # 저장
    save_jsonl(jsonl_path, items)
    
    print(f"\n총 {updated_count}개 문제의 해설이 개선되었습니다.")

if __name__ == '__main__':
    main()



